
var unityFramework = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(unityFramework) {
  unityFramework = unityFramework || {};



// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof unityFramework != 'undefined' ? unityFramework : {};

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_main')) {
        Object.defineProperty(Module['ready'], '_main', { configurable: true, get: function() { abort('You are getting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_main', { configurable: true, set: function() { abort('You are setting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_ReleaseKeys')) {
        Object.defineProperty(Module['ready'], '_ReleaseKeys', { configurable: true, get: function() { abort('You are getting _ReleaseKeys on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_ReleaseKeys', { configurable: true, set: function() { abort('You are setting _ReleaseKeys on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getMemInfo')) {
        Object.defineProperty(Module['ready'], '_getMemInfo', { configurable: true, get: function() { abort('You are getting _getMemInfo on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_getMemInfo', { configurable: true, set: function() { abort('You are setting _getMemInfo on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_SendMessageFloat')) {
        Object.defineProperty(Module['ready'], '_SendMessageFloat', { configurable: true, get: function() { abort('You are getting _SendMessageFloat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_SendMessageFloat', { configurable: true, set: function() { abort('You are setting _SendMessageFloat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_SendMessageString')) {
        Object.defineProperty(Module['ready'], '_SendMessageString', { configurable: true, get: function() { abort('You are getting _SendMessageString on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_SendMessageString', { configurable: true, set: function() { abort('You are setting _SendMessageString on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_SendMessage')) {
        Object.defineProperty(Module['ready'], '_SendMessage', { configurable: true, get: function() { abort('You are getting _SendMessage on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_SendMessage', { configurable: true, set: function() { abort('You are setting _SendMessage on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_SetFullscreen')) {
        Object.defineProperty(Module['ready'], '_SetFullscreen', { configurable: true, get: function() { abort('You are getting _SetFullscreen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_SetFullscreen', { configurable: true, set: function() { abort('You are setting _SetFullscreen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_InjectProfilerSample')) {
        Object.defineProperty(Module['ready'], '_InjectProfilerSample', { configurable: true, get: function() { abort('You are getting _InjectProfilerSample on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_InjectProfilerSample', { configurable: true, set: function() { abort('You are setting _InjectProfilerSample on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '___stdio_exit')) {
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, get: function() { abort('You are getting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, set: function() { abort('You are setting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], 'onRuntimeInitialized')) {
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, get: function() { abort('You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, set: function() { abort('You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
(function(factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function() {
  "use strict";
  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReact_production_min;
  function requireReact_production_min() {
    if (hasRequiredReact_production_min)
      return react_production_min;
    hasRequiredReact_production_min = 1;
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z10 = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z10 && a[z10] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F10() {
    }
    F10.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F10();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K10 = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b)
        for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K10.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a10) {
        return b[a10];
      });
    }
    var P10 = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k)
        a = null;
      var h = false;
      if (null === a)
        h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
      if (h)
        return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P10, "$&/") + "/"), R(c, b, e, "", function(a10) {
          return a10;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P10, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), "function" === typeof f)
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k)
        throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a)
        return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a10) {
        return b.call(e, a10, c++);
      });
      return d;
    }
    function T10(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b10) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b10;
        }, function(b10) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b10;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K10 };
    function X() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    react_production_min.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a10) {
        return a10;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E;
    react_production_min.Fragment = p;
    react_production_min.Profiler = r;
    react_production_min.PureComponent = G;
    react_production_min.StrictMode = q;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    react_production_min.act = X;
    react_production_min.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K10.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M;
    react_production_min.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    react_production_min.isValidElement = O;
    react_production_min.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T10 };
    };
    react_production_min.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    react_production_min.unstable_act = X;
    react_production_min.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    react_production_min.useContext = function(a) {
      return U.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    react_production_min.useId = function() {
      return U.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    react_production_min.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    react_production_min.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    react_production_min.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    react_production_min.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    react_production_min.useRef = function(a) {
      return U.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    react_production_min.useTransition = function() {
      return U.current.useTransition();
    };
    react_production_min.version = "18.3.1";
    return react_production_min;
  }
  {
    react.exports = requireReact_production_min();
  }
  var reactExports = react.exports;
  const K = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredScheduler_production_min;
  function requireScheduler_production_min() {
    if (hasRequiredScheduler_production_min)
      return scheduler_production_min;
    hasRequiredScheduler_production_min = 1;
    (function(exports) {
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a:
          for (; 0 < c; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (0 < g(e, b))
              a[d] = b, a[c] = e, c = d;
            else
              break a;
          }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length)
          return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a:
            for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
              var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
              if (0 > g(C, c))
                n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
              else if (n < e && 0 > g(x, c))
                a[d] = x, a[n] = c, d = n;
              else
                break a;
            }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        var p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var r = [], t = [], u = 1, v = null, y = 3, z10 = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F10 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback)
            k(t);
          else if (b.startTime <= a)
            k(t), b.sortIndex = b.expirationTime, f(r, b);
          else
            break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A)
          if (null !== h(r))
            A = true, I(J);
          else {
            var b = h(t);
            null !== b && K10(H, b.startTime - a);
          }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z10 = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else
              k(r);
            v = h(r);
          }
          if (null !== v)
            var w = true;
          else {
            var m = h(t);
            null !== m && K10(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z10 = false;
        }
      }
      var N = false, O = null, L = -1, P10 = 5, Q = -1;
      function M() {
        return exports.unstable_now() - Q < P10 ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else
          N = false;
      }
      var S;
      if ("function" === typeof F10)
        S = function() {
          F10(R);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T10 = new MessageChannel(), U = T10.port2;
        T10.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else
        S = function() {
          D(R, 0);
        };
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K10(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z10 || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P10 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K10(H, c - d))) : (a.sortIndex = e, f(r, a), A || z10 || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    })(scheduler_production_min);
    return scheduler_production_min;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler)
      return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production_min();
    }
    return scheduler.exports;
  }
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactDom_production_min;
  function requireReactDom_production_min() {
    if (hasRequiredReactDom_production_min)
      return reactDom_production_min;
    hasRequiredReactDom_production_min = 1;
    var aa2 = reactExports, ca2 = requireScheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da2 = /* @__PURE__ */ new Set(), ea2 = {};
    function fa2(a, b) {
      ha2(a, b);
      ha2(a + "Capture", b);
    }
    function ha2(a, b) {
      ea2[a] = b;
      for (a = 0; a < b.length; a++)
        da2.add(b[a]);
    }
    var ia2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja2 = Object.prototype.hasOwnProperty, ka2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la2 = {}, ma2 = {};
    function oa2(a) {
      if (ja2.call(ma2, a))
        return true;
      if (ja2.call(la2, a))
        return false;
      if (ka2.test(a))
        return ma2[a] = true;
      la2[a] = true;
      return false;
    }
    function pa2(a, b, c, d) {
      if (null !== c && 0 === c.type)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (null !== c)
            return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa2(a, b, c, d) {
      if (null === b || "undefined" === typeof b || pa2(a, b, c, d))
        return true;
      if (d)
        return false;
      if (null !== c)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    var z10 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z10[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z10[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z10[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z10[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z10[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z10[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z10[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z10[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z10[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra2 = /[\-:]([a-z])/g;
    function sa2(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra2,
        sa2
      );
      z10[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra2, sa2);
      z10[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra2, sa2);
      z10[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z10[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z10.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z10[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta2(a, b, c, d) {
      var e = z10.hasOwnProperty(b) ? z10[b] : null;
      if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1])
        qa2(b, c, e, d) && (c = null), d || null === e ? oa2(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
    }
    var ua2 = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va2 = Symbol.for("react.element"), wa2 = Symbol.for("react.portal"), ya2 = Symbol.for("react.fragment"), za2 = Symbol.for("react.strict_mode"), Aa2 = Symbol.for("react.profiler"), Ba2 = Symbol.for("react.provider"), Ca2 = Symbol.for("react.context"), Da2 = Symbol.for("react.forward_ref"), Ea2 = Symbol.for("react.suspense"), Fa2 = Symbol.for("react.suspense_list"), Ga2 = Symbol.for("react.memo"), Ha2 = Symbol.for("react.lazy");
    var Ia2 = Symbol.for("react.offscreen");
    var Ja2 = Symbol.iterator;
    function Ka2(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja2 && a[Ja2] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign, La2;
    function Ma(a) {
      if (void 0 === La2)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La2 = b && b[1] || "";
        }
      return "\n" + La2 + a;
    }
    var Na2 = false;
    function Oa2(a, b) {
      if (!a || Na2)
        return "";
      Na2 = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
            h--;
          for (; 1 <= g && 0 <= h; g--, h--)
            if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
        }
      } finally {
        Na2 = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa2(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa2(a.type, false), a;
        case 11:
          return a = Oa2(a.type.render, false), a;
        case 1:
          return a = Oa2(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa2(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya2:
          return "Fragment";
        case wa2:
          return "Portal";
        case Aa2:
          return "Profiler";
        case za2:
          return "StrictMode";
        case Ea2:
          return "Suspense";
        case Fa2:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca2:
            return (a.displayName || "Context") + ".Consumer";
          case Ba2:
            return (a._context.displayName || "Context") + ".Provider";
          case Da2:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga2:
            return b = a.displayName || null, null !== b ? b : Qa2(a.type) || "Memo";
          case Ha2:
            b = a._payload;
            a = a._init;
            try {
              return Qa2(a(b));
            } catch (c) {
            }
        }
      return null;
    }
    function Ra2(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa2(b);
        case 8:
          return b === za2 ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b)
            return b.displayName || b.name || null;
          if ("string" === typeof b)
            return b;
      }
      return null;
    }
    function Sa2(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta2(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua2(a) {
      var b = Ta2(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a10) {
          d = "" + a10;
          f.call(this, a10);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a10) {
          d = "" + a10;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function Va2(a) {
      a._valueTracker || (a._valueTracker = Ua2(a));
    }
    function Wa2(a) {
      if (!a)
        return false;
      var b = a._valueTracker;
      if (!b)
        return true;
      var c = b.getValue();
      var d = "";
      a && (d = Ta2(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function Xa2(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya2(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Za2(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa2(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab2(a, b) {
      b = b.checked;
      null != b && ta2(a, "checked", b, false);
    }
    function bb2(a, b) {
      ab2(a, b);
      var c = Sa2(b.value), d = b.type;
      if (null != c)
        if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c)
            a.value = "" + c;
        } else
          a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb2(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb2(a, b.type, Sa2(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function db2(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
          return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function cb2(a, b, c) {
      if ("number" !== b || Xa2(a.ownerDocument) !== a)
        null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    var eb2 = Array.isArray;
    function fb2(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa2(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb2(a, b) {
      if (null != b.dangerouslySetInnerHTML)
        throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb2(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b)
            throw Error(p(92));
          if (eb2(c)) {
            if (1 < c.length)
              throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa2(c) };
    }
    function ib2(a, b) {
      var c = Sa2(b.value), d = Sa2(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function jb2(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    function kb2(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb2(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb2(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb2, nb2 = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b;
      else {
        mb2 = mb2 || document.createElement("div");
        mb2.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb2.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function ob2(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb2 = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb2 = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb2).forEach(function(a) {
      qb2.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb2[b] = pb2[a];
      });
    });
    function rb2(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb2.hasOwnProperty(a) && pb2[a] ? ("" + b).trim() : b + "px";
    }
    function sb2(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb2(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var tb2 = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub2(a, b) {
      if (b) {
        if (tb2[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children)
            throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
            throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style)
          throw Error(p(62));
      }
    }
    function vb2(a, b) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb2 = null;
    function xb2(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb2 = null, zb2 = null, Ab2 = null;
    function Bb2(a) {
      if (a = Cb2(a)) {
        if ("function" !== typeof yb2)
          throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db2(b), yb2(a.stateNode, a.type, b));
      }
    }
    function Eb2(a) {
      zb2 ? Ab2 ? Ab2.push(a) : Ab2 = [a] : zb2 = a;
    }
    function Fb2() {
      if (zb2) {
        var a = zb2, b = Ab2;
        Ab2 = zb2 = null;
        Bb2(a);
        if (b)
          for (a = 0; a < b.length; a++)
            Bb2(b[a]);
      }
    }
    function Gb2(a, b) {
      return a(b);
    }
    function Hb2() {
    }
    var Ib2 = false;
    function Jb2(a, b, c) {
      if (Ib2)
        return a(b, c);
      Ib2 = true;
      try {
        return Gb2(a, b, c);
      } finally {
        if (Ib2 = false, null !== zb2 || null !== Ab2)
          Hb2(), Fb2();
      }
    }
    function Kb2(a, b) {
      var c = a.stateNode;
      if (null === c)
        return null;
      var d = Db2(c);
      if (null === d)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c && "function" !== typeof c)
        throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb2 = false;
    if (ia2)
      try {
        var Mb2 = {};
        Object.defineProperty(Mb2, "passive", { get: function() {
          Lb2 = true;
        } });
        window.addEventListener("test", Mb2, Mb2);
        window.removeEventListener("test", Mb2, Mb2);
      } catch (a) {
        Lb2 = false;
      }
    function Nb2(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob2 = false, Pb2 = null, Qb2 = false, Rb2 = null, Sb2 = { onError: function(a) {
      Ob2 = true;
      Pb2 = a;
    } };
    function Tb2(a, b, c, d, e, f, g, h, k) {
      Ob2 = false;
      Pb2 = null;
      Nb2.apply(Sb2, arguments);
    }
    function Ub2(a, b, c, d, e, f, g, h, k) {
      Tb2.apply(this, arguments);
      if (Ob2) {
        if (Ob2) {
          var l = Pb2;
          Ob2 = false;
          Pb2 = null;
        } else
          throw Error(p(198));
        Qb2 || (Qb2 = true, Rb2 = l);
      }
    }
    function Vb2(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function Wb2(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b)
          return b.dehydrated;
      }
      return null;
    }
    function Xb2(a) {
      if (Vb2(a) !== a)
        throw Error(p(188));
    }
    function Yb2(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb2(a);
        if (null === b)
          throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e)
          break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c)
              return Xb2(e), a;
            if (f === d)
              return Xb2(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return)
          c = e, d = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d = f;
              break;
            }
            if (h === d) {
              g = true;
              d = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d = e;
                break;
              }
              if (h === d) {
                g = true;
                d = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g)
              throw Error(p(189));
          }
        }
        if (c.alternate !== d)
          throw Error(p(190));
      }
      if (3 !== c.tag)
        throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb2(a) {
      a = Yb2(a);
      return null !== a ? $b2(a) : null;
    }
    function $b2(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b = $b2(a);
        if (null !== b)
          return b;
        a = a.sibling;
      }
      return null;
    }
    var ac2 = ca2.unstable_scheduleCallback, bc2 = ca2.unstable_cancelCallback, cc2 = ca2.unstable_shouldYield, dc2 = ca2.unstable_requestPaint, B = ca2.unstable_now, ec2 = ca2.unstable_getCurrentPriorityLevel, fc2 = ca2.unstable_ImmediatePriority, gc2 = ca2.unstable_UserBlockingPriority, hc2 = ca2.unstable_NormalPriority, ic2 = ca2.unstable_LowPriority, jc2 = ca2.unstable_IdlePriority, kc2 = null, lc2 = null;
    function mc2(a) {
      if (lc2 && "function" === typeof lc2.onCommitFiberRoot)
        try {
          lc2.onCommitFiberRoot(kc2, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
    }
    var oc2 = Math.clz32 ? Math.clz32 : nc2, pc2 = Math.log, qc2 = Math.LN2;
    function nc2(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc2(a) / qc2 | 0) | 0;
    }
    var rc2 = 64, sc2 = 4194304;
    function tc2(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc2(a, b) {
      var c = a.pendingLanes;
      if (0 === c)
        return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d = tc2(h) : (f &= g, 0 !== f && (d = tc2(f)));
      } else
        g = c & ~e, 0 !== g ? d = tc2(g) : 0 !== f && (d = tc2(f));
      if (0 === d)
        return 0;
      if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240)))
        return b;
      0 !== (d & 4) && (d |= c & 16);
      b = a.entangledLanes;
      if (0 !== b)
        for (a = a.entanglements, b &= d; 0 < b; )
          c = 31 - oc2(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc2(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc2(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc2(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d))
            e[g] = vc2(h, b);
        } else
          k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    function xc2(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc2() {
      var a = rc2;
      rc2 <<= 1;
      0 === (rc2 & 4194240) && (rc2 = 64);
      return a;
    }
    function zc2(a) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a);
      return b;
    }
    function Ac2(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc2(b);
      a[b] = c;
    }
    function Bc2(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc2(c), f = 1 << e;
        b[e] = 0;
        d[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    function Cc2(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc2(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b);
        c &= ~e;
      }
    }
    var C = 0;
    function Dc2(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec2, Fc2, Gc2, Hc2, Ic2, Jc2 = false, Kc2 = [], Lc2 = null, Mc2 = null, Nc2 = null, Oc2 = /* @__PURE__ */ new Map(), Pc2 = /* @__PURE__ */ new Map(), Qc2 = [], Rc2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc2(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc2 = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc2 = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc2 = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc2.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc2.delete(b.pointerId);
      }
    }
    function Tc2(a, b, c, d, e, f) {
      if (null === a || a.nativeEvent !== f)
        return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb2(b), null !== b && Fc2(b)), a;
      a.eventSystemFlags |= d;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    function Uc2(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc2 = Tc2(Lc2, a, b, c, d, e), true;
        case "dragenter":
          return Mc2 = Tc2(Mc2, a, b, c, d, e), true;
        case "mouseover":
          return Nc2 = Tc2(Nc2, a, b, c, d, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc2.set(f, Tc2(Oc2.get(f) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc2.set(f, Tc2(Pc2.get(f) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Vc2(a) {
      var b = Wc2(a.target);
      if (null !== b) {
        var c = Vb2(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb2(c), null !== b) {
              a.blockedOn = b;
              Ic2(a.priority, function() {
                Gc2(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc2(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc2(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb2 = d;
          c.target.dispatchEvent(d);
          wb2 = null;
        } else
          return b = Cb2(c), null !== b && Fc2(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function Zc2(a, b, c) {
      Xc2(a) && c.delete(b);
    }
    function $c2() {
      Jc2 = false;
      null !== Lc2 && Xc2(Lc2) && (Lc2 = null);
      null !== Mc2 && Xc2(Mc2) && (Mc2 = null);
      null !== Nc2 && Xc2(Nc2) && (Nc2 = null);
      Oc2.forEach(Zc2);
      Pc2.forEach(Zc2);
    }
    function ad2(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc2 || (Jc2 = true, ca2.unstable_scheduleCallback(ca2.unstable_NormalPriority, $c2)));
    }
    function bd2(a) {
      function b(b10) {
        return ad2(b10, a);
      }
      if (0 < Kc2.length) {
        ad2(Kc2[0], a);
        for (var c = 1; c < Kc2.length; c++) {
          var d = Kc2[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Lc2 && ad2(Lc2, a);
      null !== Mc2 && ad2(Mc2, a);
      null !== Nc2 && ad2(Nc2, a);
      Oc2.forEach(b);
      Pc2.forEach(b);
      for (c = 0; c < Qc2.length; c++)
        d = Qc2[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc2.length && (c = Qc2[0], null === c.blockedOn); )
        Vc2(c), null === c.blockedOn && Qc2.shift();
    }
    var cd2 = ua2.ReactCurrentBatchConfig, dd2 = true;
    function ed2(a, b, c, d) {
      var e = C, f = cd2.transition;
      cd2.transition = null;
      try {
        C = 1, fd2(a, b, c, d);
      } finally {
        C = e, cd2.transition = f;
      }
    }
    function gd2(a, b, c, d) {
      var e = C, f = cd2.transition;
      cd2.transition = null;
      try {
        C = 4, fd2(a, b, c, d);
      } finally {
        C = e, cd2.transition = f;
      }
    }
    function fd2(a, b, c, d) {
      if (dd2) {
        var e = Yc2(a, b, c, d);
        if (null === e)
          hd2(a, b, d, id2, c), Sc2(a, d);
        else if (Uc2(e, a, b, c, d))
          d.stopPropagation();
        else if (Sc2(a, d), b & 4 && -1 < Rc2.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb2(e);
            null !== f && Ec2(f);
            f = Yc2(a, b, c, d);
            null === f && hd2(a, b, d, id2, c);
            if (f === e)
              break;
            e = f;
          }
          null !== e && d.stopPropagation();
        } else
          hd2(a, b, d, null, c);
      }
    }
    var id2 = null;
    function Yc2(a, b, c, d) {
      id2 = null;
      a = xb2(d);
      a = Wc2(a);
      if (null !== a)
        if (b = Vb2(a), null === b)
          a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb2(b);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else
          b !== a && (a = null);
      id2 = a;
      return null;
    }
    function jd2(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec2()) {
            case fc2:
              return 1;
            case gc2:
              return 4;
            case hc2:
            case ic2:
              return 16;
            case jc2:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd2 = null, ld2 = null, md2 = null;
    function nd2() {
      if (md2)
        return md2;
      var a, b = ld2, c = b.length, d, e = "value" in kd2 ? kd2.value : kd2.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
        ;
      return md2 = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od2(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd2() {
      return true;
    }
    function qd2() {
      return false;
    }
    function rd2(a) {
      function b(b10, d, e, f, g) {
        this._reactName = b10;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && (b10 = a[c], this[c] = b10 ? b10(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd2 : qd2;
        this.isPropagationStopped = qd2;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a10 = this.nativeEvent;
        a10 && (a10.preventDefault ? a10.preventDefault() : "unknown" !== typeof a10.returnValue && (a10.returnValue = false), this.isDefaultPrevented = pd2);
      }, stopPropagation: function() {
        var a10 = this.nativeEvent;
        a10 && (a10.stopPropagation ? a10.stopPropagation() : "unknown" !== typeof a10.cancelBubble && (a10.cancelBubble = true), this.isPropagationStopped = pd2);
      }, persist: function() {
      }, isPersistent: pd2 });
      return b;
    }
    var sd2 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td2 = rd2(sd2), ud2 = A({}, sd2, { view: 0, detail: 0 }), vd2 = rd2(ud2), wd2, xd2, yd2, Ad2 = A({}, ud2, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd2, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd2 && (yd2 && "mousemove" === a.type ? (wd2 = a.screenX - yd2.screenX, xd2 = a.screenY - yd2.screenY) : xd2 = wd2 = 0, yd2 = a);
      return wd2;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd2;
    } }), Bd2 = rd2(Ad2), Cd2 = A({}, Ad2, { dataTransfer: 0 }), Dd2 = rd2(Cd2), Ed2 = A({}, ud2, { relatedTarget: 0 }), Fd2 = rd2(Ed2), Gd2 = A({}, sd2, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd2 = rd2(Gd2), Id2 = A({}, sd2, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd2 = rd2(Id2), Kd2 = A({}, sd2, { data: 0 }), Ld2 = rd2(Kd2), Md2 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd2 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd2(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od2[a]) ? !!b[a] : false;
    }
    function zd2() {
      return Pd2;
    }
    var Qd2 = A({}, ud2, { key: function(a) {
      if (a.key) {
        var b = Md2[a.key] || a.key;
        if ("Unidentified" !== b)
          return b;
      }
      return "keypress" === a.type ? (a = od2(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd2[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd2, charCode: function(a) {
      return "keypress" === a.type ? od2(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od2(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd2 = rd2(Qd2), Sd2 = A({}, Ad2, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td2 = rd2(Sd2), Ud2 = A({}, ud2, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd2 }), Vd2 = rd2(Ud2), Wd2 = A({}, sd2, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd2 = rd2(Wd2), Yd2 = A({}, Ad2, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd2 = rd2(Yd2), $d2 = [9, 13, 27, 32], ae = ia2 && "CompositionEvent" in window, be = null;
    ia2 && "documentMode" in document && (be = document.documentMode);
    var ce2 = ia2 && "TextEvent" in window && !be, de = ia2 && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d2.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke2(a, b) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b) ? (a = nd2(), md2 = ld2 = kd2 = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    function ne(a, b, c, d) {
      Eb2(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td2("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe2 = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa2(b))
        return a;
    }
    function ve(a, b) {
      if ("change" === a)
        return b;
    }
    var we = false;
    if (ia2) {
      var xe;
      if (ia2) {
        var ye2 = "oninput" in document;
        if (!ye2) {
          var ze2 = document.createElement("div");
          ze2.setAttribute("oninput", "return;");
          ye2 = "function" === typeof ze2.oninput;
        }
        xe = ye2;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be2), qe2 = pe = null);
    }
    function Be2(a) {
      if ("value" === a.propertyName && te(qe2)) {
        var b = [];
        ne(b, qe2, a, xb2(a));
        Jb2(re, b);
      }
    }
    function Ce2(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe2 = c, pe.attachEvent("onpropertychange", Be2)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe2);
    }
    function Ee(a, b) {
      if ("click" === a)
        return te(b);
    }
    function Fe(a, b) {
      if ("input" === a || "change" === a)
        return te(b);
    }
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He2 = "function" === typeof Object.is ? Object.is : Ge;
    function Ie2(a, b) {
      if (He2(a, b))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
        return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return false;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja2.call(b, e) || !He2(a[e], b[e]))
          return false;
      }
      return true;
    }
    function Je2(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke2(a, b) {
      var c = Je2(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b)
            return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je2(c);
      }
    }
    function Le2(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le2(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me2() {
      for (var a = window, b = Xa2(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = Xa2(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    function Oe2(a) {
      var b = Me2(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le2(c.ownerDocument.documentElement, c)) {
        if (null !== d && Ne(c)) {
          if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c)
            c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = void 0 === d.end ? f : Math.min(d.end, e);
            !a.extend && f > d && (e = d, d = f, f = e);
            e = Ke2(c, f);
            var g = Ke2(
              c,
              d
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; )
          1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++)
          a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia2 && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re = null, Se = null, Te2 = false;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te2 || null == Qe2 || Qe2 !== Xa2(d) || (d = Qe2, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie2(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td2("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe2)));
    }
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var We2 = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe2 = {}, Ye2 = {};
    ia2 && (Ye2 = document.createElement("div").style, "AnimationEvent" in window || (delete We2.animationend.animation, delete We2.animationiteration.animation, delete We2.animationstart.animation), "TransitionEvent" in window || delete We2.transitionend.transition);
    function Ze(a) {
      if (Xe2[a])
        return Xe2[a];
      if (!We2[a])
        return a;
      var b = We2[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Ye2)
          return Xe2[a] = b[c];
      return a;
    }
    var $e2 = Ze("animationend"), af2 = Ze("animationiteration"), bf2 = Ze("animationstart"), cf2 = Ze("transitionend"), df2 = /* @__PURE__ */ new Map(), ef2 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff2(a, b) {
      df2.set(a, b);
      fa2(b, [a]);
    }
    for (var gf2 = 0; gf2 < ef2.length; gf2++) {
      var hf2 = ef2[gf2], jf2 = hf2.toLowerCase(), kf2 = hf2[0].toUpperCase() + hf2.slice(1);
      ff2(jf2, "on" + kf2);
    }
    ff2($e2, "onAnimationEnd");
    ff2(af2, "onAnimationIteration");
    ff2(bf2, "onAnimationStart");
    ff2("dblclick", "onDoubleClick");
    ff2("focusin", "onFocus");
    ff2("focusout", "onBlur");
    ff2(cf2, "onTransitionEnd");
    ha2("onMouseEnter", ["mouseout", "mouseover"]);
    ha2("onMouseLeave", ["mouseout", "mouseover"]);
    ha2("onPointerEnter", ["pointerout", "pointerover"]);
    ha2("onPointerLeave", ["pointerout", "pointerover"]);
    fa2("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa2("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa2("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa2("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa2("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf2 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf2));
    function nf2(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c;
      Ub2(d, b, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped())
                break a;
              nf2(e, h, l);
              f = k;
            }
          else
            for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped())
                break a;
              nf2(e, h, l);
              f = k;
            }
        }
      }
      if (Qb2)
        throw a = Rb2, Qb2 = false, Rb2 = null, a;
    }
    function D(a, b) {
      var c = b[of2];
      void 0 === c && (c = b[of2] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf2(b, a, 2, false), c.add(d));
    }
    function qf2(a, b, c) {
      var d = 0;
      b && (d |= 4);
      pf2(c, a, d, b);
    }
    var rf2 = "_reactListening" + Math.random().toString(36).slice(2);
    function sf2(a) {
      if (!a[rf2]) {
        a[rf2] = true;
        da2.forEach(function(b10) {
          "selectionchange" !== b10 && (mf2.has(b10) || qf2(b10, false, a), qf2(b10, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf2] || (b[rf2] = true, qf2("selectionchange", false, b));
      }
    }
    function pf2(a, b, c, d) {
      switch (jd2(b)) {
        case 1:
          var e = ed2;
          break;
        case 4:
          e = gd2;
          break;
        default:
          e = fd2;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb2 || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    function hd2(a, b, c, d, e) {
      var f = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d)
        a:
          for (; ; ) {
            if (null === d)
              return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || 8 === h.nodeType && h.parentNode === e)
                break;
              if (4 === g)
                for (g = d.return; null !== g; ) {
                  var k = g.tag;
                  if (3 === k || 4 === k) {
                    if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                      return;
                  }
                  g = g.return;
                }
              for (; null !== h; ) {
                g = Wc2(h);
                if (null === g)
                  return;
                k = g.tag;
                if (5 === k || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
      Jb2(function() {
        var d10 = f, e10 = xb2(c), g10 = [];
        a: {
          var h10 = df2.get(a);
          if (void 0 !== h10) {
            var k10 = td2, n = a;
            switch (a) {
              case "keypress":
                if (0 === od2(c))
                  break a;
              case "keydown":
              case "keyup":
                k10 = Rd2;
                break;
              case "focusin":
                n = "focus";
                k10 = Fd2;
                break;
              case "focusout":
                n = "blur";
                k10 = Fd2;
                break;
              case "beforeblur":
              case "afterblur":
                k10 = Fd2;
                break;
              case "click":
                if (2 === c.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k10 = Bd2;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k10 = Dd2;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k10 = Vd2;
                break;
              case $e2:
              case af2:
              case bf2:
                k10 = Hd2;
                break;
              case cf2:
                k10 = Xd2;
                break;
              case "scroll":
                k10 = vd2;
                break;
              case "wheel":
                k10 = Zd2;
                break;
              case "copy":
              case "cut":
              case "paste":
                k10 = Jd2;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k10 = Td2;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h10 ? h10 + "Capture" : null : h10;
            t = [];
            for (var w = d10, u; null !== w; ) {
              u = w;
              var F10 = u.stateNode;
              5 === u.tag && null !== F10 && (u = F10, null !== x && (F10 = Kb2(w, x), null != F10 && t.push(tf2(w, F10, u))));
              if (J)
                break;
              w = w.return;
            }
            0 < t.length && (h10 = new k10(h10, n, null, c, e10), g10.push({ event: h10, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h10 = "mouseover" === a || "pointerover" === a;
            k10 = "mouseout" === a || "pointerout" === a;
            if (h10 && c !== wb2 && (n = c.relatedTarget || c.fromElement) && (Wc2(n) || n[uf2]))
              break a;
            if (k10 || h10) {
              h10 = e10.window === e10 ? e10 : (h10 = e10.ownerDocument) ? h10.defaultView || h10.parentWindow : window;
              if (k10) {
                if (n = c.relatedTarget || c.toElement, k10 = d10, n = n ? Wc2(n) : null, null !== n && (J = Vb2(n), n !== J || 5 !== n.tag && 6 !== n.tag))
                  n = null;
              } else
                k10 = null, n = d10;
              if (k10 !== n) {
                t = Bd2;
                F10 = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t = Td2, F10 = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k10 ? h10 : ue(k10);
                u = null == n ? h10 : ue(n);
                h10 = new t(F10, w + "leave", k10, c, e10);
                h10.target = J;
                h10.relatedTarget = u;
                F10 = null;
                Wc2(e10) === d10 && (t = new t(x, w + "enter", n, c, e10), t.target = u, t.relatedTarget = J, F10 = t);
                J = F10;
                if (k10 && n)
                  b: {
                    t = k10;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf2(u))
                      w++;
                    u = 0;
                    for (F10 = x; F10; F10 = vf2(F10))
                      u++;
                    for (; 0 < w - u; )
                      t = vf2(t), w--;
                    for (; 0 < u - w; )
                      x = vf2(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate)
                        break b;
                      t = vf2(t);
                      x = vf2(x);
                    }
                    t = null;
                  }
                else
                  t = null;
                null !== k10 && wf2(g10, h10, k10, t, false);
                null !== n && null !== J && wf2(g10, J, n, t, true);
              }
            }
          }
          a: {
            h10 = d10 ? ue(d10) : window;
            k10 = h10.nodeName && h10.nodeName.toLowerCase();
            if ("select" === k10 || "input" === k10 && "file" === h10.type)
              var na2 = ve;
            else if (me(h10))
              if (we)
                na2 = Fe;
              else {
                na2 = De;
                var xa2 = Ce2;
              }
            else
              (k10 = h10.nodeName) && "input" === k10.toLowerCase() && ("checkbox" === h10.type || "radio" === h10.type) && (na2 = Ee);
            if (na2 && (na2 = na2(a, d10))) {
              ne(g10, na2, c, e10);
              break a;
            }
            xa2 && xa2(a, h10, d10);
            "focusout" === a && (xa2 = h10._wrapperState) && xa2.controlled && "number" === h10.type && cb2(h10, "number", h10.value);
          }
          xa2 = d10 ? ue(d10) : window;
          switch (a) {
            case "focusin":
              if (me(xa2) || "true" === xa2.contentEditable)
                Qe2 = xa2, Re = d10, Se = null;
              break;
            case "focusout":
              Se = Re = Qe2 = null;
              break;
            case "mousedown":
              Te2 = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te2 = false;
              Ue(g10, c, e10);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g10, c, e10);
          }
          var $a2;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba2 = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba2 = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba2 = "onCompositionUpdate";
                  break b;
              }
              ba2 = void 0;
            }
          else
            ie ? ge(a, c) && (ba2 = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba2 = "onCompositionStart");
          ba2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie && ($a2 = nd2()) : (kd2 = e10, ld2 = "value" in kd2 ? kd2.value : kd2.textContent, ie = true)), xa2 = oe(d10, ba2), 0 < xa2.length && (ba2 = new Ld2(ba2, a, null, c, e10), g10.push({ event: ba2, listeners: xa2 }), $a2 ? ba2.data = $a2 : ($a2 = he(c), null !== $a2 && (ba2.data = $a2))));
          if ($a2 = ce2 ? je(a, c) : ke2(a, c))
            d10 = oe(d10, "onBeforeInput"), 0 < d10.length && (e10 = new Ld2("onBeforeInput", "beforeinput", null, c, e10), g10.push({ event: e10, listeners: d10 }), e10.data = $a2);
        }
        se(g10, b);
      });
    }
    function tf2(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb2(a, c), null != f && d.unshift(tf2(a, f, e)), f = Kb2(a, b), null != f && d.push(tf2(a, f, e)));
        a = a.return;
      }
      return d;
    }
    function vf2(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf2(a, b, c, d, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d)
          break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb2(c, f), null != k && g.unshift(tf2(c, k, h))) : e || (k = Kb2(c, f), null != k && g.push(tf2(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    var xf2 = /\r\n?/g, yf2 = /\u0000|\uFFFD/g;
    function zf2(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf2, "\n").replace(yf2, "");
    }
    function Af2(a, b, c) {
      b = zf2(b);
      if (zf2(a) !== b && c)
        throw Error(p(425));
    }
    function Bf2() {
    }
    var Cf2 = null, Df2 = null;
    function Ef2(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff2 = "function" === typeof setTimeout ? setTimeout : void 0, Gf2 = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf2 = "function" === typeof Promise ? Promise : void 0, Jf2 = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf2 ? function(a) {
      return Hf2.resolve(null).then(a).catch(If2);
    } : Ff2;
    function If2(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf2(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType)
          if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd2(b);
              return;
            }
            d--;
          } else
            "$" !== c && "$?" !== c && "$!" !== c || d++;
        c = e;
      } while (c);
      bd2(b);
    }
    function Lf2(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b)
          break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b)
            break;
          if ("/$" === b)
            return null;
        }
      }
      return a;
    }
    function Mf2(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b)
              return a;
            b--;
          } else
            "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf2 = Math.random().toString(36).slice(2), Of2 = "__reactFiber$" + Nf2, Pf2 = "__reactProps$" + Nf2, uf2 = "__reactContainer$" + Nf2, of2 = "__reactEvents$" + Nf2, Qf2 = "__reactListeners$" + Nf2, Rf2 = "__reactHandles$" + Nf2;
    function Wc2(a) {
      var b = a[Of2];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf2] || c[Of2]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child)
            for (a = Mf2(a); null !== a; ) {
              if (c = a[Of2])
                return c;
              a = Mf2(a);
            }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Cb2(a) {
      a = a[Of2] || a[uf2];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p(33));
    }
    function Db2(a) {
      return a[Pf2] || null;
    }
    var Sf2 = [], Tf2 = -1;
    function Uf2(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf2 || (a.current = Sf2[Tf2], Sf2[Tf2] = null, Tf2--);
    }
    function G(a, b) {
      Tf2++;
      Sf2[Tf2] = a.current;
      a.current = b;
    }
    var Vf2 = {}, H = Uf2(Vf2), Wf2 = Uf2(false), Xf2 = Vf2;
    function Yf2(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Vf2;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c)
        e[f] = b[f];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Zf2(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f2() {
      E(Wf2);
      E(H);
    }
    function ag2(a, b, c) {
      if (H.current !== Vf2)
        throw Error(p(168));
      G(H, b);
      G(Wf2, c);
    }
    function bg2(a, b, c) {
      var d = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in b))
          throw Error(p(108, Ra2(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg2(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf2;
      Xf2 = H.current;
      G(H, a);
      G(Wf2, Wf2.current);
      return true;
    }
    function dg2(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(p(169));
      c ? (a = bg2(a, b, Xf2), d.__reactInternalMemoizedMergedChildContext = a, E(Wf2), E(H), G(H, a)) : E(Wf2);
      G(Wf2, c);
    }
    var eg2 = null, fg2 = false, gg2 = false;
    function hg2(a) {
      null === eg2 ? eg2 = [a] : eg2.push(a);
    }
    function ig2(a) {
      fg2 = true;
      hg2(a);
    }
    function jg2() {
      if (!gg2 && null !== eg2) {
        gg2 = true;
        var a = 0, b = C;
        try {
          var c = eg2;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(true);
            while (null !== d);
          }
          eg2 = null;
          fg2 = false;
        } catch (e) {
          throw null !== eg2 && (eg2 = eg2.slice(a + 1)), ac2(fc2, jg2), e;
        } finally {
          C = b, gg2 = false;
        }
      }
      return null;
    }
    var kg2 = [], lg2 = 0, mg2 = null, ng2 = 0, og2 = [], pg2 = 0, qg2 = null, rg2 = 1, sg2 = "";
    function tg2(a, b) {
      kg2[lg2++] = ng2;
      kg2[lg2++] = mg2;
      mg2 = a;
      ng2 = b;
    }
    function ug2(a, b, c) {
      og2[pg2++] = rg2;
      og2[pg2++] = sg2;
      og2[pg2++] = qg2;
      qg2 = a;
      var d = rg2;
      a = sg2;
      var e = 32 - oc2(d) - 1;
      d &= ~(1 << e);
      c += 1;
      var f = 32 - oc2(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32);
        d >>= g;
        e -= g;
        rg2 = 1 << 32 - oc2(b) + e | c << e | d;
        sg2 = f + a;
      } else
        rg2 = 1 << f | c << e | d, sg2 = a;
    }
    function vg2(a) {
      null !== a.return && (tg2(a, 1), ug2(a, 1, 0));
    }
    function wg2(a) {
      for (; a === mg2; )
        mg2 = kg2[--lg2], kg2[lg2] = null, ng2 = kg2[--lg2], kg2[lg2] = null;
      for (; a === qg2; )
        qg2 = og2[--pg2], og2[pg2] = null, sg2 = og2[--pg2], og2[pg2] = null, rg2 = og2[--pg2], og2[pg2] = null;
    }
    var xg2 = null, yg2 = null, I = false, zg2 = null;
    function Ag2(a, b) {
      var c = Bg2(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg2(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg2 = a, yg2 = Lf2(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg2 = a, yg2 = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg2 ? { id: rg2, overflow: sg2 } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg2(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg2 = a, yg2 = null, true) : false;
        default:
          return false;
      }
    }
    function Dg2(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg2(a) {
      if (I) {
        var b = yg2;
        if (b) {
          var c = b;
          if (!Cg2(a, b)) {
            if (Dg2(a))
              throw Error(p(418));
            b = Lf2(c.nextSibling);
            var d = xg2;
            b && Cg2(a, b) ? Ag2(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg2 = a);
          }
        } else {
          if (Dg2(a))
            throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg2 = a;
        }
      }
    }
    function Fg2(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg2 = a;
    }
    function Gg2(a) {
      if (a !== xg2)
        return false;
      if (!I)
        return Fg2(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef2(a.type, a.memoizedProps));
      if (b && (b = yg2)) {
        if (Dg2(a))
          throw Hg2(), Error(p(418));
        for (; b; )
          Ag2(a, b), b = Lf2(b.nextSibling);
      }
      Fg2(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg2 = Lf2(a.nextSibling);
                  break a;
                }
                b--;
              } else
                "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg2 = null;
        }
      } else
        yg2 = xg2 ? Lf2(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg2() {
      for (var a = yg2; a; )
        a = Lf2(a.nextSibling);
    }
    function Ig2() {
      yg2 = xg2 = null;
      I = false;
    }
    function Jg2(a) {
      null === zg2 ? zg2 = [a] : zg2.push(a);
    }
    var Kg2 = ua2.ReactCurrentBatchConfig;
    function Lg2(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag)
              throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(p(147, a));
          var e = d, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f)
            return b.ref;
          b = function(a10) {
            var b10 = e.refs;
            null === a10 ? delete b10[f] : b10[f] = a10;
          };
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a)
          throw Error(p(284));
        if (!c._owner)
          throw Error(p(290, a));
      }
      return a;
    }
    function Mg2(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function Ng2(a) {
      var b = a._init;
      return b(a._payload);
    }
    function Og2(a) {
      function b(b10, c10) {
        if (a) {
          var d10 = b10.deletions;
          null === d10 ? (b10.deletions = [c10], b10.flags |= 16) : d10.push(c10);
        }
      }
      function c(c10, d10) {
        if (!a)
          return null;
        for (; null !== d10; )
          b(c10, d10), d10 = d10.sibling;
        return null;
      }
      function d(a10, b10) {
        for (a10 = /* @__PURE__ */ new Map(); null !== b10; )
          null !== b10.key ? a10.set(b10.key, b10) : a10.set(b10.index, b10), b10 = b10.sibling;
        return a10;
      }
      function e(a10, b10) {
        a10 = Pg2(a10, b10);
        a10.index = 0;
        a10.sibling = null;
        return a10;
      }
      function f(b10, c10, d10) {
        b10.index = d10;
        if (!a)
          return b10.flags |= 1048576, c10;
        d10 = b10.alternate;
        if (null !== d10)
          return d10 = d10.index, d10 < c10 ? (b10.flags |= 2, c10) : d10;
        b10.flags |= 2;
        return c10;
      }
      function g(b10) {
        a && null === b10.alternate && (b10.flags |= 2);
        return b10;
      }
      function h(a10, b10, c10, d10) {
        if (null === b10 || 6 !== b10.tag)
          return b10 = Qg2(c10, a10.mode, d10), b10.return = a10, b10;
        b10 = e(b10, c10);
        b10.return = a10;
        return b10;
      }
      function k(a10, b10, c10, d10) {
        var f10 = c10.type;
        if (f10 === ya2)
          return m(a10, b10, c10.props.children, d10, c10.key);
        if (null !== b10 && (b10.elementType === f10 || "object" === typeof f10 && null !== f10 && f10.$$typeof === Ha2 && Ng2(f10) === b10.type))
          return d10 = e(b10, c10.props), d10.ref = Lg2(a10, b10, c10), d10.return = a10, d10;
        d10 = Rg2(c10.type, c10.key, c10.props, null, a10.mode, d10);
        d10.ref = Lg2(a10, b10, c10);
        d10.return = a10;
        return d10;
      }
      function l(a10, b10, c10, d10) {
        if (null === b10 || 4 !== b10.tag || b10.stateNode.containerInfo !== c10.containerInfo || b10.stateNode.implementation !== c10.implementation)
          return b10 = Sg2(c10, a10.mode, d10), b10.return = a10, b10;
        b10 = e(b10, c10.children || []);
        b10.return = a10;
        return b10;
      }
      function m(a10, b10, c10, d10, f10) {
        if (null === b10 || 7 !== b10.tag)
          return b10 = Tg2(c10, a10.mode, d10, f10), b10.return = a10, b10;
        b10 = e(b10, c10);
        b10.return = a10;
        return b10;
      }
      function q(a10, b10, c10) {
        if ("string" === typeof b10 && "" !== b10 || "number" === typeof b10)
          return b10 = Qg2("" + b10, a10.mode, c10), b10.return = a10, b10;
        if ("object" === typeof b10 && null !== b10) {
          switch (b10.$$typeof) {
            case va2:
              return c10 = Rg2(b10.type, b10.key, b10.props, null, a10.mode, c10), c10.ref = Lg2(a10, null, b10), c10.return = a10, c10;
            case wa2:
              return b10 = Sg2(b10, a10.mode, c10), b10.return = a10, b10;
            case Ha2:
              var d10 = b10._init;
              return q(a10, d10(b10._payload), c10);
          }
          if (eb2(b10) || Ka2(b10))
            return b10 = Tg2(b10, a10.mode, c10, null), b10.return = a10, b10;
          Mg2(a10, b10);
        }
        return null;
      }
      function r(a10, b10, c10, d10) {
        var e10 = null !== b10 ? b10.key : null;
        if ("string" === typeof c10 && "" !== c10 || "number" === typeof c10)
          return null !== e10 ? null : h(a10, b10, "" + c10, d10);
        if ("object" === typeof c10 && null !== c10) {
          switch (c10.$$typeof) {
            case va2:
              return c10.key === e10 ? k(a10, b10, c10, d10) : null;
            case wa2:
              return c10.key === e10 ? l(a10, b10, c10, d10) : null;
            case Ha2:
              return e10 = c10._init, r(
                a10,
                b10,
                e10(c10._payload),
                d10
              );
          }
          if (eb2(c10) || Ka2(c10))
            return null !== e10 ? null : m(a10, b10, c10, d10, null);
          Mg2(a10, c10);
        }
        return null;
      }
      function y(a10, b10, c10, d10, e10) {
        if ("string" === typeof d10 && "" !== d10 || "number" === typeof d10)
          return a10 = a10.get(c10) || null, h(b10, a10, "" + d10, e10);
        if ("object" === typeof d10 && null !== d10) {
          switch (d10.$$typeof) {
            case va2:
              return a10 = a10.get(null === d10.key ? c10 : d10.key) || null, k(b10, a10, d10, e10);
            case wa2:
              return a10 = a10.get(null === d10.key ? c10 : d10.key) || null, l(b10, a10, d10, e10);
            case Ha2:
              var f10 = d10._init;
              return y(a10, b10, c10, f10(d10._payload), e10);
          }
          if (eb2(d10) || Ka2(d10))
            return a10 = a10.get(c10) || null, m(b10, a10, d10, e10, null);
          Mg2(b10, d10);
        }
        return null;
      }
      function n(e10, g10, h10, k10) {
        for (var l10 = null, m10 = null, u = g10, w = g10 = 0, x = null; null !== u && w < h10.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n10 = r(e10, u, h10[w], k10);
          if (null === n10) {
            null === u && (u = x);
            break;
          }
          a && u && null === n10.alternate && b(e10, u);
          g10 = f(n10, g10, w);
          null === m10 ? l10 = n10 : m10.sibling = n10;
          m10 = n10;
          u = x;
        }
        if (w === h10.length)
          return c(e10, u), I && tg2(e10, w), l10;
        if (null === u) {
          for (; w < h10.length; w++)
            u = q(e10, h10[w], k10), null !== u && (g10 = f(u, g10, w), null === m10 ? l10 = u : m10.sibling = u, m10 = u);
          I && tg2(e10, w);
          return l10;
        }
        for (u = d(e10, u); w < h10.length; w++)
          x = y(u, e10, w, h10[w], k10), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g10 = f(x, g10, w), null === m10 ? l10 = x : m10.sibling = x, m10 = x);
        a && u.forEach(function(a10) {
          return b(e10, a10);
        });
        I && tg2(e10, w);
        return l10;
      }
      function t(e10, g10, h10, k10) {
        var l10 = Ka2(h10);
        if ("function" !== typeof l10)
          throw Error(p(150));
        h10 = l10.call(h10);
        if (null == h10)
          throw Error(p(151));
        for (var u = l10 = null, m10 = g10, w = g10 = 0, x = null, n10 = h10.next(); null !== m10 && !n10.done; w++, n10 = h10.next()) {
          m10.index > w ? (x = m10, m10 = null) : x = m10.sibling;
          var t10 = r(e10, m10, n10.value, k10);
          if (null === t10) {
            null === m10 && (m10 = x);
            break;
          }
          a && m10 && null === t10.alternate && b(e10, m10);
          g10 = f(t10, g10, w);
          null === u ? l10 = t10 : u.sibling = t10;
          u = t10;
          m10 = x;
        }
        if (n10.done)
          return c(
            e10,
            m10
          ), I && tg2(e10, w), l10;
        if (null === m10) {
          for (; !n10.done; w++, n10 = h10.next())
            n10 = q(e10, n10.value, k10), null !== n10 && (g10 = f(n10, g10, w), null === u ? l10 = n10 : u.sibling = n10, u = n10);
          I && tg2(e10, w);
          return l10;
        }
        for (m10 = d(e10, m10); !n10.done; w++, n10 = h10.next())
          n10 = y(m10, e10, w, n10.value, k10), null !== n10 && (a && null !== n10.alternate && m10.delete(null === n10.key ? w : n10.key), g10 = f(n10, g10, w), null === u ? l10 = n10 : u.sibling = n10, u = n10);
        a && m10.forEach(function(a10) {
          return b(e10, a10);
        });
        I && tg2(e10, w);
        return l10;
      }
      function J(a10, d10, f10, h10) {
        "object" === typeof f10 && null !== f10 && f10.type === ya2 && null === f10.key && (f10 = f10.props.children);
        if ("object" === typeof f10 && null !== f10) {
          switch (f10.$$typeof) {
            case va2:
              a: {
                for (var k10 = f10.key, l10 = d10; null !== l10; ) {
                  if (l10.key === k10) {
                    k10 = f10.type;
                    if (k10 === ya2) {
                      if (7 === l10.tag) {
                        c(a10, l10.sibling);
                        d10 = e(l10, f10.props.children);
                        d10.return = a10;
                        a10 = d10;
                        break a;
                      }
                    } else if (l10.elementType === k10 || "object" === typeof k10 && null !== k10 && k10.$$typeof === Ha2 && Ng2(k10) === l10.type) {
                      c(a10, l10.sibling);
                      d10 = e(l10, f10.props);
                      d10.ref = Lg2(a10, l10, f10);
                      d10.return = a10;
                      a10 = d10;
                      break a;
                    }
                    c(a10, l10);
                    break;
                  } else
                    b(a10, l10);
                  l10 = l10.sibling;
                }
                f10.type === ya2 ? (d10 = Tg2(f10.props.children, a10.mode, h10, f10.key), d10.return = a10, a10 = d10) : (h10 = Rg2(f10.type, f10.key, f10.props, null, a10.mode, h10), h10.ref = Lg2(a10, d10, f10), h10.return = a10, a10 = h10);
              }
              return g(a10);
            case wa2:
              a: {
                for (l10 = f10.key; null !== d10; ) {
                  if (d10.key === l10)
                    if (4 === d10.tag && d10.stateNode.containerInfo === f10.containerInfo && d10.stateNode.implementation === f10.implementation) {
                      c(a10, d10.sibling);
                      d10 = e(d10, f10.children || []);
                      d10.return = a10;
                      a10 = d10;
                      break a;
                    } else {
                      c(a10, d10);
                      break;
                    }
                  else
                    b(a10, d10);
                  d10 = d10.sibling;
                }
                d10 = Sg2(f10, a10.mode, h10);
                d10.return = a10;
                a10 = d10;
              }
              return g(a10);
            case Ha2:
              return l10 = f10._init, J(a10, d10, l10(f10._payload), h10);
          }
          if (eb2(f10))
            return n(a10, d10, f10, h10);
          if (Ka2(f10))
            return t(a10, d10, f10, h10);
          Mg2(a10, f10);
        }
        return "string" === typeof f10 && "" !== f10 || "number" === typeof f10 ? (f10 = "" + f10, null !== d10 && 6 === d10.tag ? (c(a10, d10.sibling), d10 = e(d10, f10), d10.return = a10, a10 = d10) : (c(a10, d10), d10 = Qg2(f10, a10.mode, h10), d10.return = a10, a10 = d10), g(a10)) : c(a10, d10);
      }
      return J;
    }
    var Ug2 = Og2(true), Vg2 = Og2(false), Wg2 = Uf2(null), Xg2 = null, Yg2 = null, Zg2 = null;
    function $g2() {
      Zg2 = Yg2 = Xg2 = null;
    }
    function ah2(a) {
      var b = Wg2.current;
      E(Wg2);
      a._currentValue = b;
    }
    function bh2(a, b, c) {
      for (; null !== a; ) {
        var d = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a === c)
          break;
        a = a.return;
      }
    }
    function ch2(a, b) {
      Xg2 = a;
      Zg2 = Yg2 = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh2 = true), a.firstContext = null);
    }
    function eh2(a) {
      var b = a._currentValue;
      if (Zg2 !== a)
        if (a = { context: a, memoizedValue: b, next: null }, null === Yg2) {
          if (null === Xg2)
            throw Error(p(308));
          Yg2 = a;
          Xg2.dependencies = { lanes: 0, firstContext: a };
        } else
          Yg2 = Yg2.next = a;
      return b;
    }
    var fh2 = null;
    function gh2(a) {
      null === fh2 ? fh2 = [a] : fh2.push(a);
    }
    function hh2(a, b, c, d) {
      var e = b.interleaved;
      null === e ? (c.next = c, gh2(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return ih2(a, d);
    }
    function ih2(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    var jh2 = false;
    function kh2(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh2(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function mh2(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh2(a, b, c) {
      var d = a.updateQueue;
      if (null === d)
        return null;
      d = d.shared;
      if (0 !== (K10 & 2)) {
        var e = d.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d.pending = b;
        return ih2(a, c);
      }
      e = d.interleaved;
      null === e ? (b.next = b, gh2(d)) : (b.next = e.next, e.next = b);
      d.interleaved = b;
      return ih2(a, c);
    }
    function oh2(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc2(a, c);
      }
    }
    function ph2(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else
          e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    function qh2(a, b, c, d) {
      var e = a.updateQueue;
      jh2 = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m = a.alternate;
        null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d & r) === r) {
            null !== m && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r = "function" === typeof n ? n.call(y, q, r) : n;
                  if (null === r || void 0 === r)
                    break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  jh2 = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
          } else
            y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
          h = h.next;
          if (null === h)
            if (h = e.shared.pending, null === h)
              break;
            else
              r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else
          null === f && (e.shared.lanes = 0);
        rh2 |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    function sh2(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e)
              throw Error(p(191, e));
            e.call(d);
          }
        }
    }
    var th2 = {}, uh2 = Uf2(th2), vh2 = Uf2(th2), wh2 = Uf2(th2);
    function xh2(a) {
      if (a === th2)
        throw Error(p(174));
      return a;
    }
    function yh2(a, b) {
      G(wh2, b);
      G(vh2, a);
      G(uh2, th2);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb2(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb2(b, a);
      }
      E(uh2);
      G(uh2, b);
    }
    function zh2() {
      E(uh2);
      E(vh2);
      E(wh2);
    }
    function Ah2(a) {
      xh2(wh2.current);
      var b = xh2(uh2.current);
      var c = lb2(b, a.type);
      b !== c && (G(vh2, a), G(uh2, c));
    }
    function Bh2(a) {
      vh2.current === a && (E(uh2), E(vh2));
    }
    var L = Uf2(0);
    function Ch2(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Dh2 = [];
    function Eh2() {
      for (var a = 0; a < Dh2.length; a++)
        Dh2[a]._workInProgressVersionPrimary = null;
      Dh2.length = 0;
    }
    var Fh2 = ua2.ReactCurrentDispatcher, Gh2 = ua2.ReactCurrentBatchConfig, Hh2 = 0, M = null, N = null, O = null, Ih2 = false, Jh2 = false, Kh2 = 0, Lh2 = 0;
    function P10() {
      throw Error(p(321));
    }
    function Mh2(a, b) {
      if (null === b)
        return false;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He2(a[c], b[c]))
          return false;
      return true;
    }
    function Nh2(a, b, c, d, e, f) {
      Hh2 = f;
      M = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Fh2.current = null === a || null === a.memoizedState ? Oh2 : Ph2;
      a = c(d, e);
      if (Jh2) {
        f = 0;
        do {
          Jh2 = false;
          Kh2 = 0;
          if (25 <= f)
            throw Error(p(301));
          f += 1;
          O = N = null;
          b.updateQueue = null;
          Fh2.current = Qh2;
          a = c(d, e);
        } while (Jh2);
      }
      Fh2.current = Rh2;
      b = null !== N && null !== N.next;
      Hh2 = 0;
      O = N = M = null;
      Ih2 = false;
      if (b)
        throw Error(p(300));
      return a;
    }
    function Sh2() {
      var a = 0 !== Kh2;
      Kh2 = 0;
      return a;
    }
    function Th2() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
      return O;
    }
    function Uh2() {
      if (null === N) {
        var a = M.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = N.next;
      var b = null === O ? M.memoizedState : O.next;
      if (null !== b)
        O = b, N = a;
      else {
        if (null === a)
          throw Error(p(310));
        N = a;
        a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
      }
      return O;
    }
    function Vh2(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function Wh2(a) {
      var b = Uh2(), c = b.queue;
      if (null === c)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = N, e = d.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Hh2 & m) === m)
            null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d) : k = k.next = q;
            M.lanes |= m;
            rh2 |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d : k.next = h;
        He2(d, b.memoizedState) || (dh2 = true);
        b.memoizedState = d;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, M.lanes |= f, rh2 |= f, e = e.next;
        while (e !== a);
      } else
        null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function Xh2(a) {
      var b = Uh2(), c = b.queue;
      if (null === c)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He2(f, b.memoizedState) || (dh2 = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Yh2() {
    }
    function Zh2(a, b) {
      var c = M, d = Uh2(), e = b(), f = !He2(d.memoizedState, e);
      f && (d.memoizedState = e, dh2 = true);
      d = d.queue;
      $h2(ai2.bind(null, c, d, a), [a]);
      if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
        c.flags |= 2048;
        bi2(9, ci2.bind(null, c, d, e, b), void 0, null);
        if (null === Q)
          throw Error(p(349));
        0 !== (Hh2 & 30) || di2(c, b, e);
      }
      return e;
    }
    function di2(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    function ci2(a, b, c, d) {
      b.value = c;
      b.getSnapshot = d;
      ei2(b) && fi2(a);
    }
    function ai2(a, b, c) {
      return c(function() {
        ei2(b) && fi2(a);
      });
    }
    function ei2(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He2(a, c);
      } catch (d) {
        return true;
      }
    }
    function fi2(a) {
      var b = ih2(a, 1);
      null !== b && gi2(b, a, 1, -1);
    }
    function hi(a) {
      var b = Th2();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh2, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ii2.bind(null, M, a);
      return [b.memoizedState, a];
    }
    function bi2(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function ji() {
      return Uh2().memoizedState;
    }
    function ki2(a, b, c, d) {
      var e = Th2();
      M.flags |= a;
      e.memoizedState = bi2(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function li2(a, b, c, d) {
      var e = Uh2();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== N) {
        var g = N.memoizedState;
        f = g.destroy;
        if (null !== d && Mh2(d, g.deps)) {
          e.memoizedState = bi2(b, c, f, d);
          return;
        }
      }
      M.flags |= a;
      e.memoizedState = bi2(1 | b, c, f, d);
    }
    function mi2(a, b) {
      return ki2(8390656, 8, a, b);
    }
    function $h2(a, b) {
      return li2(2048, 8, a, b);
    }
    function ni2(a, b) {
      return li2(4, 2, a, b);
    }
    function oi2(a, b) {
      return li2(4, 4, a, b);
    }
    function pi2(a, b) {
      if ("function" === typeof b)
        return a = a(), b(a), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function qi2(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return li2(4, 4, pi2.bind(null, b, a), c);
    }
    function ri2() {
    }
    function si2(a, b) {
      var c = Uh2();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh2(b, d[1]))
        return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function ti2(a, b) {
      var c = Uh2();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Mh2(b, d[1]))
        return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function ui2(a, b, c) {
      if (0 === (Hh2 & 21))
        return a.baseState && (a.baseState = false, dh2 = true), a.memoizedState = c;
      He2(c, b) || (c = yc2(), M.lanes |= c, rh2 |= c, a.baseState = true);
      return b;
    }
    function vi2(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d = Gh2.transition;
      Gh2.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Gh2.transition = d;
      }
    }
    function wi2() {
      return Uh2().memoizedState;
    }
    function xi2(a, b, c) {
      var d = yi2(a);
      c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi2(a))
        Ai2(b, c);
      else if (c = hh2(a, b, c, d), null !== c) {
        var e = R();
        gi2(c, a, d, e);
        Bi2(c, b, d);
      }
    }
    function ii2(a, b, c) {
      var d = yi2(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
      if (zi2(a))
        Ai2(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f))
          try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He2(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh2(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
        c = hh2(a, b, e, d);
        null !== c && (e = R(), gi2(c, a, d, e), Bi2(c, b, d));
      }
    }
    function zi2(a) {
      var b = a.alternate;
      return a === M || null !== b && b === M;
    }
    function Ai2(a, b) {
      Jh2 = Ih2 = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    function Bi2(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d = b.lanes;
        d &= a.pendingLanes;
        c |= d;
        b.lanes = c;
        Cc2(a, c);
      }
    }
    var Rh2 = { readContext: eh2, useCallback: P10, useContext: P10, useEffect: P10, useImperativeHandle: P10, useInsertionEffect: P10, useLayoutEffect: P10, useMemo: P10, useReducer: P10, useRef: P10, useState: P10, useDebugValue: P10, useDeferredValue: P10, useTransition: P10, useMutableSource: P10, useSyncExternalStore: P10, useId: P10, unstable_isNewReconciler: false }, Oh2 = { readContext: eh2, useCallback: function(a, b) {
      Th2().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, useContext: eh2, useEffect: mi2, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ki2(
        4194308,
        4,
        pi2.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ki2(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ki2(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Th2();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, useReducer: function(a, b, c) {
      var d = Th2();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d.queue = a;
      a = a.dispatch = xi2.bind(null, M, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = Th2();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: hi, useDebugValue: ri2, useDeferredValue: function(a) {
      return Th2().memoizedState = a;
    }, useTransition: function() {
      var a = hi(false), b = a[0];
      a = vi2.bind(null, a[1]);
      Th2().memoizedState = a;
      return [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th2();
      if (I) {
        if (void 0 === c)
          throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === Q)
          throw Error(p(349));
        0 !== (Hh2 & 30) || di2(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      mi2(ai2.bind(
        null,
        d,
        f,
        a
      ), [a]);
      d.flags |= 2048;
      bi2(9, ci2.bind(null, d, f, c, b), void 0, null);
      return c;
    }, useId: function() {
      var a = Th2(), b = Q.identifierPrefix;
      if (I) {
        var c = sg2;
        var d = rg2;
        c = (d & ~(1 << 32 - oc2(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Kh2++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else
        c = Lh2++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: false }, Ph2 = {
      readContext: eh2,
      useCallback: si2,
      useContext: eh2,
      useEffect: $h2,
      useImperativeHandle: qi2,
      useInsertionEffect: ni2,
      useLayoutEffect: oi2,
      useMemo: ti2,
      useReducer: Wh2,
      useRef: ji,
      useState: function() {
        return Wh2(Vh2);
      },
      useDebugValue: ri2,
      useDeferredValue: function(a) {
        var b = Uh2();
        return ui2(b, N.memoizedState, a);
      },
      useTransition: function() {
        var a = Wh2(Vh2)[0], b = Uh2().memoizedState;
        return [a, b];
      },
      useMutableSource: Yh2,
      useSyncExternalStore: Zh2,
      useId: wi2,
      unstable_isNewReconciler: false
    }, Qh2 = { readContext: eh2, useCallback: si2, useContext: eh2, useEffect: $h2, useImperativeHandle: qi2, useInsertionEffect: ni2, useLayoutEffect: oi2, useMemo: ti2, useReducer: Xh2, useRef: ji, useState: function() {
      return Xh2(Vh2);
    }, useDebugValue: ri2, useDeferredValue: function(a) {
      var b = Uh2();
      return null === N ? b.memoizedState = a : ui2(b, N.memoizedState, a);
    }, useTransition: function() {
      var a = Xh2(Vh2)[0], b = Uh2().memoizedState;
      return [a, b];
    }, useMutableSource: Yh2, useSyncExternalStore: Zh2, useId: wi2, unstable_isNewReconciler: false };
    function Ci2(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a)
          void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Di2(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    var Ei2 = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb2(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi2(a), f = mh2(d, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh2(a, f, e);
      null !== b && (gi2(b, a, e, d), oh2(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi2(a), f = mh2(d, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = nh2(a, f, e);
      null !== b && (gi2(b, a, e, d), oh2(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi2(a), e = mh2(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = nh2(a, e, d);
      null !== b && (gi2(b, a, d, c), oh2(b, a, d));
    } };
    function Fi(a, b, c, d, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie2(c, d) || !Ie2(e, f) : true;
    }
    function Gi2(a, b, c) {
      var d = false, e = Vf2;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = eh2(f) : (e = Zf2(b) ? Xf2 : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf2(a, e) : Vf2);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Ei2;
      a.stateNode = b;
      b._reactInternals = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function Hi2(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && Ei2.enqueueReplaceState(b, b.state, null);
    }
    function Ii2(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = {};
      kh2(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = eh2(f) : (f = Zf2(b) ? Xf2 : H.current, e.context = Yf2(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (Di2(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei2.enqueueReplaceState(e, e.state, null), qh2(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    function Ji2(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa2(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Ki2(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    function Li2(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Mi2 = "function" === typeof WeakMap ? WeakMap : Map;
    function Ni2(a, b, c) {
      c = mh2(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Oi2 || (Oi2 = true, Pi2 = d);
        Li2(a, b);
      };
      return c;
    }
    function Qi2(a, b, c) {
      c = mh2(-1, c);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          return d(e);
        };
        c.callback = function() {
          Li2(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Li2(a, b);
        "function" !== typeof d && (null === Ri2 ? Ri2 = /* @__PURE__ */ new Set([this]) : Ri2.add(this));
        var c10 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c10 ? c10 : "" });
      });
      return c;
    }
    function Si2(a, b, c) {
      var d = a.pingCache;
      if (null === d) {
        d = a.pingCache = new Mi2();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else
        e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ti2.bind(null, a, b, c), b.then(a, a));
    }
    function Ui(a) {
      do {
        var b;
        if (b = 13 === a.tag)
          b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Vi2(a, b, c, d, e) {
      if (0 === (a.mode & 1))
        return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh2(-1, 1), b.tag = 2, nh2(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    var Wi = ua2.ReactCurrentOwner, dh2 = false;
    function Xi2(a, b, c, d) {
      b.child = null === a ? Vg2(b, null, c, d) : Ug2(b, a.child, c, d);
    }
    function Yi2(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      ch2(b, e);
      d = Nh2(a, b, c, d, f, e);
      c = Sh2();
      if (null !== a && !dh2)
        return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi2(a, b, e);
      I && c && vg2(b);
      b.flags |= 1;
      Xi2(a, b, d, e);
      return b.child;
    }
    function $i2(a, b, c, d, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps)
          return b.tag = 15, b.type = f, bj(a, b, f, d, e);
        a = Rg2(c.type, null, d, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie2;
        if (c(g, d) && a.ref === b.ref)
          return Zi2(a, b, e);
      }
      b.flags |= 1;
      a = Pg2(f, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function bj(a, b, c, d, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie2(f, d) && a.ref === b.ref)
          if (dh2 = false, b.pendingProps = d = f, 0 !== (a.lanes & e))
            0 !== (a.flags & 131072) && (dh2 = true);
          else
            return b.lanes = a.lanes, Zi2(a, b, e);
      }
      return cj(a, b, c, d, e);
    }
    function dj(a, b, c) {
      var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d.mode)
        if (0 === (b.mode & 1))
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824))
            return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
      else
        null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
      Xi2(a, b, e, c);
      return b.child;
    }
    function gj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c)
        b.flags |= 512, b.flags |= 2097152;
    }
    function cj(a, b, c, d, e) {
      var f = Zf2(c) ? Xf2 : H.current;
      f = Yf2(b, f);
      ch2(b, e);
      c = Nh2(a, b, c, d, f, e);
      d = Sh2();
      if (null !== a && !dh2)
        return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi2(a, b, e);
      I && d && vg2(b);
      b.flags |= 1;
      Xi2(a, b, c, e);
      return b.child;
    }
    function hj(a, b, c, d, e) {
      if (Zf2(c)) {
        var f = true;
        cg2(b);
      } else
        f = false;
      ch2(b, e);
      if (null === b.stateNode)
        ij(a, b), Gi2(b, c, d), Ii2(b, c, d, e), d = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = eh2(l) : (l = Zf2(c) ? Xf2 : H.current, l = Yf2(b, l));
        var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi2(b, g, d, l);
        jh2 = false;
        var r = b.memoizedState;
        g.state = r;
        qh2(b, d, g, e);
        k = b.memoizedState;
        h !== d || r !== k || Wf2.current || jh2 ? ("function" === typeof m && (Di2(b, c, m, d), k = b.memoizedState), (h = jh2 || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g = b.stateNode;
        lh2(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Ci2(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = eh2(k) : (k = Zf2(c) ? Xf2 : H.current, k = Yf2(b, k));
        var y = c.getDerivedStateFromProps;
        (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi2(b, g, d, k);
        jh2 = false;
        r = b.memoizedState;
        g.state = r;
        qh2(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf2.current || jh2 ? ("function" === typeof y && (Di2(b, c, y, d), n = b.memoizedState), (l = jh2 || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
      }
      return jj(a, b, c, d, f, e);
    }
    function jj(a, b, c, d, e, f) {
      gj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d && !g)
        return e && dg2(b, c, false), Zi2(a, b, f);
      d = b.stateNode;
      Wi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Ug2(b, a.child, null, f), b.child = Ug2(b, null, h, f)) : Xi2(a, b, h, f);
      b.memoizedState = d.state;
      e && dg2(b, c, true);
      return b.child;
    }
    function kj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag2(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag2(a, b.context, false);
      yh2(a, b.containerInfo);
    }
    function lj(a, b, c, d, e) {
      Ig2();
      Jg2(e);
      b.flags |= 256;
      Xi2(a, b, c, d);
      return b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function oj(a, b, c) {
      var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h)
        f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e |= 1;
      G(L, e & 1);
      if (null === a) {
        Eg2(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d.children;
        a = d.fallback;
        return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg2(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h))
        return rj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg2(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = Pg2(h, f) : (f = Tg2(f, g, c, null), f.flags |= 2);
        f.return = b;
        d.return = b;
        d.sibling = f;
        b.child = d;
        d = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = mj;
        return d;
      }
      f = a.child;
      a = f.sibling;
      d = Pg2(f, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c);
      d.return = b;
      d.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function qj(a, b) {
      b = pj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    function sj(a, b, c, d) {
      null !== d && Jg2(d);
      Ug2(b, a.child, null, c);
      a = qj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    function rj(a, b, c, d, e, f, g) {
      if (c) {
        if (b.flags & 256)
          return b.flags &= -257, d = Ki2(Error(p(422))), sj(a, b, g, d);
        if (null !== b.memoizedState)
          return b.child = a.child, b.flags |= 128, null;
        f = d.fallback;
        e = b.mode;
        d = pj({ mode: "visible", children: d.children }, e, 0, null);
        f = Tg2(f, e, g, null);
        f.flags |= 2;
        d.return = b;
        f.return = b;
        d.sibling = f;
        b.child = d;
        0 !== (b.mode & 1) && Ug2(b, a.child, null, g);
        b.child.memoizedState = nj(g);
        b.memoizedState = mj;
        return f;
      }
      if (0 === (b.mode & 1))
        return sj(a, b, g, null);
      if ("$!" === e.data) {
        d = e.nextSibling && e.nextSibling.dataset;
        if (d)
          var h = d.dgst;
        d = h;
        f = Error(p(419));
        d = Ki2(f, d, void 0);
        return sj(a, b, g, d);
      }
      h = 0 !== (g & a.childLanes);
      if (dh2 || h) {
        d = Q;
        if (null !== d) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, ih2(a, e), gi2(d, a, e, -1));
        }
        tj();
        d = Ki2(Error(p(421)));
        return sj(a, b, g, d);
      }
      if ("$?" === e.data)
        return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg2 = Lf2(e.nextSibling);
      xg2 = b;
      I = true;
      zg2 = null;
      null !== a && (og2[pg2++] = rg2, og2[pg2++] = sg2, og2[pg2++] = qg2, rg2 = a.id, sg2 = a.overflow, qg2 = b);
      b = qj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function vj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      null !== d && (d.lanes |= b);
      bh2(a.return, b, c);
    }
    function wj(a, b, c, d, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function xj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Xi2(a, b, d.children, c);
      d = L.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && vj(a, c, b);
              else if (19 === a.tag)
                vj(a, c, b);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d &= 1;
      }
      G(L, d);
      if (0 === (b.mode & 1))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; )
              a = c.alternate, null !== a && null === Ch2(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch2(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function ij(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi2(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      rh2 |= b.lanes;
      if (0 === (c & b.childLanes))
        return null;
      if (null !== a && b.child !== a.child)
        throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = Pg2(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; )
          a = a.sibling, c = c.sibling = Pg2(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function yj(a, b, c) {
      switch (b.tag) {
        case 3:
          kj(b);
          Ig2();
          break;
        case 5:
          Ah2(b);
          break;
        case 1:
          Zf2(b.type) && cg2(b);
          break;
        case 4:
          yh2(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg2, d._currentValue);
          d._currentValue = e;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated)
              return G(L, L.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes))
              return oj(a, b, c);
            G(L, L.current & 1);
            a = Zi2(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(L, L.current & 1);
          break;
        case 19:
          d = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d)
              return xj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(L, L.current);
          if (d)
            break;
          else
            return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a, b, c);
      }
      return Zi2(a, b, c);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag)
          a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode;
        xh2(uh2.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya2(a, e);
            d = Ya2(a, d);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb2(a, e);
            d = gb2(a, d);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf2);
        }
        ub2(c, d);
        var g;
        c = null;
        for (l in e)
          if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
            if ("style" === l) {
              var h = e[l];
              for (g in h)
                h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else
              "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea2.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          h = null != e ? e[l] : void 0;
          if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
            if ("style" === l)
              if (h) {
                for (g in h)
                  !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                for (g in k)
                  k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
              } else
                c || (f || (f = []), f.push(
                  l,
                  c
                )), c = k;
            else
              "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea2.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l)
          b.flags |= 4;
      }
    };
    Cj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Dj(a, b) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; )
              null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; )
              null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
    }
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
      if (b)
        for (var e = a.child; null !== e; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else
        for (e = a.child; null !== e; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d;
      a.childLanes = c;
      return b;
    }
    function Ej(a, b, c) {
      var d = b.pendingProps;
      wg2(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf2(b.type) && $f2(), S(b), null;
        case 3:
          d = b.stateNode;
          zh2();
          E(Wf2);
          E(H);
          Eh2();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a || null === a.child)
            Gg2(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg2 && (Fj(zg2), zg2 = null));
          Aj(a, b);
          S(b);
          return null;
        case 5:
          Bh2(b);
          var e = xh2(wh2.current);
          c = b.type;
          if (null !== a && null != b.stateNode)
            Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode)
                throw Error(p(166));
              S(b);
              return null;
            }
            a = xh2(uh2.current);
            if (Gg2(b)) {
              d = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d[Of2] = b;
              d[Pf2] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf2.length; e++)
                    D(lf2[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za2(d, f);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb2(d, f), D("invalid", d);
              }
              ub2(c, f);
              e = null;
              for (var g in f)
                if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af2(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af2(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea2.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
              switch (c) {
                case "input":
                  Va2(d);
                  db2(d, f, true);
                  break;
                case "textarea":
                  Va2(d);
                  jb2(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d.onclick = Bf2);
              }
              d = e;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb2(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
              a[Of2] = b;
              a[Pf2] = d;
              zj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb2(c, d);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf2.length; e++)
                      D(lf2[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za2(a, d);
                    e = Ya2(a, d);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = A({}, d, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb2(a, d);
                    e = gb2(a, d);
                    D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub2(c, e);
                h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb2(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb2(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob2(a, k) : "number" === typeof k && ob2(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea2.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta2(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va2(a);
                    db2(a, d, false);
                    break;
                  case "textarea":
                    Va2(a);
                    jb2(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa2(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb2(a, !!d.multiple, f, false) : null != d.defaultValue && fb2(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf2);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode)
            Cj(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(p(166));
            c = xh2(wh2.current);
            xh2(uh2.current);
            if (Gg2(b)) {
              d = b.stateNode;
              c = b.memoizedProps;
              d[Of2] = b;
              if (f = d.nodeValue !== c) {
                if (a = xg2, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af2(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af2(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
              }
              f && (b.flags |= 4);
            } else
              d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of2] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(L);
          d = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg2 && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
              Hg2(), Ig2(), b.flags |= 98560, f = false;
            else if (f = Gg2(b), null !== d && null !== d.dehydrated) {
              if (null === a) {
                if (!f)
                  throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f)
                  throw Error(p(317));
                f[Of2] = b;
              } else
                Ig2(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else
              null !== zg2 && (Fj(zg2), zg2 = null), f = true;
            if (!f)
              return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128))
            return b.lanes = c, b;
          d = null !== d;
          d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T10 && (T10 = 3) : tj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return zh2(), Aj(a, b), null === a && sf2(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah2(b.type._context), S(b), null;
        case 17:
          return Zf2(b.type) && $f2(), S(b), null;
        case 19:
          E(L);
          f = b.memoizedState;
          if (null === f)
            return S(b), null;
          d = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g)
            if (d)
              Dj(f, false);
            else {
              if (0 !== T10 || null !== a && 0 !== (a.flags & 128))
                for (a = b.child; null !== a; ) {
                  g = Ch2(a);
                  if (null !== g) {
                    b.flags |= 128;
                    Dj(f, false);
                    d = g.updateQueue;
                    null !== d && (b.updateQueue = d, b.flags |= 4);
                    b.subtreeFlags = 0;
                    d = c;
                    for (c = b.child; null !== c; )
                      f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                    G(L, L.current & 1 | 2);
                    return b.child;
                  }
                  a = a.sibling;
                }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
          else {
            if (!d)
              if (a = Ch2(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I)
                  return S(b), null;
              } else
                2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail)
            return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a, b) {
      wg2(b);
      switch (b.tag) {
        case 1:
          return Zf2(b.type) && $f2(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return zh2(), E(Wf2), E(H), Eh2(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Bh2(b), null;
        case 13:
          E(L);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate)
              throw Error(p(340));
            Ig2();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(L), null;
        case 4:
          return zh2(), null;
        case 10:
          return ah2(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Lj(a, b) {
      var c = a.ref;
      if (null !== c)
        if ("function" === typeof c)
          try {
            c(null);
          } catch (d) {
            W(a, b, d);
          }
        else
          c.current = null;
    }
    function Mj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Nj = false;
    function Oj(a, b) {
      Cf2 = dd2;
      a = Me2();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F10) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b:
                for (; ; ) {
                  for (var y; ; ) {
                    q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                    q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                    3 === q.nodeType && (g += q.nodeValue.length);
                    if (null === (y = q.firstChild))
                      break;
                    r = q;
                    q = y;
                  }
                  for (; ; ) {
                    if (q === a)
                      break b;
                    r === c && ++l === e && (h = g);
                    r === f && ++m === d && (k = g);
                    if (null !== (y = q.nextSibling))
                      break;
                    q = r;
                    r = q.parentNode;
                  }
                  q = y;
                }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else
              c = null;
          }
        c = c || { start: 0, end: 0 };
      } else
        c = null;
      Df2 = { focusedElem: a, selectionRange: c };
      dd2 = false;
      for (V = b; null !== V; )
        if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a)
          a.return = b, V = a;
        else
          for (; null !== V; ) {
            b = V;
            try {
              var n = b.alternate;
              if (0 !== (b.flags & 1024))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n) {
                      var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci2(b.type, t), J);
                      x.__reactInternalSnapshotBeforeUpdate = w;
                    }
                    break;
                  case 3:
                    var u = b.stateNode.containerInfo;
                    1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
            } catch (F10) {
              W(b, b.return, F10);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V = a;
              break;
            }
            V = b.return;
          }
      n = Nj;
      Nj = false;
      return n;
    }
    function Pj(a, b, c) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Mj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Rj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    function Sj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Sj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of2], delete b[Pf2], delete b[of2], delete b[Qf2], delete b[Rf2]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Tj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Uj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Vj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf2));
      else if (4 !== d && (a = a.child, null !== a))
        for (Vj(a, b, c), a = a.sibling; null !== a; )
          Vj(a, b, c), a = a.sibling;
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (5 === d || 6 === d)
        a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a))
        for (Wj(a, b, c), a = a.sibling; null !== a; )
          Wj(a, b, c), a = a.sibling;
    }
    var X = null, Xj = false;
    function Yj(a, b, c) {
      for (c = c.child; null !== c; )
        Zj(a, b, c), c = c.sibling;
    }
    function Zj(a, b, c) {
      if (lc2 && "function" === typeof lc2.onCommitFiberUnmount)
        try {
          lc2.onCommitFiberUnmount(kc2, c);
        } catch (h) {
        }
      switch (c.tag) {
        case 5:
          U || Lj(c, b);
        case 6:
          var d = X, e = Xj;
          X = null;
          Yj(a, b, c);
          X = d;
          Xj = e;
          null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf2(a.parentNode, c) : 1 === a.nodeType && Kf2(a, c), bd2(a)) : Kf2(X, c.stateNode));
          break;
        case 4:
          d = X;
          e = Xj;
          X = c.stateNode.containerInfo;
          Xj = true;
          Yj(a, b, c);
          X = d;
          Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
              e = e.next;
            } while (e !== d);
          }
          Yj(a, b, c);
          break;
        case 1:
          if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount))
            try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
          Yj(a, b, c);
          break;
        case 21:
          Yj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
          break;
        default:
          Yj(a, b, c);
      }
    }
    function ak(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Kj());
        b.forEach(function(b10) {
          var d = bk.bind(null, a, b10);
          c.has(b10) || (c.add(b10), b10.then(d, d));
        });
      }
    }
    function ck(a, b) {
      var c = b.deletions;
      if (null !== c)
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a:
              for (; null !== h; ) {
                switch (h.tag) {
                  case 5:
                    X = h.stateNode;
                    Xj = false;
                    break a;
                  case 3:
                    X = h.stateNode.containerInfo;
                    Xj = true;
                    break a;
                  case 4:
                    X = h.stateNode.containerInfo;
                    Xj = true;
                    break a;
                }
                h = h.return;
              }
            if (null === X)
              throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; null !== b; )
          dk(b, a), b = b.sibling;
    }
    function dk(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ck(b, a);
          ek(a);
          if (d & 4) {
            try {
              Pj(3, a, a.return), Qj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Pj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          break;
        case 5:
          ck(b, a);
          ek(a);
          d & 512 && null !== c && Lj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob2(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k)
              try {
                "input" === h && "radio" === f.type && null != f.name && ab2(e, f);
                vb2(h, g);
                var l = vb2(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb2(e, q) : "dangerouslySetInnerHTML" === m ? nb2(e, q) : "children" === m ? ob2(e, q) : ta2(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb2(e, f);
                    break;
                  case "textarea":
                    ib2(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb2(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb2(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb2(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf2] = f;
              } catch (t) {
                W(a, a.return, t);
              }
          }
          break;
        case 6:
          ck(b, a);
          ek(a);
          if (d & 4) {
            if (null === a.stateNode)
              throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          ck(b, a);
          ek(a);
          if (d & 4 && null !== c && c.memoizedState.isDehydrated)
            try {
              bd2(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
          break;
        case 4:
          ck(b, a);
          ek(a);
          break;
        case 13:
          ck(b, a);
          ek(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
          d & 4 && ak(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
          ek(a);
          if (d & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1))
              for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
            a:
              for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb2("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m)
                    try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a)
                  break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a)
                    break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
          }
          break;
        case 19:
          ck(b, a);
          ek(a);
          d & 4 && ak(a);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a
          ), ek(a);
      }
    }
    function ek(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Tj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob2(e, ""), d.flags &= -33);
              var f = Uj(a);
              Wj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a);
              Vj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function hk(a, b, c) {
      V = a;
      ik(a);
    }
    function ik(a, b, c) {
      for (var d = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d) {
          var g = null !== e.memoizedState || Jj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Jj;
            var l = U;
            Jj = g;
            if ((U = k) && !l)
              for (V = e; null !== V; )
                g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
            for (; null !== f; )
              V = f, ik(f), f = f.sibling;
            V = e;
            Jj = h;
            U = l;
          }
          kk(a);
        } else
          0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772))
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (null === c)
                      d.componentDidMount();
                    else {
                      var e = b.elementType === b.type ? c.memoizedProps : Ci2(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f = b.updateQueue;
                  null !== f && sh2(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child)
                      switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                    sh2(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd2(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
            U || b.flags & 512 && Rj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function gk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    function jk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Qj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua2.ReactCurrentDispatcher, nk = ua2.ReactCurrentOwner, ok = ua2.ReactCurrentBatchConfig, K10 = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf2(0), T10 = 0, pk = null, rh2 = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi2 = false, Pi2 = null, Ri2 = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return 0 !== (K10 & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
    }
    function yi2(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K10 & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg2.transition)
        return 0 === Bk && (Bk = yc2()), Bk;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd2(a.type);
      return a;
    }
    function gi2(a, b, c, d) {
      if (50 < yk)
        throw yk = 0, zk = null, Error(p(185));
      Ac2(a, c, d);
      if (0 === (K10 & 2) || a !== Q)
        a === Q && (0 === (K10 & 2) && (qk |= c), 4 === T10 && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K10 && 0 === (b.mode & 1) && (Gj = B() + 500, fg2 && jg2());
    }
    function Dk(a, b) {
      var c = a.callbackNode;
      wc2(a, b);
      var d = uc2(a, a === Q ? Z : 0);
      if (0 === d)
        null !== c && bc2(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        null != c && bc2(c);
        if (1 === b)
          0 === a.tag ? ig2(Ek.bind(null, a)) : hg2(Ek.bind(null, a)), Jf2(function() {
            0 === (K10 & 6) && jg2();
          }), c = null;
        else {
          switch (Dc2(d)) {
            case 1:
              c = fc2;
              break;
            case 4:
              c = gc2;
              break;
            case 16:
              c = hc2;
              break;
            case 536870912:
              c = jc2;
              break;
            default:
              c = hc2;
          }
          c = Fk(c, Gk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    function Gk(a, b) {
      Ak = -1;
      Bk = 0;
      if (0 !== (K10 & 6))
        throw Error(p(327));
      var c = a.callbackNode;
      if (Hk() && a.callbackNode !== c)
        return null;
      var d = uc2(a, a === Q ? Z : 0);
      if (0 === d)
        return null;
      if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b)
        b = Ik(a, d);
      else {
        b = d;
        var e = K10;
        K10 |= 2;
        var f = Jk();
        if (Q !== a || Z !== b)
          uk = null, Gj = B() + 500, Kk(a, b);
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a, h);
          }
        while (1);
        $g2();
        mk.current = f;
        K10 = e;
        null !== Y ? b = 0 : (Q = null, Z = 0, b = T10);
      }
      if (0 !== b) {
        2 === b && (e = xc2(a), 0 !== e && (d = e, b = Nk(a, e)));
        if (1 === b)
          throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        if (6 === b)
          Ck(a, d);
        else {
          e = a.current.alternate;
          if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc2(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b))
            throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a, tk, uk);
              break;
            case 3:
              Ck(a, d);
              if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (0 !== uc2(a, 0))
                  break;
                e = a.suspendedLanes;
                if ((e & d) !== d) {
                  R();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff2(Pk.bind(null, a, tk, uk), b);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 4:
              Ck(a, d);
              if ((d & 4194240) === d)
                break;
              b = a.eventTimes;
              for (e = -1; 0 < d; ) {
                var g = 31 - oc2(d);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d &= ~f;
              }
              d = e;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
              if (10 < d) {
                a.timeoutHandle = Ff2(Pk.bind(null, a, tk, uk), d);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 5:
              Pk(a, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Dk(a, B());
      return a.callbackNode === c ? Gk.bind(null, a) : null;
    }
    function Nk(a, b) {
      var c = sk;
      a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
      a = Ik(a, b);
      2 !== a && (b = tk, tk = c, null !== b && Fj(b));
      return a;
    }
    function Fj(a) {
      null === tk ? tk = a : tk.push.apply(tk, a);
    }
    function Ok(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c))
            for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He2(f(), e))
                  return false;
              } catch (g) {
                return false;
              }
            }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c)
          c.return = b, b = c;
        else {
          if (b === a)
            break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a)
              return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Ck(a, b) {
      b &= ~rk;
      b &= ~qk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc2(b), d = 1 << c;
        a[c] = -1;
        b &= ~d;
      }
    }
    function Ek(a) {
      if (0 !== (K10 & 6))
        throw Error(p(327));
      Hk();
      var b = uc2(a, 0);
      if (0 === (b & 1))
        return Dk(a, B()), null;
      var c = Ik(a, b);
      if (0 !== a.tag && 2 === c) {
        var d = xc2(a);
        0 !== d && (b = d, c = Nk(a, d));
      }
      if (1 === c)
        throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
      if (6 === c)
        throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Pk(a, tk, uk);
      Dk(a, B());
      return null;
    }
    function Qk(a, b) {
      var c = K10;
      K10 |= 1;
      try {
        return a(b);
      } finally {
        K10 = c, 0 === K10 && (Gj = B() + 500, fg2 && jg2());
      }
    }
    function Rk(a) {
      null !== wk && 0 === wk.tag && 0 === (K10 & 6) && Hk();
      var b = K10;
      K10 |= 1;
      var c = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a)
          return a();
      } finally {
        C = d, ok.transition = c, K10 = b, 0 === (K10 & 6) && jg2();
      }
    }
    function Hj() {
      fj = ej.current;
      E(ej);
    }
    function Kk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf2(c));
      if (null !== Y)
        for (c = Y.return; null !== c; ) {
          var d = c;
          wg2(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f2();
              break;
            case 3:
              zh2();
              E(Wf2);
              E(H);
              Eh2();
              break;
            case 5:
              Bh2(d);
              break;
            case 4:
              zh2();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah2(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
      Q = a;
      Y = a = Pg2(a.current, null);
      Z = fj = b;
      T10 = 0;
      pk = null;
      rk = qk = rh2 = 0;
      tk = sk = null;
      if (null !== fh2) {
        for (b = 0; b < fh2.length; b++)
          if (c = fh2[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
        fh2 = null;
      }
      return a;
    }
    function Mk(a, b) {
      do {
        var c = Y;
        try {
          $g2();
          Fh2.current = Rh2;
          if (Ih2) {
            for (var d = M.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            Ih2 = false;
          }
          Hh2 = 0;
          O = N = M = null;
          Jh2 = false;
          Kh2 = 0;
          nk.current = null;
          if (null === c || null === c.return) {
            T10 = 1;
            pk = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m = h, q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Ui(g);
              if (null !== y) {
                y.flags &= -257;
                Vi2(y, g, h, f, b);
                y.mode & 1 && Si2(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else
                  n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Si2(f, l, b);
                  tj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Ui(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Vi2(J, g, h, f, b);
                Jg2(Ji2(k, h));
                break a;
              }
            }
            f = k = Ji2(k, h);
            4 !== T10 && (T10 = 2);
            null === sk ? sk = [f] : sk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Ni2(f, k, b);
                  ph2(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri2 || !Ri2.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F10 = Qi2(f, h, b);
                    ph2(f, F10);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Sk(c);
        } catch (na2) {
          b = na2;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a = mk.current;
      mk.current = Rh2;
      return null === a ? Rh2 : a;
    }
    function tj() {
      if (0 === T10 || 3 === T10 || 2 === T10)
        T10 = 4;
      null === Q || 0 === (rh2 & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a, b) {
      var c = K10;
      K10 |= 2;
      var d = Jk();
      if (Q !== a || Z !== b)
        uk = null, Kk(a, b);
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a, e);
        }
      while (1);
      $g2();
      K10 = c;
      mk.current = d;
      if (null !== Y)
        throw Error(p(261));
      Q = null;
      Z = 0;
      return T10;
    }
    function Tk() {
      for (; null !== Y; )
        Uk(Y);
    }
    function Lk() {
      for (; null !== Y && !cc2(); )
        Uk(Y);
    }
    function Uk(a) {
      var b = Vk(a.alternate, a, fj);
      a.memoizedProps = a.pendingProps;
      null === b ? Sk(a) : Y = b;
      nk.current = null;
    }
    function Sk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Ej(c, b, fj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Ij(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T10 = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T10 && (T10 = 5);
    }
    function Pk(a, b, c) {
      var d = C, e = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a, b, c, d);
      } finally {
        ok.transition = e, C = d;
      }
      return null;
    }
    function Wk(a, b, c, d) {
      do
        Hk();
      while (null !== wk);
      if (0 !== (K10 & 6))
        throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current)
        throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc2(a, f);
      a === Q && (Y = Q = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc2, function() {
        Hk();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = ok.transition;
        ok.transition = null;
        var g = C;
        C = 1;
        var h = K10;
        K10 |= 4;
        nk.current = null;
        Oj(a, c);
        dk(c, a);
        Oe2(Df2);
        dd2 = !!Cf2;
        Df2 = Cf2 = null;
        a.current = c;
        hk(c);
        dc2();
        K10 = h;
        C = g;
        ok.transition = f;
      } else
        a.current = c;
      vk && (vk = false, wk = a, xk = e);
      f = a.pendingLanes;
      0 === f && (Ri2 = null);
      mc2(c.stateNode);
      Dk(a, B());
      if (null !== b)
        for (d = a.onRecoverableError, c = 0; c < b.length; c++)
          e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi2)
        throw Oi2 = false, a = Pi2, Pi2 = null, a;
      0 !== (xk & 1) && 0 !== a.tag && Hk();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
      jg2();
      return null;
    }
    function Hk() {
      if (null !== wk) {
        var a = Dc2(xk), b = ok.transition, c = C;
        try {
          ok.transition = null;
          C = 16 > a ? 16 : a;
          if (null === wk)
            var d = false;
          else {
            a = wk;
            wk = null;
            xk = 0;
            if (0 !== (K10 & 6))
              throw Error(p(331));
            var e = K10;
            K10 |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q)
                        q.return = m, V = q;
                      else
                        for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g)
                g.return = f, V = g;
              else
                b:
                  for (; null !== V; ) {
                    f = V;
                    if (0 !== (f.flags & 2048))
                      switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f, f.return);
                      }
                    var x = f.sibling;
                    if (null !== x) {
                      x.return = f.return;
                      V = x;
                      break b;
                    }
                    V = f.return;
                  }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u)
                u.return = g, V = u;
              else
                b:
                  for (g = w; null !== V; ) {
                    h = V;
                    if (0 !== (h.flags & 2048))
                      try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h);
                        }
                      } catch (na2) {
                        W(h, h.return, na2);
                      }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F10 = h.sibling;
                    if (null !== F10) {
                      F10.return = h.return;
                      V = F10;
                      break b;
                    }
                    V = h.return;
                  }
            }
            K10 = e;
            jg2();
            if (lc2 && "function" === typeof lc2.onPostCommitFiberRoot)
              try {
                lc2.onPostCommitFiberRoot(kc2, a);
              } catch (na2) {
              }
            d = true;
          }
          return d;
        } finally {
          C = c, ok.transition = b;
        }
      }
      return false;
    }
    function Xk(a, b, c) {
      b = Ji2(c, b);
      b = Ni2(a, b, 1);
      a = nh2(a, b, 1);
      b = R();
      null !== a && (Ac2(a, 1, b), Dk(a, b));
    }
    function W(a, b, c) {
      if (3 === a.tag)
        Xk(a, a, c);
      else
        for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri2 || !Ri2.has(d))) {
              a = Ji2(c, a);
              a = Qi2(b, a, 1);
              b = nh2(b, a, 1);
              a = R();
              null !== b && (Ac2(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ti2(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      b = R();
      a.pingedLanes |= a.suspendedLanes & c;
      Q === a && (Z & c) === c && (4 === T10 || 3 === T10 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
      Dk(a, b);
    }
    function Yk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc2, sc2 <<= 1, 0 === (sc2 & 130023424) && (sc2 = 4194304)));
      var c = R();
      a = ih2(a, b);
      null !== a && (Ac2(a, b, c), Dk(a, c));
    }
    function uj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Yk(a, c);
    }
    function bk(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d && d.delete(b);
      Yk(a, c);
    }
    var Vk;
    Vk = function(a, b, c) {
      if (null !== a)
        if (a.memoizedProps !== b.pendingProps || Wf2.current)
          dh2 = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128))
            return dh2 = false, yj(a, b, c);
          dh2 = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        dh2 = false, I && 0 !== (b.flags & 1048576) && ug2(b, ng2, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          ij(a, b);
          a = b.pendingProps;
          var e = Yf2(b, H.current);
          ch2(b, c);
          e = Nh2(null, b, d, a, e, c);
          var f = Sh2();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf2(d) ? (f = true, cg2(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh2(b), e.updater = Ei2, b.stateNode = e, e._reactInternals = b, Ii2(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg2(b), Xi2(null, b, e, c), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            ij(a, b);
            a = b.pendingProps;
            e = d._init;
            d = e(d._payload);
            b.type = d;
            e = b.tag = Zk(d);
            a = Ci2(d, a);
            switch (e) {
              case 0:
                b = cj(null, b, d, a, c);
                break a;
              case 1:
                b = hj(null, b, d, a, c);
                break a;
              case 11:
                b = Yi2(null, b, d, a, c);
                break a;
              case 14:
                b = $i2(null, b, d, Ci2(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci2(d, e), cj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci2(d, e), hj(a, b, d, e, c);
        case 3:
          a: {
            kj(b);
            if (null === a)
              throw Error(p(387));
            d = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            lh2(a, b);
            qh2(b, d, null, c);
            var g = b.memoizedState;
            d = g.element;
            if (f.isDehydrated)
              if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji2(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji2(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else
                for (yg2 = Lf2(b.stateNode.containerInfo.firstChild), xg2 = b, I = true, zg2 = null, c = Vg2(b, null, d, c), b.child = c; c; )
                  c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig2();
              if (d === e) {
                b = Zi2(a, b, c);
                break a;
              }
              Xi2(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah2(b), null === a && Eg2(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef2(d, e) ? g = null : null !== f && Ef2(d, f) && (b.flags |= 32), gj(a, b), Xi2(a, b, g, c), b.child;
        case 6:
          return null === a && Eg2(b), null;
        case 13:
          return oj(a, b, c);
        case 4:
          return yh2(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug2(b, null, d, c) : Xi2(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci2(d, e), Yi2(a, b, d, e, c);
        case 7:
          return Xi2(a, b, b.pendingProps, c), b.child;
        case 8:
          return Xi2(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Xi2(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Wg2, d._currentValue);
            d._currentValue = g;
            if (null !== f)
              if (He2(f.value, g)) {
                if (f.children === e.children && !Wf2.current) {
                  b = Zi2(a, b, c);
                  break a;
                }
              } else
                for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                  var h = f.dependencies;
                  if (null !== h) {
                    g = f.child;
                    for (var k = h.firstContext; null !== k; ) {
                      if (k.context === d) {
                        if (1 === f.tag) {
                          k = mh2(-1, c & -c);
                          k.tag = 2;
                          var l = f.updateQueue;
                          if (null !== l) {
                            l = l.shared;
                            var m = l.pending;
                            null === m ? k.next = k : (k.next = m.next, m.next = k);
                            l.pending = k;
                          }
                        }
                        f.lanes |= c;
                        k = f.alternate;
                        null !== k && (k.lanes |= c);
                        bh2(
                          f.return,
                          c,
                          b
                        );
                        h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (10 === f.tag)
                    g = f.type === b.type ? null : f.child;
                  else if (18 === f.tag) {
                    g = f.return;
                    if (null === g)
                      throw Error(p(341));
                    g.lanes |= c;
                    h = g.alternate;
                    null !== h && (h.lanes |= c);
                    bh2(g, c, b);
                    g = f.sibling;
                  } else
                    g = f.child;
                  if (null !== g)
                    g.return = f;
                  else
                    for (g = f; null !== g; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      f = g.sibling;
                      if (null !== f) {
                        f.return = g.return;
                        g = f;
                        break;
                      }
                      g = g.return;
                    }
                  f = g;
                }
            Xi2(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch2(b, c), e = eh2(e), d = d(e), b.flags |= 1, Xi2(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Ci2(d, b.pendingProps), e = Ci2(d.type, e), $i2(a, b, d, e, c);
        case 15:
          return bj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci2(d, e), ij(a, b), b.tag = 1, Zf2(d) ? (a = true, cg2(b)) : a = false, ch2(b, c), Gi2(b, d, e), Ii2(b, d, e, c), jj(null, b, d, true, a, c);
        case 19:
          return xj(a, b, c);
        case 22:
          return dj(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a, b) {
      return ac2(a, b);
    }
    function $k(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg2(a, b, c, d) {
      return new $k(a, b, c, d);
    }
    function aj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function Zk(a) {
      if ("function" === typeof a)
        return aj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da2)
          return 11;
        if (a === Ga2)
          return 14;
      }
      return 2;
    }
    function Pg2(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg2(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function Rg2(a, b, c, d, e, f) {
      var g = 2;
      d = a;
      if ("function" === typeof a)
        aj(a) && (g = 1);
      else if ("string" === typeof a)
        g = 5;
      else
        a:
          switch (a) {
            case ya2:
              return Tg2(c.children, e, f, b);
            case za2:
              g = 8;
              e |= 8;
              break;
            case Aa2:
              return a = Bg2(12, c, b, e | 2), a.elementType = Aa2, a.lanes = f, a;
            case Ea2:
              return a = Bg2(13, c, b, e), a.elementType = Ea2, a.lanes = f, a;
            case Fa2:
              return a = Bg2(19, c, b, e), a.elementType = Fa2, a.lanes = f, a;
            case Ia2:
              return pj(c, e, f, b);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba2:
                    g = 10;
                    break a;
                  case Ca2:
                    g = 9;
                    break a;
                  case Da2:
                    g = 11;
                    break a;
                  case Ga2:
                    g = 14;
                    break a;
                  case Ha2:
                    g = 16;
                    d = null;
                    break a;
                }
              throw Error(p(130, null == a ? a : typeof a, ""));
          }
      b = Bg2(g, c, b, e);
      b.elementType = a;
      b.type = d;
      b.lanes = f;
      return b;
    }
    function Tg2(a, b, c, d) {
      a = Bg2(7, a, d, b);
      a.lanes = c;
      return a;
    }
    function pj(a, b, c, d) {
      a = Bg2(22, a, d, b);
      a.elementType = Ia2;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    function Qg2(a, b, c) {
      a = Bg2(6, a, null, b);
      a.lanes = c;
      return a;
    }
    function Sg2(a, b, c) {
      b = Bg2(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function al2(a, b, c, d, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc2(0);
      this.expirationTimes = zc2(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc2(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    function bl(a, b, c, d, e, f, g, h, k) {
      a = new al2(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg2(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      kh2(f);
      return a;
    }
    function cl2(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa2, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function dl2(a) {
      if (!a)
        return Vf2;
      a = a._reactInternals;
      a: {
        if (Vb2(a) !== a || 1 !== a.tag)
          throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf2(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf2(c))
          return bg2(a, c, b);
      }
      return b;
    }
    function el2(a, b, c, d, e, f, g, h, k) {
      a = bl(c, d, true, a, e, f, g, h, k);
      a.context = dl2(null);
      c = a.current;
      d = R();
      e = yi2(c);
      f = mh2(d, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      nh2(c, f, e);
      a.current.lanes = e;
      Ac2(a, e, d);
      Dk(a, d);
      return a;
    }
    function fl2(a, b, c, d) {
      var e = b.current, f = R(), g = yi2(e);
      c = dl2(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = mh2(f, g);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a = nh2(e, b, g);
      null !== a && (gi2(a, e, g, f), oh2(a, e, g));
      return g;
    }
    function gl2(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function hl2(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function il2(a, b) {
      hl2(a, b);
      (a = a.alternate) && hl2(a, b);
    }
    function jl2() {
      return null;
    }
    var kl2 = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ll2(a) {
      this._internalRoot = a;
    }
    ml2.prototype.render = ll2.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b)
        throw Error(p(409));
      fl2(a, b, null, null);
    };
    ml2.prototype.unmount = ll2.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Rk(function() {
          fl2(null, a, null, null);
        });
        b[uf2] = null;
      }
    };
    function ml2(a) {
      this._internalRoot = a;
    }
    ml2.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc2();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc2.length && 0 !== b && b < Qc2[c].priority; c++)
          ;
        Qc2.splice(c, 0, a);
        0 === c && Vc2(a);
      }
    };
    function nl2(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function ol2(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function pl2() {
    }
    function ql2(a, b, c, d, e) {
      if (e) {
        if ("function" === typeof d) {
          var f = d;
          d = function() {
            var a10 = gl2(g);
            f.call(a10);
          };
        }
        var g = el2(b, d, a, 0, null, false, false, "", pl2);
        a._reactRootContainer = g;
        a[uf2] = g.current;
        sf2(8 === a.nodeType ? a.parentNode : a);
        Rk();
        return g;
      }
      for (; e = a.lastChild; )
        a.removeChild(e);
      if ("function" === typeof d) {
        var h = d;
        d = function() {
          var a10 = gl2(k);
          h.call(a10);
        };
      }
      var k = bl(a, 0, false, null, null, false, false, "", pl2);
      a._reactRootContainer = k;
      a[uf2] = k.current;
      sf2(8 === a.nodeType ? a.parentNode : a);
      Rk(function() {
        fl2(b, k, c, d);
      });
      return k;
    }
    function rl2(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = function() {
            var a10 = gl2(g);
            h.call(a10);
          };
        }
        fl2(b, g, a, e);
      } else
        g = ql2(c, b, a, e, d);
      return gl2(g);
    }
    Ec2 = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc2(b.pendingLanes);
            0 !== c && (Cc2(b, c | 1), Dk(b, B()), 0 === (K10 & 6) && (Gj = B() + 500, jg2()));
          }
          break;
        case 13:
          Rk(function() {
            var b10 = ih2(a, 1);
            if (null !== b10) {
              var c10 = R();
              gi2(b10, a, 1, c10);
            }
          }), il2(a, 1);
      }
    };
    Fc2 = function(a) {
      if (13 === a.tag) {
        var b = ih2(a, 134217728);
        if (null !== b) {
          var c = R();
          gi2(b, a, 134217728, c);
        }
        il2(a, 134217728);
      }
    };
    Gc2 = function(a) {
      if (13 === a.tag) {
        var b = yi2(a), c = ih2(a, b);
        if (null !== c) {
          var d = R();
          gi2(c, a, b, d);
        }
        il2(a, b);
      }
    };
    Hc2 = function() {
      return C;
    };
    Ic2 = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb2 = function(a, b, c) {
      switch (b) {
        case "input":
          bb2(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db2(d);
                if (!e)
                  throw Error(p(90));
                Wa2(d);
                bb2(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib2(a, c);
          break;
        case "select":
          b = c.value, null != b && fb2(a, !!c.multiple, b, false);
      }
    };
    Gb2 = Qk;
    Hb2 = Rk;
    var sl2 = { usingClientEntryPoint: false, Events: [Cb2, ue, Db2, Eb2, Fb2, Qk] }, tl2 = { findFiberByHostInstance: Wc2, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
    var ul2 = { bundleType: tl2.bundleType, version: tl2.version, rendererPackageName: tl2.rendererPackageName, rendererConfig: tl2.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb2(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: tl2.findFiberByHostInstance || jl2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!vl.isDisabled && vl.supportsFiber)
        try {
          kc2 = vl.inject(ul2), lc2 = vl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl2;
    reactDom_production_min.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!nl2(b))
        throw Error(p(200));
      return cl2(a, b, null, c);
    };
    reactDom_production_min.createRoot = function(a, b) {
      if (!nl2(a))
        throw Error(p(299));
      var c = false, d = "", e = kl2;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = bl(a, 1, false, null, null, c, false, d, e);
      a[uf2] = b.current;
      sf2(8 === a.nodeType ? a.parentNode : a);
      return new ll2(b);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render)
          throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb2(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Rk(a);
    };
    reactDom_production_min.hydrate = function(a, b, c) {
      if (!ol2(b))
        throw Error(p(200));
      return rl2(null, a, b, true, c);
    };
    reactDom_production_min.hydrateRoot = function(a, b, c) {
      if (!nl2(a))
        throw Error(p(405));
      var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl2;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = el2(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf2] = b.current;
      sf2(a);
      if (d)
        for (a = 0; a < d.length; a++)
          c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
            c,
            e
          );
      return new ml2(b);
    };
    reactDom_production_min.render = function(a, b, c) {
      if (!ol2(b))
        throw Error(p(200));
      return rl2(null, a, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!ol2(a))
        throw Error(p(40));
      return a._reactRootContainer ? (Rk(function() {
        rl2(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf2] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Qk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!ol2(c))
        throw Error(p(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p(38));
      return rl2(a, b, c, false, d);
    };
    reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
    return reactDom_production_min;
  }
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  var reactDomExports = reactDom.exports;
  const Wt = /* @__PURE__ */ getDefaultExportFromCjs$1(reactDomExports);
  var define_process_env_default = { NODE_ENV: "production" };
  var Vm = Object.defineProperty;
  var qm = (t10, e, r) => e in t10 ? Vm(t10, e, { enumerable: true, configurable: true, writable: true, value: r }) : t10[e] = r;
  var ye = (t10, e, r) => (qm(t10, typeof e != "symbol" ? e + "" : e, r), r);
  const p0 = {
    SyncIntervalTime: 3e3
  };
  var fs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
  function g0(t10) {
    if (t10.__esModule)
      return t10;
    var e = t10.default;
    if (typeof e == "function") {
      var r = function n() {
        if (this instanceof n) {
          var i = [null];
          i.push.apply(i, arguments);
          var o = Function.bind.apply(e, i);
          return new o();
        }
        return e.apply(this, arguments);
      };
      r.prototype = e.prototype;
    } else
      r = {};
    return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(t10).forEach(function(n) {
      var i = Object.getOwnPropertyDescriptor(t10, n);
      Object.defineProperty(r, n, i.get ? i : {
        enumerable: true,
        get: function() {
          return t10[n];
        }
      });
    }), r;
  }
  var wi = {}, Qm = {
    get exports() {
      return wi;
    },
    set exports(t10) {
      wi = t10;
    }
  }, pi = typeof Reflect == "object" ? Reflect : null, Mf = pi && typeof pi.apply == "function" ? pi.apply : function(e, r, n) {
    return Function.prototype.apply.call(e, r, n);
  }, Ws;
  pi && typeof pi.ownKeys == "function" ? Ws = pi.ownKeys : Object.getOwnPropertySymbols ? Ws = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : Ws = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function Gm(t10) {
    console && console.warn && console.warn(t10);
  }
  var m0 = Number.isNaN || function(e) {
    return e !== e;
  };
  function tt() {
    tt.init.call(this);
  }
  Qm.exports = tt;
  wi.once = ty;
  tt.EventEmitter = tt;
  tt.prototype._events = void 0;
  tt.prototype._eventsCount = 0;
  tt.prototype._maxListeners = void 0;
  var Nf = 10;
  function Na(t10) {
    if (typeof t10 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t10);
  }
  Object.defineProperty(tt, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return Nf;
    },
    set: function(t10) {
      if (typeof t10 != "number" || t10 < 0 || m0(t10))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t10 + ".");
      Nf = t10;
    }
  });
  tt.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  tt.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || m0(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function y0(t10) {
    return t10._maxListeners === void 0 ? tt.defaultMaxListeners : t10._maxListeners;
  }
  tt.prototype.getMaxListeners = function() {
    return y0(this);
  };
  tt.prototype.emit = function(e) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r.push(arguments[n]);
    var i = e === "error", o = this._events;
    if (o !== void 0)
      i = i && o.error === void 0;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (r.length > 0 && (s = r[0]), s instanceof Error)
        throw s;
      var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw a.context = s, a;
    }
    var l = o[e];
    if (l === void 0)
      return false;
    if (typeof l == "function")
      Mf(l, this, r);
    else
      for (var c = l.length, u = x0(l, c), n = 0; n < c; ++n)
        Mf(u[n], this, r);
    return true;
  };
  function b0(t10, e, r, n) {
    var i, o, s;
    if (Na(r), o = t10._events, o === void 0 ? (o = t10._events = /* @__PURE__ */ Object.create(null), t10._eventsCount = 0) : (o.newListener !== void 0 && (t10.emit(
      "newListener",
      e,
      r.listener ? r.listener : r
    ), o = t10._events), s = o[e]), s === void 0)
      s = o[e] = r, ++t10._eventsCount;
    else if (typeof s == "function" ? s = o[e] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), i = y0(t10), i > 0 && s.length > i && !s.warned) {
      s.warned = true;
      var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = t10, a.type = e, a.count = s.length, Gm(a);
    }
    return t10;
  }
  tt.prototype.addListener = function(e, r) {
    return b0(this, e, r, false);
  };
  tt.prototype.on = tt.prototype.addListener;
  tt.prototype.prependListener = function(e, r) {
    return b0(this, e, r, true);
  };
  function Zm() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function v0(t10, e, r) {
    var n = { fired: false, wrapFn: void 0, target: t10, type: e, listener: r }, i = Zm.bind(n);
    return i.listener = r, n.wrapFn = i, i;
  }
  tt.prototype.once = function(e, r) {
    return Na(r), this.on(e, v0(this, e, r)), this;
  };
  tt.prototype.prependOnceListener = function(e, r) {
    return Na(r), this.prependListener(e, v0(this, e, r)), this;
  };
  tt.prototype.removeListener = function(e, r) {
    var n, i, o, s, a;
    if (Na(r), i = this._events, i === void 0)
      return this;
    if (n = i[e], n === void 0)
      return this;
    if (n === r || n.listener === r)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
    else if (typeof n != "function") {
      for (o = -1, s = n.length - 1; s >= 0; s--)
        if (n[s] === r || n[s].listener === r) {
          a = n[s].listener, o = s;
          break;
        }
      if (o < 0)
        return this;
      o === 0 ? n.shift() : $m(n, o), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
    }
    return this;
  };
  tt.prototype.off = tt.prototype.removeListener;
  tt.prototype.removeAllListeners = function(e) {
    var r, n, i;
    if (n = this._events, n === void 0)
      return this;
    if (n.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
      var o = Object.keys(n), s;
      for (i = 0; i < o.length; ++i)
        s = o[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (r = n[e], typeof r == "function")
      this.removeListener(e, r);
    else if (r !== void 0)
      for (i = r.length - 1; i >= 0; i--)
        this.removeListener(e, r[i]);
    return this;
  };
  function A0(t10, e, r) {
    var n = t10._events;
    if (n === void 0)
      return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ey(i) : x0(i, i.length);
  }
  tt.prototype.listeners = function(e) {
    return A0(this, e, true);
  };
  tt.prototype.rawListeners = function(e) {
    return A0(this, e, false);
  };
  tt.listenerCount = function(t10, e) {
    return typeof t10.listenerCount == "function" ? t10.listenerCount(e) : w0.call(t10, e);
  };
  tt.prototype.listenerCount = w0;
  function w0(t10) {
    var e = this._events;
    if (e !== void 0) {
      var r = e[t10];
      if (typeof r == "function")
        return 1;
      if (r !== void 0)
        return r.length;
    }
    return 0;
  }
  tt.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Ws(this._events) : [];
  };
  function x0(t10, e) {
    for (var r = new Array(e), n = 0; n < e; ++n)
      r[n] = t10[n];
    return r;
  }
  function $m(t10, e) {
    for (; e + 1 < t10.length; e++)
      t10[e] = t10[e + 1];
    t10.pop();
  }
  function ey(t10) {
    for (var e = new Array(t10.length), r = 0; r < e.length; ++r)
      e[r] = t10[r].listener || t10[r];
    return e;
  }
  function ty(t10, e) {
    return new Promise(function(r, n) {
      function i(s) {
        t10.removeListener(e, o), n(s);
      }
      function o() {
        typeof t10.removeListener == "function" && t10.removeListener("error", i), r([].slice.call(arguments));
      }
      _0(t10, e, o, { once: true }), e !== "error" && ry(t10, i, { once: true });
    });
  }
  function ry(t10, e, r) {
    typeof t10.on == "function" && _0(t10, "error", e, r);
  }
  function _0(t10, e, r, n) {
    if (typeof t10.on == "function")
      n.once ? t10.once(e, r) : t10.on(e, r);
    else if (typeof t10.addEventListener == "function")
      t10.addEventListener(e, function i(o) {
        n.once && t10.removeEventListener(e, i), r(o);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t10);
  }
  class gu extends wi.EventEmitter {
    constructor() {
      super(), this.temporaryListeners = [];
    }
    on(e, r, n) {
      return super.on(e, r), n && this.temporaryListeners.push([e, r]), () => {
        this.off(e, r);
      };
    }
    removeTemporaryListeners() {
      console.log(
        "removeTemporaryListeners CALLED",
        this,
        this.temporaryListeners
      ), this.temporaryListeners.forEach(([e, r]) => {
        this.removeListener(e, r);
      }), this.temporaryListeners = [];
    }
  }
  var na = {}, ny = {
    get exports() {
      return na;
    },
    set exports(t10) {
      na = t10;
    }
  }, _l, Lf;
  function iy() {
    if (Lf)
      return _l;
    Lf = 1;
    var t10 = 1e3, e = t10 * 60, r = e * 60, n = r * 24, i = n * 7, o = n * 365.25;
    _l = function(u, f) {
      f = f || {};
      var d = typeof u;
      if (d === "string" && u.length > 0)
        return s(u);
      if (d === "number" && isFinite(u))
        return f.long ? l(u) : a(u);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
      );
    };
    function s(u) {
      if (u = String(u), !(u.length > 100)) {
        var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          u
        );
        if (f) {
          var d = parseFloat(f[1]), h = (f[2] || "ms").toLowerCase();
          switch (h) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return d * o;
            case "weeks":
            case "week":
            case "w":
              return d * i;
            case "days":
            case "day":
            case "d":
              return d * n;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return d * r;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return d * e;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return d * t10;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return d;
            default:
              return;
          }
        }
      }
    }
    function a(u) {
      var f = Math.abs(u);
      return f >= n ? Math.round(u / n) + "d" : f >= r ? Math.round(u / r) + "h" : f >= e ? Math.round(u / e) + "m" : f >= t10 ? Math.round(u / t10) + "s" : u + "ms";
    }
    function l(u) {
      var f = Math.abs(u);
      return f >= n ? c(u, f, n, "day") : f >= r ? c(u, f, r, "hour") : f >= e ? c(u, f, e, "minute") : f >= t10 ? c(u, f, t10, "second") : u + " ms";
    }
    function c(u, f, d, h) {
      var g = f >= d * 1.5;
      return Math.round(u / d) + " " + h + (g ? "s" : "");
    }
    return _l;
  }
  function oy(t10) {
    r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = iy(), r.destroy = c, Object.keys(t10).forEach((u) => {
      r[u] = t10[u];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(u) {
      let f = 0;
      for (let d = 0; d < u.length; d++)
        f = (f << 5) - f + u.charCodeAt(d), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    r.selectColor = e;
    function r(u) {
      let f, d = null, h, g;
      function p(...y) {
        if (!p.enabled)
          return;
        const b = p, x = Number(/* @__PURE__ */ new Date()), S = x - (f || x);
        b.diff = S, b.prev = f, b.curr = x, f = x, y[0] = r.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
        let O = 0;
        y[0] = y[0].replace(/%([a-zA-Z%])/g, (L, N) => {
          if (L === "%%")
            return "%";
          O++;
          const j = r.formatters[N];
          if (typeof j == "function") {
            const W = y[O];
            L = j.call(b, W), y.splice(O, 1), O--;
          }
          return L;
        }), r.formatArgs.call(b, y), (b.log || r.log).apply(b, y);
      }
      return p.namespace = u, p.useColors = r.useColors(), p.color = r.selectColor(u), p.extend = n, p.destroy = r.destroy, Object.defineProperty(p, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => d !== null ? d : (h !== r.namespaces && (h = r.namespaces, g = r.enabled(u)), g),
        set: (y) => {
          d = y;
        }
      }), typeof r.init == "function" && r.init(p), p;
    }
    function n(u, f) {
      const d = r(this.namespace + (typeof f > "u" ? ":" : f) + u);
      return d.log = this.log, d;
    }
    function i(u) {
      r.save(u), r.namespaces = u, r.names = [], r.skips = [];
      let f;
      const d = (typeof u == "string" ? u : "").split(/[\s,]+/), h = d.length;
      for (f = 0; f < h; f++)
        d[f] && (u = d[f].replace(/\*/g, ".*?"), u[0] === "-" ? r.skips.push(new RegExp("^" + u.slice(1) + "$")) : r.names.push(new RegExp("^" + u + "$")));
    }
    function o() {
      const u = [
        ...r.names.map(a),
        ...r.skips.map(a).map((f) => "-" + f)
      ].join(",");
      return r.enable(""), u;
    }
    function s(u) {
      if (u[u.length - 1] === "*")
        return true;
      let f, d;
      for (f = 0, d = r.skips.length; f < d; f++)
        if (r.skips[f].test(u))
          return false;
      for (f = 0, d = r.names.length; f < d; f++)
        if (r.names[f].test(u))
          return true;
      return false;
    }
    function a(u) {
      return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  var sy = oy;
  (function(t10, e) {
    e.formatArgs = n, e.save = i, e.load = o, e.useColors = r, e.storage = s(), e.destroy = /* @__PURE__ */ (() => {
      let l = false;
      return () => {
        l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(l) {
      if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t10.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      l.splice(1, 0, c, "color: inherit");
      let u = 0, f = 0;
      l[0].replace(/%[a-zA-Z%]/g, (d) => {
        d !== "%%" && (u++, d === "%c" && (f = u));
      }), l.splice(f, 0, c);
    }
    e.log = console.debug || console.log || (() => {
    });
    function i(l) {
      try {
        l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function o() {
      let l;
      try {
        l = e.storage.getItem("debug");
      } catch {
      }
      return !l && typeof process < "u" && "env" in process && (l = define_process_env_default.DEBUG), l;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    t10.exports = sy(e);
    const { formatters: a } = t10.exports;
    a.j = function(l) {
      try {
        return JSON.stringify(l);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(ny, na);
  var ay = function() {
    if (typeof globalThis > "u")
      return null;
    var e = {
      RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
      RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
      RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
    };
    return e.RTCPeerConnection ? e : null;
  }, _c = {}, Bf = {
    get exports() {
      return _c;
    },
    set exports(t10) {
      _c = t10;
    }
  }, So = {}, ly = {
    get exports() {
      return So;
    },
    set exports(t10) {
      So = t10;
    }
  }, Ho = {}, Yo = {};
  Yo.byteLength = fy;
  Yo.toByteArray = hy;
  Yo.fromByteArray = my;
  var _r = [], rr = [], cy = typeof Uint8Array < "u" ? Uint8Array : Array, Sl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var $n = 0, uy = Sl.length; $n < uy; ++$n)
    _r[$n] = Sl[$n], rr[Sl.charCodeAt($n)] = $n;
  rr["-".charCodeAt(0)] = 62;
  rr["_".charCodeAt(0)] = 63;
  function S0(t10) {
    var e = t10.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t10.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n];
  }
  function fy(t10) {
    var e = S0(t10), r = e[0], n = e[1];
    return (r + n) * 3 / 4 - n;
  }
  function dy(t10, e, r) {
    return (e + r) * 3 / 4 - r;
  }
  function hy(t10) {
    var e, r = S0(t10), n = r[0], i = r[1], o = new cy(dy(t10, n, i)), s = 0, a = i > 0 ? n - 4 : n, l;
    for (l = 0; l < a; l += 4)
      e = rr[t10.charCodeAt(l)] << 18 | rr[t10.charCodeAt(l + 1)] << 12 | rr[t10.charCodeAt(l + 2)] << 6 | rr[t10.charCodeAt(l + 3)], o[s++] = e >> 16 & 255, o[s++] = e >> 8 & 255, o[s++] = e & 255;
    return i === 2 && (e = rr[t10.charCodeAt(l)] << 2 | rr[t10.charCodeAt(l + 1)] >> 4, o[s++] = e & 255), i === 1 && (e = rr[t10.charCodeAt(l)] << 10 | rr[t10.charCodeAt(l + 1)] << 4 | rr[t10.charCodeAt(l + 2)] >> 2, o[s++] = e >> 8 & 255, o[s++] = e & 255), o;
  }
  function py(t10) {
    return _r[t10 >> 18 & 63] + _r[t10 >> 12 & 63] + _r[t10 >> 6 & 63] + _r[t10 & 63];
  }
  function gy(t10, e, r) {
    for (var n, i = [], o = e; o < r; o += 3)
      n = (t10[o] << 16 & 16711680) + (t10[o + 1] << 8 & 65280) + (t10[o + 2] & 255), i.push(py(n));
    return i.join("");
  }
  function my(t10) {
    for (var e, r = t10.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)
      i.push(gy(t10, s, s + o > a ? a : s + o));
    return n === 1 ? (e = t10[r - 1], i.push(
      _r[e >> 2] + _r[e << 4 & 63] + "=="
    )) : n === 2 && (e = (t10[r - 2] << 8) + t10[r - 1], i.push(
      _r[e >> 10] + _r[e >> 4 & 63] + _r[e << 2 & 63] + "="
    )), i.join("");
  }
  var La = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  La.read = function(t10, e, r, n, i) {
    var o, s, a = i * 8 - n - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f = r ? i - 1 : 0, d = r ? -1 : 1, h = t10[e + f];
    for (f += d, o = h & (1 << -u) - 1, h >>= -u, u += a; u > 0; o = o * 256 + t10[e + f], f += d, u -= 8)
      ;
    for (s = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; s = s * 256 + t10[e + f], f += d, u -= 8)
      ;
    if (o === 0)
      o = 1 - c;
    else {
      if (o === l)
        return s ? NaN : (h ? -1 : 1) * (1 / 0);
      s = s + Math.pow(2, n), o = o - c;
    }
    return (h ? -1 : 1) * s * Math.pow(2, o - n);
  };
  La.write = function(t10, e, r, n, i, o) {
    var s, a, l, c = o * 8 - i - 1, u = (1 << c) - 1, f = u >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : o - 1, g = n ? 1 : -1, p = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = u) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), s + f >= 1 ? e += d / l : e += d * Math.pow(2, 1 - f), e * l >= 2 && (s++, l /= 2), s + f >= u ? (a = 0, s = u) : s + f >= 1 ? (a = (e * l - 1) * Math.pow(2, i), s = s + f) : (a = e * Math.pow(2, f - 1) * Math.pow(2, i), s = 0)); i >= 8; t10[r + h] = a & 255, h += g, a /= 256, i -= 8)
      ;
    for (s = s << i | a, c += i; c > 0; t10[r + h] = s & 255, h += g, s /= 256, c -= 8)
      ;
    t10[r + h - g] |= p * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(t10) {
    var e = Yo, r = La, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t10.Buffer = a, t10.SlowBuffer = x, t10.INSPECT_MAX_BYTES = 50;
    var i = 2147483647;
    t10.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function o() {
      try {
        var C = new Uint8Array(1), v = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(v, Uint8Array.prototype), Object.setPrototypeOf(C, v), C.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.byteOffset;
      }
    });
    function s(C) {
      if (C > i)
        throw new RangeError('The value "' + C + '" is invalid for option "size"');
      var v = new Uint8Array(C);
      return Object.setPrototypeOf(v, a.prototype), v;
    }
    function a(C, v, w) {
      if (typeof C == "number") {
        if (typeof v == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(C);
      }
      return l(C, v, w);
    }
    a.poolSize = 8192;
    function l(C, v, w) {
      if (typeof C == "string")
        return d(C, v);
      if (ArrayBuffer.isView(C))
        return g(C);
      if (C == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
        );
      if (re(C, ArrayBuffer) || C && re(C.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (re(C, SharedArrayBuffer) || C && re(C.buffer, SharedArrayBuffer)))
        return p(C, v, w);
      if (typeof C == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var D = C.valueOf && C.valueOf();
      if (D != null && D !== C)
        return a.from(D, v, w);
      var J = y(C);
      if (J)
        return J;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof C[Symbol.toPrimitive] == "function")
        return a.from(
          C[Symbol.toPrimitive]("string"),
          v,
          w
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
      );
    }
    a.from = function(C, v, w) {
      return l(C, v, w);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function c(C) {
      if (typeof C != "number")
        throw new TypeError('"size" argument must be of type number');
      if (C < 0)
        throw new RangeError('The value "' + C + '" is invalid for option "size"');
    }
    function u(C, v, w) {
      return c(C), C <= 0 ? s(C) : v !== void 0 ? typeof w == "string" ? s(C).fill(v, w) : s(C).fill(v) : s(C);
    }
    a.alloc = function(C, v, w) {
      return u(C, v, w);
    };
    function f(C) {
      return c(C), s(C < 0 ? 0 : b(C) | 0);
    }
    a.allocUnsafe = function(C) {
      return f(C);
    }, a.allocUnsafeSlow = function(C) {
      return f(C);
    };
    function d(C, v) {
      if ((typeof v != "string" || v === "") && (v = "utf8"), !a.isEncoding(v))
        throw new TypeError("Unknown encoding: " + v);
      var w = S(C, v) | 0, D = s(w), J = D.write(C, v);
      return J !== w && (D = D.slice(0, J)), D;
    }
    function h(C) {
      for (var v = C.length < 0 ? 0 : b(C.length) | 0, w = s(v), D = 0; D < v; D += 1)
        w[D] = C[D] & 255;
      return w;
    }
    function g(C) {
      if (re(C, Uint8Array)) {
        var v = new Uint8Array(C);
        return p(v.buffer, v.byteOffset, v.byteLength);
      }
      return h(C);
    }
    function p(C, v, w) {
      if (v < 0 || C.byteLength < v)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (C.byteLength < v + (w || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var D;
      return v === void 0 && w === void 0 ? D = new Uint8Array(C) : w === void 0 ? D = new Uint8Array(C, v) : D = new Uint8Array(C, v, w), Object.setPrototypeOf(D, a.prototype), D;
    }
    function y(C) {
      if (a.isBuffer(C)) {
        var v = b(C.length) | 0, w = s(v);
        return w.length === 0 || C.copy(w, 0, 0, v), w;
      }
      if (C.length !== void 0)
        return typeof C.length != "number" || ne(C.length) ? s(0) : h(C);
      if (C.type === "Buffer" && Array.isArray(C.data))
        return h(C.data);
    }
    function b(C) {
      if (C >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return C | 0;
    }
    function x(C) {
      return +C != C && (C = 0), a.alloc(+C);
    }
    a.isBuffer = function(v) {
      return v != null && v._isBuffer === true && v !== a.prototype;
    }, a.compare = function(v, w) {
      if (re(v, Uint8Array) && (v = a.from(v, v.offset, v.byteLength)), re(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), !a.isBuffer(v) || !a.isBuffer(w))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (v === w)
        return 0;
      for (var D = v.length, J = w.length, ae = 0, ue = Math.min(D, J); ae < ue; ++ae)
        if (v[ae] !== w[ae]) {
          D = v[ae], J = w[ae];
          break;
        }
      return D < J ? -1 : J < D ? 1 : 0;
    }, a.isEncoding = function(v) {
      switch (String(v).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, a.concat = function(v, w) {
      if (!Array.isArray(v))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (v.length === 0)
        return a.alloc(0);
      var D;
      if (w === void 0)
        for (w = 0, D = 0; D < v.length; ++D)
          w += v[D].length;
      var J = a.allocUnsafe(w), ae = 0;
      for (D = 0; D < v.length; ++D) {
        var ue = v[D];
        if (re(ue, Uint8Array))
          ae + ue.length > J.length ? a.from(ue).copy(J, ae) : Uint8Array.prototype.set.call(
            J,
            ue,
            ae
          );
        else if (a.isBuffer(ue))
          ue.copy(J, ae);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ae += ue.length;
      }
      return J;
    };
    function S(C, v) {
      if (a.isBuffer(C))
        return C.length;
      if (ArrayBuffer.isView(C) || re(C, ArrayBuffer))
        return C.byteLength;
      if (typeof C != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof C
        );
      var w = C.length, D = arguments.length > 2 && arguments[2] === true;
      if (!D && w === 0)
        return 0;
      for (var J = false; ; )
        switch (v) {
          case "ascii":
          case "latin1":
          case "binary":
            return w;
          case "utf8":
          case "utf-8":
            return Z(C).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return w * 2;
          case "hex":
            return w >>> 1;
          case "base64":
            return R(C).length;
          default:
            if (J)
              return D ? -1 : Z(C).length;
            v = ("" + v).toLowerCase(), J = true;
        }
    }
    a.byteLength = S;
    function O(C, v, w) {
      var D = false;
      if ((v === void 0 || v < 0) && (v = 0), v > this.length || ((w === void 0 || w > this.length) && (w = this.length), w <= 0) || (w >>>= 0, v >>>= 0, w <= v))
        return "";
      for (C || (C = "utf8"); ; )
        switch (C) {
          case "hex":
            return X(this, v, w);
          case "utf8":
          case "utf-8":
            return z10(this, v, w);
          case "ascii":
            return V(this, v, w);
          case "latin1":
          case "binary":
            return te(this, v, w);
          case "base64":
            return P10(this, v, w);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return H(this, v, w);
          default:
            if (D)
              throw new TypeError("Unknown encoding: " + C);
            C = (C + "").toLowerCase(), D = true;
        }
    }
    a.prototype._isBuffer = true;
    function _(C, v, w) {
      var D = C[v];
      C[v] = C[w], C[w] = D;
    }
    a.prototype.swap16 = function() {
      var v = this.length;
      if (v % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var w = 0; w < v; w += 2)
        _(this, w, w + 1);
      return this;
    }, a.prototype.swap32 = function() {
      var v = this.length;
      if (v % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var w = 0; w < v; w += 4)
        _(this, w, w + 3), _(this, w + 1, w + 2);
      return this;
    }, a.prototype.swap64 = function() {
      var v = this.length;
      if (v % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var w = 0; w < v; w += 8)
        _(this, w, w + 7), _(this, w + 1, w + 6), _(this, w + 2, w + 5), _(this, w + 3, w + 4);
      return this;
    }, a.prototype.toString = function() {
      var v = this.length;
      return v === 0 ? "" : arguments.length === 0 ? z10(this, 0, v) : O.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(v) {
      if (!a.isBuffer(v))
        throw new TypeError("Argument must be a Buffer");
      return this === v ? true : a.compare(this, v) === 0;
    }, a.prototype.inspect = function() {
      var v = "", w = t10.INSPECT_MAX_BYTES;
      return v = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(), this.length > w && (v += " ... "), "<Buffer " + v + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(v, w, D, J, ae) {
      if (re(v, Uint8Array) && (v = a.from(v, v.offset, v.byteLength)), !a.isBuffer(v))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof v
        );
      if (w === void 0 && (w = 0), D === void 0 && (D = v ? v.length : 0), J === void 0 && (J = 0), ae === void 0 && (ae = this.length), w < 0 || D > v.length || J < 0 || ae > this.length)
        throw new RangeError("out of range index");
      if (J >= ae && w >= D)
        return 0;
      if (J >= ae)
        return -1;
      if (w >= D)
        return 1;
      if (w >>>= 0, D >>>= 0, J >>>= 0, ae >>>= 0, this === v)
        return 0;
      for (var ue = ae - J, Se = D - w, _e = Math.min(ue, Se), we = this.slice(J, ae), Ne = v.slice(w, D), E = 0; E < _e; ++E)
        if (we[E] !== Ne[E]) {
          ue = we[E], Se = Ne[E];
          break;
        }
      return ue < Se ? -1 : Se < ue ? 1 : 0;
    };
    function L(C, v, w, D, J) {
      if (C.length === 0)
        return -1;
      if (typeof w == "string" ? (D = w, w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648), w = +w, ne(w) && (w = J ? 0 : C.length - 1), w < 0 && (w = C.length + w), w >= C.length) {
        if (J)
          return -1;
        w = C.length - 1;
      } else if (w < 0)
        if (J)
          w = 0;
        else
          return -1;
      if (typeof v == "string" && (v = a.from(v, D)), a.isBuffer(v))
        return v.length === 0 ? -1 : N(C, v, w, D, J);
      if (typeof v == "number")
        return v = v & 255, typeof Uint8Array.prototype.indexOf == "function" ? J ? Uint8Array.prototype.indexOf.call(C, v, w) : Uint8Array.prototype.lastIndexOf.call(C, v, w) : N(C, [v], w, D, J);
      throw new TypeError("val must be string, number or Buffer");
    }
    function N(C, v, w, D, J) {
      var ae = 1, ue = C.length, Se = v.length;
      if (D !== void 0 && (D = String(D).toLowerCase(), D === "ucs2" || D === "ucs-2" || D === "utf16le" || D === "utf-16le")) {
        if (C.length < 2 || v.length < 2)
          return -1;
        ae = 2, ue /= 2, Se /= 2, w /= 2;
      }
      function _e(A, M) {
        return ae === 1 ? A[M] : A.readUInt16BE(M * ae);
      }
      var we;
      if (J) {
        var Ne = -1;
        for (we = w; we < ue; we++)
          if (_e(C, we) === _e(v, Ne === -1 ? 0 : we - Ne)) {
            if (Ne === -1 && (Ne = we), we - Ne + 1 === Se)
              return Ne * ae;
          } else
            Ne !== -1 && (we -= we - Ne), Ne = -1;
      } else
        for (w + Se > ue && (w = ue - Se), we = w; we >= 0; we--) {
          for (var E = true, m = 0; m < Se; m++)
            if (_e(C, we + m) !== _e(v, m)) {
              E = false;
              break;
            }
          if (E)
            return we;
        }
      return -1;
    }
    a.prototype.includes = function(v, w, D) {
      return this.indexOf(v, w, D) !== -1;
    }, a.prototype.indexOf = function(v, w, D) {
      return L(this, v, w, D, true);
    }, a.prototype.lastIndexOf = function(v, w, D) {
      return L(this, v, w, D, false);
    };
    function j(C, v, w, D) {
      w = Number(w) || 0;
      var J = C.length - w;
      D ? (D = Number(D), D > J && (D = J)) : D = J;
      var ae = v.length;
      D > ae / 2 && (D = ae / 2);
      for (var ue = 0; ue < D; ++ue) {
        var Se = parseInt(v.substr(ue * 2, 2), 16);
        if (ne(Se))
          return ue;
        C[w + ue] = Se;
      }
      return ue;
    }
    function W(C, v, w, D) {
      return k(Z(v, C.length - w), C, w, D);
    }
    function G(C, v, w, D) {
      return k(oe(v), C, w, D);
    }
    function ee(C, v, w, D) {
      return k(R(v), C, w, D);
    }
    function fe(C, v, w, D) {
      return k(de(v, C.length - w), C, w, D);
    }
    a.prototype.write = function(v, w, D, J) {
      if (w === void 0)
        J = "utf8", D = this.length, w = 0;
      else if (D === void 0 && typeof w == "string")
        J = w, D = this.length, w = 0;
      else if (isFinite(w))
        w = w >>> 0, isFinite(D) ? (D = D >>> 0, J === void 0 && (J = "utf8")) : (J = D, D = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var ae = this.length - w;
      if ((D === void 0 || D > ae) && (D = ae), v.length > 0 && (D < 0 || w < 0) || w > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      J || (J = "utf8");
      for (var ue = false; ; )
        switch (J) {
          case "hex":
            return j(this, v, w, D);
          case "utf8":
          case "utf-8":
            return W(this, v, w, D);
          case "ascii":
          case "latin1":
          case "binary":
            return G(this, v, w, D);
          case "base64":
            return ee(this, v, w, D);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return fe(this, v, w, D);
          default:
            if (ue)
              throw new TypeError("Unknown encoding: " + J);
            J = ("" + J).toLowerCase(), ue = true;
        }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function P10(C, v, w) {
      return v === 0 && w === C.length ? e.fromByteArray(C) : e.fromByteArray(C.slice(v, w));
    }
    function z10(C, v, w) {
      w = Math.min(C.length, w);
      for (var D = [], J = v; J < w; ) {
        var ae = C[J], ue = null, Se = ae > 239 ? 4 : ae > 223 ? 3 : ae > 191 ? 2 : 1;
        if (J + Se <= w) {
          var _e, we, Ne, E;
          switch (Se) {
            case 1:
              ae < 128 && (ue = ae);
              break;
            case 2:
              _e = C[J + 1], (_e & 192) === 128 && (E = (ae & 31) << 6 | _e & 63, E > 127 && (ue = E));
              break;
            case 3:
              _e = C[J + 1], we = C[J + 2], (_e & 192) === 128 && (we & 192) === 128 && (E = (ae & 15) << 12 | (_e & 63) << 6 | we & 63, E > 2047 && (E < 55296 || E > 57343) && (ue = E));
              break;
            case 4:
              _e = C[J + 1], we = C[J + 2], Ne = C[J + 3], (_e & 192) === 128 && (we & 192) === 128 && (Ne & 192) === 128 && (E = (ae & 15) << 18 | (_e & 63) << 12 | (we & 63) << 6 | Ne & 63, E > 65535 && E < 1114112 && (ue = E));
          }
        }
        ue === null ? (ue = 65533, Se = 1) : ue > 65535 && (ue -= 65536, D.push(ue >>> 10 & 1023 | 55296), ue = 56320 | ue & 1023), D.push(ue), J += Se;
      }
      return I(D);
    }
    var U = 4096;
    function I(C) {
      var v = C.length;
      if (v <= U)
        return String.fromCharCode.apply(String, C);
      for (var w = "", D = 0; D < v; )
        w += String.fromCharCode.apply(
          String,
          C.slice(D, D += U)
        );
      return w;
    }
    function V(C, v, w) {
      var D = "";
      w = Math.min(C.length, w);
      for (var J = v; J < w; ++J)
        D += String.fromCharCode(C[J] & 127);
      return D;
    }
    function te(C, v, w) {
      var D = "";
      w = Math.min(C.length, w);
      for (var J = v; J < w; ++J)
        D += String.fromCharCode(C[J]);
      return D;
    }
    function X(C, v, w) {
      var D = C.length;
      (!v || v < 0) && (v = 0), (!w || w < 0 || w > D) && (w = D);
      for (var J = "", ae = v; ae < w; ++ae)
        J += Ae[C[ae]];
      return J;
    }
    function H(C, v, w) {
      for (var D = C.slice(v, w), J = "", ae = 0; ae < D.length - 1; ae += 2)
        J += String.fromCharCode(D[ae] + D[ae + 1] * 256);
      return J;
    }
    a.prototype.slice = function(v, w) {
      var D = this.length;
      v = ~~v, w = w === void 0 ? D : ~~w, v < 0 ? (v += D, v < 0 && (v = 0)) : v > D && (v = D), w < 0 ? (w += D, w < 0 && (w = 0)) : w > D && (w = D), w < v && (w = v);
      var J = this.subarray(v, w);
      return Object.setPrototypeOf(J, a.prototype), J;
    };
    function $(C, v, w) {
      if (C % 1 !== 0 || C < 0)
        throw new RangeError("offset is not uint");
      if (C + v > w)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var J = this[v], ae = 1, ue = 0; ++ue < w && (ae *= 256); )
        J += this[v + ue] * ae;
      return J;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var J = this[v + --w], ae = 1; w > 0 && (ae *= 256); )
        J += this[v + --w] * ae;
      return J;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(v, w) {
      return v = v >>> 0, w || $(v, 1, this.length), this[v];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(v, w) {
      return v = v >>> 0, w || $(v, 2, this.length), this[v] | this[v + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(v, w) {
      return v = v >>> 0, w || $(v, 2, this.length), this[v] << 8 | this[v + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]);
    }, a.prototype.readIntLE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var J = this[v], ae = 1, ue = 0; ++ue < w && (ae *= 256); )
        J += this[v + ue] * ae;
      return ae *= 128, J >= ae && (J -= Math.pow(2, 8 * w)), J;
    }, a.prototype.readIntBE = function(v, w, D) {
      v = v >>> 0, w = w >>> 0, D || $(v, w, this.length);
      for (var J = w, ae = 1, ue = this[v + --J]; J > 0 && (ae *= 256); )
        ue += this[v + --J] * ae;
      return ae *= 128, ue >= ae && (ue -= Math.pow(2, 8 * w)), ue;
    }, a.prototype.readInt8 = function(v, w) {
      return v = v >>> 0, w || $(v, 1, this.length), this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v];
    }, a.prototype.readInt16LE = function(v, w) {
      v = v >>> 0, w || $(v, 2, this.length);
      var D = this[v] | this[v + 1] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, a.prototype.readInt16BE = function(v, w) {
      v = v >>> 0, w || $(v, 2, this.length);
      var D = this[v + 1] | this[v] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, a.prototype.readInt32LE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24;
    }, a.prototype.readInt32BE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3];
    }, a.prototype.readFloatLE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), r.read(this, v, true, 23, 4);
    }, a.prototype.readFloatBE = function(v, w) {
      return v = v >>> 0, w || $(v, 4, this.length), r.read(this, v, false, 23, 4);
    }, a.prototype.readDoubleLE = function(v, w) {
      return v = v >>> 0, w || $(v, 8, this.length), r.read(this, v, true, 52, 8);
    }, a.prototype.readDoubleBE = function(v, w) {
      return v = v >>> 0, w || $(v, 8, this.length), r.read(this, v, false, 52, 8);
    };
    function se(C, v, w, D, J, ae) {
      if (!a.isBuffer(C))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (v > J || v < ae)
        throw new RangeError('"value" argument is out of bounds');
      if (w + D > C.length)
        throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(v, w, D, J) {
      if (v = +v, w = w >>> 0, D = D >>> 0, !J) {
        var ae = Math.pow(2, 8 * D) - 1;
        se(this, v, w, D, ae, 0);
      }
      var ue = 1, Se = 0;
      for (this[w] = v & 255; ++Se < D && (ue *= 256); )
        this[w + Se] = v / ue & 255;
      return w + D;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(v, w, D, J) {
      if (v = +v, w = w >>> 0, D = D >>> 0, !J) {
        var ae = Math.pow(2, 8 * D) - 1;
        se(this, v, w, D, ae, 0);
      }
      var ue = D - 1, Se = 1;
      for (this[w + ue] = v & 255; --ue >= 0 && (Se *= 256); )
        this[w + ue] = v / Se & 255;
      return w + D;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 1, 255, 0), this[w] = v & 255, w + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 65535, 0), this[w] = v & 255, this[w + 1] = v >>> 8, w + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 65535, 0), this[w] = v >>> 8, this[w + 1] = v & 255, w + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 4294967295, 0), this[w + 3] = v >>> 24, this[w + 2] = v >>> 16, this[w + 1] = v >>> 8, this[w] = v & 255, w + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 4294967295, 0), this[w] = v >>> 24, this[w + 1] = v >>> 16, this[w + 2] = v >>> 8, this[w + 3] = v & 255, w + 4;
    }, a.prototype.writeIntLE = function(v, w, D, J) {
      if (v = +v, w = w >>> 0, !J) {
        var ae = Math.pow(2, 8 * D - 1);
        se(this, v, w, D, ae - 1, -ae);
      }
      var ue = 0, Se = 1, _e = 0;
      for (this[w] = v & 255; ++ue < D && (Se *= 256); )
        v < 0 && _e === 0 && this[w + ue - 1] !== 0 && (_e = 1), this[w + ue] = (v / Se >> 0) - _e & 255;
      return w + D;
    }, a.prototype.writeIntBE = function(v, w, D, J) {
      if (v = +v, w = w >>> 0, !J) {
        var ae = Math.pow(2, 8 * D - 1);
        se(this, v, w, D, ae - 1, -ae);
      }
      var ue = D - 1, Se = 1, _e = 0;
      for (this[w + ue] = v & 255; --ue >= 0 && (Se *= 256); )
        v < 0 && _e === 0 && this[w + ue + 1] !== 0 && (_e = 1), this[w + ue] = (v / Se >> 0) - _e & 255;
      return w + D;
    }, a.prototype.writeInt8 = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 1, 127, -128), v < 0 && (v = 255 + v + 1), this[w] = v & 255, w + 1;
    }, a.prototype.writeInt16LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 32767, -32768), this[w] = v & 255, this[w + 1] = v >>> 8, w + 2;
    }, a.prototype.writeInt16BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 2, 32767, -32768), this[w] = v >>> 8, this[w + 1] = v & 255, w + 2;
    }, a.prototype.writeInt32LE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 2147483647, -2147483648), this[w] = v & 255, this[w + 1] = v >>> 8, this[w + 2] = v >>> 16, this[w + 3] = v >>> 24, w + 4;
    }, a.prototype.writeInt32BE = function(v, w, D) {
      return v = +v, w = w >>> 0, D || se(this, v, w, 4, 2147483647, -2147483648), v < 0 && (v = 4294967295 + v + 1), this[w] = v >>> 24, this[w + 1] = v >>> 16, this[w + 2] = v >>> 8, this[w + 3] = v & 255, w + 4;
    };
    function he(C, v, w, D, J, ae) {
      if (w + D > C.length)
        throw new RangeError("Index out of range");
      if (w < 0)
        throw new RangeError("Index out of range");
    }
    function pe(C, v, w, D, J) {
      return v = +v, w = w >>> 0, J || he(C, v, w, 4), r.write(C, v, w, D, 23, 4), w + 4;
    }
    a.prototype.writeFloatLE = function(v, w, D) {
      return pe(this, v, w, true, D);
    }, a.prototype.writeFloatBE = function(v, w, D) {
      return pe(this, v, w, false, D);
    };
    function me(C, v, w, D, J) {
      return v = +v, w = w >>> 0, J || he(C, v, w, 8), r.write(C, v, w, D, 52, 8), w + 8;
    }
    a.prototype.writeDoubleLE = function(v, w, D) {
      return me(this, v, w, true, D);
    }, a.prototype.writeDoubleBE = function(v, w, D) {
      return me(this, v, w, false, D);
    }, a.prototype.copy = function(v, w, D, J) {
      if (!a.isBuffer(v))
        throw new TypeError("argument should be a Buffer");
      if (D || (D = 0), !J && J !== 0 && (J = this.length), w >= v.length && (w = v.length), w || (w = 0), J > 0 && J < D && (J = D), J === D || v.length === 0 || this.length === 0)
        return 0;
      if (w < 0)
        throw new RangeError("targetStart out of bounds");
      if (D < 0 || D >= this.length)
        throw new RangeError("Index out of range");
      if (J < 0)
        throw new RangeError("sourceEnd out of bounds");
      J > this.length && (J = this.length), v.length - w < J - D && (J = v.length - w + D);
      var ae = J - D;
      return this === v && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(w, D, J) : Uint8Array.prototype.set.call(
        v,
        this.subarray(D, J),
        w
      ), ae;
    }, a.prototype.fill = function(v, w, D, J) {
      if (typeof v == "string") {
        if (typeof w == "string" ? (J = w, w = 0, D = this.length) : typeof D == "string" && (J = D, D = this.length), J !== void 0 && typeof J != "string")
          throw new TypeError("encoding must be a string");
        if (typeof J == "string" && !a.isEncoding(J))
          throw new TypeError("Unknown encoding: " + J);
        if (v.length === 1) {
          var ae = v.charCodeAt(0);
          (J === "utf8" && ae < 128 || J === "latin1") && (v = ae);
        }
      } else
        typeof v == "number" ? v = v & 255 : typeof v == "boolean" && (v = Number(v));
      if (w < 0 || this.length < w || this.length < D)
        throw new RangeError("Out of range index");
      if (D <= w)
        return this;
      w = w >>> 0, D = D === void 0 ? this.length : D >>> 0, v || (v = 0);
      var ue;
      if (typeof v == "number")
        for (ue = w; ue < D; ++ue)
          this[ue] = v;
      else {
        var Se = a.isBuffer(v) ? v : a.from(v, J), _e = Se.length;
        if (_e === 0)
          throw new TypeError('The value "' + v + '" is invalid for argument "value"');
        for (ue = 0; ue < D - w; ++ue)
          this[ue + w] = Se[ue % _e];
      }
      return this;
    };
    var B = /[^+/0-9A-Za-z-_]/g;
    function q(C) {
      if (C = C.split("=")[0], C = C.trim().replace(B, ""), C.length < 2)
        return "";
      for (; C.length % 4 !== 0; )
        C = C + "=";
      return C;
    }
    function Z(C, v) {
      v = v || 1 / 0;
      for (var w, D = C.length, J = null, ae = [], ue = 0; ue < D; ++ue) {
        if (w = C.charCodeAt(ue), w > 55295 && w < 57344) {
          if (!J) {
            if (w > 56319) {
              (v -= 3) > -1 && ae.push(239, 191, 189);
              continue;
            } else if (ue + 1 === D) {
              (v -= 3) > -1 && ae.push(239, 191, 189);
              continue;
            }
            J = w;
            continue;
          }
          if (w < 56320) {
            (v -= 3) > -1 && ae.push(239, 191, 189), J = w;
            continue;
          }
          w = (J - 55296 << 10 | w - 56320) + 65536;
        } else
          J && (v -= 3) > -1 && ae.push(239, 191, 189);
        if (J = null, w < 128) {
          if ((v -= 1) < 0)
            break;
          ae.push(w);
        } else if (w < 2048) {
          if ((v -= 2) < 0)
            break;
          ae.push(
            w >> 6 | 192,
            w & 63 | 128
          );
        } else if (w < 65536) {
          if ((v -= 3) < 0)
            break;
          ae.push(
            w >> 12 | 224,
            w >> 6 & 63 | 128,
            w & 63 | 128
          );
        } else if (w < 1114112) {
          if ((v -= 4) < 0)
            break;
          ae.push(
            w >> 18 | 240,
            w >> 12 & 63 | 128,
            w >> 6 & 63 | 128,
            w & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ae;
    }
    function oe(C) {
      for (var v = [], w = 0; w < C.length; ++w)
        v.push(C.charCodeAt(w) & 255);
      return v;
    }
    function de(C, v) {
      for (var w, D, J, ae = [], ue = 0; ue < C.length && !((v -= 2) < 0); ++ue)
        w = C.charCodeAt(ue), D = w >> 8, J = w % 256, ae.push(J), ae.push(D);
      return ae;
    }
    function R(C) {
      return e.toByteArray(q(C));
    }
    function k(C, v, w, D) {
      for (var J = 0; J < D && !(J + w >= v.length || J >= C.length); ++J)
        v[J + w] = C[J];
      return J;
    }
    function re(C, v) {
      return C instanceof v || C != null && C.constructor != null && C.constructor.name != null && C.constructor.name === v.name;
    }
    function ne(C) {
      return C !== C;
    }
    var Ae = function() {
      for (var C = "0123456789abcdef", v = new Array(256), w = 0; w < 16; ++w)
        for (var D = w * 16, J = 0; J < 16; ++J)
          v[D + J] = C[w] + C[J];
      return v;
    }();
  })(Ho);
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  (function(t10, e) {
    var r = Ho, n = r.Buffer;
    function i(s, a) {
      for (var l in s)
        a[l] = s[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t10.exports = r : (i(r, e), e.Buffer = o);
    function o(s, a, l) {
      return n(s, a, l);
    }
    o.prototype = Object.create(n.prototype), i(n, o), o.from = function(s, a, l) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, a, l);
    }, o.alloc = function(s, a, l) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var c = n(s);
      return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
    }, o.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, o.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  })(ly, So);
  var El = 65536, yy = 4294967295;
  function by() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var vy = So.Buffer, ia = globalThis.crypto || globalThis.msCrypto;
  ia && ia.getRandomValues ? Bf.exports = Ay : Bf.exports = by;
  function Ay(t10, e) {
    if (t10 > yy)
      throw new RangeError("requested too many random bytes");
    var r = vy.allocUnsafe(t10);
    if (t10 > 0)
      if (t10 > El)
        for (var n = 0; n < t10; n += El)
          ia.getRandomValues(r.slice(n, n + El));
      else
        ia.getRandomValues(r);
    return typeof e == "function" ? process.nextTick(function() {
      e(null, r);
    }) : r;
  }
  var oa = {}, wy = {
    get exports() {
      return oa;
    },
    set exports(t10) {
      oa = t10;
    }
  }, E0 = wi.EventEmitter;
  const xy = {}, _y = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: xy
  }, Symbol.toStringTag, { value: "Module" })), k0 = /* @__PURE__ */ g0(_y);
  var kl, Ff;
  function Sy() {
    if (Ff)
      return kl;
    Ff = 1;
    function t10(d, h) {
      var g = Object.keys(d);
      if (Object.getOwnPropertySymbols) {
        var p = Object.getOwnPropertySymbols(d);
        h && (p = p.filter(function(y) {
          return Object.getOwnPropertyDescriptor(d, y).enumerable;
        })), g.push.apply(g, p);
      }
      return g;
    }
    function e(d) {
      for (var h = 1; h < arguments.length; h++) {
        var g = arguments[h] != null ? arguments[h] : {};
        h % 2 ? t10(Object(g), true).forEach(function(p) {
          r(d, p, g[p]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(g)) : t10(Object(g)).forEach(function(p) {
          Object.defineProperty(d, p, Object.getOwnPropertyDescriptor(g, p));
        });
      }
      return d;
    }
    function r(d, h, g) {
      return h in d ? Object.defineProperty(d, h, { value: g, enumerable: true, configurable: true, writable: true }) : d[h] = g, d;
    }
    function n(d, h) {
      if (!(d instanceof h))
        throw new TypeError("Cannot call a class as a function");
    }
    function i(d, h) {
      for (var g = 0; g < h.length; g++) {
        var p = h[g];
        p.enumerable = p.enumerable || false, p.configurable = true, "value" in p && (p.writable = true), Object.defineProperty(d, p.key, p);
      }
    }
    function o(d, h, g) {
      return h && i(d.prototype, h), d;
    }
    var s = Ho, a = s.Buffer, l = k0, c = l.inspect, u = c && c.custom || "inspect";
    function f(d, h, g) {
      a.prototype.copy.call(d, h, g);
    }
    return kl = /* @__PURE__ */ function() {
      function d() {
        n(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return o(d, [{
        key: "push",
        value: function(g) {
          var p = {
            data: g,
            next: null
          };
          this.length > 0 ? this.tail.next = p : this.head = p, this.tail = p, ++this.length;
        }
      }, {
        key: "unshift",
        value: function(g) {
          var p = {
            data: g,
            next: this.head
          };
          this.length === 0 && (this.tail = p), this.head = p, ++this.length;
        }
      }, {
        key: "shift",
        value: function() {
          if (this.length !== 0) {
            var g = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, g;
          }
        }
      }, {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0;
        }
      }, {
        key: "join",
        value: function(g) {
          if (this.length === 0)
            return "";
          for (var p = this.head, y = "" + p.data; p = p.next; )
            y += g + p.data;
          return y;
        }
      }, {
        key: "concat",
        value: function(g) {
          if (this.length === 0)
            return a.alloc(0);
          for (var p = a.allocUnsafe(g >>> 0), y = this.head, b = 0; y; )
            f(y.data, p, b), b += y.data.length, y = y.next;
          return p;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function(g, p) {
          var y;
          return g < this.head.data.length ? (y = this.head.data.slice(0, g), this.head.data = this.head.data.slice(g)) : g === this.head.data.length ? y = this.shift() : y = p ? this._getString(g) : this._getBuffer(g), y;
        }
      }, {
        key: "first",
        value: function() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function(g) {
          var p = this.head, y = 1, b = p.data;
          for (g -= b.length; p = p.next; ) {
            var x = p.data, S = g > x.length ? x.length : g;
            if (S === x.length ? b += x : b += x.slice(0, g), g -= S, g === 0) {
              S === x.length ? (++y, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = x.slice(S));
              break;
            }
            ++y;
          }
          return this.length -= y, b;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function(g) {
          var p = a.allocUnsafe(g), y = this.head, b = 1;
          for (y.data.copy(p), g -= y.data.length; y = y.next; ) {
            var x = y.data, S = g > x.length ? x.length : g;
            if (x.copy(p, p.length - g, 0, S), g -= S, g === 0) {
              S === x.length ? (++b, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = x.slice(S));
              break;
            }
            ++b;
          }
          return this.length -= b, p;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: u,
        value: function(g, p) {
          return c(this, e({}, p, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]), d;
    }(), kl;
  }
  function Ey(t10, e) {
    var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t10) : t10 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Sc, this, t10)) : process.nextTick(Sc, this, t10)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t10 || null, function(o) {
      !e && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Us, r) : (r._writableState.errorEmitted = true, process.nextTick(jf, r, o)) : process.nextTick(jf, r, o) : e ? (process.nextTick(Us, r), e(o)) : process.nextTick(Us, r);
    }), this);
  }
  function jf(t10, e) {
    Sc(t10, e), Us(t10);
  }
  function Us(t10) {
    t10._writableState && !t10._writableState.emitClose || t10._readableState && !t10._readableState.emitClose || t10.emit("close");
  }
  function ky() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function Sc(t10, e) {
    t10.emit("error", e);
  }
  function Cy(t10, e) {
    var r = t10._readableState, n = t10._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t10.destroy(e) : t10.emit("error", e);
  }
  var C0 = {
    destroy: Ey,
    undestroy: ky,
    errorOrDestroy: Cy
  }, Gn = {};
  function Ty(t10, e) {
    t10.prototype = Object.create(e.prototype), t10.prototype.constructor = t10, t10.__proto__ = e;
  }
  var T0 = {};
  function lr(t10, e, r) {
    r || (r = Error);
    function n(o, s, a) {
      return typeof e == "string" ? e : e(o, s, a);
    }
    var i = /* @__PURE__ */ function(o) {
      Ty(s, o);
      function s(a, l, c) {
        return o.call(this, n(a, l, c)) || this;
      }
      return s;
    }(r);
    i.prototype.name = r.name, i.prototype.code = t10, T0[t10] = i;
  }
  function Wf(t10, e) {
    if (Array.isArray(t10)) {
      var r = t10.length;
      return t10 = t10.map(function(n) {
        return String(n);
      }), r > 2 ? "one of ".concat(e, " ").concat(t10.slice(0, r - 1).join(", "), ", or ") + t10[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t10[0], " or ").concat(t10[1]) : "of ".concat(e, " ").concat(t10[0]);
    } else
      return "of ".concat(e, " ").concat(String(t10));
  }
  function Oy(t10, e, r) {
    return t10.substr(0, e.length) === e;
  }
  function Iy(t10, e, r) {
    return (r === void 0 || r > t10.length) && (r = t10.length), t10.substring(r - e.length, r) === e;
  }
  function Py(t10, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t10.length ? false : t10.indexOf(e, r) !== -1;
  }
  lr("ERR_INVALID_OPT_VALUE", function(t10, e) {
    return 'The value "' + e + '" is invalid for option "' + t10 + '"';
  }, TypeError);
  lr("ERR_INVALID_ARG_TYPE", function(t10, e, r) {
    var n;
    typeof e == "string" && Oy(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (Iy(t10, " argument"))
      i = "The ".concat(t10, " ").concat(n, " ").concat(Wf(e, "type"));
    else {
      var o = Py(t10, ".") ? "property" : "argument";
      i = 'The "'.concat(t10, '" ').concat(o, " ").concat(n, " ").concat(Wf(e, "type"));
    }
    return i += ". Received type ".concat(typeof r), i;
  }, TypeError);
  lr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  lr("ERR_METHOD_NOT_IMPLEMENTED", function(t10) {
    return "The " + t10 + " method is not implemented";
  });
  lr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  lr("ERR_STREAM_DESTROYED", function(t10) {
    return "Cannot call " + t10 + " after a stream was destroyed";
  });
  lr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  lr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  lr("ERR_STREAM_WRITE_AFTER_END", "write after end");
  lr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  lr("ERR_UNKNOWN_ENCODING", function(t10) {
    return "Unknown encoding: " + t10;
  }, TypeError);
  lr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Gn.codes = T0;
  var Ry = Gn.codes.ERR_INVALID_OPT_VALUE;
  function Dy(t10, e, r) {
    return t10.highWaterMark != null ? t10.highWaterMark : e ? t10[r] : null;
  }
  function My(t10, e, r, n) {
    var i = Dy(e, n, r);
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var o = n ? r : "highWaterMark";
        throw new Ry(o, i);
      }
      return Math.floor(i);
    }
    return t10.objectMode ? 16 : 16 * 1024;
  }
  var O0 = {
    getHighWaterMark: My
  }, Un = {}, Uf = {
    get exports() {
      return Un;
    },
    set exports(t10) {
      Un = t10;
    }
  };
  typeof Object.create == "function" ? Uf.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
      constructor: {
        value: e,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : Uf.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
  var Ny = Ly;
  function Ly(t10, e) {
    if (Cl("noDeprecation"))
      return t10;
    var r = false;
    function n() {
      if (!r) {
        if (Cl("throwDeprecation"))
          throw new Error(e);
        Cl("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t10.apply(this, arguments);
    }
    return n;
  }
  function Cl(t10) {
    try {
      if (!globalThis.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = globalThis.localStorage[t10];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
  var Tl, zf;
  function I0() {
    if (zf)
      return Tl;
    zf = 1, Tl = j;
    function t10(B) {
      var q = this;
      this.next = null, this.entry = null, this.finish = function() {
        me(q, B);
      };
    }
    var e;
    j.WritableState = L;
    var r = {
      deprecate: Ny
    }, n = E0, i = Ho.Buffer, o = globalThis.Uint8Array || function() {
    };
    function s(B) {
      return i.from(B);
    }
    function a(B) {
      return i.isBuffer(B) || B instanceof o;
    }
    var l = C0, c = O0, u = c.getHighWaterMark, f = Gn.codes, d = f.ERR_INVALID_ARG_TYPE, h = f.ERR_METHOD_NOT_IMPLEMENTED, g = f.ERR_MULTIPLE_CALLBACK, p = f.ERR_STREAM_CANNOT_PIPE, y = f.ERR_STREAM_DESTROYED, b = f.ERR_STREAM_NULL_VALUES, x = f.ERR_STREAM_WRITE_AFTER_END, S = f.ERR_UNKNOWN_ENCODING, O = l.errorOrDestroy;
    Un(j, n);
    function _() {
    }
    function L(B, q, Z) {
      e = e || xi(), B = B || {}, typeof Z != "boolean" && (Z = q instanceof e), this.objectMode = !!B.objectMode, Z && (this.objectMode = this.objectMode || !!B.writableObjectMode), this.highWaterMark = u(this, B, "writableHighWaterMark", Z), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var oe = B.decodeStrings === false;
      this.decodeStrings = !oe, this.defaultEncoding = B.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(de) {
        I(q, de);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = B.emitClose !== false, this.autoDestroy = !!B.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t10(this);
    }
    L.prototype.getBuffer = function() {
      for (var q = this.bufferedRequest, Z = []; q; )
        Z.push(q), q = q.next;
      return Z;
    }, function() {
      try {
        Object.defineProperty(L.prototype, "buffer", {
          get: r.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch {
      }
    }();
    var N;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (N = Function.prototype[Symbol.hasInstance], Object.defineProperty(j, Symbol.hasInstance, {
      value: function(q) {
        return N.call(this, q) ? true : this !== j ? false : q && q._writableState instanceof L;
      }
    })) : N = function(q) {
      return q instanceof this;
    };
    function j(B) {
      e = e || xi();
      var q = this instanceof e;
      if (!q && !N.call(j, this))
        return new j(B);
      this._writableState = new L(B, this, q), this.writable = true, B && (typeof B.write == "function" && (this._write = B.write), typeof B.writev == "function" && (this._writev = B.writev), typeof B.destroy == "function" && (this._destroy = B.destroy), typeof B.final == "function" && (this._final = B.final)), n.call(this);
    }
    j.prototype.pipe = function() {
      O(this, new p());
    };
    function W(B, q) {
      var Z = new x();
      O(B, Z), process.nextTick(q, Z);
    }
    function G(B, q, Z, oe) {
      var de;
      return Z === null ? de = new b() : typeof Z != "string" && !q.objectMode && (de = new d("chunk", ["string", "Buffer"], Z)), de ? (O(B, de), process.nextTick(oe, de), false) : true;
    }
    j.prototype.write = function(B, q, Z) {
      var oe = this._writableState, de = false, R = !oe.objectMode && a(B);
      return R && !i.isBuffer(B) && (B = s(B)), typeof q == "function" && (Z = q, q = null), R ? q = "buffer" : q || (q = oe.defaultEncoding), typeof Z != "function" && (Z = _), oe.ending ? W(this, Z) : (R || G(this, oe, B, Z)) && (oe.pendingcb++, de = fe(this, oe, R, B, q, Z)), de;
    }, j.prototype.cork = function() {
      this._writableState.corked++;
    }, j.prototype.uncork = function() {
      var B = this._writableState;
      B.corked && (B.corked--, !B.writing && !B.corked && !B.bufferProcessing && B.bufferedRequest && X(this, B));
    }, j.prototype.setDefaultEncoding = function(q) {
      if (typeof q == "string" && (q = q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((q + "").toLowerCase()) > -1))
        throw new S(q);
      return this._writableState.defaultEncoding = q, this;
    }, Object.defineProperty(j.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function ee(B, q, Z) {
      return !B.objectMode && B.decodeStrings !== false && typeof q == "string" && (q = i.from(q, Z)), q;
    }
    Object.defineProperty(j.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function fe(B, q, Z, oe, de, R) {
      if (!Z) {
        var k = ee(q, oe, de);
        oe !== k && (Z = true, de = "buffer", oe = k);
      }
      var re = q.objectMode ? 1 : oe.length;
      q.length += re;
      var ne = q.length < q.highWaterMark;
      if (ne || (q.needDrain = true), q.writing || q.corked) {
        var Ae = q.lastBufferedRequest;
        q.lastBufferedRequest = {
          chunk: oe,
          encoding: de,
          isBuf: Z,
          callback: R,
          next: null
        }, Ae ? Ae.next = q.lastBufferedRequest : q.bufferedRequest = q.lastBufferedRequest, q.bufferedRequestCount += 1;
      } else
        P10(B, q, false, re, oe, de, R);
      return ne;
    }
    function P10(B, q, Z, oe, de, R, k) {
      q.writelen = oe, q.writecb = k, q.writing = true, q.sync = true, q.destroyed ? q.onwrite(new y("write")) : Z ? B._writev(de, q.onwrite) : B._write(de, R, q.onwrite), q.sync = false;
    }
    function z10(B, q, Z, oe, de) {
      --q.pendingcb, Z ? (process.nextTick(de, oe), process.nextTick(he, B, q), B._writableState.errorEmitted = true, O(B, oe)) : (de(oe), B._writableState.errorEmitted = true, O(B, oe), he(B, q));
    }
    function U(B) {
      B.writing = false, B.writecb = null, B.length -= B.writelen, B.writelen = 0;
    }
    function I(B, q) {
      var Z = B._writableState, oe = Z.sync, de = Z.writecb;
      if (typeof de != "function")
        throw new g();
      if (U(Z), q)
        z10(B, Z, oe, q, de);
      else {
        var R = H(Z) || B.destroyed;
        !R && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && X(B, Z), oe ? process.nextTick(V, B, Z, R, de) : V(B, Z, R, de);
      }
    }
    function V(B, q, Z, oe) {
      Z || te(B, q), q.pendingcb--, oe(), he(B, q);
    }
    function te(B, q) {
      q.length === 0 && q.needDrain && (q.needDrain = false, B.emit("drain"));
    }
    function X(B, q) {
      q.bufferProcessing = true;
      var Z = q.bufferedRequest;
      if (B._writev && Z && Z.next) {
        var oe = q.bufferedRequestCount, de = new Array(oe), R = q.corkedRequestsFree;
        R.entry = Z;
        for (var k = 0, re = true; Z; )
          de[k] = Z, Z.isBuf || (re = false), Z = Z.next, k += 1;
        de.allBuffers = re, P10(B, q, true, q.length, de, "", R.finish), q.pendingcb++, q.lastBufferedRequest = null, R.next ? (q.corkedRequestsFree = R.next, R.next = null) : q.corkedRequestsFree = new t10(q), q.bufferedRequestCount = 0;
      } else {
        for (; Z; ) {
          var ne = Z.chunk, Ae = Z.encoding, C = Z.callback, v = q.objectMode ? 1 : ne.length;
          if (P10(B, q, false, v, ne, Ae, C), Z = Z.next, q.bufferedRequestCount--, q.writing)
            break;
        }
        Z === null && (q.lastBufferedRequest = null);
      }
      q.bufferedRequest = Z, q.bufferProcessing = false;
    }
    j.prototype._write = function(B, q, Z) {
      Z(new h("_write()"));
    }, j.prototype._writev = null, j.prototype.end = function(B, q, Z) {
      var oe = this._writableState;
      return typeof B == "function" ? (Z = B, B = null, q = null) : typeof q == "function" && (Z = q, q = null), B != null && this.write(B, q), oe.corked && (oe.corked = 1, this.uncork()), oe.ending || pe(this, oe, Z), this;
    }, Object.defineProperty(j.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function H(B) {
      return B.ending && B.length === 0 && B.bufferedRequest === null && !B.finished && !B.writing;
    }
    function $(B, q) {
      B._final(function(Z) {
        q.pendingcb--, Z && O(B, Z), q.prefinished = true, B.emit("prefinish"), he(B, q);
      });
    }
    function se(B, q) {
      !q.prefinished && !q.finalCalled && (typeof B._final == "function" && !q.destroyed ? (q.pendingcb++, q.finalCalled = true, process.nextTick($, B, q)) : (q.prefinished = true, B.emit("prefinish")));
    }
    function he(B, q) {
      var Z = H(q);
      if (Z && (se(B, q), q.pendingcb === 0 && (q.finished = true, B.emit("finish"), q.autoDestroy))) {
        var oe = B._readableState;
        (!oe || oe.autoDestroy && oe.endEmitted) && B.destroy();
      }
      return Z;
    }
    function pe(B, q, Z) {
      q.ending = true, he(B, q), Z && (q.finished ? process.nextTick(Z) : B.once("finish", Z)), q.ended = true, B.writable = false;
    }
    function me(B, q, Z) {
      var oe = B.entry;
      for (B.entry = null; oe; ) {
        var de = oe.callback;
        q.pendingcb--, de(Z), oe = oe.next;
      }
      q.corkedRequestsFree.next = B;
    }
    return Object.defineProperty(j.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState === void 0 ? false : this._writableState.destroyed;
      },
      set: function(q) {
        this._writableState && (this._writableState.destroyed = q);
      }
    }), j.prototype.destroy = l.destroy, j.prototype._undestroy = l.undestroy, j.prototype._destroy = function(B, q) {
      q(B);
    }, Tl;
  }
  var Ol, Vf;
  function xi() {
    if (Vf)
      return Ol;
    Vf = 1;
    var t10 = Object.keys || function(c) {
      var u = [];
      for (var f in c)
        u.push(f);
      return u;
    };
    Ol = s;
    var e = R0(), r = I0();
    Un(s, e);
    for (var n = t10(r.prototype), i = 0; i < n.length; i++) {
      var o = n[i];
      s.prototype[o] || (s.prototype[o] = r.prototype[o]);
    }
    function s(c) {
      if (!(this instanceof s))
        return new s(c);
      e.call(this, c), r.call(this, c), this.allowHalfOpen = true, c && (c.readable === false && (this.readable = false), c.writable === false && (this.writable = false), c.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", a)));
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    }), Object.defineProperty(s.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    }), Object.defineProperty(s.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function a() {
      this._writableState.ended || process.nextTick(l, this);
    }
    function l(c) {
      c.end();
    }
    return Object.defineProperty(s.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(u) {
        this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u);
      }
    }), Ol;
  }
  var Il = {}, qf;
  function Hf() {
    if (qf)
      return Il;
    qf = 1;
    var t10 = So.Buffer, e = t10.isEncoding || function(b) {
      switch (b = "" + b, b && b.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function r(b) {
      if (!b)
        return "utf8";
      for (var x; ; )
        switch (b) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return b;
          default:
            if (x)
              return;
            b = ("" + b).toLowerCase(), x = true;
        }
    }
    function n(b) {
      var x = r(b);
      if (typeof x != "string" && (t10.isEncoding === e || !e(b)))
        throw new Error("Unknown encoding: " + b);
      return x || b;
    }
    Il.StringDecoder = i;
    function i(b) {
      this.encoding = n(b);
      var x;
      switch (this.encoding) {
        case "utf16le":
          this.text = f, this.end = d, x = 4;
          break;
        case "utf8":
          this.fillLast = l, x = 4;
          break;
        case "base64":
          this.text = h, this.end = g, x = 3;
          break;
        default:
          this.write = p, this.end = y;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t10.allocUnsafe(x);
    }
    i.prototype.write = function(b) {
      if (b.length === 0)
        return "";
      var x, S;
      if (this.lastNeed) {
        if (x = this.fillLast(b), x === void 0)
          return "";
        S = this.lastNeed, this.lastNeed = 0;
      } else
        S = 0;
      return S < b.length ? x ? x + this.text(b, S) : this.text(b, S) : x || "";
    }, i.prototype.end = u, i.prototype.text = c, i.prototype.fillLast = function(b) {
      if (this.lastNeed <= b.length)
        return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
    };
    function o(b) {
      return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
    }
    function s(b, x, S) {
      var O = x.length - 1;
      if (O < S)
        return 0;
      var _ = o(x[O]);
      return _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 1), _) : --O < S || _ === -2 ? 0 : (_ = o(x[O]), _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 2), _) : --O < S || _ === -2 ? 0 : (_ = o(x[O]), _ >= 0 ? (_ > 0 && (_ === 2 ? _ = 0 : b.lastNeed = _ - 3), _) : 0));
    }
    function a(b, x, S) {
      if ((x[0] & 192) !== 128)
        return b.lastNeed = 0, "";
      if (b.lastNeed > 1 && x.length > 1) {
        if ((x[1] & 192) !== 128)
          return b.lastNeed = 1, "";
        if (b.lastNeed > 2 && x.length > 2 && (x[2] & 192) !== 128)
          return b.lastNeed = 2, "";
      }
    }
    function l(b) {
      var x = this.lastTotal - this.lastNeed, S = a(this, b);
      if (S !== void 0)
        return S;
      if (this.lastNeed <= b.length)
        return b.copy(this.lastChar, x, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      b.copy(this.lastChar, x, 0, b.length), this.lastNeed -= b.length;
    }
    function c(b, x) {
      var S = s(this, b, x);
      if (!this.lastNeed)
        return b.toString("utf8", x);
      this.lastTotal = S;
      var O = b.length - (S - this.lastNeed);
      return b.copy(this.lastChar, 0, O), b.toString("utf8", x, O);
    }
    function u(b) {
      var x = b && b.length ? this.write(b) : "";
      return this.lastNeed ? x + "" : x;
    }
    function f(b, x) {
      if ((b.length - x) % 2 === 0) {
        var S = b.toString("utf16le", x);
        if (S) {
          var O = S.charCodeAt(S.length - 1);
          if (O >= 55296 && O <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], S.slice(0, -1);
        }
        return S;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", x, b.length - 1);
    }
    function d(b) {
      var x = b && b.length ? this.write(b) : "";
      if (this.lastNeed) {
        var S = this.lastTotal - this.lastNeed;
        return x + this.lastChar.toString("utf16le", 0, S);
      }
      return x;
    }
    function h(b, x) {
      var S = (b.length - x) % 3;
      return S === 0 ? b.toString("base64", x) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", x, b.length - S));
    }
    function g(b) {
      var x = b && b.length ? this.write(b) : "";
      return this.lastNeed ? x + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : x;
    }
    function p(b) {
      return b.toString(this.encoding);
    }
    function y(b) {
      return b && b.length ? this.write(b) : "";
    }
    return Il;
  }
  var Yf = Gn.codes.ERR_STREAM_PREMATURE_CLOSE;
  function By(t10) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i];
        t10.apply(this, n);
      }
    };
  }
  function Fy() {
  }
  function jy(t10) {
    return t10.setHeader && typeof t10.abort == "function";
  }
  function P0(t10, e, r) {
    if (typeof e == "function")
      return P0(t10, null, e);
    e || (e = {}), r = By(r || Fy);
    var n = e.readable || e.readable !== false && t10.readable, i = e.writable || e.writable !== false && t10.writable, o = function() {
      t10.writable || a();
    }, s = t10._writableState && t10._writableState.finished, a = function() {
      i = false, s = true, n || r.call(t10);
    }, l = t10._readableState && t10._readableState.endEmitted, c = function() {
      n = false, l = true, i || r.call(t10);
    }, u = function(g) {
      r.call(t10, g);
    }, f = function() {
      var g;
      if (n && !l)
        return (!t10._readableState || !t10._readableState.ended) && (g = new Yf()), r.call(t10, g);
      if (i && !s)
        return (!t10._writableState || !t10._writableState.ended) && (g = new Yf()), r.call(t10, g);
    }, d = function() {
      t10.req.on("finish", a);
    };
    return jy(t10) ? (t10.on("complete", a), t10.on("abort", f), t10.req ? d() : t10.on("request", d)) : i && !t10._writableState && (t10.on("end", o), t10.on("close", o)), t10.on("end", c), t10.on("finish", a), e.error !== false && t10.on("error", u), t10.on("close", f), function() {
      t10.removeListener("complete", a), t10.removeListener("abort", f), t10.removeListener("request", d), t10.req && t10.req.removeListener("finish", a), t10.removeListener("end", o), t10.removeListener("close", o), t10.removeListener("finish", a), t10.removeListener("end", c), t10.removeListener("error", u), t10.removeListener("close", f);
    };
  }
  var mu = P0, Pl, Kf;
  function Wy() {
    if (Kf)
      return Pl;
    Kf = 1;
    var t10;
    function e(b, x, S) {
      return x in b ? Object.defineProperty(b, x, { value: S, enumerable: true, configurable: true, writable: true }) : b[x] = S, b;
    }
    var r = mu, n = Symbol("lastResolve"), i = Symbol("lastReject"), o = Symbol("error"), s = Symbol("ended"), a = Symbol("lastPromise"), l = Symbol("handlePromise"), c = Symbol("stream");
    function u(b, x) {
      return {
        value: b,
        done: x
      };
    }
    function f(b) {
      var x = b[n];
      if (x !== null) {
        var S = b[c].read();
        S !== null && (b[a] = null, b[n] = null, b[i] = null, x(u(S, false)));
      }
    }
    function d(b) {
      process.nextTick(f, b);
    }
    function h(b, x) {
      return function(S, O) {
        b.then(function() {
          if (x[s]) {
            S(u(void 0, true));
            return;
          }
          x[l](S, O);
        }, O);
      };
    }
    var g = Object.getPrototypeOf(function() {
    }), p = Object.setPrototypeOf((t10 = {
      get stream() {
        return this[c];
      },
      next: function() {
        var x = this, S = this[o];
        if (S !== null)
          return Promise.reject(S);
        if (this[s])
          return Promise.resolve(u(void 0, true));
        if (this[c].destroyed)
          return new Promise(function(N, j) {
            process.nextTick(function() {
              x[o] ? j(x[o]) : N(u(void 0, true));
            });
          });
        var O = this[a], _;
        if (O)
          _ = new Promise(h(O, this));
        else {
          var L = this[c].read();
          if (L !== null)
            return Promise.resolve(u(L, false));
          _ = new Promise(this[l]);
        }
        return this[a] = _, _;
      }
    }, e(t10, Symbol.asyncIterator, function() {
      return this;
    }), e(t10, "return", function() {
      var x = this;
      return new Promise(function(S, O) {
        x[c].destroy(null, function(_) {
          if (_) {
            O(_);
            return;
          }
          S(u(void 0, true));
        });
      });
    }), t10), g), y = function(x) {
      var S, O = Object.create(p, (S = {}, e(S, c, {
        value: x,
        writable: true
      }), e(S, n, {
        value: null,
        writable: true
      }), e(S, i, {
        value: null,
        writable: true
      }), e(S, o, {
        value: null,
        writable: true
      }), e(S, s, {
        value: x._readableState.endEmitted,
        writable: true
      }), e(S, l, {
        value: function(L, N) {
          var j = O[c].read();
          j ? (O[a] = null, O[n] = null, O[i] = null, L(u(j, false))) : (O[n] = L, O[i] = N);
        },
        writable: true
      }), S));
      return O[a] = null, r(x, function(_) {
        if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var L = O[i];
          L !== null && (O[a] = null, O[n] = null, O[i] = null, L(_)), O[o] = _;
          return;
        }
        var N = O[n];
        N !== null && (O[a] = null, O[n] = null, O[i] = null, N(u(void 0, true))), O[s] = true;
      }), x.on("readable", d.bind(null, O)), O;
    };
    return Pl = y, Pl;
  }
  var Rl, Xf;
  function Uy() {
    return Xf || (Xf = 1, Rl = function() {
      throw new Error("Readable.from is not available in the browser");
    }), Rl;
  }
  var Dl, Jf;
  function R0() {
    if (Jf)
      return Dl;
    Jf = 1, Dl = W;
    var t10;
    W.ReadableState = j, wi.EventEmitter;
    var e = function(k, re) {
      return k.listeners(re).length;
    }, r = E0, n = Ho.Buffer, i = globalThis.Uint8Array || function() {
    };
    function o(R) {
      return n.from(R);
    }
    function s(R) {
      return n.isBuffer(R) || R instanceof i;
    }
    var a = k0, l;
    a && a.debuglog ? l = a.debuglog("stream") : l = function() {
    };
    var c = Sy(), u = C0, f = O0, d = f.getHighWaterMark, h = Gn.codes, g = h.ERR_INVALID_ARG_TYPE, p = h.ERR_STREAM_PUSH_AFTER_EOF, y = h.ERR_METHOD_NOT_IMPLEMENTED, b = h.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, x, S, O;
    Un(W, r);
    var _ = u.errorOrDestroy, L = ["error", "close", "destroy", "pause", "resume"];
    function N(R, k, re) {
      if (typeof R.prependListener == "function")
        return R.prependListener(k, re);
      !R._events || !R._events[k] ? R.on(k, re) : Array.isArray(R._events[k]) ? R._events[k].unshift(re) : R._events[k] = [re, R._events[k]];
    }
    function j(R, k, re) {
      t10 = t10 || xi(), R = R || {}, typeof re != "boolean" && (re = k instanceof t10), this.objectMode = !!R.objectMode, re && (this.objectMode = this.objectMode || !!R.readableObjectMode), this.highWaterMark = d(this, R, "readableHighWaterMark", re), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = R.emitClose !== false, this.autoDestroy = !!R.autoDestroy, this.destroyed = false, this.defaultEncoding = R.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, R.encoding && (x || (x = Hf().StringDecoder), this.decoder = new x(R.encoding), this.encoding = R.encoding);
    }
    function W(R) {
      if (t10 = t10 || xi(), !(this instanceof W))
        return new W(R);
      var k = this instanceof t10;
      this._readableState = new j(R, this, k), this.readable = true, R && (typeof R.read == "function" && (this._read = R.read), typeof R.destroy == "function" && (this._destroy = R.destroy)), r.call(this);
    }
    Object.defineProperty(W.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 ? false : this._readableState.destroyed;
      },
      set: function(k) {
        this._readableState && (this._readableState.destroyed = k);
      }
    }), W.prototype.destroy = u.destroy, W.prototype._undestroy = u.undestroy, W.prototype._destroy = function(R, k) {
      k(R);
    }, W.prototype.push = function(R, k) {
      var re = this._readableState, ne;
      return re.objectMode ? ne = true : typeof R == "string" && (k = k || re.defaultEncoding, k !== re.encoding && (R = n.from(R, k), k = ""), ne = true), G(this, R, k, false, ne);
    }, W.prototype.unshift = function(R) {
      return G(this, R, null, true, false);
    };
    function G(R, k, re, ne, Ae) {
      l("readableAddChunk", k);
      var C = R._readableState;
      if (k === null)
        C.reading = false, I(R, C);
      else {
        var v;
        if (Ae || (v = fe(C, k)), v)
          _(R, v);
        else if (C.objectMode || k && k.length > 0)
          if (typeof k != "string" && !C.objectMode && Object.getPrototypeOf(k) !== n.prototype && (k = o(k)), ne)
            C.endEmitted ? _(R, new b()) : ee(R, C, k, true);
          else if (C.ended)
            _(R, new p());
          else {
            if (C.destroyed)
              return false;
            C.reading = false, C.decoder && !re ? (k = C.decoder.write(k), C.objectMode || k.length !== 0 ? ee(R, C, k, false) : X(R, C)) : ee(R, C, k, false);
          }
        else
          ne || (C.reading = false, X(R, C));
      }
      return !C.ended && (C.length < C.highWaterMark || C.length === 0);
    }
    function ee(R, k, re, ne) {
      k.flowing && k.length === 0 && !k.sync ? (k.awaitDrain = 0, R.emit("data", re)) : (k.length += k.objectMode ? 1 : re.length, ne ? k.buffer.unshift(re) : k.buffer.push(re), k.needReadable && V(R)), X(R, k);
    }
    function fe(R, k) {
      var re;
      return !s(k) && typeof k != "string" && k !== void 0 && !R.objectMode && (re = new g("chunk", ["string", "Buffer", "Uint8Array"], k)), re;
    }
    W.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    }, W.prototype.setEncoding = function(R) {
      x || (x = Hf().StringDecoder);
      var k = new x(R);
      this._readableState.decoder = k, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var re = this._readableState.buffer.head, ne = ""; re !== null; )
        ne += k.write(re.data), re = re.next;
      return this._readableState.buffer.clear(), ne !== "" && this._readableState.buffer.push(ne), this._readableState.length = ne.length, this;
    };
    var P10 = 1073741824;
    function z10(R) {
      return R >= P10 ? R = P10 : (R--, R |= R >>> 1, R |= R >>> 2, R |= R >>> 4, R |= R >>> 8, R |= R >>> 16, R++), R;
    }
    function U(R, k) {
      return R <= 0 || k.length === 0 && k.ended ? 0 : k.objectMode ? 1 : R !== R ? k.flowing && k.length ? k.buffer.head.data.length : k.length : (R > k.highWaterMark && (k.highWaterMark = z10(R)), R <= k.length ? R : k.ended ? k.length : (k.needReadable = true, 0));
    }
    W.prototype.read = function(R) {
      l("read", R), R = parseInt(R, 10);
      var k = this._readableState, re = R;
      if (R !== 0 && (k.emittedReadable = false), R === 0 && k.needReadable && ((k.highWaterMark !== 0 ? k.length >= k.highWaterMark : k.length > 0) || k.ended))
        return l("read: emitReadable", k.length, k.ended), k.length === 0 && k.ended ? Z(this) : V(this), null;
      if (R = U(R, k), R === 0 && k.ended)
        return k.length === 0 && Z(this), null;
      var ne = k.needReadable;
      l("need readable", ne), (k.length === 0 || k.length - R < k.highWaterMark) && (ne = true, l("length less than watermark", ne)), k.ended || k.reading ? (ne = false, l("reading or ended", ne)) : ne && (l("do read"), k.reading = true, k.sync = true, k.length === 0 && (k.needReadable = true), this._read(k.highWaterMark), k.sync = false, k.reading || (R = U(re, k)));
      var Ae;
      return R > 0 ? Ae = q(R, k) : Ae = null, Ae === null ? (k.needReadable = k.length <= k.highWaterMark, R = 0) : (k.length -= R, k.awaitDrain = 0), k.length === 0 && (k.ended || (k.needReadable = true), re !== R && k.ended && Z(this)), Ae !== null && this.emit("data", Ae), Ae;
    };
    function I(R, k) {
      if (l("onEofChunk"), !k.ended) {
        if (k.decoder) {
          var re = k.decoder.end();
          re && re.length && (k.buffer.push(re), k.length += k.objectMode ? 1 : re.length);
        }
        k.ended = true, k.sync ? V(R) : (k.needReadable = false, k.emittedReadable || (k.emittedReadable = true, te(R)));
      }
    }
    function V(R) {
      var k = R._readableState;
      l("emitReadable", k.needReadable, k.emittedReadable), k.needReadable = false, k.emittedReadable || (l("emitReadable", k.flowing), k.emittedReadable = true, process.nextTick(te, R));
    }
    function te(R) {
      var k = R._readableState;
      l("emitReadable_", k.destroyed, k.length, k.ended), !k.destroyed && (k.length || k.ended) && (R.emit("readable"), k.emittedReadable = false), k.needReadable = !k.flowing && !k.ended && k.length <= k.highWaterMark, B(R);
    }
    function X(R, k) {
      k.readingMore || (k.readingMore = true, process.nextTick(H, R, k));
    }
    function H(R, k) {
      for (; !k.reading && !k.ended && (k.length < k.highWaterMark || k.flowing && k.length === 0); ) {
        var re = k.length;
        if (l("maybeReadMore read 0"), R.read(0), re === k.length)
          break;
      }
      k.readingMore = false;
    }
    W.prototype._read = function(R) {
      _(this, new y("_read()"));
    }, W.prototype.pipe = function(R, k) {
      var re = this, ne = this._readableState;
      switch (ne.pipesCount) {
        case 0:
          ne.pipes = R;
          break;
        case 1:
          ne.pipes = [ne.pipes, R];
          break;
        default:
          ne.pipes.push(R);
          break;
      }
      ne.pipesCount += 1, l("pipe count=%d opts=%j", ne.pipesCount, k);
      var Ae = (!k || k.end !== false) && R !== process.stdout && R !== process.stderr, C = Ae ? w : Ne;
      ne.endEmitted ? process.nextTick(C) : re.once("end", C), R.on("unpipe", v);
      function v(E, m) {
        l("onunpipe"), E === re && m && m.hasUnpiped === false && (m.hasUnpiped = true, ae());
      }
      function w() {
        l("onend"), R.end();
      }
      var D = $(re);
      R.on("drain", D);
      var J = false;
      function ae() {
        l("cleanup"), R.removeListener("close", _e), R.removeListener("finish", we), R.removeListener("drain", D), R.removeListener("error", Se), R.removeListener("unpipe", v), re.removeListener("end", w), re.removeListener("end", Ne), re.removeListener("data", ue), J = true, ne.awaitDrain && (!R._writableState || R._writableState.needDrain) && D();
      }
      re.on("data", ue);
      function ue(E) {
        l("ondata");
        var m = R.write(E);
        l("dest.write", m), m === false && ((ne.pipesCount === 1 && ne.pipes === R || ne.pipesCount > 1 && de(ne.pipes, R) !== -1) && !J && (l("false write response, pause", ne.awaitDrain), ne.awaitDrain++), re.pause());
      }
      function Se(E) {
        l("onerror", E), Ne(), R.removeListener("error", Se), e(R, "error") === 0 && _(R, E);
      }
      N(R, "error", Se);
      function _e() {
        R.removeListener("finish", we), Ne();
      }
      R.once("close", _e);
      function we() {
        l("onfinish"), R.removeListener("close", _e), Ne();
      }
      R.once("finish", we);
      function Ne() {
        l("unpipe"), re.unpipe(R);
      }
      return R.emit("pipe", re), ne.flowing || (l("pipe resume"), re.resume()), R;
    };
    function $(R) {
      return function() {
        var re = R._readableState;
        l("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && e(R, "data") && (re.flowing = true, B(R));
      };
    }
    W.prototype.unpipe = function(R) {
      var k = this._readableState, re = {
        hasUnpiped: false
      };
      if (k.pipesCount === 0)
        return this;
      if (k.pipesCount === 1)
        return R && R !== k.pipes ? this : (R || (R = k.pipes), k.pipes = null, k.pipesCount = 0, k.flowing = false, R && R.emit("unpipe", this, re), this);
      if (!R) {
        var ne = k.pipes, Ae = k.pipesCount;
        k.pipes = null, k.pipesCount = 0, k.flowing = false;
        for (var C = 0; C < Ae; C++)
          ne[C].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var v = de(k.pipes, R);
      return v === -1 ? this : (k.pipes.splice(v, 1), k.pipesCount -= 1, k.pipesCount === 1 && (k.pipes = k.pipes[0]), R.emit("unpipe", this, re), this);
    }, W.prototype.on = function(R, k) {
      var re = r.prototype.on.call(this, R, k), ne = this._readableState;
      return R === "data" ? (ne.readableListening = this.listenerCount("readable") > 0, ne.flowing !== false && this.resume()) : R === "readable" && !ne.endEmitted && !ne.readableListening && (ne.readableListening = ne.needReadable = true, ne.flowing = false, ne.emittedReadable = false, l("on readable", ne.length, ne.reading), ne.length ? V(this) : ne.reading || process.nextTick(he, this)), re;
    }, W.prototype.addListener = W.prototype.on, W.prototype.removeListener = function(R, k) {
      var re = r.prototype.removeListener.call(this, R, k);
      return R === "readable" && process.nextTick(se, this), re;
    }, W.prototype.removeAllListeners = function(R) {
      var k = r.prototype.removeAllListeners.apply(this, arguments);
      return (R === "readable" || R === void 0) && process.nextTick(se, this), k;
    };
    function se(R) {
      var k = R._readableState;
      k.readableListening = R.listenerCount("readable") > 0, k.resumeScheduled && !k.paused ? k.flowing = true : R.listenerCount("data") > 0 && R.resume();
    }
    function he(R) {
      l("readable nexttick read 0"), R.read(0);
    }
    W.prototype.resume = function() {
      var R = this._readableState;
      return R.flowing || (l("resume"), R.flowing = !R.readableListening, pe(this, R)), R.paused = false, this;
    };
    function pe(R, k) {
      k.resumeScheduled || (k.resumeScheduled = true, process.nextTick(me, R, k));
    }
    function me(R, k) {
      l("resume", k.reading), k.reading || R.read(0), k.resumeScheduled = false, R.emit("resume"), B(R), k.flowing && !k.reading && R.read(0);
    }
    W.prototype.pause = function() {
      return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function B(R) {
      var k = R._readableState;
      for (l("flow", k.flowing); k.flowing && R.read() !== null; )
        ;
    }
    W.prototype.wrap = function(R) {
      var k = this, re = this._readableState, ne = false;
      R.on("end", function() {
        if (l("wrapped end"), re.decoder && !re.ended) {
          var v = re.decoder.end();
          v && v.length && k.push(v);
        }
        k.push(null);
      }), R.on("data", function(v) {
        if (l("wrapped data"), re.decoder && (v = re.decoder.write(v)), !(re.objectMode && v == null) && !(!re.objectMode && (!v || !v.length))) {
          var w = k.push(v);
          w || (ne = true, R.pause());
        }
      });
      for (var Ae in R)
        this[Ae] === void 0 && typeof R[Ae] == "function" && (this[Ae] = /* @__PURE__ */ function(w) {
          return function() {
            return R[w].apply(R, arguments);
          };
        }(Ae));
      for (var C = 0; C < L.length; C++)
        R.on(L[C], this.emit.bind(this, L[C]));
      return this._read = function(v) {
        l("wrapped _read", v), ne && (ne = false, R.resume());
      }, this;
    }, typeof Symbol == "function" && (W.prototype[Symbol.asyncIterator] = function() {
      return S === void 0 && (S = Wy()), S(this);
    }), Object.defineProperty(W.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    }), Object.defineProperty(W.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    }), Object.defineProperty(W.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(k) {
        this._readableState && (this._readableState.flowing = k);
      }
    }), W._fromList = q, Object.defineProperty(W.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.length;
      }
    });
    function q(R, k) {
      if (k.length === 0)
        return null;
      var re;
      return k.objectMode ? re = k.buffer.shift() : !R || R >= k.length ? (k.decoder ? re = k.buffer.join("") : k.buffer.length === 1 ? re = k.buffer.first() : re = k.buffer.concat(k.length), k.buffer.clear()) : re = k.buffer.consume(R, k.decoder), re;
    }
    function Z(R) {
      var k = R._readableState;
      l("endReadable", k.endEmitted), k.endEmitted || (k.ended = true, process.nextTick(oe, k, R));
    }
    function oe(R, k) {
      if (l("endReadableNT", R.endEmitted, R.length), !R.endEmitted && R.length === 0 && (R.endEmitted = true, k.readable = false, k.emit("end"), R.autoDestroy)) {
        var re = k._writableState;
        (!re || re.autoDestroy && re.finished) && k.destroy();
      }
    }
    typeof Symbol == "function" && (W.from = function(R, k) {
      return O === void 0 && (O = Uy()), O(W, R, k);
    });
    function de(R, k) {
      for (var re = 0, ne = R.length; re < ne; re++)
        if (R[re] === k)
          return re;
      return -1;
    }
    return Dl;
  }
  var D0 = Hr, Ba = Gn.codes, zy = Ba.ERR_METHOD_NOT_IMPLEMENTED, Vy = Ba.ERR_MULTIPLE_CALLBACK, qy = Ba.ERR_TRANSFORM_ALREADY_TRANSFORMING, Hy = Ba.ERR_TRANSFORM_WITH_LENGTH_0, Fa = xi();
  Un(Hr, Fa);
  function Yy(t10, e) {
    var r = this._transformState;
    r.transforming = false;
    var n = r.writecb;
    if (n === null)
      return this.emit("error", new Vy());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t10);
    var i = this._readableState;
    i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
  function Hr(t10) {
    if (!(this instanceof Hr))
      return new Hr(t10);
    Fa.call(this, t10), this._transformState = {
      afterTransform: Yy.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = true, this._readableState.sync = false, t10 && (typeof t10.transform == "function" && (this._transform = t10.transform), typeof t10.flush == "function" && (this._flush = t10.flush)), this.on("prefinish", Ky);
  }
  function Ky() {
    var t10 = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Qf(t10, e, r);
    }) : Qf(this, null, null);
  }
  Hr.prototype.push = function(t10, e) {
    return this._transformState.needTransform = false, Fa.prototype.push.call(this, t10, e);
  };
  Hr.prototype._transform = function(t10, e, r) {
    r(new zy("_transform()"));
  };
  Hr.prototype._write = function(t10, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t10, n.writeencoding = e, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
  };
  Hr.prototype._read = function(t10) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  Hr.prototype._destroy = function(t10, e) {
    Fa.prototype._destroy.call(this, t10, function(r) {
      e(r);
    });
  };
  function Qf(t10, e, r) {
    if (e)
      return t10.emit("error", e);
    if (r != null && t10.push(r), t10._writableState.length)
      throw new Hy();
    if (t10._transformState.transforming)
      throw new qy();
    return t10.push(null);
  }
  var Xy = Eo, M0 = D0;
  Un(Eo, M0);
  function Eo(t10) {
    if (!(this instanceof Eo))
      return new Eo(t10);
    M0.call(this, t10);
  }
  Eo.prototype._transform = function(t10, e, r) {
    r(null, t10);
  };
  var Ml;
  function Jy(t10) {
    var e = false;
    return function() {
      e || (e = true, t10.apply(void 0, arguments));
    };
  }
  var N0 = Gn.codes, Qy = N0.ERR_MISSING_ARGS, Gy = N0.ERR_STREAM_DESTROYED;
  function Gf(t10) {
    if (t10)
      throw t10;
  }
  function Zy(t10) {
    return t10.setHeader && typeof t10.abort == "function";
  }
  function $y(t10, e, r, n) {
    n = Jy(n);
    var i = false;
    t10.on("close", function() {
      i = true;
    }), Ml === void 0 && (Ml = mu), Ml(t10, {
      readable: e,
      writable: r
    }, function(s) {
      if (s)
        return n(s);
      i = true, n();
    });
    var o = false;
    return function(s) {
      if (!i && !o) {
        if (o = true, Zy(t10))
          return t10.abort();
        if (typeof t10.destroy == "function")
          return t10.destroy();
        n(s || new Gy("pipe"));
      }
    };
  }
  function Zf(t10) {
    t10();
  }
  function eb(t10, e) {
    return t10.pipe(e);
  }
  function tb(t10) {
    return !t10.length || typeof t10[t10.length - 1] != "function" ? Gf : t10.pop();
  }
  function rb() {
    for (var t10 = arguments.length, e = new Array(t10), r = 0; r < t10; r++)
      e[r] = arguments[r];
    var n = tb(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new Qy("streams");
    var i, o = e.map(function(s, a) {
      var l = a < e.length - 1, c = a > 0;
      return $y(s, l, c, function(u) {
        i || (i = u), u && o.forEach(Zf), !l && (o.forEach(Zf), n(i));
      });
    });
    return e.reduce(eb);
  }
  var nb = rb;
  (function(t10, e) {
    e = t10.exports = R0(), e.Stream = e, e.Readable = e, e.Writable = I0(), e.Duplex = xi(), e.Transform = D0, e.PassThrough = Xy, e.finished = mu, e.pipeline = nb;
  })(wy, oa);
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  let $f;
  var ib = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : globalThis) : (t10) => ($f || ($f = Promise.resolve())).then(t10).catch((e) => setTimeout(() => {
    throw e;
  }, 0));
  function ed(t10, e) {
    for (const r in e)
      Object.defineProperty(t10, r, {
        value: e[r],
        enumerable: true,
        configurable: true
      });
    return t10;
  }
  function ob(t10, e, r) {
    if (!t10 || typeof t10 == "string")
      throw new TypeError("Please pass an Error to err-code");
    r || (r = {}), typeof e == "object" && (r = e, e = ""), e && (r.code = e);
    try {
      return ed(t10, r);
    } catch {
      r.message = t10.message, r.stack = t10.stack;
      const i = function() {
      };
      return i.prototype = Object.create(Object.getPrototypeOf(t10)), ed(new i(), r);
    }
  }
  var sb = ob, L0 = {};
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(t10) {
    const e = Yo, r = La, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t10.Buffer = a, t10.SlowBuffer = x, t10.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t10.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function o() {
      try {
        const E = new Uint8Array(1), m = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(m, Uint8Array.prototype), Object.setPrototypeOf(E, m), E.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this))
          return this.byteOffset;
      }
    });
    function s(E) {
      if (E > i)
        throw new RangeError('The value "' + E + '" is invalid for option "size"');
      const m = new Uint8Array(E);
      return Object.setPrototypeOf(m, a.prototype), m;
    }
    function a(E, m, A) {
      if (typeof E == "number") {
        if (typeof m == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return f(E);
      }
      return l(E, m, A);
    }
    a.poolSize = 8192;
    function l(E, m, A) {
      if (typeof E == "string")
        return d(E, m);
      if (ArrayBuffer.isView(E))
        return g(E);
      if (E == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
        );
      if (ue(E, ArrayBuffer) || E && ue(E.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ue(E, SharedArrayBuffer) || E && ue(E.buffer, SharedArrayBuffer)))
        return p(E, m, A);
      if (typeof E == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const M = E.valueOf && E.valueOf();
      if (M != null && M !== E)
        return a.from(M, m, A);
      const Q = y(E);
      if (Q)
        return Q;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof E[Symbol.toPrimitive] == "function")
        return a.from(E[Symbol.toPrimitive]("string"), m, A);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof E
      );
    }
    a.from = function(E, m, A) {
      return l(E, m, A);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function c(E) {
      if (typeof E != "number")
        throw new TypeError('"size" argument must be of type number');
      if (E < 0)
        throw new RangeError('The value "' + E + '" is invalid for option "size"');
    }
    function u(E, m, A) {
      return c(E), E <= 0 ? s(E) : m !== void 0 ? typeof A == "string" ? s(E).fill(m, A) : s(E).fill(m) : s(E);
    }
    a.alloc = function(E, m, A) {
      return u(E, m, A);
    };
    function f(E) {
      return c(E), s(E < 0 ? 0 : b(E) | 0);
    }
    a.allocUnsafe = function(E) {
      return f(E);
    }, a.allocUnsafeSlow = function(E) {
      return f(E);
    };
    function d(E, m) {
      if ((typeof m != "string" || m === "") && (m = "utf8"), !a.isEncoding(m))
        throw new TypeError("Unknown encoding: " + m);
      const A = S(E, m) | 0;
      let M = s(A);
      const Q = M.write(E, m);
      return Q !== A && (M = M.slice(0, Q)), M;
    }
    function h(E) {
      const m = E.length < 0 ? 0 : b(E.length) | 0, A = s(m);
      for (let M = 0; M < m; M += 1)
        A[M] = E[M] & 255;
      return A;
    }
    function g(E) {
      if (ue(E, Uint8Array)) {
        const m = new Uint8Array(E);
        return p(m.buffer, m.byteOffset, m.byteLength);
      }
      return h(E);
    }
    function p(E, m, A) {
      if (m < 0 || E.byteLength < m)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (E.byteLength < m + (A || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let M;
      return m === void 0 && A === void 0 ? M = new Uint8Array(E) : A === void 0 ? M = new Uint8Array(E, m) : M = new Uint8Array(E, m, A), Object.setPrototypeOf(M, a.prototype), M;
    }
    function y(E) {
      if (a.isBuffer(E)) {
        const m = b(E.length) | 0, A = s(m);
        return A.length === 0 || E.copy(A, 0, 0, m), A;
      }
      if (E.length !== void 0)
        return typeof E.length != "number" || Se(E.length) ? s(0) : h(E);
      if (E.type === "Buffer" && Array.isArray(E.data))
        return h(E.data);
    }
    function b(E) {
      if (E >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return E | 0;
    }
    function x(E) {
      return +E != E && (E = 0), a.alloc(+E);
    }
    a.isBuffer = function(m) {
      return m != null && m._isBuffer === true && m !== a.prototype;
    }, a.compare = function(m, A) {
      if (ue(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), ue(A, Uint8Array) && (A = a.from(A, A.offset, A.byteLength)), !a.isBuffer(m) || !a.isBuffer(A))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (m === A)
        return 0;
      let M = m.length, Q = A.length;
      for (let ie = 0, le = Math.min(M, Q); ie < le; ++ie)
        if (m[ie] !== A[ie]) {
          M = m[ie], Q = A[ie];
          break;
        }
      return M < Q ? -1 : Q < M ? 1 : 0;
    }, a.isEncoding = function(m) {
      switch (String(m).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, a.concat = function(m, A) {
      if (!Array.isArray(m))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (m.length === 0)
        return a.alloc(0);
      let M;
      if (A === void 0)
        for (A = 0, M = 0; M < m.length; ++M)
          A += m[M].length;
      const Q = a.allocUnsafe(A);
      let ie = 0;
      for (M = 0; M < m.length; ++M) {
        let le = m[M];
        if (ue(le, Uint8Array))
          ie + le.length > Q.length ? (a.isBuffer(le) || (le = a.from(le)), le.copy(Q, ie)) : Uint8Array.prototype.set.call(
            Q,
            le,
            ie
          );
        else if (a.isBuffer(le))
          le.copy(Q, ie);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ie += le.length;
      }
      return Q;
    };
    function S(E, m) {
      if (a.isBuffer(E))
        return E.length;
      if (ArrayBuffer.isView(E) || ue(E, ArrayBuffer))
        return E.byteLength;
      if (typeof E != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof E
        );
      const A = E.length, M = arguments.length > 2 && arguments[2] === true;
      if (!M && A === 0)
        return 0;
      let Q = false;
      for (; ; )
        switch (m) {
          case "ascii":
          case "latin1":
          case "binary":
            return A;
          case "utf8":
          case "utf-8":
            return v(E).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return A * 2;
          case "hex":
            return A >>> 1;
          case "base64":
            return J(E).length;
          default:
            if (Q)
              return M ? -1 : v(E).length;
            m = ("" + m).toLowerCase(), Q = true;
        }
    }
    a.byteLength = S;
    function O(E, m, A) {
      let M = false;
      if ((m === void 0 || m < 0) && (m = 0), m > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, m >>>= 0, A <= m))
        return "";
      for (E || (E = "utf8"); ; )
        switch (E) {
          case "hex":
            return X(this, m, A);
          case "utf8":
          case "utf-8":
            return z10(this, m, A);
          case "ascii":
            return V(this, m, A);
          case "latin1":
          case "binary":
            return te(this, m, A);
          case "base64":
            return P10(this, m, A);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return H(this, m, A);
          default:
            if (M)
              throw new TypeError("Unknown encoding: " + E);
            E = (E + "").toLowerCase(), M = true;
        }
    }
    a.prototype._isBuffer = true;
    function _(E, m, A) {
      const M = E[m];
      E[m] = E[A], E[A] = M;
    }
    a.prototype.swap16 = function() {
      const m = this.length;
      if (m % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let A = 0; A < m; A += 2)
        _(this, A, A + 1);
      return this;
    }, a.prototype.swap32 = function() {
      const m = this.length;
      if (m % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let A = 0; A < m; A += 4)
        _(this, A, A + 3), _(this, A + 1, A + 2);
      return this;
    }, a.prototype.swap64 = function() {
      const m = this.length;
      if (m % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let A = 0; A < m; A += 8)
        _(this, A, A + 7), _(this, A + 1, A + 6), _(this, A + 2, A + 5), _(this, A + 3, A + 4);
      return this;
    }, a.prototype.toString = function() {
      const m = this.length;
      return m === 0 ? "" : arguments.length === 0 ? z10(this, 0, m) : O.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(m) {
      if (!a.isBuffer(m))
        throw new TypeError("Argument must be a Buffer");
      return this === m ? true : a.compare(this, m) === 0;
    }, a.prototype.inspect = function() {
      let m = "";
      const A = t10.INSPECT_MAX_BYTES;
      return m = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (m += " ... "), "<Buffer " + m + ">";
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(m, A, M, Q, ie) {
      if (ue(m, Uint8Array) && (m = a.from(m, m.offset, m.byteLength)), !a.isBuffer(m))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m
        );
      if (A === void 0 && (A = 0), M === void 0 && (M = m ? m.length : 0), Q === void 0 && (Q = 0), ie === void 0 && (ie = this.length), A < 0 || M > m.length || Q < 0 || ie > this.length)
        throw new RangeError("out of range index");
      if (Q >= ie && A >= M)
        return 0;
      if (Q >= ie)
        return -1;
      if (A >= M)
        return 1;
      if (A >>>= 0, M >>>= 0, Q >>>= 0, ie >>>= 0, this === m)
        return 0;
      let le = ie - Q, Ee = M - A;
      const Fe = Math.min(le, Ee), Ve = this.slice(Q, ie), Ge = m.slice(A, M);
      for (let Ue = 0; Ue < Fe; ++Ue)
        if (Ve[Ue] !== Ge[Ue]) {
          le = Ve[Ue], Ee = Ge[Ue];
          break;
        }
      return le < Ee ? -1 : Ee < le ? 1 : 0;
    };
    function L(E, m, A, M, Q) {
      if (E.length === 0)
        return -1;
      if (typeof A == "string" ? (M = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, Se(A) && (A = Q ? 0 : E.length - 1), A < 0 && (A = E.length + A), A >= E.length) {
        if (Q)
          return -1;
        A = E.length - 1;
      } else if (A < 0)
        if (Q)
          A = 0;
        else
          return -1;
      if (typeof m == "string" && (m = a.from(m, M)), a.isBuffer(m))
        return m.length === 0 ? -1 : N(E, m, A, M, Q);
      if (typeof m == "number")
        return m = m & 255, typeof Uint8Array.prototype.indexOf == "function" ? Q ? Uint8Array.prototype.indexOf.call(E, m, A) : Uint8Array.prototype.lastIndexOf.call(E, m, A) : N(E, [m], A, M, Q);
      throw new TypeError("val must be string, number or Buffer");
    }
    function N(E, m, A, M, Q) {
      let ie = 1, le = E.length, Ee = m.length;
      if (M !== void 0 && (M = String(M).toLowerCase(), M === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
        if (E.length < 2 || m.length < 2)
          return -1;
        ie = 2, le /= 2, Ee /= 2, A /= 2;
      }
      function Fe(Ge, Ue) {
        return ie === 1 ? Ge[Ue] : Ge.readUInt16BE(Ue * ie);
      }
      let Ve;
      if (Q) {
        let Ge = -1;
        for (Ve = A; Ve < le; Ve++)
          if (Fe(E, Ve) === Fe(m, Ge === -1 ? 0 : Ve - Ge)) {
            if (Ge === -1 && (Ge = Ve), Ve - Ge + 1 === Ee)
              return Ge * ie;
          } else
            Ge !== -1 && (Ve -= Ve - Ge), Ge = -1;
      } else
        for (A + Ee > le && (A = le - Ee), Ve = A; Ve >= 0; Ve--) {
          let Ge = true;
          for (let Ue = 0; Ue < Ee; Ue++)
            if (Fe(E, Ve + Ue) !== Fe(m, Ue)) {
              Ge = false;
              break;
            }
          if (Ge)
            return Ve;
        }
      return -1;
    }
    a.prototype.includes = function(m, A, M) {
      return this.indexOf(m, A, M) !== -1;
    }, a.prototype.indexOf = function(m, A, M) {
      return L(this, m, A, M, true);
    }, a.prototype.lastIndexOf = function(m, A, M) {
      return L(this, m, A, M, false);
    };
    function j(E, m, A, M) {
      A = Number(A) || 0;
      const Q = E.length - A;
      M ? (M = Number(M), M > Q && (M = Q)) : M = Q;
      const ie = m.length;
      M > ie / 2 && (M = ie / 2);
      let le;
      for (le = 0; le < M; ++le) {
        const Ee = parseInt(m.substr(le * 2, 2), 16);
        if (Se(Ee))
          return le;
        E[A + le] = Ee;
      }
      return le;
    }
    function W(E, m, A, M) {
      return ae(v(m, E.length - A), E, A, M);
    }
    function G(E, m, A, M) {
      return ae(w(m), E, A, M);
    }
    function ee(E, m, A, M) {
      return ae(J(m), E, A, M);
    }
    function fe(E, m, A, M) {
      return ae(D(m, E.length - A), E, A, M);
    }
    a.prototype.write = function(m, A, M, Q) {
      if (A === void 0)
        Q = "utf8", M = this.length, A = 0;
      else if (M === void 0 && typeof A == "string")
        Q = A, M = this.length, A = 0;
      else if (isFinite(A))
        A = A >>> 0, isFinite(M) ? (M = M >>> 0, Q === void 0 && (Q = "utf8")) : (Q = M, M = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const ie = this.length - A;
      if ((M === void 0 || M > ie) && (M = ie), m.length > 0 && (M < 0 || A < 0) || A > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Q || (Q = "utf8");
      let le = false;
      for (; ; )
        switch (Q) {
          case "hex":
            return j(this, m, A, M);
          case "utf8":
          case "utf-8":
            return W(this, m, A, M);
          case "ascii":
          case "latin1":
          case "binary":
            return G(this, m, A, M);
          case "base64":
            return ee(this, m, A, M);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return fe(this, m, A, M);
          default:
            if (le)
              throw new TypeError("Unknown encoding: " + Q);
            Q = ("" + Q).toLowerCase(), le = true;
        }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function P10(E, m, A) {
      return m === 0 && A === E.length ? e.fromByteArray(E) : e.fromByteArray(E.slice(m, A));
    }
    function z10(E, m, A) {
      A = Math.min(E.length, A);
      const M = [];
      let Q = m;
      for (; Q < A; ) {
        const ie = E[Q];
        let le = null, Ee = ie > 239 ? 4 : ie > 223 ? 3 : ie > 191 ? 2 : 1;
        if (Q + Ee <= A) {
          let Fe, Ve, Ge, Ue;
          switch (Ee) {
            case 1:
              ie < 128 && (le = ie);
              break;
            case 2:
              Fe = E[Q + 1], (Fe & 192) === 128 && (Ue = (ie & 31) << 6 | Fe & 63, Ue > 127 && (le = Ue));
              break;
            case 3:
              Fe = E[Q + 1], Ve = E[Q + 2], (Fe & 192) === 128 && (Ve & 192) === 128 && (Ue = (ie & 15) << 12 | (Fe & 63) << 6 | Ve & 63, Ue > 2047 && (Ue < 55296 || Ue > 57343) && (le = Ue));
              break;
            case 4:
              Fe = E[Q + 1], Ve = E[Q + 2], Ge = E[Q + 3], (Fe & 192) === 128 && (Ve & 192) === 128 && (Ge & 192) === 128 && (Ue = (ie & 15) << 18 | (Fe & 63) << 12 | (Ve & 63) << 6 | Ge & 63, Ue > 65535 && Ue < 1114112 && (le = Ue));
          }
        }
        le === null ? (le = 65533, Ee = 1) : le > 65535 && (le -= 65536, M.push(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), M.push(le), Q += Ee;
      }
      return I(M);
    }
    const U = 4096;
    function I(E) {
      const m = E.length;
      if (m <= U)
        return String.fromCharCode.apply(String, E);
      let A = "", M = 0;
      for (; M < m; )
        A += String.fromCharCode.apply(
          String,
          E.slice(M, M += U)
        );
      return A;
    }
    function V(E, m, A) {
      let M = "";
      A = Math.min(E.length, A);
      for (let Q = m; Q < A; ++Q)
        M += String.fromCharCode(E[Q] & 127);
      return M;
    }
    function te(E, m, A) {
      let M = "";
      A = Math.min(E.length, A);
      for (let Q = m; Q < A; ++Q)
        M += String.fromCharCode(E[Q]);
      return M;
    }
    function X(E, m, A) {
      const M = E.length;
      (!m || m < 0) && (m = 0), (!A || A < 0 || A > M) && (A = M);
      let Q = "";
      for (let ie = m; ie < A; ++ie)
        Q += _e[E[ie]];
      return Q;
    }
    function H(E, m, A) {
      const M = E.slice(m, A);
      let Q = "";
      for (let ie = 0; ie < M.length - 1; ie += 2)
        Q += String.fromCharCode(M[ie] + M[ie + 1] * 256);
      return Q;
    }
    a.prototype.slice = function(m, A) {
      const M = this.length;
      m = ~~m, A = A === void 0 ? M : ~~A, m < 0 ? (m += M, m < 0 && (m = 0)) : m > M && (m = M), A < 0 ? (A += M, A < 0 && (A = 0)) : A > M && (A = M), A < m && (A = m);
      const Q = this.subarray(m, A);
      return Object.setPrototypeOf(Q, a.prototype), Q;
    };
    function $(E, m, A) {
      if (E % 1 !== 0 || E < 0)
        throw new RangeError("offset is not uint");
      if (E + m > A)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let Q = this[m], ie = 1, le = 0;
      for (; ++le < A && (ie *= 256); )
        Q += this[m + le] * ie;
      return Q;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let Q = this[m + --A], ie = 1;
      for (; A > 0 && (ie *= 256); )
        Q += this[m + --A] * ie;
      return Q;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(m, A) {
      return m = m >>> 0, A || $(m, 1, this.length), this[m];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(m, A) {
      return m = m >>> 0, A || $(m, 2, this.length), this[m] | this[m + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(m, A) {
      return m = m >>> 0, A || $(m, 2, this.length), this[m] << 8 | this[m + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
    }, a.prototype.readBigUInt64LE = we(function(m) {
      m = m >>> 0, re(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && ne(m, this.length - 8);
      const Q = A + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24, ie = this[++m] + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + M * 2 ** 24;
      return BigInt(Q) + (BigInt(ie) << BigInt(32));
    }), a.prototype.readBigUInt64BE = we(function(m) {
      m = m >>> 0, re(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && ne(m, this.length - 8);
      const Q = A * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m], ie = this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + M;
      return (BigInt(Q) << BigInt(32)) + BigInt(ie);
    }), a.prototype.readIntLE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let Q = this[m], ie = 1, le = 0;
      for (; ++le < A && (ie *= 256); )
        Q += this[m + le] * ie;
      return ie *= 128, Q >= ie && (Q -= Math.pow(2, 8 * A)), Q;
    }, a.prototype.readIntBE = function(m, A, M) {
      m = m >>> 0, A = A >>> 0, M || $(m, A, this.length);
      let Q = A, ie = 1, le = this[m + --Q];
      for (; Q > 0 && (ie *= 256); )
        le += this[m + --Q] * ie;
      return ie *= 128, le >= ie && (le -= Math.pow(2, 8 * A)), le;
    }, a.prototype.readInt8 = function(m, A) {
      return m = m >>> 0, A || $(m, 1, this.length), this[m] & 128 ? (255 - this[m] + 1) * -1 : this[m];
    }, a.prototype.readInt16LE = function(m, A) {
      m = m >>> 0, A || $(m, 2, this.length);
      const M = this[m] | this[m + 1] << 8;
      return M & 32768 ? M | 4294901760 : M;
    }, a.prototype.readInt16BE = function(m, A) {
      m = m >>> 0, A || $(m, 2, this.length);
      const M = this[m + 1] | this[m] << 8;
      return M & 32768 ? M | 4294901760 : M;
    }, a.prototype.readInt32LE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
    }, a.prototype.readInt32BE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
    }, a.prototype.readBigInt64LE = we(function(m) {
      m = m >>> 0, re(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && ne(m, this.length - 8);
      const Q = this[m + 4] + this[m + 5] * 2 ** 8 + this[m + 6] * 2 ** 16 + (M << 24);
      return (BigInt(Q) << BigInt(32)) + BigInt(A + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24);
    }), a.prototype.readBigInt64BE = we(function(m) {
      m = m >>> 0, re(m, "offset");
      const A = this[m], M = this[m + 7];
      (A === void 0 || M === void 0) && ne(m, this.length - 8);
      const Q = (A << 24) + // Overflow
      this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m];
      return (BigInt(Q) << BigInt(32)) + BigInt(this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + M);
    }), a.prototype.readFloatLE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), r.read(this, m, true, 23, 4);
    }, a.prototype.readFloatBE = function(m, A) {
      return m = m >>> 0, A || $(m, 4, this.length), r.read(this, m, false, 23, 4);
    }, a.prototype.readDoubleLE = function(m, A) {
      return m = m >>> 0, A || $(m, 8, this.length), r.read(this, m, true, 52, 8);
    }, a.prototype.readDoubleBE = function(m, A) {
      return m = m >>> 0, A || $(m, 8, this.length), r.read(this, m, false, 52, 8);
    };
    function se(E, m, A, M, Q, ie) {
      if (!a.isBuffer(E))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (m > Q || m < ie)
        throw new RangeError('"value" argument is out of bounds');
      if (A + M > E.length)
        throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(m, A, M, Q) {
      if (m = +m, A = A >>> 0, M = M >>> 0, !Q) {
        const Ee = Math.pow(2, 8 * M) - 1;
        se(this, m, A, M, Ee, 0);
      }
      let ie = 1, le = 0;
      for (this[A] = m & 255; ++le < M && (ie *= 256); )
        this[A + le] = m / ie & 255;
      return A + M;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(m, A, M, Q) {
      if (m = +m, A = A >>> 0, M = M >>> 0, !Q) {
        const Ee = Math.pow(2, 8 * M) - 1;
        se(this, m, A, M, Ee, 0);
      }
      let ie = M - 1, le = 1;
      for (this[A + ie] = m & 255; --ie >= 0 && (le *= 256); )
        this[A + ie] = m / le & 255;
      return A + M;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 1, 255, 0), this[A] = m & 255, A + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 65535, 0), this[A] = m & 255, this[A + 1] = m >>> 8, A + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 65535, 0), this[A] = m >>> 8, this[A + 1] = m & 255, A + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 4294967295, 0), this[A + 3] = m >>> 24, this[A + 2] = m >>> 16, this[A + 1] = m >>> 8, this[A] = m & 255, A + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 4294967295, 0), this[A] = m >>> 24, this[A + 1] = m >>> 16, this[A + 2] = m >>> 8, this[A + 3] = m & 255, A + 4;
    };
    function he(E, m, A, M, Q) {
      k(m, M, Q, E, A, 7);
      let ie = Number(m & BigInt(4294967295));
      E[A++] = ie, ie = ie >> 8, E[A++] = ie, ie = ie >> 8, E[A++] = ie, ie = ie >> 8, E[A++] = ie;
      let le = Number(m >> BigInt(32) & BigInt(4294967295));
      return E[A++] = le, le = le >> 8, E[A++] = le, le = le >> 8, E[A++] = le, le = le >> 8, E[A++] = le, A;
    }
    function pe(E, m, A, M, Q) {
      k(m, M, Q, E, A, 7);
      let ie = Number(m & BigInt(4294967295));
      E[A + 7] = ie, ie = ie >> 8, E[A + 6] = ie, ie = ie >> 8, E[A + 5] = ie, ie = ie >> 8, E[A + 4] = ie;
      let le = Number(m >> BigInt(32) & BigInt(4294967295));
      return E[A + 3] = le, le = le >> 8, E[A + 2] = le, le = le >> 8, E[A + 1] = le, le = le >> 8, E[A] = le, A + 8;
    }
    a.prototype.writeBigUInt64LE = we(function(m, A = 0) {
      return he(this, m, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = we(function(m, A = 0) {
      return pe(this, m, A, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(m, A, M, Q) {
      if (m = +m, A = A >>> 0, !Q) {
        const Fe = Math.pow(2, 8 * M - 1);
        se(this, m, A, M, Fe - 1, -Fe);
      }
      let ie = 0, le = 1, Ee = 0;
      for (this[A] = m & 255; ++ie < M && (le *= 256); )
        m < 0 && Ee === 0 && this[A + ie - 1] !== 0 && (Ee = 1), this[A + ie] = (m / le >> 0) - Ee & 255;
      return A + M;
    }, a.prototype.writeIntBE = function(m, A, M, Q) {
      if (m = +m, A = A >>> 0, !Q) {
        const Fe = Math.pow(2, 8 * M - 1);
        se(this, m, A, M, Fe - 1, -Fe);
      }
      let ie = M - 1, le = 1, Ee = 0;
      for (this[A + ie] = m & 255; --ie >= 0 && (le *= 256); )
        m < 0 && Ee === 0 && this[A + ie + 1] !== 0 && (Ee = 1), this[A + ie] = (m / le >> 0) - Ee & 255;
      return A + M;
    }, a.prototype.writeInt8 = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[A] = m & 255, A + 1;
    }, a.prototype.writeInt16LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 32767, -32768), this[A] = m & 255, this[A + 1] = m >>> 8, A + 2;
    }, a.prototype.writeInt16BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 2, 32767, -32768), this[A] = m >>> 8, this[A + 1] = m & 255, A + 2;
    }, a.prototype.writeInt32LE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 2147483647, -2147483648), this[A] = m & 255, this[A + 1] = m >>> 8, this[A + 2] = m >>> 16, this[A + 3] = m >>> 24, A + 4;
    }, a.prototype.writeInt32BE = function(m, A, M) {
      return m = +m, A = A >>> 0, M || se(this, m, A, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[A] = m >>> 24, this[A + 1] = m >>> 16, this[A + 2] = m >>> 8, this[A + 3] = m & 255, A + 4;
    }, a.prototype.writeBigInt64LE = we(function(m, A = 0) {
      return he(this, m, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = we(function(m, A = 0) {
      return pe(this, m, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function me(E, m, A, M, Q, ie) {
      if (A + M > E.length)
        throw new RangeError("Index out of range");
      if (A < 0)
        throw new RangeError("Index out of range");
    }
    function B(E, m, A, M, Q) {
      return m = +m, A = A >>> 0, Q || me(E, m, A, 4), r.write(E, m, A, M, 23, 4), A + 4;
    }
    a.prototype.writeFloatLE = function(m, A, M) {
      return B(this, m, A, true, M);
    }, a.prototype.writeFloatBE = function(m, A, M) {
      return B(this, m, A, false, M);
    };
    function q(E, m, A, M, Q) {
      return m = +m, A = A >>> 0, Q || me(E, m, A, 8), r.write(E, m, A, M, 52, 8), A + 8;
    }
    a.prototype.writeDoubleLE = function(m, A, M) {
      return q(this, m, A, true, M);
    }, a.prototype.writeDoubleBE = function(m, A, M) {
      return q(this, m, A, false, M);
    }, a.prototype.copy = function(m, A, M, Q) {
      if (!a.isBuffer(m))
        throw new TypeError("argument should be a Buffer");
      if (M || (M = 0), !Q && Q !== 0 && (Q = this.length), A >= m.length && (A = m.length), A || (A = 0), Q > 0 && Q < M && (Q = M), Q === M || m.length === 0 || this.length === 0)
        return 0;
      if (A < 0)
        throw new RangeError("targetStart out of bounds");
      if (M < 0 || M >= this.length)
        throw new RangeError("Index out of range");
      if (Q < 0)
        throw new RangeError("sourceEnd out of bounds");
      Q > this.length && (Q = this.length), m.length - A < Q - M && (Q = m.length - A + M);
      const ie = Q - M;
      return this === m && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, M, Q) : Uint8Array.prototype.set.call(
        m,
        this.subarray(M, Q),
        A
      ), ie;
    }, a.prototype.fill = function(m, A, M, Q) {
      if (typeof m == "string") {
        if (typeof A == "string" ? (Q = A, A = 0, M = this.length) : typeof M == "string" && (Q = M, M = this.length), Q !== void 0 && typeof Q != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Q == "string" && !a.isEncoding(Q))
          throw new TypeError("Unknown encoding: " + Q);
        if (m.length === 1) {
          const le = m.charCodeAt(0);
          (Q === "utf8" && le < 128 || Q === "latin1") && (m = le);
        }
      } else
        typeof m == "number" ? m = m & 255 : typeof m == "boolean" && (m = Number(m));
      if (A < 0 || this.length < A || this.length < M)
        throw new RangeError("Out of range index");
      if (M <= A)
        return this;
      A = A >>> 0, M = M === void 0 ? this.length : M >>> 0, m || (m = 0);
      let ie;
      if (typeof m == "number")
        for (ie = A; ie < M; ++ie)
          this[ie] = m;
      else {
        const le = a.isBuffer(m) ? m : a.from(m, Q), Ee = le.length;
        if (Ee === 0)
          throw new TypeError('The value "' + m + '" is invalid for argument "value"');
        for (ie = 0; ie < M - A; ++ie)
          this[ie + A] = le[ie % Ee];
      }
      return this;
    };
    const Z = {};
    function oe(E, m, A) {
      Z[E] = class extends A {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: m.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${E}]`, this.stack, delete this.name;
        }
        get code() {
          return E;
        }
        set code(Q) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: Q,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${E}]: ${this.message}`;
        }
      };
    }
    oe(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(E) {
        return E ? `${E} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), oe(
      "ERR_INVALID_ARG_TYPE",
      function(E, m) {
        return `The "${E}" argument must be of type number. Received type ${typeof m}`;
      },
      TypeError
    ), oe(
      "ERR_OUT_OF_RANGE",
      function(E, m, A) {
        let M = `The value of "${E}" is out of range.`, Q = A;
        return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? Q = de(String(A)) : typeof A == "bigint" && (Q = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (Q = de(Q)), Q += "n"), M += ` It must be ${m}. Received ${Q}`, M;
      },
      RangeError
    );
    function de(E) {
      let m = "", A = E.length;
      const M = E[0] === "-" ? 1 : 0;
      for (; A >= M + 4; A -= 3)
        m = `_${E.slice(A - 3, A)}${m}`;
      return `${E.slice(0, A)}${m}`;
    }
    function R(E, m, A) {
      re(m, "offset"), (E[m] === void 0 || E[m + A] === void 0) && ne(m, E.length - (A + 1));
    }
    function k(E, m, A, M, Q, ie) {
      if (E > A || E < m) {
        const le = typeof m == "bigint" ? "n" : "";
        let Ee;
        throw m === 0 || m === BigInt(0) ? Ee = `>= 0${le} and < 2${le} ** ${(ie + 1) * 8}${le}` : Ee = `>= -(2${le} ** ${(ie + 1) * 8 - 1}${le}) and < 2 ** ${(ie + 1) * 8 - 1}${le}`, new Z.ERR_OUT_OF_RANGE("value", Ee, E);
      }
      R(M, Q, ie);
    }
    function re(E, m) {
      if (typeof E != "number")
        throw new Z.ERR_INVALID_ARG_TYPE(m, "number", E);
    }
    function ne(E, m, A) {
      throw Math.floor(E) !== E ? (re(E, A), new Z.ERR_OUT_OF_RANGE("offset", "an integer", E)) : m < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${m}`,
        E
      );
    }
    const Ae = /[^+/0-9A-Za-z-_]/g;
    function C(E) {
      if (E = E.split("=")[0], E = E.trim().replace(Ae, ""), E.length < 2)
        return "";
      for (; E.length % 4 !== 0; )
        E = E + "=";
      return E;
    }
    function v(E, m) {
      m = m || 1 / 0;
      let A;
      const M = E.length;
      let Q = null;
      const ie = [];
      for (let le = 0; le < M; ++le) {
        if (A = E.charCodeAt(le), A > 55295 && A < 57344) {
          if (!Q) {
            if (A > 56319) {
              (m -= 3) > -1 && ie.push(239, 191, 189);
              continue;
            } else if (le + 1 === M) {
              (m -= 3) > -1 && ie.push(239, 191, 189);
              continue;
            }
            Q = A;
            continue;
          }
          if (A < 56320) {
            (m -= 3) > -1 && ie.push(239, 191, 189), Q = A;
            continue;
          }
          A = (Q - 55296 << 10 | A - 56320) + 65536;
        } else
          Q && (m -= 3) > -1 && ie.push(239, 191, 189);
        if (Q = null, A < 128) {
          if ((m -= 1) < 0)
            break;
          ie.push(A);
        } else if (A < 2048) {
          if ((m -= 2) < 0)
            break;
          ie.push(
            A >> 6 | 192,
            A & 63 | 128
          );
        } else if (A < 65536) {
          if ((m -= 3) < 0)
            break;
          ie.push(
            A >> 12 | 224,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else if (A < 1114112) {
          if ((m -= 4) < 0)
            break;
          ie.push(
            A >> 18 | 240,
            A >> 12 & 63 | 128,
            A >> 6 & 63 | 128,
            A & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ie;
    }
    function w(E) {
      const m = [];
      for (let A = 0; A < E.length; ++A)
        m.push(E.charCodeAt(A) & 255);
      return m;
    }
    function D(E, m) {
      let A, M, Q;
      const ie = [];
      for (let le = 0; le < E.length && !((m -= 2) < 0); ++le)
        A = E.charCodeAt(le), M = A >> 8, Q = A % 256, ie.push(Q), ie.push(M);
      return ie;
    }
    function J(E) {
      return e.toByteArray(C(E));
    }
    function ae(E, m, A, M) {
      let Q;
      for (Q = 0; Q < M && !(Q + A >= m.length || Q >= E.length); ++Q)
        m[Q + A] = E[Q];
      return Q;
    }
    function ue(E, m) {
      return E instanceof m || E != null && E.constructor != null && E.constructor.name != null && E.constructor.name === m.name;
    }
    function Se(E) {
      return E !== E;
    }
    const _e = function() {
      const E = "0123456789abcdef", m = new Array(256);
      for (let A = 0; A < 16; ++A) {
        const M = A * 16;
        for (let Q = 0; Q < 16; ++Q)
          m[M + Q] = E[A] + E[Q];
      }
      return m;
    }();
    function we(E) {
      return typeof BigInt > "u" ? Ne : E;
    }
    function Ne() {
      throw new Error("BigInt not supported");
    }
  })(L0);
  /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  const ab = na("simple-peer"), B0 = ay, td = _c, lb = oa, Nl = ib, Be = sb, { Buffer: cb } = L0, Ll = 64 * 1024, ub = 5 * 1e3, fb = 5 * 1e3;
  function rd(t10) {
    return t10.replace(/a=ice-options:trickle\s\n/g, "");
  }
  function db(t10) {
    console.warn(t10);
  }
  class zn extends lb.Duplex {
    constructor(e) {
      if (e = Object.assign({
        allowHalfOpen: false
      }, e), super(e), this._id = td(4).toString("hex").slice(0, 7), this._debug("new peer %o", e), this.channelName = e.initiator ? e.channelName || td(20).toString("hex") : null, this.initiator = e.initiator || false, this.channelConfig = e.channelConfig || zn.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, zn.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || ((r) => r), this.streams = e.streams || (e.stream ? [e.stream] : []), this.trickle = e.trickle !== void 0 ? e.trickle : true, this.allowHalfTrickle = e.allowHalfTrickle !== void 0 ? e.allowHalfTrickle : false, this.iceCompleteTimeout = e.iceCompleteTimeout || ub, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e.wrtc && typeof e.wrtc == "object" ? e.wrtc : B0(), !this._wrtc)
        throw Be(typeof window > "u" ? new Error("No WebRTC support: Specify `opts.wrtc` option in this environment") : new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
      try {
        this._pc = new this._wrtc.RTCPeerConnection(this.config);
      } catch (r) {
        this.destroy(Be(r, "ERR_PC_CONSTRUCTOR"));
        return;
      }
      this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => {
        this._onIceStateChange();
      }, this._pc.onicegatheringstatechange = () => {
        this._onIceStateChange();
      }, this._pc.onconnectionstatechange = () => {
        this._onConnectionStateChange();
      }, this._pc.onsignalingstatechange = () => {
        this._onSignalingStateChange();
      }, this._pc.onicecandidate = (r) => {
        this._onIceCandidate(r);
      }, typeof this._pc.peerIdentity == "object" && this._pc.peerIdentity.catch((r) => {
        this.destroy(Be(r, "ERR_PC_PEER_IDENTITY"));
      }), this.initiator || this.channelNegotiated ? this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      }) : this._pc.ondatachannel = (r) => {
        this._setupData(r);
      }, this.streams && this.streams.forEach((r) => {
        this.addStream(r);
      }), this._pc.ontrack = (r) => {
        this._onTrack(r);
      }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
        this._onFinish();
      }, this.once("finish", this._onFinishBound);
    }
    get bufferSize() {
      return this._channel && this._channel.bufferedAmount || 0;
    }
    // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    get connected() {
      return this._connected && this._channel.readyState === "open";
    }
    address() {
      return { port: this.localPort, family: this.localFamily, address: this.localAddress };
    }
    signal(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
        if (typeof e == "string")
          try {
            e = JSON.parse(e);
          } catch {
            e = {};
          }
        this._debug("signal()"), e.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then(() => {
          this.destroyed || (this._pendingCandidates.forEach((r) => {
            this._addIceCandidate(r);
          }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer());
        }).catch((r) => {
          this.destroy(Be(r, "ERR_SET_REMOTE_DESCRIPTION"));
        }), !e.sdp && !e.candidate && !e.renegotiate && !e.transceiverRequest && this.destroy(Be(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
      }
    }
    _addIceCandidate(e) {
      const r = new this._wrtc.RTCIceCandidate(e);
      this._pc.addIceCandidate(r).catch((n) => {
        !r.address || r.address.endsWith(".local") ? db("Ignoring unsupported ICE candidate.") : this.destroy(Be(n, "ERR_ADD_ICE_CANDIDATE"));
      });
    }
    /**
     * Send text/binary data to the remote peer.
     * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
     */
    send(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
        this._channel.send(e);
      }
    }
    /**
     * Add a Transceiver to the connection.
     * @param {String} kind
     * @param {Object} init
     */
    addTransceiver(e, r) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
        if (this._debug("addTransceiver()"), this.initiator)
          try {
            this._pc.addTransceiver(e, r), this._needsNegotiation();
          } catch (n) {
            this.destroy(Be(n, "ERR_ADD_TRANSCEIVER"));
          }
        else
          this.emit("signal", {
            // request initiator to renegotiate
            type: "transceiverRequest",
            transceiverRequest: { kind: e, init: r }
          });
      }
    }
    /**
     * Add a MediaStream to the connection.
     * @param {MediaStream} stream
     */
    addStream(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addStream()"), e.getTracks().forEach((r) => {
          this.addTrack(r, e);
        });
      }
    }
    /**
     * Add a MediaStreamTrack to the connection.
     * @param {MediaStreamTrack} track
     * @param {MediaStream} stream
     */
    addTrack(e, r) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Be(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("addTrack()");
      const n = this._senderMap.get(e) || /* @__PURE__ */ new Map();
      let i = n.get(r);
      if (!i)
        i = this._pc.addTrack(e, r), n.set(r, i), this._senderMap.set(e, n), this._needsNegotiation();
      else
        throw i.removed ? Be(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED") : Be(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
    /**
     * Replace a MediaStreamTrack by another in the connection.
     * @param {MediaStreamTrack} oldTrack
     * @param {MediaStreamTrack} newTrack
     * @param {MediaStream} stream
     */
    replaceTrack(e, r, n) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Be(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("replaceTrack()");
      const i = this._senderMap.get(e), o = i ? i.get(n) : null;
      if (!o)
        throw Be(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
      r && this._senderMap.set(r, i), o.replaceTrack != null ? o.replaceTrack(r) : this.destroy(Be(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
    /**
     * Remove a MediaStreamTrack from the connection.
     * @param {MediaStreamTrack} track
     * @param {MediaStream} stream
     */
    removeTrack(e, r) {
      if (this.destroying)
        return;
      if (this.destroyed)
        throw Be(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
      this._debug("removeSender()");
      const n = this._senderMap.get(e), i = n ? n.get(r) : null;
      if (!i)
        throw Be(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
      try {
        i.removed = true, this._pc.removeTrack(i);
      } catch (o) {
        o.name === "NS_ERROR_UNEXPECTED" ? this._sendersAwaitingStable.push(i) : this.destroy(Be(o, "ERR_REMOVE_TRACK"));
      }
      this._needsNegotiation();
    }
    /**
     * Remove a MediaStream from the connection.
     * @param {MediaStream} stream
     */
    removeStream(e) {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSenders()"), e.getTracks().forEach((r) => {
          this.removeTrack(r, e);
        });
      }
    }
    _needsNegotiation() {
      this._debug("_needsNegotiation"), !this._batchedNegotiation && (this._batchedNegotiation = true, Nl(() => {
        this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
      }));
    }
    negotiate() {
      if (!this.destroying) {
        if (this.destroyed)
          throw Be(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
        this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
          this._createOffer();
        }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", {
          // request initiator to renegotiate
          type: "renegotiate",
          renegotiate: true
        })), this._isNegotiating = true;
      }
    }
    // TODO: Delete this method once readable-stream is updated to contain a default
    // implementation of destroy() that automatically calls _destroy()
    // See: https://github.com/nodejs/readable-stream/issues/283
    destroy(e) {
      this._destroy(e, () => {
      });
    }
    _destroy(e, r) {
      this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e && (e.message || e)), Nl(() => {
        if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e && (e.message || e)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
          try {
            this._channel.close();
          } catch {
          }
          this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
        }
        if (this._pc) {
          try {
            this._pc.close();
          } catch {
          }
          this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
        }
        this._pc = null, this._channel = null, e && this.emit("error", e), this.emit("close"), r();
      }));
    }
    _setupData(e) {
      if (!e.channel)
        return this.destroy(Be(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
      this._channel = e.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = Ll), this.channelName = this._channel.label, this._channel.onmessage = (n) => {
        this._onChannelMessage(n);
      }, this._channel.onbufferedamountlow = () => {
        this._onChannelBufferedAmountLow();
      }, this._channel.onopen = () => {
        this._onChannelOpen();
      }, this._channel.onclose = () => {
        this._onChannelClose();
      }, this._channel.onerror = (n) => {
        const i = n.error instanceof Error ? n.error : new Error(`Datachannel error: ${n.message} ${n.filename}:${n.lineno}:${n.colno}`);
        this.destroy(Be(i, "ERR_DATA_CHANNEL"));
      };
      let r = false;
      this._closingInterval = setInterval(() => {
        this._channel && this._channel.readyState === "closing" ? (r && this._onChannelClose(), r = true) : r = false;
      }, fb);
    }
    _read() {
    }
    _write(e, r, n) {
      if (this.destroyed)
        return n(Be(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
      if (this._connected) {
        try {
          this.send(e);
        } catch (i) {
          return this.destroy(Be(i, "ERR_DATA_CHANNEL"));
        }
        this._channel.bufferedAmount > Ll ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n) : n(null);
      } else
        this._debug("write before connect"), this._chunk = e, this._cb = n;
    }
    // When stream finishes writing, close socket. Half open connections are not
    // supported.
    _onFinish() {
      if (this.destroyed)
        return;
      const e = () => {
        setTimeout(() => this.destroy(), 1e3);
      };
      this._connected ? e() : this.once("connect", e);
    }
    _startIceCompleteTimeout() {
      this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
        this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
      }, this.iceCompleteTimeout));
    }
    _createOffer() {
      this.destroyed || this._pc.createOffer(this.offerOptions).then((e) => {
        if (this.destroyed)
          return;
        !this.trickle && !this.allowHalfTrickle && (e.sdp = rd(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
        const r = () => {
          if (this.destroyed)
            return;
          const o = this._pc.localDescription || e;
          this._debug("signal"), this.emit("signal", {
            type: o.type,
            sdp: o.sdp
          });
        }, n = () => {
          this._debug("createOffer success"), !this.destroyed && (this.trickle || this._iceComplete ? r() : this.once("_iceComplete", r));
        }, i = (o) => {
          this.destroy(Be(o, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(e).then(n).catch(i);
      }).catch((e) => {
        this.destroy(Be(e, "ERR_CREATE_OFFER"));
      });
    }
    _requestMissingTransceivers() {
      this._pc.getTransceivers && this._pc.getTransceivers().forEach((e) => {
        !e.mid && e.sender.track && !e.requested && (e.requested = true, this.addTransceiver(e.sender.track.kind));
      });
    }
    _createAnswer() {
      this.destroyed || this._pc.createAnswer(this.answerOptions).then((e) => {
        if (this.destroyed)
          return;
        !this.trickle && !this.allowHalfTrickle && (e.sdp = rd(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
        const r = () => {
          if (this.destroyed)
            return;
          const o = this._pc.localDescription || e;
          this._debug("signal"), this.emit("signal", {
            type: o.type,
            sdp: o.sdp
          }), this.initiator || this._requestMissingTransceivers();
        }, n = () => {
          this.destroyed || (this.trickle || this._iceComplete ? r() : this.once("_iceComplete", r));
        }, i = (o) => {
          this.destroy(Be(o, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(e).then(n).catch(i);
      }).catch((e) => {
        this.destroy(Be(e, "ERR_CREATE_ANSWER"));
      });
    }
    _onConnectionStateChange() {
      this.destroyed || this._pc.connectionState === "failed" && this.destroy(Be(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
    _onIceStateChange() {
      if (this.destroyed)
        return;
      const e = this._pc.iceConnectionState, r = this._pc.iceGatheringState;
      this._debug(
        "iceStateChange (connection: %s) (gathering: %s)",
        e,
        r
      ), this.emit("iceStateChange", e, r), (e === "connected" || e === "completed") && (this._pcReady = true, this._maybeReady()), e === "failed" && this.destroy(Be(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), e === "closed" && this.destroy(Be(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
    getStats(e) {
      const r = (n) => (Object.prototype.toString.call(n.values) === "[object Array]" && n.values.forEach((i) => {
        Object.assign(n, i);
      }), n);
      this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then((n) => {
        const i = [];
        n.forEach((o) => {
          i.push(r(o));
        }), e(null, i);
      }, (n) => e(n)) : this._pc.getStats.length > 0 ? this._pc.getStats((n) => {
        if (this.destroyed)
          return;
        const i = [];
        n.result().forEach((o) => {
          const s = {};
          o.names().forEach((a) => {
            s[a] = o.stat(a);
          }), s.id = o.id, s.type = o.type, s.timestamp = o.timestamp, i.push(r(s));
        }), e(null, i);
      }, (n) => e(n)) : e(null, []);
    }
    _maybeReady() {
      if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
        return;
      this._connecting = true;
      const e = () => {
        this.destroyed || this.getStats((r, n) => {
          if (this.destroyed)
            return;
          r && (n = []);
          const i = {}, o = {}, s = {};
          let a = false;
          n.forEach((c) => {
            (c.type === "remotecandidate" || c.type === "remote-candidate") && (i[c.id] = c), (c.type === "localcandidate" || c.type === "local-candidate") && (o[c.id] = c), (c.type === "candidatepair" || c.type === "candidate-pair") && (s[c.id] = c);
          });
          const l = (c) => {
            a = true;
            let u = o[c.localCandidateId];
            u && (u.ip || u.address) ? (this.localAddress = u.ip || u.address, this.localPort = Number(u.port)) : u && u.ipAddress ? (this.localAddress = u.ipAddress, this.localPort = Number(u.portNumber)) : typeof c.googLocalAddress == "string" && (u = c.googLocalAddress.split(":"), this.localAddress = u[0], this.localPort = Number(u[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
            let f = i[c.remoteCandidateId];
            f && (f.ip || f.address) ? (this.remoteAddress = f.ip || f.address, this.remotePort = Number(f.port)) : f && f.ipAddress ? (this.remoteAddress = f.ipAddress, this.remotePort = Number(f.portNumber)) : typeof c.googRemoteAddress == "string" && (f = c.googRemoteAddress.split(":"), this.remoteAddress = f[0], this.remotePort = Number(f[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug(
              "connect local: %s:%s remote: %s:%s",
              this.localAddress,
              this.localPort,
              this.remoteAddress,
              this.remotePort
            );
          };
          if (n.forEach((c) => {
            c.type === "transport" && c.selectedCandidatePairId && l(s[c.selectedCandidatePairId]), (c.type === "googCandidatePair" && c.googActiveConnection === "true" || (c.type === "candidatepair" || c.type === "candidate-pair") && c.selected) && l(c);
          }), !a && (!Object.keys(s).length || Object.keys(o).length)) {
            setTimeout(e, 100);
            return;
          } else
            this._connecting = false, this._connected = true;
          if (this._chunk) {
            try {
              this.send(this._chunk);
            } catch (u) {
              return this.destroy(Be(u, "ERR_DATA_CHANNEL"));
            }
            this._chunk = null, this._debug('sent chunk from "write before connect"');
            const c = this._cb;
            this._cb = null, c(null);
          }
          typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
        });
      };
      e();
    }
    _onInterval() {
      !this._cb || !this._channel || this._channel.bufferedAmount > Ll || this._onChannelBufferedAmountLow();
    }
    _onSignalingStateChange() {
      this.destroyed || (this._pc.signalingState === "stable" && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e) => {
        this._pc.removeTrack(e), this._queuedNegotiation = true;
      }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
    }
    _onIceCandidate(e) {
      this.destroyed || (e.candidate && this.trickle ? this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: e.candidate.candidate,
          sdpMLineIndex: e.candidate.sdpMLineIndex,
          sdpMid: e.candidate.sdpMid
        }
      }) : !e.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout());
    }
    _onChannelMessage(e) {
      if (this.destroyed)
        return;
      let r = e.data;
      r instanceof ArrayBuffer && (r = cb.from(r)), this.push(r);
    }
    _onChannelBufferedAmountLow() {
      if (this.destroyed || !this._cb)
        return;
      this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
      const e = this._cb;
      this._cb = null, e(null);
    }
    _onChannelOpen() {
      this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
    }
    _onChannelClose() {
      this.destroyed || (this._debug("on channel close"), this.destroy());
    }
    _onTrack(e) {
      this.destroyed || e.streams.forEach((r) => {
        this._debug("on track"), this.emit("track", e.track, r), this._remoteTracks.push({
          track: e.track,
          stream: r
        }), !this._remoteStreams.some((n) => n.id === r.id) && (this._remoteStreams.push(r), Nl(() => {
          this._debug("on stream"), this.emit("stream", r);
        }));
      });
    }
    _debug() {
      const e = [].slice.call(arguments);
      e[0] = "[" + this._id + "] " + e[0], ab.apply(null, e);
    }
  }
  zn.WEBRTC_SUPPORT = !!B0();
  zn.config = {
    iceServers: [
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:globalThis.stun.twilio.com:3478"
        ]
      }
    ],
    sdpSemantics: "unified-plan"
  };
  zn.channelConfig = {};
  var nd = zn;
  function Ce() {
    localStorage.getItem("debug") === "true" && console.log(...arguments);
  }
  typeof window < "u" && (window.process = {
    ...window.process,
    nextTick: function(t10, e, r, n) {
      setTimeout(() => {
        t10(e, r, n);
      }, 0);
    }
  }, window.process.env = window.process.env || {});
  function hb(t10) {
    t10 = t10.replace(/#/g, "");
    var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    t10 = t10.replace(e, function(n, i, o, s) {
      return i + i + o + o + s + s;
    });
    var r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t10);
    return r ? {
      r: parseInt(r[1], 16),
      g: parseInt(r[2], 16),
      b: parseInt(r[3], 16),
      hexString: `#${t10}`,
      hex: parseInt(r[1], 16) << 16 | parseInt(r[2], 16) << 8 | parseInt(r[3], 16)
    } : null;
  }
  class pb extends gu {
    constructor({
      websocketSend: e,
      id: r,
      myId: n,
      isRenderServer: i,
      isRenderServerOrHostIfNotCasting: o,
      playerIsSpectator: s,
      playerIsProxy: a,
      broadcastUnreliable: l,
      setPlayerState: c,
      getBootDate: u,
      avatarList: f,
      kickPlayer: d,
      state: h = {},
      defaultPlayerState: g = {}
    }) {
      super(), this.websocketSend = e, this.broadcastUnreliable = l, this.setPlayerState = c, this.myId = n, this._kickPlayerTrigger = d, this.id = r, this.avatarList = f, this.syncIntervalTime = p0.SyncIntervalTime, this.isRenderServer = i, this.isRenderServerOrHostIfNotCasting = o, this.playerIsSpectator = s, this.playerIsProxy = a, this.state = h, this.defaultPlayerState = g, this.iUpdatedStateAt = {}, this.playerIsProxy && (this.state.__proxyBy = n), this.getBootDate = u, this.stateKeyUpdateOrder = {}, this.inputState = {}, this.peer = null, this.webrtcConnected = false, this.webrtcRetryCount = 0, this.controllerLegacy = false, this.heartbeatInterval = 0, this.retryWebRtcTimeout = 0, this.isDestroyed = false, this.timeDiffFromServer = 0, this.bot = void 0, this.on("input_broadcast", (p) => {
        !o() && !s && this.send({ pinput: p });
      });
    }
    send(e, r, n) {
      if (this.webrtcConnected && !r && !this.playerIsProxy)
        try {
          Ce(
            "sending unreliable",
            e,
            r,
            "webrtcConnected",
            this.webrtcConnected
          ), this.peer.send(JSON.stringify(e));
        } catch (i) {
          Ce(i);
        }
      else
        !r && this.isRenderServerOrHostIfNotCasting() && !n ? this.broadcastUnreliable(e) : this.playerIsProxy || (this.isRenderServerOrHostIfNotCasting() && (e.for = this.id), Ce(
          "sending reliable",
          e,
          r,
          "webrtcConnected",
          this.webrtcConnected
        ), this.websocketSend(JSON.stringify(e)));
    }
    startWebrtc() {
      if (this.retryWebRtcTimeout && (clearTimeout(this.retryWebRtcTimeout), this.retryWebRtcTimeout = 0), this.peer && this.peer.destroy(), !this.isRenderServerOrHostIfNotCasting() && this.myId === this.id) {
        Ce("webrtc::connecting", "not render server, isMyId");
        try {
          this.peer = new nd({ initiator: true, objectMode: true });
        } catch (e) {
          Ce(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
          return;
        }
        this.peer.on("signal", (e) => {
          Ce("got signal", e), this.send({ signal: e }, true);
        }), this.peer.on("connect", () => {
          this.webrtcConnected = true, this.webrtcRetryCount = 0, this.emit("webrtc_connected"), clearTimeout(this.retryWebRtcTimeout);
        }), this.peer.on("data", (e) => {
          e = JSON.parse(e), Ce("webrtc::host says:", e), e.ping ? (this.timeDiffFromServer = e.ping - Date.now(), this.send({ pong: e.ping })) : e.pstate ? this.setPlayerState(e) : e.gstate && this.emit("global_state_unreliable", e.gstate);
        }), this.peer.on("stream", (e) => {
          this.emit("stream", e);
        }), this.peer.on("close", () => {
          Ce(this._idToHuman(), "::webrtc:", "connection closed"), this.webrtcConnected = false, this.retryWebRtcTimeout = setTimeout(() => {
            !this.isDestroyed && this.webrtcRetryCount < 5 && (this.startWebrtc(), this.webrtcRetryCount++);
          }, 3e3);
        }), this.peer.on("error", (e) => {
          Ce(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
        });
      } else if (this.isRenderServerOrHostIfNotCasting() && this.myId !== this.id) {
        Ce("webrtc::connecting", "is render server, notMyId"), clearInterval(this.heartbeatInterval), this.heartbeatInterval = setInterval(() => {
          this.send({
            ping: Date.now()
          });
        }, 5e3);
        try {
          this.peer = new nd({ objectMode: true });
        } catch (e) {
          Ce(this._idToHuman(), "::webrtc:", "connection error", e), this.webrtcConnected = false;
          return;
        }
        this.peer.on("signal", (e) => {
          Ce("got signal", e), this.send({ for: this.id, signal: e }, true);
        }), this.peer.on("connect", () => {
          Ce("connected to player via webrtc"), this.webrtcConnected = true, this.send({ ping: Date.now() }), this.emit("webrtc_connected");
        }), this.peer.on("data", (e) => {
          Ce(this._idToHuman(), "::webrtc:", e), e = JSON.parse(e), e.pinput ? this.handleInput(e.pinput) : e.pstate ? this.setState(e.d[0], e.d[1]) : e.pong && this.handlePingResponse(e);
        }), this.peer.on("close", () => {
          this.webrtcConnected = false, Ce(this._idToHuman(), "::webrtc:", "connection closed");
        }), this.peer.on("error", (e) => {
          this.webrtcConnected = false, Ce(this._idToHuman(), "::webrtc:", "connection error", e);
        });
      }
    }
    _idToHuman() {
      return `${this.playerIsSpectator ? "spectator" : "player"}(${this.id})`;
    }
    signal(e) {
      this.peer.destroyed && this.isRenderServerOrHostIfNotCasting() && this.startWebrtc();
      try {
        Ce("signaling", e), this.peer.signal(e);
      } catch (r) {
        Ce(r);
      }
    }
    handlePingResponse(e) {
      var r = Date.now() - e.pong;
      this.emit("ping", r);
    }
    // used for local players
    attachControllerLegacy(e) {
      this.detachControllerLegacy(), this.controllerLegacy = e, this.controllerLegacy.on("keydown", this.handleKeyDown.bind(this)), this.controllerLegacy.on("keyup", this.handleKeyUp.bind(this)), this.controllerLegacy.on("dpad", this.handleDpad.bind(this)), this.controllerLegacy.on("gyro", this.handleGyro.bind(this));
    }
    detachControllerLegacy() {
      if (this.controllerLegacy) {
        const e = this.controllerLegacy;
        return this.controllerLegacy.off("keydown", this.handleKeyDown), this.controllerLegacy.off("keyup", this.handleKeyUp), this.controllerLegacy.off("dpad", this.handleDpad), this.controllerLegacy.off("gyro", this.handleGyro), delete this.controllerLegacy, e;
      }
    }
    onKeyPress(e, r) {
      this.on("keypress", (n) => {
        n.key === e && r(n);
      });
    }
    onKeyUp(e, r) {
      this.on("keyup", (n) => {
        n.key === e && r(n);
      });
    }
    onKeyDown(e, r) {
      this.on("keydown", (n) => {
        n.key === e && r(n);
      });
    }
    onQuit(e) {
      return this.on("quit", e);
    }
    handleKeyDown(e) {
      this.handleInput({ keydown: e });
    }
    handleKeyUp(e) {
      this.handleInput({ keyup: e });
    }
    handleDpad(e) {
      this.handleInput({ dpad: e });
    }
    handleGyro(e) {
      this.handleInput({ gyro: e });
    }
    // handle the input, pass it to subscribers (usually the game logic which will use this to move players in engine)
    handleInput(e, r) {
      let n = false;
      Object.keys(e).forEach((i) => {
        const o = e[i];
        i === "keydown" && !this.inputState[o] && (this.inputState[o] = true, this.emit("keydown", { key: o }), this.emit("keypress", { key: o }), n = true), i === "keyup" && this.inputState[o] && (delete this.inputState[o], this.emit("keyup", { key: o }), n = true), i === "dpad" && (this.inputState.dpad = e.dpad, n = true), i === "gyro" && (this.inputState.gyro = e.gyro, n = true);
      }), n && (Ce("inputEmit", e), this.emit("input", e), r || this.emit("input_broadcast", e));
    }
    isKeyDown(e) {
      return this.inputState[e];
    }
    on(e, r, n) {
      return e === "profile" && r(this.state.profile), e === "webrtc_connected" && this.webrtcConnected && r(), super.on(e, r, n);
    }
    getState(e) {
      return e ? typeof this.state[e] == "object" ? JSON.parse(JSON.stringify(this.state[e])) : this.state[e] : this.state;
    }
    // public method to change state object (used by host only or to change my own state). This is then synced with all clients.
    setState(e, r, n) {
      JSON.stringify(this.state[e]) !== JSON.stringify(r) && (this.setLocalState(e, r), this.iUpdatedStateAt[e] = Date.now(), this.isRenderServerOrHostIfNotCasting() && !n ? this.broadcastUnreliable({
        pstate: this.id,
        d: [e, r],
        o: Date.now() - this.getBootDate()
      }) : this.send(
        {
          pstate: this.id,
          d: [e, r],
          o: Date.now() - this.getBootDate() - this.timeDiffFromServer
        },
        n
      ));
    }
    setFullDefaultLocalState(e) {
      Object.keys(e).forEach((r) => {
        this.setDefaultLocalState(r, e[r]);
      });
    }
    // get default player state
    getDefaultState(e) {
      return e ? typeof this.defaultPlayerState[e] == "object" ? JSON.parse(JSON.stringify(this.defaultPlayerState[e])) : this.defaultPlayerState[e] : this.defaultPlayerState;
    }
    /**
     * store default player states. This will come in handy when we reset the player states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      const n = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r;
      this.setDefaultLocalState(e, n) && this.send(
        {
          default_pstate: this.id,
          d: [e, n],
          o: Date.now() - this.getBootDate() - this.timeDiffFromServer
        },
        true
      );
    }
    setDefaultLocalState(e, r) {
      if (JSON.stringify(this.defaultPlayerState[e]) !== JSON.stringify(r))
        return this.defaultPlayerState[e] = r, true;
    }
    getProfile() {
      let e = this.getState("profile") || { color: "#ffffff", name: "" };
      return e && e.color && (e = { ...e, color: hb(e.color) }), this.avatarList && this.avatarList.length > 0 && (e.avatarIndex = this.avatarList.indexOf(e.photo)), e.avatarIndex === void 0 && (e.avatarIndex = -1), e;
    }
    setRoundState(e, r, n) {
      this.setState(`round.${e}`, r, n);
    }
    getRoundState(e) {
      if (e)
        return this.getState(`round.${e}`);
      {
        let r = {};
        return Object.keys(this.getState()).forEach((n) => {
          n.startsWith("round.") && (r[n.substring(6)] = this.getState(n));
        }), r;
      }
    }
    resetRoundState() {
      Object.keys(this.getState()).forEach((e) => {
        e.startsWith("round.") && this.setState(e, void 0);
      });
    }
    setFullLocalState(e, r) {
      Object.keys(e).forEach((n) => {
        (!this.iUpdatedStateAt[n] || this.iUpdatedStateAt[n] + this.syncIntervalTime < Date.now()) && this.setLocalState(n, e[n], r);
      }), Object.keys(this.state).forEach((n) => {
        var i;
        (!this.iUpdatedStateAt[n] || this.iUpdatedStateAt[n] + this.syncIntervalTime < Date.now()) && e[n] === void 0 && (Ce("set default states for the playerState", this.state[n]), this.setLocalState(n, (i = this.defaultPlayerState) == null ? void 0 : i[n], r));
      });
    }
    // just change local state without broadcasting
    // updateOrder: since we have two channels the state can come from,
    // we keep order in mind and only update if it's latest from host
    setLocalState(e, r, n) {
      if (n && this.stateKeyUpdateOrder[e] && this.stateKeyUpdateOrder[e] > n)
        return;
      this.stateKeyUpdateOrder[e] = n || 0;
      const i = JSON.stringify(r);
      var o = false;
      JSON.stringify(this.state[e]) !== i && (o = true);
      const s = typeof r == "object" ? JSON.parse(i) : r;
      return this.state[e] = s, o && (this.emit("state", e, s), e === "profile" && this.emit("profile", s)), o;
    }
    kick() {
      return new Promise((e, r) => {
        if (!this.isRenderServerOrHostIfNotCasting()) {
          r("Only the host can kick a player.");
          return;
        }
        this._kickPlayerTrigger(this.id, e);
      });
    }
    disconnect(e) {
      Ce("[PlayerState] disconnecting with eventCode:", e), this.detachControllerLegacy(), clearInterval(this.heartbeatInterval), this.isDestroyed = true, this.peer && this.peer.destroy(), this.emit("quit", this);
    }
    isBot() {
      return this.state.__bot;
    }
    isProxyPlayer() {
      return this.state.__proxyBy;
    }
  }
  typeof window < "u" && (window.__TEMPSTORAGE__ = {});
  function gb(t10, e) {
    var r;
    window._USETEMPSTORAGE ? window.__TEMPSTORAGE__[t10] = e : (r = window._PLAYROOM_CONFIG) != null && r.sessionStorage ? sessionStorage.setItem(t10, e) : localStorage.setItem(t10, e);
  }
  function mb(t10) {
    var e;
    return window._USETEMPSTORAGE ? window.__TEMPSTORAGE__[t10] : (e = window._PLAYROOM_CONFIG) != null && e.sessionStorage ? sessionStorage.getItem(t10) : localStorage.getItem(t10);
  }
  const xt = {
    set: gb,
    get: mb
  };
  let ja = (t10 = 21) => crypto.getRandomValues(new Uint8Array(t10)).reduce((e, r) => (r &= 63, r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r > 62 ? e += "-" : e += "_", e), "");
  function F0() {
    const t10 = localStorage.getItem("permId") || ja(32);
    return localStorage.setItem("permId", t10), t10;
  }
  function yb() {
    const t10 = xt.get("myId") || ja(12);
    return xt.set("myId", t10), t10;
  }
  function Bl(t10) {
    return new Promise((e) => setTimeout(e, t10));
  }
  function bb(t10, e) {
    return new Promise((r, n) => {
      if (t10.getState(e) !== void 0)
        r();
      else {
        const i = t10.on(
          "state",
          (o, s) => {
            o === e && (i(), r());
          },
          true
        );
      }
    });
  }
  function iE(t10, e) {
    const r = Ie();
    return new Promise((n, i) => {
      const o = (l) => {
        e && e(l), n(l);
      };
      let s = r.getState(t10);
      s && o(s);
      const a = r.on("state", (l, c) => {
        c === t10 && l[c] && (a(), o(l[c]));
      });
    });
  }
  function oE(t10, e, r) {
    return new Promise((n) => {
      const i = (a) => {
        r && r(a), n(a);
      };
      let o = t10.getState(e);
      o && i(o);
      const s = t10.on("state", (a, l) => {
        a === e && l && (s(), i(l));
      });
    });
  }
  var j0 = {}, W0 = {};
  Object.defineProperty(W0, "__esModule", { value: true });
  var U0 = {};
  (function(t10) {
    Object.defineProperty(t10, "__esModule", { value: true }), t10.createArrayPatch = t10.createObjectPatch = t10.createPatch = void 0;
    const e = (s) => (s instanceof Object && typeof s.toJSON == "function" && (s = s.toJSON()), typeof s == "function" ? s = void 0 : typeof s == "number" && (s !== s || s === 1 / 0 || s === -1 / 0) && (s = null), s), r = (s, a) => (s = e(s), a = e(a), n(s, a));
    t10.createPatch = r;
    const n = (s, a) => {
      if (s === void 0 && (s = null), a === void 0 && (a = null), s === a)
        return "none";
      if (typeof s == "object" && s !== null && (typeof a == "object" && a !== null)) {
        const u = Array.isArray(s), f = Array.isArray(a);
        if (u && f)
          return (0, t10.createArrayPatch)(s, a);
        if (!u && !f)
          return (0, t10.createObjectPatch)(s, a);
      }
      return "reset";
    }, i = (s, a) => {
      const l = [], c = {}, u = {};
      let f = 0, d = 0, h = 0;
      for (const p in s) {
        const y = e(s[p]);
        if (y === void 0)
          continue;
        f += 1;
        const b = e(a[p]);
        if (b === void 0) {
          l.push(p);
          continue;
        }
        const x = n(y, b);
        x === "reset" ? (c[p] = b, d += 1) : x !== "none" && (u[p] = x, h += 1);
      }
      if (f && l.length + d === f)
        return "reset";
      for (const p in a) {
        const y = e(a[p]);
        if (y === void 0)
          continue;
        if (f === 0)
          return "reset";
        e(s[p]) === void 0 && (c[p] = y, d += 1);
      }
      const g = { t: "o" };
      return l.length && (g.r = l), d && (g.s = c), h && (g.p = u), !g.r && !g.s && !g.p ? "none" : g;
    };
    t10.createObjectPatch = i;
    const o = (s, a) => {
      const l = s.length, c = a.length;
      let u, f, d, h, g;
      for (h = 0; h < l && h < c; h += 1) {
        const V = e(s[h]), te = e(a[h]);
        if (g = n(V, te), g !== "none")
          break;
      }
      if (h === l)
        return h === c ? "none" : { t: "a", s: [[
          l,
          0,
          ...a.slice(h, c).map(e)
        ]] };
      if (h === c)
        return { t: "a", s: [[h, l - h]] };
      let p = l - 1, y = c - 1, b;
      for (; p >= h && y >= h && (u = e(s[p]), f = e(a[y]), b = n(u, f), b === "none"); )
        p -= 1, y -= 1;
      if (p < h)
        return { t: "a", s: [[
          h,
          0,
          ...a.slice(h, y + 1).map(e)
        ]] };
      if (y < h)
        return { t: "a", s: [[h, p - h + 1]] };
      const x = p - h + 1, S = y - h + 1, O = x * S, _ = x + 1, L = new Array(O);
      L[0] = g, L[O - 1] = b;
      let N, j, W, G, ee, fe;
      N = { 1: 0 };
      e:
        for (j = 0; j < O; j++)
          for (N = Object.create(N), W = -j; W <= j; W += 2) {
            for (W === -j || W !== j && N[W - 1] < N[W + 1] ? G = N[W + 1] : G = N[W - 1] + 1, ee = G - W, d = ee * x + G; d < O && G < x && ee < S && (fe = L[d], fe || (u = e(s[h + G]), f = e(a[h + ee]), fe = L[d] = n(u, f)), fe !== "reset"); )
              G++, ee++, d += _;
            if (N[W] = G, G >= x && ee >= S)
              break e;
          }
      let P10 = false;
      const z10 = {}, U = [];
      if (j === O) {
        if (h === 0 && x === l)
          return "reset";
        U.push([h, x, ...a.slice(h, y + 1)]);
      } else {
        W = x - S;
        let V = [NaN, NaN];
        for (; j-- >= 0; ) {
          const te = N[W - 1] === void 0 || N[W + 1] !== void 0 && N[W - 1] < N[W + 1];
          W = te ? W + 1 : W - 1, G = N[W], ee = G - W;
          const X = h + G;
          for (te ? (ee !== -1 && (V[0] === X ? (f = e(a[h + ee]), V.splice(2, 0, f)) : U.push(V = [X, 0, a[h + ee]])), ee++) : (ee !== -1 && (V[0] === X + 1 ? (V[0] -= 1, V[1] += 1) : U.push(V = [X, 1])), G++), d = ee * x + G; d < O && G < x && ee < S && (fe = L[d], fe !== "reset"); )
            fe !== "none" && (z10[h + G] = fe, P10 = true), G++, ee++, d += _;
          N = Object.getPrototypeOf(N);
        }
      }
      const I = { t: "a" };
      return P10 && (I.p = z10), U.length && (I.s = U), I;
    };
    t10.createArrayPatch = o;
  })(U0);
  var ln$1 = {};
  Object.defineProperty(ln$1, "__esModule", { value: true });
  ln$1.applyArrayPatch = ln$1.applyObjectPatch = ln$1.applyPatch = void 0;
  function z0(t10 = false) {
    const e = (i, o) => {
      if (o.t === "o")
        return r(i, o);
      if (o.t === "a")
        return n(i, o);
      throw Error("Invalid patch");
    }, r = (i, o) => {
      let s = t10 ? i : Object.assign({}, i);
      const a = o.r;
      if (a)
        for (const u of a)
          delete s[u];
      const l = o.s;
      if (l)
        for (const u in l)
          s[u] = l[u];
      const c = o.p;
      if (c)
        for (const u in c)
          s[u] = e(s[u], c[u]);
      return s;
    }, n = (i, o) => {
      const s = t10 ? i : [...i], a = o.p;
      if (a)
        for (const c in a)
          s[c] = e(s[c], a[c]);
      const l = o.s;
      if (l)
        for (let c of l)
          s.splice(...c);
      return s;
    };
    return { applyPatch: e, applyObjectPatch: r, applyArrayPatch: n };
  }
  const yu = z0(), bu = z0(true);
  ln$1.applyPatch = Object.assign(yu.applyPatch, {
    /**
     * Variant that modifies the target value in-place.
     */
    inPlace: bu.applyPatch
  });
  ln$1.applyObjectPatch = Object.assign(yu.applyObjectPatch, {
    /**
     * Variant that modifies the target object in-place.
     */
    inPlace: bu.applyObjectPatch
  });
  ln$1.applyArrayPatch = Object.assign(yu.applyArrayPatch, {
    /**
     * Variant that modifies the target array in-place.
     */
    inPlace: bu.applyArrayPatch
  });
  (function(t10) {
    var e = fs && fs.__createBinding || (Object.create ? function(n, i, o, s) {
      s === void 0 && (s = o);
      var a = Object.getOwnPropertyDescriptor(i, o);
      (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
        return i[o];
      } }), Object.defineProperty(n, s, a);
    } : function(n, i, o, s) {
      s === void 0 && (s = o), n[s] = i[o];
    }), r = fs && fs.__exportStar || function(n, i) {
      for (var o in n)
        o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && e(i, n, o);
    };
    Object.defineProperty(t10, "__esModule", { value: true }), r(W0, t10), r(U0, t10), r(ln$1, t10);
  })(j0);
  var cn = {
    DEBUG: false,
    LIB_VERSION: "2.45.0"
  }, Dt;
  if (typeof window > "u") {
    var id = {
      hostname: ""
    };
    Dt = {
      navigator: { userAgent: "" },
      document: {
        location: id,
        referrer: ""
      },
      screen: { width: 0, height: 0 },
      location: id
    };
  } else
    Dt = window;
  var Wa = Array.prototype, vb = Function.prototype, V0 = Object.prototype, en = Wa.slice, Ko = V0.toString, Ua = V0.hasOwnProperty, yt = Dt.console, Br = Dt.navigator, rt = Dt.document, zi = Dt.opera, sa = Dt.screen, ur = Br.userAgent, Fl = vb.bind, od = Wa.forEach, sd = Wa.indexOf, ad = Wa.map, Ab = Array.isArray, Ec = {}, T = {
    trim: function(t10) {
      return t10.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
  }, et = {
    /** @type {function(...*)} */
    log: function() {
      if (cn.DEBUG && !T.isUndefined(yt) && yt)
        try {
          yt.log.apply(yt, arguments);
        } catch {
          T.each(arguments, function(e) {
            yt.log(e);
          });
        }
    },
    /** @type {function(...*)} */
    warn: function() {
      if (cn.DEBUG && !T.isUndefined(yt) && yt) {
        var t10 = ["Mixpanel warning:"].concat(T.toArray(arguments));
        try {
          yt.warn.apply(yt, t10);
        } catch {
          T.each(t10, function(r) {
            yt.warn(r);
          });
        }
      }
    },
    /** @type {function(...*)} */
    error: function() {
      if (cn.DEBUG && !T.isUndefined(yt) && yt) {
        var t10 = ["Mixpanel error:"].concat(T.toArray(arguments));
        try {
          yt.error.apply(yt, t10);
        } catch {
          T.each(t10, function(r) {
            yt.error(r);
          });
        }
      }
    },
    /** @type {function(...*)} */
    critical: function() {
      if (!T.isUndefined(yt) && yt) {
        var t10 = ["Mixpanel error:"].concat(T.toArray(arguments));
        try {
          yt.error.apply(yt, t10);
        } catch {
          T.each(t10, function(r) {
            yt.error(r);
          });
        }
      }
    }
  }, jl = function(t10, e) {
    return function() {
      return arguments[0] = "[" + e + "] " + arguments[0], t10.apply(et, arguments);
    };
  }, vu = function(t10) {
    return {
      log: jl(et.log, t10),
      error: jl(et.error, t10),
      critical: jl(et.critical, t10)
    };
  };
  T.bind = function(t10, e) {
    var r, n;
    if (Fl && t10.bind === Fl)
      return Fl.apply(t10, en.call(arguments, 1));
    if (!T.isFunction(t10))
      throw new TypeError();
    return r = en.call(arguments, 2), n = function() {
      if (!(this instanceof n))
        return t10.apply(e, r.concat(en.call(arguments)));
      var i = {};
      i.prototype = t10.prototype;
      var o = new i();
      i.prototype = null;
      var s = t10.apply(o, r.concat(en.call(arguments)));
      return Object(s) === s ? s : o;
    }, n;
  };
  T.each = function(t10, e, r) {
    if (t10 != null) {
      if (od && t10.forEach === od)
        t10.forEach(e, r);
      else if (t10.length === +t10.length) {
        for (var n = 0, i = t10.length; n < i; n++)
          if (n in t10 && e.call(r, t10[n], n, t10) === Ec)
            return;
      } else
        for (var o in t10)
          if (Ua.call(t10, o) && e.call(r, t10[o], o, t10) === Ec)
            return;
    }
  };
  T.extend = function(t10) {
    return T.each(en.call(arguments, 1), function(e) {
      for (var r in e)
        e[r] !== void 0 && (t10[r] = e[r]);
    }), t10;
  };
  T.isArray = Ab || function(t10) {
    return Ko.call(t10) === "[object Array]";
  };
  T.isFunction = function(t10) {
    try {
      return /^\s*\bfunction\b/.test(t10);
    } catch {
      return false;
    }
  };
  T.isArguments = function(t10) {
    return !!(t10 && Ua.call(t10, "callee"));
  };
  T.toArray = function(t10) {
    return t10 ? t10.toArray ? t10.toArray() : T.isArray(t10) || T.isArguments(t10) ? en.call(t10) : T.values(t10) : [];
  };
  T.map = function(t10, e, r) {
    if (ad && t10.map === ad)
      return t10.map(e, r);
    var n = [];
    return T.each(t10, function(i) {
      n.push(e.call(r, i));
    }), n;
  };
  T.keys = function(t10) {
    var e = [];
    return t10 === null || T.each(t10, function(r, n) {
      e[e.length] = n;
    }), e;
  };
  T.values = function(t10) {
    var e = [];
    return t10 === null || T.each(t10, function(r) {
      e[e.length] = r;
    }), e;
  };
  T.include = function(t10, e) {
    var r = false;
    return t10 === null ? r : sd && t10.indexOf === sd ? t10.indexOf(e) != -1 : (T.each(t10, function(n) {
      if (r || (r = n === e))
        return Ec;
    }), r);
  };
  T.includes = function(t10, e) {
    return t10.indexOf(e) !== -1;
  };
  T.inherit = function(t10, e) {
    return t10.prototype = new e(), t10.prototype.constructor = t10, t10.superclass = e.prototype, t10;
  };
  T.isObject = function(t10) {
    return t10 === Object(t10) && !T.isArray(t10);
  };
  T.isEmptyObject = function(t10) {
    if (T.isObject(t10)) {
      for (var e in t10)
        if (Ua.call(t10, e))
          return false;
      return true;
    }
    return false;
  };
  T.isUndefined = function(t10) {
    return t10 === void 0;
  };
  T.isString = function(t10) {
    return Ko.call(t10) == "[object String]";
  };
  T.isDate = function(t10) {
    return Ko.call(t10) == "[object Date]";
  };
  T.isNumber = function(t10) {
    return Ko.call(t10) == "[object Number]";
  };
  T.isElement = function(t10) {
    return !!(t10 && t10.nodeType === 1);
  };
  T.encodeDates = function(t10) {
    return T.each(t10, function(e, r) {
      T.isDate(e) ? t10[r] = T.formatDate(e) : T.isObject(e) && (t10[r] = T.encodeDates(e));
    }), t10;
  };
  T.timestamp = function() {
    return Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    }, Date.now();
  };
  T.formatDate = function(t10) {
    function e(r) {
      return r < 10 ? "0" + r : r;
    }
    return t10.getUTCFullYear() + "-" + e(t10.getUTCMonth() + 1) + "-" + e(t10.getUTCDate()) + "T" + e(t10.getUTCHours()) + ":" + e(t10.getUTCMinutes()) + ":" + e(t10.getUTCSeconds());
  };
  T.strip_empty_properties = function(t10) {
    var e = {};
    return T.each(t10, function(r, n) {
      T.isString(r) && r.length > 0 && (e[n] = r);
    }), e;
  };
  T.truncate = function(t10, e) {
    var r;
    return typeof t10 == "string" ? r = t10.slice(0, e) : T.isArray(t10) ? (r = [], T.each(t10, function(n) {
      r.push(T.truncate(n, e));
    })) : T.isObject(t10) ? (r = {}, T.each(t10, function(n, i) {
      r[i] = T.truncate(n, e);
    })) : r = t10, r;
  };
  T.JSONEncode = /* @__PURE__ */ function() {
    return function(t10) {
      var e = t10, r = function(i) {
        var o = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, s = {
          // table of character substitutions
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        };
        return o.lastIndex = 0, o.test(i) ? '"' + i.replace(o, function(a) {
          var l = s[a];
          return typeof l == "string" ? l : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + i + '"';
      }, n = function(i, o) {
        var s = "", a = "    ", l = 0, c = "", u = "", f = 0, d = s, h = [], g = o[i];
        switch (g && typeof g == "object" && typeof g.toJSON == "function" && (g = g.toJSON(i)), typeof g) {
          case "string":
            return r(g);
          case "number":
            return isFinite(g) ? String(g) : "null";
          case "boolean":
          case "null":
            return String(g);
          case "object":
            if (!g)
              return "null";
            if (s += a, h = [], Ko.apply(g) === "[object Array]") {
              for (f = g.length, l = 0; l < f; l += 1)
                h[l] = n(l, g) || "null";
              return u = h.length === 0 ? "[]" : s ? `[
` + s + h.join(`,
` + s) + `
` + d + "]" : "[" + h.join(",") + "]", s = d, u;
            }
            for (c in g)
              Ua.call(g, c) && (u = n(c, g), u && h.push(r(c) + (s ? ": " : ":") + u));
            return u = h.length === 0 ? "{}" : s ? "{" + h.join(",") + d + "}" : "{" + h.join(",") + "}", s = d, u;
        }
      };
      return n("", {
        "": e
      });
    };
  }();
  T.JSONDecode = function() {
    var t10, e, r = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "	"
    }, n, i = function(h) {
      var g = new SyntaxError(h);
      throw g.at = t10, g.text = n, g;
    }, o = function(h) {
      return h && h !== e && i("Expected '" + h + "' instead of '" + e + "'"), e = n.charAt(t10), t10 += 1, e;
    }, s = function() {
      var h, g = "";
      for (e === "-" && (g = "-", o("-")); e >= "0" && e <= "9"; )
        g += e, o();
      if (e === ".")
        for (g += "."; o() && e >= "0" && e <= "9"; )
          g += e;
      if (e === "e" || e === "E")
        for (g += e, o(), (e === "-" || e === "+") && (g += e, o()); e >= "0" && e <= "9"; )
          g += e, o();
      if (h = +g, !isFinite(h))
        i("Bad number");
      else
        return h;
    }, a = function() {
      var h, g, p = "", y;
      if (e === '"')
        for (; o(); ) {
          if (e === '"')
            return o(), p;
          if (e === "\\")
            if (o(), e === "u") {
              for (y = 0, g = 0; g < 4 && (h = parseInt(o(), 16), !!isFinite(h)); g += 1)
                y = y * 16 + h;
              p += String.fromCharCode(y);
            } else if (typeof r[e] == "string")
              p += r[e];
            else
              break;
          else
            p += e;
        }
      i("Bad string");
    }, l = function() {
      for (; e && e <= " "; )
        o();
    }, c = function() {
      switch (e) {
        case "t":
          return o("t"), o("r"), o("u"), o("e"), true;
        case "f":
          return o("f"), o("a"), o("l"), o("s"), o("e"), false;
        case "n":
          return o("n"), o("u"), o("l"), o("l"), null;
      }
      i('Unexpected "' + e + '"');
    }, u, f = function() {
      var h = [];
      if (e === "[") {
        if (o("["), l(), e === "]")
          return o("]"), h;
        for (; e; ) {
          if (h.push(u()), l(), e === "]")
            return o("]"), h;
          o(","), l();
        }
      }
      i("Bad array");
    }, d = function() {
      var h, g = {};
      if (e === "{") {
        if (o("{"), l(), e === "}")
          return o("}"), g;
        for (; e; ) {
          if (h = a(), l(), o(":"), Object.hasOwnProperty.call(g, h) && i('Duplicate key "' + h + '"'), g[h] = u(), l(), e === "}")
            return o("}"), g;
          o(","), l();
        }
      }
      i("Bad object");
    };
    return u = function() {
      switch (l(), e) {
        case "{":
          return d();
        case "[":
          return f();
        case '"':
          return a();
        case "-":
          return s();
        default:
          return e >= "0" && e <= "9" ? s() : c();
      }
    }, function(h) {
      var g;
      return n = h, t10 = 0, e = " ", g = u(), l(), e && i("Syntax error"), g;
    };
  }();
  T.base64Encode = function(t10) {
    var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", r, n, i, o, s, a, l, c, u = 0, f = 0, d = "", h = [];
    if (!t10)
      return t10;
    t10 = T.utf8Encode(t10);
    do
      r = t10.charCodeAt(u++), n = t10.charCodeAt(u++), i = t10.charCodeAt(u++), c = r << 16 | n << 8 | i, o = c >> 18 & 63, s = c >> 12 & 63, a = c >> 6 & 63, l = c & 63, h[f++] = e.charAt(o) + e.charAt(s) + e.charAt(a) + e.charAt(l);
    while (u < t10.length);
    switch (d = h.join(""), t10.length % 3) {
      case 1:
        d = d.slice(0, -2) + "==";
        break;
      case 2:
        d = d.slice(0, -1) + "=";
        break;
    }
    return d;
  };
  T.utf8Encode = function(t10) {
    t10 = (t10 + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`);
    var e = "", r, n, i = 0, o;
    for (r = n = 0, i = t10.length, o = 0; o < i; o++) {
      var s = t10.charCodeAt(o), a = null;
      s < 128 ? n++ : s > 127 && s < 2048 ? a = String.fromCharCode(s >> 6 | 192, s & 63 | 128) : a = String.fromCharCode(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128), a !== null && (n > r && (e += t10.substring(r, n)), e += a, r = n = o + 1);
    }
    return n > r && (e += t10.substring(r, t10.length)), e;
  };
  T.UUID = /* @__PURE__ */ function() {
    var t10 = function() {
      for (var n = 1 * /* @__PURE__ */ new Date(), i = 0; n == 1 * /* @__PURE__ */ new Date(); )
        i++;
      return n.toString(16) + i.toString(16);
    }, e = function() {
      return Math.random().toString(16).replace(".", "");
    }, r = function() {
      var n = ur, i, o, s = [], a = 0;
      function l(c, u) {
        var f, d = 0;
        for (f = 0; f < u.length; f++)
          d |= s[f] << f * 8;
        return c ^ d;
      }
      for (i = 0; i < n.length; i++)
        o = n.charCodeAt(i), s.unshift(o & 255), s.length >= 4 && (a = l(a, s), s = []);
      return s.length > 0 && (a = l(a, s)), a.toString(16);
    };
    return function() {
      var n = (sa.height * sa.width).toString(16);
      return t10() + "-" + e() + "-" + r() + "-" + n + "-" + t10();
    };
  }();
  var ld = [
    "ahrefsbot",
    "baiduspider",
    "bingbot",
    "bingpreview",
    "facebookexternal",
    "petalbot",
    "pinterest",
    "screaming frog",
    "yahoo! slurp",
    "yandexbot",
    // a whole bunch of goog-specific crawlers
    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers
    "adsbot-google",
    "apis-google",
    "duplexweb-google",
    "feedfetcher-google",
    "google favicon",
    "google web preview",
    "google-read-aloud",
    "googlebot",
    "googleweblight",
    "mediapartners-google",
    "storebot-google"
  ];
  T.isBlockedUA = function(t10) {
    var e;
    for (t10 = t10.toLowerCase(), e = 0; e < ld.length; e++)
      if (t10.indexOf(ld[e]) !== -1)
        return true;
    return false;
  };
  T.HTTPBuildQuery = function(t10, e) {
    var r, n, i = [];
    return T.isUndefined(e) && (e = "&"), T.each(t10, function(o, s) {
      r = encodeURIComponent(o.toString()), n = encodeURIComponent(s), i[i.length] = n + "=" + r;
    }), i.join(e);
  };
  T.getQueryParam = function(t10, e) {
    e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
    var r = "[\\?&]" + e + "=([^&#]*)", n = new RegExp(r), i = n.exec(t10);
    if (i === null || i && typeof i[1] != "string" && i[1].length)
      return "";
    var o = i[1];
    try {
      o = decodeURIComponent(o);
    } catch {
      et.error("Skipping decoding for malformed query param: " + o);
    }
    return o.replace(/\+/g, " ");
  };
  T.cookie = {
    get: function(t10) {
      for (var e = t10 + "=", r = rt.cookie.split(";"), n = 0; n < r.length; n++) {
        for (var i = r[n]; i.charAt(0) == " "; )
          i = i.substring(1, i.length);
        if (i.indexOf(e) === 0)
          return decodeURIComponent(i.substring(e.length, i.length));
      }
      return null;
    },
    parse: function(t10) {
      var e;
      try {
        e = T.JSONDecode(T.cookie.get(t10)) || {};
      } catch {
      }
      return e;
    },
    set_seconds: function(t10, e, r, n, i, o, s) {
      var a = "", l = "", c = "";
      if (s)
        a = "; domain=" + s;
      else if (n) {
        var u = cd(rt.location.hostname);
        a = u ? "; domain=." + u : "";
      }
      if (r) {
        var f = /* @__PURE__ */ new Date();
        f.setTime(f.getTime() + r * 1e3), l = "; expires=" + f.toGMTString();
      }
      o && (i = true, c = "; SameSite=None"), i && (c += "; secure"), rt.cookie = t10 + "=" + encodeURIComponent(e) + l + "; path=/" + a + c;
    },
    set: function(t10, e, r, n, i, o, s) {
      var a = "", l = "", c = "";
      if (s)
        a = "; domain=" + s;
      else if (n) {
        var u = cd(rt.location.hostname);
        a = u ? "; domain=." + u : "";
      }
      if (r) {
        var f = /* @__PURE__ */ new Date();
        f.setTime(f.getTime() + r * 24 * 60 * 60 * 1e3), l = "; expires=" + f.toGMTString();
      }
      o && (i = true, c = "; SameSite=None"), i && (c += "; secure");
      var d = t10 + "=" + encodeURIComponent(e) + l + "; path=/" + a + c;
      return rt.cookie = d, d;
    },
    remove: function(t10, e, r) {
      T.cookie.set(t10, "", -1, e, false, false, r);
    }
  };
  var Wl = null, aa = function(t10, e) {
    if (Wl !== null && !e)
      return Wl;
    var r = true;
    try {
      t10 = t10 || window.localStorage;
      var n = "__mplss_" + Au(8), i = "xyz";
      t10.setItem(n, i), t10.getItem(n) !== i && (r = false), t10.removeItem(n);
    } catch {
      r = false;
    }
    return Wl = r, r;
  };
  T.localStorage = {
    is_supported: function(t10) {
      var e = aa(null, t10);
      return e || et.error("localStorage unsupported; falling back to cookie store"), e;
    },
    error: function(t10) {
      et.error("localStorage error: " + t10);
    },
    get: function(t10) {
      try {
        return window.localStorage.getItem(t10);
      } catch (e) {
        T.localStorage.error(e);
      }
      return null;
    },
    parse: function(t10) {
      try {
        return T.JSONDecode(T.localStorage.get(t10)) || {};
      } catch {
      }
      return null;
    },
    set: function(t10, e) {
      try {
        window.localStorage.setItem(t10, e);
      } catch (r) {
        T.localStorage.error(r);
      }
    },
    remove: function(t10) {
      try {
        window.localStorage.removeItem(t10);
      } catch (e) {
        T.localStorage.error(e);
      }
    }
  };
  T.register_event = function() {
    var t10 = function(n, i, o, s, a) {
      if (!n) {
        et.error("No valid element provided to register_event");
        return;
      }
      if (n.addEventListener && !s)
        n.addEventListener(i, o, !!a);
      else {
        var l = "on" + i, c = n[l];
        n[l] = e(n, o, c);
      }
    };
    function e(n, i, o) {
      var s = function(a) {
        if (a = a || r(window.event), !!a) {
          var l = true, c, u;
          return T.isFunction(o) && (c = o(a)), u = i.call(n, a), (c === false || u === false) && (l = false), l;
        }
      };
      return s;
    }
    function r(n) {
      return n && (n.preventDefault = r.preventDefault, n.stopPropagation = r.stopPropagation), n;
    }
    return r.preventDefault = function() {
      this.returnValue = false;
    }, r.stopPropagation = function() {
      this.cancelBubble = true;
    }, t10;
  }();
  var wb = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
  T.dom_query = /* @__PURE__ */ function() {
    function t10(i) {
      return i.all ? i.all : i.getElementsByTagName("*");
    }
    var e = /[\t\r\n]/g;
    function r(i, o) {
      var s = " " + o + " ";
      return (" " + i.className + " ").replace(e, " ").indexOf(s) >= 0;
    }
    function n(i) {
      if (!rt.getElementsByTagName)
        return [];
      var o = i.split(" "), s, a, l, c, u, f, d, h, g, p, y = [rt];
      for (f = 0; f < o.length; f++) {
        if (s = o[f].replace(/^\s+/, "").replace(/\s+$/, ""), s.indexOf("#") > -1) {
          a = s.split("#"), l = a[0];
          var b = a[1], x = rt.getElementById(b);
          if (!x || l && x.nodeName.toLowerCase() != l)
            return [];
          y = [x];
          continue;
        }
        if (s.indexOf(".") > -1) {
          a = s.split("."), l = a[0];
          var S = a[1];
          for (l || (l = "*"), c = [], u = 0, d = 0; d < y.length; d++)
            for (l == "*" ? g = t10(y[d]) : g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
              c[u++] = g[h];
          for (y = [], p = 0, d = 0; d < c.length; d++)
            c[d].className && T.isString(c[d].className) && // some SVG elements have classNames which are not strings
            r(c[d], S) && (y[p++] = c[d]);
          continue;
        }
        var O = s.match(wb);
        if (O) {
          l = O[1];
          var _ = O[2], L = O[3], N = O[4];
          for (l || (l = "*"), c = [], u = 0, d = 0; d < y.length; d++)
            for (l == "*" ? g = t10(y[d]) : g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
              c[u++] = g[h];
          y = [], p = 0;
          var j;
          switch (L) {
            case "=":
              j = function(W) {
                return W.getAttribute(_) == N;
              };
              break;
            case "~":
              j = function(W) {
                return W.getAttribute(_).match(new RegExp("\\b" + N + "\\b"));
              };
              break;
            case "|":
              j = function(W) {
                return W.getAttribute(_).match(new RegExp("^" + N + "-?"));
              };
              break;
            case "^":
              j = function(W) {
                return W.getAttribute(_).indexOf(N) === 0;
              };
              break;
            case "$":
              j = function(W) {
                return W.getAttribute(_).lastIndexOf(N) == W.getAttribute(_).length - N.length;
              };
              break;
            case "*":
              j = function(W) {
                return W.getAttribute(_).indexOf(N) > -1;
              };
              break;
            default:
              j = function(W) {
                return W.getAttribute(_);
              };
          }
          for (y = [], p = 0, d = 0; d < c.length; d++)
            j(c[d]) && (y[p++] = c[d]);
          continue;
        }
        for (l = s, c = [], u = 0, d = 0; d < y.length; d++)
          for (g = y[d].getElementsByTagName(l), h = 0; h < g.length; h++)
            c[u++] = g[h];
        y = c;
      }
      return y;
    }
    return function(i) {
      return T.isElement(i) ? [i] : T.isObject(i) && !T.isUndefined(i.length) ? i : n.call(this, i);
    };
  }();
  T.info = {
    campaignParams: function() {
      var t10 = "utm_source utm_medium utm_campaign utm_content utm_term".split(" "), e = "", r = {};
      return T.each(t10, function(n) {
        e = T.getQueryParam(rt.URL, n), e.length && (r[n] = e);
      }), r;
    },
    searchEngine: function(t10) {
      return t10.search("https?://(.*)google.([^/?]*)") === 0 ? "google" : t10.search("https?://(.*)bing.com") === 0 ? "bing" : t10.search("https?://(.*)yahoo.com") === 0 ? "yahoo" : t10.search("https?://(.*)duckduckgo.com") === 0 ? "duckduckgo" : null;
    },
    searchInfo: function(t10) {
      var e = T.info.searchEngine(t10), r = e != "yahoo" ? "q" : "p", n = {};
      if (e !== null) {
        n.$search_engine = e;
        var i = T.getQueryParam(t10, r);
        i.length && (n.mp_keyword = i);
      }
      return n;
    },
    /**
     * This function detects which browser is running this script.
     * The order of the checks are important since many user agents
     * include key words used in later checks.
     */
    browser: function(t10, e, r) {
      return e = e || "", r || T.includes(t10, " OPR/") ? T.includes(t10, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : T.includes(t10, "IEMobile") || T.includes(t10, "WPDesktop") ? "Internet Explorer Mobile" : T.includes(t10, "SamsungBrowser/") ? "Samsung Internet" : T.includes(t10, "Edge") || T.includes(t10, "Edg/") ? "Microsoft Edge" : T.includes(t10, "FBIOS") ? "Facebook Mobile" : T.includes(t10, "Chrome") ? "Chrome" : T.includes(t10, "CriOS") ? "Chrome iOS" : T.includes(t10, "UCWEB") || T.includes(t10, "UCBrowser") ? "UC Browser" : T.includes(t10, "FxiOS") ? "Firefox iOS" : T.includes(e, "Apple") ? T.includes(t10, "Mobile") ? "Mobile Safari" : "Safari" : T.includes(t10, "Android") ? "Android Mobile" : T.includes(t10, "Konqueror") ? "Konqueror" : T.includes(t10, "Firefox") ? "Firefox" : T.includes(t10, "MSIE") || T.includes(t10, "Trident/") ? "Internet Explorer" : T.includes(t10, "Gecko") ? "Mozilla" : "";
    },
    /**
     * This function detects which browser version is running this script,
     * parsing major and minor version (e.g., 42.1). User agent strings from:
     * http://www.useragentstring.com/pages/useragentstring.php
     */
    browserVersion: function(t10, e, r) {
      var n = T.info.browser(t10, e, r), i = {
        "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
        "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
        Chrome: /Chrome\/(\d+(\.\d+)?)/,
        "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
        "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
        Safari: /Version\/(\d+(\.\d+)?)/,
        "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
        Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
        Firefox: /Firefox\/(\d+(\.\d+)?)/,
        "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
        Konqueror: /Konqueror:(\d+(\.\d+)?)/,
        BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
        "Android Mobile": /android\s(\d+(\.\d+)?)/,
        "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
        "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
        Mozilla: /rv:(\d+(\.\d+)?)/
      }, o = i[n];
      if (o === void 0)
        return null;
      var s = t10.match(o);
      return s ? parseFloat(s[s.length - 2]) : null;
    },
    os: function() {
      var t10 = ur;
      return /Windows/i.test(t10) ? /Phone/.test(t10) || /WPDesktop/.test(t10) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t10) ? "iOS" : /Android/.test(t10) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : /Mac/i.test(t10) ? "Mac OS X" : /Linux/.test(t10) ? "Linux" : /CrOS/.test(t10) ? "Chrome OS" : "";
    },
    device: function(t10) {
      return /Windows Phone/i.test(t10) || /WPDesktop/.test(t10) ? "Windows Phone" : /iPad/.test(t10) ? "iPad" : /iPod/.test(t10) ? "iPod Touch" : /iPhone/.test(t10) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(t10) ? "BlackBerry" : /Android/.test(t10) ? "Android" : "";
    },
    referringDomain: function(t10) {
      var e = t10.split("/");
      return e.length >= 3 ? e[2] : "";
    },
    properties: function() {
      return T.extend(T.strip_empty_properties({
        $os: T.info.os(),
        $browser: T.info.browser(ur, Br.vendor, zi),
        $referrer: rt.referrer,
        $referring_domain: T.info.referringDomain(rt.referrer),
        $device: T.info.device(ur)
      }), {
        $current_url: Dt.location.href,
        $browser_version: T.info.browserVersion(ur, Br.vendor, zi),
        $screen_height: sa.height,
        $screen_width: sa.width,
        mp_lib: "web",
        $lib_version: cn.LIB_VERSION,
        $insert_id: Au(),
        time: T.timestamp() / 1e3
        // epoch time in seconds
      });
    },
    people_properties: function() {
      return T.extend(T.strip_empty_properties({
        $os: T.info.os(),
        $browser: T.info.browser(ur, Br.vendor, zi)
      }), {
        $browser_version: T.info.browserVersion(ur, Br.vendor, zi)
      });
    },
    pageviewInfo: function(t10) {
      return T.strip_empty_properties({
        mp_page: t10,
        mp_referrer: rt.referrer,
        mp_browser: T.info.browser(ur, Br.vendor, zi),
        mp_platform: T.info.os()
      });
    }
  };
  var Au = function(t10) {
    var e = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
    return t10 ? e.substring(0, t10) : e;
  }, xb = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i, _b = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i, cd = function(t10) {
    var e = _b, r = t10.split("."), n = r[r.length - 1];
    (n.length > 4 || n === "com" || n === "org") && (e = xb);
    var i = t10.match(e);
    return i ? i[0] : "";
  }, la = null, ca = null;
  typeof JSON < "u" && (la = JSON.stringify, ca = JSON.parse);
  la = la || T.JSONEncode;
  ca = ca || T.JSONDecode;
  T.toArray = T.toArray;
  T.isObject = T.isObject;
  T.JSONEncode = T.JSONEncode;
  T.JSONDecode = T.JSONDecode;
  T.isBlockedUA = T.isBlockedUA;
  T.isEmptyObject = T.isEmptyObject;
  T.info = T.info;
  T.info.device = T.info.device;
  T.info.browser = T.info.browser;
  T.info.browserVersion = T.info.browserVersion;
  T.info.properties = T.info.properties;
  var Xr = function() {
  };
  Xr.prototype.create_properties = function() {
  };
  Xr.prototype.event_handler = function() {
  };
  Xr.prototype.after_track_handler = function() {
  };
  Xr.prototype.init = function(t10) {
    return this.mp = t10, this;
  };
  Xr.prototype.track = function(t10, e, r, n) {
    var i = this, o = T.dom_query(t10);
    if (o.length === 0) {
      et.error("The DOM query (" + t10 + ") returned 0 elements");
      return;
    }
    return T.each(o, function(s) {
      T.register_event(s, this.override_event, function(a) {
        var l = {}, c = i.create_properties(r, this), u = i.mp.get_config("track_links_timeout");
        i.event_handler(a, this, l), window.setTimeout(i.track_callback(n, c, l, true), u), i.mp.track(e, c, i.track_callback(n, c, l));
      });
    }, this), true;
  };
  Xr.prototype.track_callback = function(t10, e, r, n) {
    n = n || false;
    var i = this;
    return function() {
      r.callback_fired || (r.callback_fired = true, !(t10 && t10(n, e) === false) && i.after_track_handler(e, r, n));
    };
  };
  Xr.prototype.create_properties = function(t10, e) {
    var r;
    return typeof t10 == "function" ? r = t10(e) : r = T.extend({}, t10), r;
  };
  var _i = function() {
    this.override_event = "click";
  };
  T.inherit(_i, Xr);
  _i.prototype.create_properties = function(t10, e) {
    var r = _i.superclass.create_properties.apply(this, arguments);
    return e.href && (r.url = e.href), r;
  };
  _i.prototype.event_handler = function(t10, e, r) {
    r.new_tab = t10.which === 2 || t10.metaKey || t10.ctrlKey || e.target === "_blank", r.href = e.href, r.new_tab || t10.preventDefault();
  };
  _i.prototype.after_track_handler = function(t10, e) {
    e.new_tab || setTimeout(function() {
      window.location = e.href;
    }, 0);
  };
  var za = function() {
    this.override_event = "submit";
  };
  T.inherit(za, Xr);
  za.prototype.event_handler = function(t10, e, r) {
    r.element = e, t10.preventDefault();
  };
  za.prototype.after_track_handler = function(t10, e) {
    setTimeout(function() {
      e.element.submit();
    }, 0);
  };
  var Sb = vu("lock"), q0 = function(t10, e) {
    e = e || {}, this.storageKey = t10, this.storage = e.storage || window.localStorage, this.pollIntervalMS = e.pollIntervalMS || 100, this.timeoutMS = e.timeoutMS || 2e3;
  };
  q0.prototype.withLock = function(t10, e, r) {
    !r && typeof e != "function" && (r = e, e = null);
    var n = r || (/* @__PURE__ */ new Date()).getTime() + "|" + Math.random(), i = (/* @__PURE__ */ new Date()).getTime(), o = this.storageKey, s = this.pollIntervalMS, a = this.timeoutMS, l = this.storage, c = o + ":X", u = o + ":Y", f = o + ":Z", d = function(x) {
      e && e(x);
    }, h = function(x) {
      if ((/* @__PURE__ */ new Date()).getTime() - i > a) {
        Sb.error("Timeout waiting for mutex on " + o + "; clearing lock. [" + n + "]"), l.removeItem(f), l.removeItem(u), y();
        return;
      }
      setTimeout(function() {
        try {
          x();
        } catch (S) {
          d(S);
        }
      }, s * (Math.random() + 0.1));
    }, g = function(x, S) {
      x() ? S() : h(function() {
        g(x, S);
      });
    }, p = function() {
      var x = l.getItem(u);
      if (x && x !== n)
        return false;
      if (l.setItem(u, n), l.getItem(u) === n)
        return true;
      if (!aa(l, true))
        throw new Error("localStorage support dropped while acquiring lock");
      return false;
    }, y = function() {
      l.setItem(c, n), g(p, function() {
        if (l.getItem(c) === n) {
          b();
          return;
        }
        h(function() {
          if (l.getItem(u) !== n) {
            y();
            return;
          }
          g(function() {
            return !l.getItem(f);
          }, b);
        });
      });
    }, b = function() {
      l.setItem(f, "1");
      try {
        t10();
      } finally {
        l.removeItem(f), l.getItem(u) === n && l.removeItem(u), l.getItem(c) === n && l.removeItem(c);
      }
    };
    try {
      if (aa(l, true))
        y();
      else
        throw new Error("localStorage support check failed");
    } catch (x) {
      d(x);
    }
  };
  var ud = vu("batch"), yn = function(t10, e) {
    e = e || {}, this.storageKey = t10, this.storage = e.storage || window.localStorage, this.reportError = e.errorReporter || T.bind(ud.error, ud), this.lock = new q0(t10, { storage: this.storage }), this.pid = e.pid || null, this.memQueue = [];
  };
  yn.prototype.enqueue = function(t10, e, r) {
    var n = {
      id: Au(),
      flushAfter: (/* @__PURE__ */ new Date()).getTime() + e * 2,
      payload: t10
    };
    this.lock.withLock(T.bind(function() {
      var o;
      try {
        var s = this.readFromStorage();
        s.push(n), o = this.saveToStorage(s), o && this.memQueue.push(n);
      } catch {
        this.reportError("Error enqueueing item", t10), o = false;
      }
      r && r(o);
    }, this), T.bind(function(o) {
      this.reportError("Error acquiring storage lock", o), r && r(false);
    }, this), this.pid);
  };
  yn.prototype.fillBatch = function(t10) {
    var e = this.memQueue.slice(0, t10);
    if (e.length < t10) {
      var r = this.readFromStorage();
      if (r.length) {
        var n = {};
        T.each(e, function(s) {
          n[s.id] = true;
        });
        for (var i = 0; i < r.length; i++) {
          var o = r[i];
          if ((/* @__PURE__ */ new Date()).getTime() > o.flushAfter && !n[o.id] && (o.orphaned = true, e.push(o), e.length >= t10))
            break;
        }
      }
    }
    return e;
  };
  var fd = function(t10, e) {
    var r = [];
    return T.each(t10, function(n) {
      n.id && !e[n.id] && r.push(n);
    }), r;
  };
  yn.prototype.removeItemsByID = function(t10, e) {
    var r = {};
    T.each(t10, function(i) {
      r[i] = true;
    }), this.memQueue = fd(this.memQueue, r);
    var n = T.bind(function() {
      var i;
      try {
        var o = this.readFromStorage();
        if (o = fd(o, r), i = this.saveToStorage(o), i) {
          o = this.readFromStorage();
          for (var s = 0; s < o.length; s++) {
            var a = o[s];
            if (a.id && r[a.id])
              return this.reportError("Item not removed from storage"), false;
          }
        }
      } catch {
        this.reportError("Error removing items", t10), i = false;
      }
      return i;
    }, this);
    this.lock.withLock(function() {
      var o = n();
      e && e(o);
    }, T.bind(function(o) {
      var s = false;
      if (this.reportError("Error acquiring storage lock", o), !aa(this.storage, true) && (s = n(), !s))
        try {
          this.storage.removeItem(this.storageKey);
        } catch (a) {
          this.reportError("Error clearing queue", a);
        }
      e && e(s);
    }, this), this.pid);
  };
  var dd = function(t10, e) {
    var r = [];
    return T.each(t10, function(n) {
      var i = n.id;
      if (i in e) {
        var o = e[i];
        o !== null && (n.payload = o, r.push(n));
      } else
        r.push(n);
    }), r;
  };
  yn.prototype.updatePayloads = function(t10, e) {
    this.memQueue = dd(this.memQueue, t10), this.lock.withLock(T.bind(function() {
      var n;
      try {
        var i = this.readFromStorage();
        i = dd(i, t10), n = this.saveToStorage(i);
      } catch {
        this.reportError("Error updating items", t10), n = false;
      }
      e && e(n);
    }, this), T.bind(function(n) {
      this.reportError("Error acquiring storage lock", n), e && e(false);
    }, this), this.pid);
  };
  yn.prototype.readFromStorage = function() {
    var t10;
    try {
      t10 = this.storage.getItem(this.storageKey), t10 && (t10 = ca(t10), T.isArray(t10) || (this.reportError("Invalid storage entry:", t10), t10 = null));
    } catch (e) {
      this.reportError("Error retrieving queue", e), t10 = null;
    }
    return t10 || [];
  };
  yn.prototype.saveToStorage = function(t10) {
    try {
      return this.storage.setItem(this.storageKey, la(t10)), true;
    } catch (e) {
      return this.reportError("Error saving queue", e), false;
    }
  };
  yn.prototype.clear = function() {
    this.memQueue = [], this.storage.removeItem(this.storageKey);
  };
  var Eb = 10 * 60 * 1e3, po = vu("batch"), Ir = function(t10, e) {
    this.errorReporter = e.errorReporter, this.queue = new yn(t10, {
      errorReporter: T.bind(this.reportError, this),
      storage: e.storage
    }), this.libConfig = e.libConfig, this.sendRequest = e.sendRequestFunc, this.beforeSendHook = e.beforeSendHook, this.stopAllBatching = e.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0;
  };
  Ir.prototype.enqueue = function(t10, e) {
    this.queue.enqueue(t10, this.flushInterval, e);
  };
  Ir.prototype.start = function() {
    this.stopped = false, this.consecutiveRemovalFailures = 0, this.flush();
  };
  Ir.prototype.stop = function() {
    this.stopped = true, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null);
  };
  Ir.prototype.clear = function() {
    this.queue.clear();
  };
  Ir.prototype.resetBatchSize = function() {
    this.batchSize = this.libConfig.batch_size;
  };
  Ir.prototype.resetFlush = function() {
    this.scheduleFlush(this.libConfig.batch_flush_interval_ms);
  };
  Ir.prototype.scheduleFlush = function(t10) {
    this.flushInterval = t10, this.stopped || (this.timeoutID = setTimeout(T.bind(this.flush, this), this.flushInterval));
  };
  Ir.prototype.flush = function(t10) {
    try {
      if (this.requestInProgress) {
        po.log("Flush: Request already in progress");
        return;
      }
      t10 = t10 || {};
      var e = this.libConfig.batch_request_timeout_ms, r = (/* @__PURE__ */ new Date()).getTime(), n = this.batchSize, i = this.queue.fillBatch(n), o = [], s = {};
      if (T.each(i, function(c) {
        var u = c.payload;
        this.beforeSendHook && !c.orphaned && (u = this.beforeSendHook(u)), u && o.push(u), s[c.id] = u;
      }, this), o.length < 1) {
        this.resetFlush();
        return;
      }
      this.requestInProgress = true;
      var a = T.bind(function(c) {
        this.requestInProgress = false;
        try {
          var u = false;
          if (t10.unloading)
            this.queue.updatePayloads(s);
          else if (T.isObject(c) && c.error === "timeout" && (/* @__PURE__ */ new Date()).getTime() - r >= e)
            this.reportError("Network timeout; retrying"), this.flush();
          else if (T.isObject(c) && c.xhr_req && (c.xhr_req.status >= 500 || c.xhr_req.status === 429 || c.error === "timeout")) {
            var f = this.flushInterval * 2, d = c.xhr_req.responseHeaders;
            if (d) {
              var h = d["Retry-After"];
              h && (f = parseInt(h, 10) * 1e3 || f);
            }
            f = Math.min(Eb, f), this.reportError("Error; retry in " + f + " ms"), this.scheduleFlush(f);
          } else if (T.isObject(c) && c.xhr_req && c.xhr_req.status === 413)
            if (i.length > 1) {
              var g = Math.max(1, Math.floor(n / 2));
              this.batchSize = Math.min(this.batchSize, g, i.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush();
            } else
              this.reportError("Single-event request too large; dropping", i), this.resetBatchSize(), u = true;
          else
            u = true;
          u && this.queue.removeItemsByID(
            T.map(i, function(p) {
              return p.id;
            }),
            T.bind(function(p) {
              p ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush());
            }, this)
          );
        } catch (p) {
          this.reportError("Error handling API response", p), this.resetFlush();
        }
      }, this), l = {
        method: "POST",
        verbose: true,
        ignore_json_errors: true,
        // eslint-disable-line camelcase
        timeout_ms: e
        // eslint-disable-line camelcase
      };
      t10.unloading && (l.transport = "sendBeacon"), po.log("MIXPANEL REQUEST:", o), this.sendRequest(o, l, a);
    } catch (c) {
      this.reportError("Error flushing request queue", c), this.resetFlush();
    }
  };
  Ir.prototype.reportError = function(t10, e) {
    if (po.error.apply(po.error, arguments), this.errorReporter)
      try {
        e instanceof Error || (e = new Error(t10)), this.errorReporter(t10, e);
      } catch (r) {
        po.error(r);
      }
  };
  var kb = "__mp_opt_in_out_";
  function Cb(t10, e) {
    K0(true, t10, e);
  }
  function Tb(t10, e) {
    K0(false, t10, e);
  }
  function Ob(t10, e) {
    return Y0(t10, e) === "1";
  }
  function H0(t10, e) {
    if (Pb(e))
      return et.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), true;
    var r = Y0(t10, e) === "0";
    return r && et.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), r;
  }
  function Xo(t10) {
    return _u(t10, function(e) {
      return this.get_config(e);
    });
  }
  function bn(t10) {
    return _u(t10, function(e) {
      return this._get_config(e);
    });
  }
  function Ni(t10) {
    return _u(t10, function(e) {
      return this._get_config(e);
    });
  }
  function Ib(t10, e) {
    e = e || {}, wu(e).remove(
      xu(t10, e),
      !!e.crossSubdomainCookie,
      e.cookieDomain
    );
  }
  function wu(t10) {
    return t10 = t10 || {}, t10.persistenceType === "localStorage" ? T.localStorage : T.cookie;
  }
  function xu(t10, e) {
    return e = e || {}, (e.persistencePrefix || kb) + t10;
  }
  function Y0(t10, e) {
    return wu(e).get(xu(t10, e));
  }
  function Pb(t10) {
    if (t10 && t10.ignoreDnt)
      return false;
    var e = t10 && t10.window || Dt, r = e.navigator || {}, n = false;
    return T.each([
      r.doNotTrack,
      // standard
      r.msDoNotTrack,
      e.doNotTrack
    ], function(i) {
      T.includes([true, 1, "1", "yes"], i) && (n = true);
    }), n;
  }
  function K0(t10, e, r) {
    if (!T.isString(e) || !e.length) {
      et.error("gdpr." + (t10 ? "optIn" : "optOut") + " called with an invalid token");
      return;
    }
    r = r || {}, wu(r).set(
      xu(e, r),
      t10 ? 1 : 0,
      T.isNumber(r.cookieExpiration) ? r.cookieExpiration : null,
      !!r.crossSubdomainCookie,
      !!r.secureCookie,
      !!r.crossSiteCookie,
      r.cookieDomain
    ), r.track && t10 && r.track(r.trackEventName || "$opt_in", r.trackProperties, {
      send_immediately: true
    });
  }
  function _u(t10, e) {
    return function() {
      var r = false;
      try {
        var n = e.call(this, "token"), i = e.call(this, "ignore_dnt"), o = e.call(this, "opt_out_tracking_persistence_type"), s = e.call(this, "opt_out_tracking_cookie_prefix"), a = e.call(this, "window");
        n && (r = H0(n, {
          ignoreDnt: i,
          persistenceType: o,
          persistencePrefix: s,
          window: a
        }));
      } catch (c) {
        et.error("Unexpected error when checking tracking opt-out status: " + c);
      }
      if (!r)
        return t10.apply(this, arguments);
      var l = arguments[arguments.length - 1];
      typeof l == "function" && l(0);
    };
  }
  var dn = "$set", Si = "$set_once", fr = "$unset", Vn = "$add", Yr = "$append", qn = "$union", hn = "$remove", Rb = "$delete", X0 = {
    set_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[dn] = n, r;
    },
    unset_action: function(t10) {
      var e = {}, r = [];
      return T.isArray(t10) || (t10 = [t10]), T.each(t10, function(n) {
        this._is_reserved_property(n) || r.push(n);
      }, this), e[fr] = r, e;
    },
    set_once_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[Si] = n, r;
    },
    union_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = T.isArray(i) ? i : [i]);
      }, this) : n[t10] = T.isArray(e) ? e : [e], r[qn] = n, r;
    },
    append_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[Yr] = n, r;
    },
    remove_action: function(t10, e) {
      var r = {}, n = {};
      return T.isObject(t10) ? T.each(t10, function(i, o) {
        this._is_reserved_property(o) || (n[o] = i);
      }, this) : n[t10] = e, r[hn] = n, r;
    },
    delete_action: function() {
      var t10 = {};
      return t10[Rb] = "", t10;
    }
  }, at = function() {
  };
  T.extend(at.prototype, X0);
  at.prototype._init = function(t10, e, r) {
    this._mixpanel = t10, this._group_key = e, this._group_id = r;
  };
  at.prototype.set = Ni(function(t10, e, r) {
    var n = this.set_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  at.prototype.set_once = Ni(function(t10, e, r) {
    var n = this.set_once_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  at.prototype.unset = Ni(function(t10, e) {
    var r = this.unset_action(t10);
    return this._send_request(r, e);
  });
  at.prototype.union = Ni(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.union_action(t10, e);
    return this._send_request(n, r);
  });
  at.prototype.delete = Ni(function(t10) {
    var e = this.delete_action();
    return this._send_request(e, t10);
  });
  at.prototype.remove = Ni(function(t10, e, r) {
    var n = this.remove_action(t10, e);
    return this._send_request(n, r);
  });
  at.prototype._send_request = function(t10, e) {
    t10.$group_key = this._group_key, t10.$group_id = this._group_id, t10.$token = this._get_config("token");
    var r = T.encodeDates(t10);
    return this._mixpanel._track_or_batch({
      type: "groups",
      data: r,
      endpoint: this._get_config("api_host") + "/groups/",
      batcher: this._mixpanel.request_batchers.groups
    }, e);
  };
  at.prototype._is_reserved_property = function(t10) {
    return t10 === "$group_key" || t10 === "$group_id";
  };
  at.prototype._get_config = function(t10) {
    return this._mixpanel.get_config(t10);
  };
  at.prototype.toString = function() {
    return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id;
  };
  at.prototype.remove = at.prototype.remove;
  at.prototype.set = at.prototype.set;
  at.prototype.set_once = at.prototype.set_once;
  at.prototype.union = at.prototype.union;
  at.prototype.unset = at.prototype.unset;
  at.prototype.toString = at.prototype.toString;
  var Te = function() {
  };
  T.extend(Te.prototype, X0);
  Te.prototype._init = function(t10) {
    this._mixpanel = t10;
  };
  Te.prototype.set = bn(function(t10, e, r) {
    var n = this.set_action(t10, e);
    return T.isObject(t10) && (r = e), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), n[dn] = T.extend(
      {},
      T.info.people_properties(),
      this._mixpanel.persistence.get_referrer_info(),
      n[dn]
    ), this._send_request(n, r);
  });
  Te.prototype.set_once = bn(function(t10, e, r) {
    var n = this.set_once_action(t10, e);
    return T.isObject(t10) && (r = e), this._send_request(n, r);
  });
  Te.prototype.unset = bn(function(t10, e) {
    var r = this.unset_action(t10);
    return this._send_request(r, e);
  });
  Te.prototype.increment = bn(function(t10, e, r) {
    var n = {}, i = {};
    return T.isObject(t10) ? (T.each(t10, function(o, s) {
      if (!this._is_reserved_property(s))
        if (isNaN(parseFloat(o))) {
          et.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
          return;
        } else
          i[s] = o;
    }, this), r = e) : (T.isUndefined(e) && (e = 1), i[t10] = e), n[Vn] = i, this._send_request(n, r);
  });
  Te.prototype.append = bn(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.append_action(t10, e);
    return this._send_request(n, r);
  });
  Te.prototype.remove = bn(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.remove_action(t10, e);
    return this._send_request(n, r);
  });
  Te.prototype.union = bn(function(t10, e, r) {
    T.isObject(t10) && (r = e);
    var n = this.union_action(t10, e);
    return this._send_request(n, r);
  });
  Te.prototype.track_charge = bn(function(t10, e, r) {
    if (!T.isNumber(t10) && (t10 = parseFloat(t10), isNaN(t10))) {
      et.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
      return;
    }
    return this.append("$transactions", T.extend({
      $amount: t10
    }, e), r);
  });
  Te.prototype.clear_charges = function(t10) {
    return this.set("$transactions", [], t10);
  };
  Te.prototype.delete_user = function() {
    if (!this._identify_called()) {
      et.error("mixpanel.people.delete_user() requires you to call identify() first");
      return;
    }
    var t10 = { $delete: this._mixpanel.get_distinct_id() };
    return this._send_request(t10);
  };
  Te.prototype.toString = function() {
    return this._mixpanel.toString() + ".people";
  };
  Te.prototype._send_request = function(t10, e) {
    t10.$token = this._get_config("token"), t10.$distinct_id = this._mixpanel.get_distinct_id();
    var r = this._mixpanel.get_property("$device_id"), n = this._mixpanel.get_property("$user_id"), i = this._mixpanel.get_property("$had_persisted_distinct_id");
    r && (t10.$device_id = r), n && (t10.$user_id = n), i && (t10.$had_persisted_distinct_id = i);
    var o = T.encodeDates(t10);
    return this._identify_called() ? this._mixpanel._track_or_batch({
      type: "people",
      data: o,
      endpoint: this._get_config("api_host") + "/engage/",
      batcher: this._mixpanel.request_batchers.people
    }, e) : (this._enqueue(t10), T.isUndefined(e) || (this._get_config("verbose") ? e({ status: -1, error: null }) : e(-1)), T.truncate(o, 255));
  };
  Te.prototype._get_config = function(t10) {
    return this._mixpanel.get_config(t10);
  };
  Te.prototype._identify_called = function() {
    return this._mixpanel._flags.identify_called === true;
  };
  Te.prototype._enqueue = function(t10) {
    dn in t10 ? this._mixpanel.persistence._add_to_people_queue(dn, t10) : Si in t10 ? this._mixpanel.persistence._add_to_people_queue(Si, t10) : fr in t10 ? this._mixpanel.persistence._add_to_people_queue(fr, t10) : Vn in t10 ? this._mixpanel.persistence._add_to_people_queue(Vn, t10) : Yr in t10 ? this._mixpanel.persistence._add_to_people_queue(Yr, t10) : hn in t10 ? this._mixpanel.persistence._add_to_people_queue(hn, t10) : qn in t10 ? this._mixpanel.persistence._add_to_people_queue(qn, t10) : et.error("Invalid call to _enqueue():", t10);
  };
  Te.prototype._flush_one_queue = function(t10, e, r, n) {
    var i = this, o = T.extend({}, this._mixpanel.persistence._get_queue(t10)), s = o;
    !T.isUndefined(o) && T.isObject(o) && !T.isEmptyObject(o) && (i._mixpanel.persistence._pop_from_people_queue(t10, o), n && (s = n(o)), e.call(i, s, function(a, l) {
      a === 0 && i._mixpanel.persistence._add_to_people_queue(t10, o), T.isUndefined(r) || r(a, l);
    }));
  };
  Te.prototype._flush = function(t10, e, r, n, i, o, s) {
    var a = this, l = this._mixpanel.persistence._get_queue(Yr), c = this._mixpanel.persistence._get_queue(hn);
    if (this._flush_one_queue(dn, this.set, t10), this._flush_one_queue(Si, this.set_once, n), this._flush_one_queue(fr, this.unset, o, function(y) {
      return T.keys(y);
    }), this._flush_one_queue(Vn, this.increment, e), this._flush_one_queue(qn, this.union, i), !T.isUndefined(l) && T.isArray(l) && l.length) {
      for (var u, f = function(y, b) {
        y === 0 && a._mixpanel.persistence._add_to_people_queue(Yr, u), T.isUndefined(r) || r(y, b);
      }, d = l.length - 1; d >= 0; d--)
        u = l.pop(), T.isEmptyObject(u) || a.append(u, f);
      a._mixpanel.persistence.save();
    }
    if (!T.isUndefined(c) && T.isArray(c) && c.length) {
      for (var h, g = function(y, b) {
        y === 0 && a._mixpanel.persistence._add_to_people_queue(hn, h), T.isUndefined(s) || s(y, b);
      }, p = c.length - 1; p >= 0; p--)
        h = c.pop(), T.isEmptyObject(h) || a.remove(h, g);
      a._mixpanel.persistence.save();
    }
  };
  Te.prototype._is_reserved_property = function(t10) {
    return t10 === "$distinct_id" || t10 === "$token" || t10 === "$device_id" || t10 === "$user_id" || t10 === "$had_persisted_distinct_id";
  };
  Te.prototype.set = Te.prototype.set;
  Te.prototype.set_once = Te.prototype.set_once;
  Te.prototype.unset = Te.prototype.unset;
  Te.prototype.increment = Te.prototype.increment;
  Te.prototype.append = Te.prototype.append;
  Te.prototype.remove = Te.prototype.remove;
  Te.prototype.union = Te.prototype.union;
  Te.prototype.track_charge = Te.prototype.track_charge;
  Te.prototype.clear_charges = Te.prototype.clear_charges;
  Te.prototype.delete_user = Te.prototype.delete_user;
  Te.prototype.toString = Te.prototype.toString;
  var Su = "__mps", Eu = "__mpso", ku = "__mpus", Cu = "__mpa", Tu = "__mpap", Ou = "__mpr", Iu = "__mpu", J0 = "$people_distinct_id", ua = "__alias", ko = "__timers", Db = [
    Su,
    Eu,
    ku,
    Cu,
    Tu,
    Ou,
    Iu,
    J0,
    ua,
    ko
  ], Me = function(t10) {
    this.props = {}, this.campaign_params_saved = false, t10.persistence_name ? this.name = "mp_" + t10.persistence_name : this.name = "mp_" + t10.token + "_mixpanel";
    var e = t10.persistence;
    e !== "cookie" && e !== "localStorage" && (et.critical("Unknown persistence type " + e + "; falling back to cookie"), e = t10.persistence = "cookie"), e === "localStorage" && T.localStorage.is_supported() ? this.storage = T.localStorage : this.storage = T.cookie, this.load(), this.update_config(t10), this.upgrade(t10), this.save();
  };
  Me.prototype.properties = function() {
    var t10 = {};
    return T.each(this.props, function(e, r) {
      T.include(Db, r) || (t10[r] = e);
    }), t10;
  };
  Me.prototype.load = function() {
    if (!this.disabled) {
      var t10 = this.storage.parse(this.name);
      t10 && (this.props = T.extend({}, t10));
    }
  };
  Me.prototype.upgrade = function(t10) {
    var e = t10.upgrade, r, n;
    e && (r = "mp_super_properties", typeof e == "string" && (r = e), n = this.storage.parse(r), this.storage.remove(r), this.storage.remove(r, true), n && (this.props = T.extend(
      this.props,
      n.all,
      n.events
    ))), !t10.cookie_name && t10.name !== "mixpanel" && (r = "mp_" + t10.token + "_" + t10.name, n = this.storage.parse(r), n && (this.storage.remove(r), this.storage.remove(r, true), this.register_once(n))), this.storage === T.localStorage && (n = T.cookie.parse(this.name), T.cookie.remove(this.name), T.cookie.remove(this.name, true), n && this.register_once(n));
  };
  Me.prototype.save = function() {
    this.disabled || this.storage.set(
      this.name,
      T.JSONEncode(this.props),
      this.expire_days,
      this.cross_subdomain,
      this.secure,
      this.cross_site,
      this.cookie_domain
    );
  };
  Me.prototype.remove = function() {
    this.storage.remove(this.name, false, this.cookie_domain), this.storage.remove(this.name, true, this.cookie_domain);
  };
  Me.prototype.clear = function() {
    this.remove(), this.props = {};
  };
  Me.prototype.register_once = function(t10, e, r) {
    return T.isObject(t10) ? (typeof e > "u" && (e = "None"), this.expire_days = typeof r > "u" ? this.default_expiry : r, T.each(t10, function(n, i) {
      (!this.props.hasOwnProperty(i) || this.props[i] === e) && (this.props[i] = n);
    }, this), this.save(), true) : false;
  };
  Me.prototype.register = function(t10, e) {
    return T.isObject(t10) ? (this.expire_days = typeof e > "u" ? this.default_expiry : e, T.extend(this.props, t10), this.save(), true) : false;
  };
  Me.prototype.unregister = function(t10) {
    t10 in this.props && (delete this.props[t10], this.save());
  };
  Me.prototype.update_campaign_params = function() {
    this.campaign_params_saved || (this.register_once(T.info.campaignParams()), this.campaign_params_saved = true);
  };
  Me.prototype.update_search_keyword = function(t10) {
    this.register(T.info.searchInfo(t10));
  };
  Me.prototype.update_referrer_info = function(t10) {
    this.register_once({
      $initial_referrer: t10 || "$direct",
      $initial_referring_domain: T.info.referringDomain(t10) || "$direct"
    }, "");
  };
  Me.prototype.get_referrer_info = function() {
    return T.strip_empty_properties({
      $initial_referrer: this.props.$initial_referrer,
      $initial_referring_domain: this.props.$initial_referring_domain
    });
  };
  Me.prototype.safe_merge = function(t10) {
    return T.each(this.props, function(e, r) {
      r in t10 || (t10[r] = e);
    }), t10;
  };
  Me.prototype.update_config = function(t10) {
    this.default_expiry = this.expire_days = t10.cookie_expiration, this.set_disabled(t10.disable_persistence), this.set_cookie_domain(t10.cookie_domain), this.set_cross_site(t10.cross_site_cookie), this.set_cross_subdomain(t10.cross_subdomain_cookie), this.set_secure(t10.secure_cookie);
  };
  Me.prototype.set_disabled = function(t10) {
    this.disabled = t10, this.disabled ? this.remove() : this.save();
  };
  Me.prototype.set_cookie_domain = function(t10) {
    t10 !== this.cookie_domain && (this.remove(), this.cookie_domain = t10, this.save());
  };
  Me.prototype.set_cross_site = function(t10) {
    t10 !== this.cross_site && (this.cross_site = t10, this.remove(), this.save());
  };
  Me.prototype.set_cross_subdomain = function(t10) {
    t10 !== this.cross_subdomain && (this.cross_subdomain = t10, this.remove(), this.save());
  };
  Me.prototype.get_cross_subdomain = function() {
    return this.cross_subdomain;
  };
  Me.prototype.set_secure = function(t10) {
    t10 !== this.secure && (this.secure = !!t10, this.remove(), this.save());
  };
  Me.prototype._add_to_people_queue = function(t10, e) {
    var r = this._get_queue_key(t10), n = e[t10], i = this._get_or_create_queue(dn), o = this._get_or_create_queue(Si), s = this._get_or_create_queue(fr), a = this._get_or_create_queue(Vn), l = this._get_or_create_queue(qn), c = this._get_or_create_queue(hn, []), u = this._get_or_create_queue(Yr, []);
    r === Su ? (T.extend(i, n), this._pop_from_people_queue(Vn, n), this._pop_from_people_queue(qn, n), this._pop_from_people_queue(fr, n)) : r === Eu ? (T.each(n, function(f, d) {
      d in o || (o[d] = f);
    }), this._pop_from_people_queue(fr, n)) : r === ku ? T.each(n, function(f) {
      T.each([i, o, a, l], function(d) {
        f in d && delete d[f];
      }), T.each(u, function(d) {
        f in d && delete d[f];
      }), s[f] = true;
    }) : r === Cu ? (T.each(n, function(f, d) {
      d in i ? i[d] += f : (d in a || (a[d] = 0), a[d] += f);
    }, this), this._pop_from_people_queue(fr, n)) : r === Iu ? (T.each(n, function(f, d) {
      T.isArray(f) && (d in l || (l[d] = []), l[d] = l[d].concat(f));
    }), this._pop_from_people_queue(fr, n)) : r === Ou ? (c.push(n), this._pop_from_people_queue(Yr, n)) : r === Tu && (u.push(n), this._pop_from_people_queue(fr, n)), et.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), et.log(e), this.save();
  };
  Me.prototype._pop_from_people_queue = function(t10, e) {
    var r = this._get_queue(t10);
    T.isUndefined(r) || (T.each(e, function(n, i) {
      t10 === Yr || t10 === hn ? T.each(r, function(o) {
        o[i] === n && delete o[i];
      }) : delete r[i];
    }, this), this.save());
  };
  Me.prototype._get_queue_key = function(t10) {
    if (t10 === dn)
      return Su;
    if (t10 === Si)
      return Eu;
    if (t10 === fr)
      return ku;
    if (t10 === Vn)
      return Cu;
    if (t10 === Yr)
      return Tu;
    if (t10 === hn)
      return Ou;
    if (t10 === qn)
      return Iu;
    et.error("Invalid queue:", t10);
  };
  Me.prototype._get_queue = function(t10) {
    return this.props[this._get_queue_key(t10)];
  };
  Me.prototype._get_or_create_queue = function(t10, e) {
    var r = this._get_queue_key(t10);
    return e = T.isUndefined(e) ? {} : e, this.props[r] || (this.props[r] = e);
  };
  Me.prototype.set_event_timer = function(t10, e) {
    var r = this.props[ko] || {};
    r[t10] = e, this.props[ko] = r, this.save();
  };
  Me.prototype.remove_event_timer = function(t10) {
    var e = this.props[ko] || {}, r = e[t10];
    return T.isUndefined(r) || (delete this.props[ko][t10], this.save()), r;
  };
  var Pu, Pt, Q0 = 0, Mb = 1, Nb = function(t10) {
    return t10;
  }, Co = function() {
  }, nr = "mixpanel", G0 = "base64", Lb = "json", gi = Dt.XMLHttpRequest && "withCredentials" in new XMLHttpRequest(), Z0 = !gi && ur.indexOf("MSIE") === -1 && ur.indexOf("Mozilla") === -1, fa = null;
  Br.sendBeacon && (fa = function() {
    return Br.sendBeacon.apply(Br, arguments);
  });
  var hd = {
    api_host: "https://api-js.mixpanel.com",
    api_method: "POST",
    api_transport: "XHR",
    api_payload_format: G0,
    app_host: "https://mixpanel.com",
    cdn: "https://cdn.mxpnl.com",
    cross_site_cookie: false,
    cross_subdomain_cookie: true,
    error_reporter: Co,
    persistence: "cookie",
    persistence_name: "",
    cookie_domain: "",
    cookie_name: "",
    loaded: Co,
    store_google: true,
    save_referrer: true,
    test: false,
    verbose: false,
    img: false,
    debug: false,
    track_links_timeout: 300,
    cookie_expiration: 365,
    upgrade: false,
    disable_persistence: false,
    disable_cookie: false,
    secure_cookie: false,
    ip: true,
    opt_out_tracking_by_default: false,
    opt_out_persistence_by_default: false,
    opt_out_tracking_persistence_type: "localStorage",
    opt_out_tracking_cookie_prefix: null,
    property_blacklist: [],
    xhr_headers: {},
    // { header: value, header2: value }
    ignore_dnt: false,
    batch_requests: true,
    batch_size: 50,
    batch_flush_interval_ms: 5e3,
    batch_request_timeout_ms: 9e4,
    batch_autostart: true,
    hooks: {}
  }, $0 = false, ce = function() {
  }, kc = function(t10, e, r) {
    var n, i = r === nr ? Pt : Pt[r];
    if (i && Pu === Q0)
      n = i;
    else {
      if (i && !T.isArray(i)) {
        et.error("You have already initialized " + r);
        return;
      }
      n = new ce();
    }
    return n._cached_groups = {}, n._init(t10, e, r), n.people = new Te(), n.people._init(n), cn.DEBUG = cn.DEBUG || n.get_config("debug"), !T.isUndefined(i) && T.isArray(i) && (n._execute_array.call(n.people, i.people), n._execute_array(i)), n;
  };
  ce.prototype.init = function(t10, e, r) {
    if (T.isUndefined(r)) {
      this.report_error("You must name your new library: init(token, config, name)");
      return;
    }
    if (r === nr) {
      this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
      return;
    }
    var n = kc(t10, e, r);
    return Pt[r] = n, n._loaded(), n;
  };
  ce.prototype._init = function(t10, e, r) {
    e = e || {}, this.__loaded = true, this.config = {};
    var n = {};
    if (!("api_payload_format" in e)) {
      var i = e.api_host || hd.api_host;
      i.match(/\.mixpanel\.com$/) && (n.api_payload_format = Lb);
    }
    if (this.set_config(T.extend({}, hd, n, e, {
      name: r,
      token: t10,
      callback_fn: (r === nr ? r : nr + "." + r) + "._jsc"
    })), this._jsc = Co, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
      disable_all_events: false,
      identify_called: false
    }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
      if (!T.localStorage.is_supported(true) || !gi)
        this._batch_requests = false, et.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
      else if (this.init_batchers(), fa && Dt.addEventListener) {
        var o = T.bind(function() {
          this.request_batchers.events.stopped || this.request_batchers.events.flush({ unloading: true });
        }, this);
        Dt.addEventListener("pagehide", function(a) {
          a.persisted && o();
        }), Dt.addEventListener("visibilitychange", function() {
          rt.visibilityState === "hidden" && o();
        });
      }
    }
    this.persistence = this.cookie = new Me(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
    var s = T.UUID();
    this.get_distinct_id() || this.register_once({
      distinct_id: s,
      $device_id: s
    }, "");
  };
  ce.prototype._loaded = function() {
    this.get_config("loaded")(this), this._set_default_superprops();
  };
  ce.prototype._set_default_superprops = function() {
    this.persistence.update_search_keyword(rt.referrer), this.get_config("store_google") && this.persistence.update_campaign_params(), this.get_config("save_referrer") && this.persistence.update_referrer_info(rt.referrer);
  };
  ce.prototype._dom_loaded = function() {
    T.each(this.__dom_loaded_queue, function(t10) {
      this._track_dom.apply(this, t10);
    }, this), this.has_opted_out_tracking() || T.each(this.__request_queue, function(t10) {
      this._send_request.apply(this, t10);
    }, this), delete this.__dom_loaded_queue, delete this.__request_queue;
  };
  ce.prototype._track_dom = function(t10, e) {
    if (this.get_config("img"))
      return this.report_error("You can't use DOM tracking functions with img = true."), false;
    if (!$0)
      return this.__dom_loaded_queue.push([t10, e]), false;
    var r = new t10().init(this);
    return r.track.apply(r, e);
  };
  ce.prototype._prepare_callback = function(t10, e) {
    if (T.isUndefined(t10))
      return null;
    if (gi) {
      var r = function(s) {
        t10(s, e);
      };
      return r;
    } else {
      var n = this._jsc, i = "" + Math.floor(Math.random() * 1e8), o = this.get_config("callback_fn") + "[" + i + "]";
      return n[i] = function(s) {
        delete n[i], t10(s, e);
      }, o;
    }
  };
  ce.prototype._send_request = function(t10, e, r, n) {
    var i = true;
    if (Z0)
      return this.__request_queue.push(arguments), i;
    var o = {
      method: this.get_config("api_method"),
      transport: this.get_config("api_transport"),
      verbose: this.get_config("verbose")
    }, s = null;
    !n && (T.isFunction(r) || typeof r == "string") && (n = r, r = null), r = T.extend(o, r || {}), gi || (r.method = "GET");
    var a = r.method === "POST", l = fa && a && r.transport.toLowerCase() === "sendbeacon", c = r.verbose;
    e.verbose && (c = true), this.get_config("test") && (e.test = 1), c && (e.verbose = 1), this.get_config("img") && (e.img = 1), gi || (n ? e.callback = n : (c || this.get_config("test")) && (e.callback = "(function(){})")), e.ip = this.get_config("ip") ? 1 : 0, e._ = (/* @__PURE__ */ new Date()).getTime().toString(), a && (s = "data=" + encodeURIComponent(e.data), delete e.data), t10 += "?" + T.HTTPBuildQuery(e);
    var u = this;
    if ("img" in e) {
      var f = rt.createElement("img");
      f.src = t10, rt.body.appendChild(f);
    } else if (l) {
      try {
        i = fa(t10, s);
      } catch (b) {
        u.report_error(b), i = false;
      }
      try {
        n && n(i ? 1 : 0);
      } catch (b) {
        u.report_error(b);
      }
    } else if (gi)
      try {
        var d = new XMLHttpRequest();
        d.open(r.method, t10, true);
        var h = this.get_config("xhr_headers");
        if (a && (h["Content-Type"] = "application/x-www-form-urlencoded"), T.each(h, function(b, x) {
          d.setRequestHeader(x, b);
        }), r.timeout_ms && typeof d.timeout < "u") {
          d.timeout = r.timeout_ms;
          var g = (/* @__PURE__ */ new Date()).getTime();
        }
        d.withCredentials = true, d.onreadystatechange = function() {
          if (d.readyState === 4)
            if (d.status === 200) {
              if (n)
                if (c) {
                  var b;
                  try {
                    b = T.JSONDecode(d.responseText);
                  } catch (S) {
                    if (u.report_error(S), r.ignore_json_errors)
                      b = d.responseText;
                    else
                      return;
                  }
                  n(b);
                } else
                  n(Number(d.responseText));
            } else {
              var x;
              d.timeout && !d.status && (/* @__PURE__ */ new Date()).getTime() - g >= d.timeout ? x = "timeout" : x = "Bad HTTP status: " + d.status + " " + d.statusText, u.report_error(x), n && n(c ? { status: 0, error: x, xhr_req: d } : 0);
            }
        }, d.send(s);
      } catch (b) {
        u.report_error(b), i = false;
      }
    else {
      var p = rt.createElement("script");
      p.type = "text/javascript", p.async = true, p.defer = true, p.src = t10;
      var y = rt.getElementsByTagName("script")[0];
      y.parentNode.insertBefore(p, y);
    }
    return i;
  };
  ce.prototype._execute_array = function(t10) {
    var e, r = [], n = [], i = [];
    T.each(t10, function(s) {
      s && (e = s[0], T.isArray(e) ? i.push(s) : typeof s == "function" ? s.call(this) : T.isArray(s) && e === "alias" ? r.push(s) : T.isArray(s) && e.indexOf("track") !== -1 && typeof this[e] == "function" ? i.push(s) : n.push(s));
    }, this);
    var o = function(s, a) {
      T.each(s, function(l) {
        if (T.isArray(l[0])) {
          var c = a;
          T.each(l, function(u) {
            c = c[u[0]].apply(c, u.slice(1));
          });
        } else
          this[l[0]].apply(this, l.slice(1));
      }, a);
    };
    o(r, this), o(n, this), o(i, this);
  };
  ce.prototype.are_batchers_initialized = function() {
    return !!this.request_batchers.events;
  };
  ce.prototype.init_batchers = function() {
    var t10 = this.get_config("token");
    if (!this.are_batchers_initialized()) {
      var e = T.bind(function(r) {
        return new Ir(
          "__mpq_" + t10 + r.queue_suffix,
          {
            libConfig: this.config,
            sendRequestFunc: T.bind(function(n, i, o) {
              this._send_request(
                this.get_config("api_host") + r.endpoint,
                this._encode_data_for_request(n),
                i,
                this._prepare_callback(o, n)
              );
            }, this),
            beforeSendHook: T.bind(function(n) {
              return this._run_hook("before_send_" + r.type, n);
            }, this),
            errorReporter: this.get_config("error_reporter"),
            stopAllBatchingFunc: T.bind(this.stop_batch_senders, this)
          }
        );
      }, this);
      this.request_batchers = {
        events: e({ type: "events", endpoint: "/track/", queue_suffix: "_ev" }),
        people: e({ type: "people", endpoint: "/engage/", queue_suffix: "_pp" }),
        groups: e({ type: "groups", endpoint: "/groups/", queue_suffix: "_gr" })
      };
    }
    this.get_config("batch_autostart") && this.start_batch_senders();
  };
  ce.prototype.start_batch_senders = function() {
    this.are_batchers_initialized() && (this._batch_requests = true, T.each(this.request_batchers, function(t10) {
      t10.start();
    }));
  };
  ce.prototype.stop_batch_senders = function() {
    this._batch_requests = false, T.each(this.request_batchers, function(t10) {
      t10.stop(), t10.clear();
    });
  };
  ce.prototype.push = function(t10) {
    this._execute_array([t10]);
  };
  ce.prototype.disable = function(t10) {
    typeof t10 > "u" ? this._flags.disable_all_events = true : this.__disabled_events = this.__disabled_events.concat(t10);
  };
  ce.prototype._encode_data_for_request = function(t10) {
    var e = T.JSONEncode(t10);
    return this.get_config("api_payload_format") === G0 && (e = T.base64Encode(e)), { data: e };
  };
  ce.prototype._track_or_batch = function(t10, e) {
    var r = T.truncate(t10.data, 255), n = t10.endpoint, i = t10.batcher, o = t10.should_send_immediately, s = t10.send_request_options || {};
    e = e || Co;
    var a = true, l = T.bind(function() {
      return s.skip_hooks || (r = this._run_hook("before_send_" + t10.type, r)), r ? (et.log("MIXPANEL REQUEST:"), et.log(r), this._send_request(
        n,
        this._encode_data_for_request(r),
        s,
        this._prepare_callback(e, r)
      )) : null;
    }, this);
    return this._batch_requests && !o ? i.enqueue(r, function(c) {
      c ? e(1, r) : l();
    }) : a = l(), a && r;
  };
  ce.prototype.track = Xo(function(t10, e, r, n) {
    !n && typeof r == "function" && (n = r, r = null), r = r || {};
    var i = r.transport;
    i && (r.transport = i);
    var o = r.send_immediately;
    if (typeof n != "function" && (n = Co), T.isUndefined(t10)) {
      this.report_error("No event name provided to mixpanel.track");
      return;
    }
    if (this._event_is_disabled(t10)) {
      n(0);
      return;
    }
    e = e || {}, e.token = this.get_config("token");
    var s = this.persistence.remove_event_timer(t10);
    if (!T.isUndefined(s)) {
      var a = (/* @__PURE__ */ new Date()).getTime() - s;
      e.$duration = parseFloat((a / 1e3).toFixed(3));
    }
    this._set_default_superprops(), e = T.extend(
      {},
      T.info.properties(),
      this.persistence.properties(),
      this.unpersisted_superprops,
      e
    );
    var l = this.get_config("property_blacklist");
    T.isArray(l) ? T.each(l, function(f) {
      delete e[f];
    }) : this.report_error("Invalid value for property_blacklist config: " + l);
    var c = {
      event: t10,
      properties: e
    }, u = this._track_or_batch({
      type: "events",
      data: c,
      endpoint: this.get_config("api_host") + "/track/",
      batcher: this.request_batchers.events,
      should_send_immediately: o,
      send_request_options: r
    }, n);
    return u;
  });
  ce.prototype.set_group = Xo(function(t10, e, r) {
    T.isArray(e) || (e = [e]);
    var n = {};
    return n[t10] = e, this.register(n), this.people.set(t10, e, r);
  });
  ce.prototype.add_group = Xo(function(t10, e, r) {
    var n = this.get_property(t10);
    if (n === void 0) {
      var i = {};
      i[t10] = [e], this.register(i);
    } else
      n.indexOf(e) === -1 && (n.push(e), this.register(i));
    return this.people.union(t10, e, r);
  });
  ce.prototype.remove_group = Xo(function(t10, e, r) {
    var n = this.get_property(t10);
    if (n !== void 0) {
      var i = n.indexOf(e);
      i > -1 && (n.splice(i, 1), this.register({ group_key: n })), n.length === 0 && this.unregister(t10);
    }
    return this.people.remove(t10, e, r);
  });
  ce.prototype.track_with_groups = Xo(function(t10, e, r, n) {
    var i = T.extend({}, e || {});
    return T.each(r, function(o, s) {
      o != null && (i[s] = o);
    }), this.track(t10, i, n);
  });
  ce.prototype._create_map_key = function(t10, e) {
    return t10 + "_" + JSON.stringify(e);
  };
  ce.prototype._remove_group_from_cache = function(t10, e) {
    delete this._cached_groups[this._create_map_key(t10, e)];
  };
  ce.prototype.get_group = function(t10, e) {
    var r = this._create_map_key(t10, e), n = this._cached_groups[r];
    return (n === void 0 || n._group_key !== t10 || n._group_id !== e) && (n = new at(), n._init(this, t10, e), this._cached_groups[r] = n), n;
  };
  ce.prototype.track_pageview = function(t10) {
    T.isUndefined(t10) && (t10 = rt.location.href), this.track("mp_page_view", T.info.pageviewInfo(t10));
  };
  ce.prototype.track_links = function() {
    return this._track_dom.call(this, _i, arguments);
  };
  ce.prototype.track_forms = function() {
    return this._track_dom.call(this, za, arguments);
  };
  ce.prototype.time_event = function(t10) {
    if (T.isUndefined(t10)) {
      this.report_error("No event name provided to mixpanel.time_event");
      return;
    }
    this._event_is_disabled(t10) || this.persistence.set_event_timer(t10, (/* @__PURE__ */ new Date()).getTime());
  };
  var Bb = {
    persistent: true
  }, Ru = function(t10) {
    var e;
    return T.isObject(t10) ? e = t10 : T.isUndefined(t10) ? e = {} : e = { days: t10 }, T.extend({}, Bb, e);
  };
  ce.prototype.register = function(t10, e) {
    var r = Ru(e);
    r.persistent ? this.persistence.register(t10, r.days) : T.extend(this.unpersisted_superprops, t10);
  };
  ce.prototype.register_once = function(t10, e, r) {
    var n = Ru(r);
    n.persistent ? this.persistence.register_once(t10, e, n.days) : (typeof e > "u" && (e = "None"), T.each(t10, function(i, o) {
      (!this.unpersisted_superprops.hasOwnProperty(o) || this.unpersisted_superprops[o] === e) && (this.unpersisted_superprops[o] = i);
    }, this));
  };
  ce.prototype.unregister = function(t10, e) {
    e = Ru(e), e.persistent ? this.persistence.unregister(t10) : delete this.unpersisted_superprops[t10];
  };
  ce.prototype._register_single = function(t10, e) {
    var r = {};
    r[t10] = e, this.register(r);
  };
  ce.prototype.identify = function(t10, e, r, n, i, o, s, a) {
    var l = this.get_distinct_id();
    if (this.register({ $user_id: t10 }), !this.get_property("$device_id")) {
      var c = l;
      this.register_once({
        $had_persisted_distinct_id: true,
        $device_id: c
      }, "");
    }
    t10 !== l && t10 !== this.get_property(ua) && (this.unregister(ua), this.register({ distinct_id: t10 })), this._flags.identify_called = true, this.people._flush(e, r, n, i, o, s, a), t10 !== l && this.track("$identify", {
      distinct_id: t10,
      $anon_distinct_id: l
    }, { skip_hooks: true });
  };
  ce.prototype.reset = function() {
    this.persistence.clear(), this._flags.identify_called = false;
    var t10 = T.UUID();
    this.register_once({
      distinct_id: t10,
      $device_id: t10
    }, "");
  };
  ce.prototype.get_distinct_id = function() {
    return this.get_property("distinct_id");
  };
  ce.prototype.alias = function(t10, e) {
    if (t10 === this.get_property(J0))
      return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
    var r = this;
    return T.isUndefined(e) && (e = this.get_distinct_id()), t10 !== e ? (this._register_single(ua, t10), this.track("$create_alias", {
      alias: t10,
      distinct_id: e
    }, {
      skip_hooks: true
    }, function() {
      r.identify(t10);
    })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(t10), -1);
  };
  ce.prototype.name_tag = function(t10) {
    this._register_single("mp_name_tag", t10);
  };
  ce.prototype.set_config = function(t10) {
    if (T.isObject(t10)) {
      T.extend(this.config, t10);
      var e = t10.batch_size;
      e && T.each(this.request_batchers, function(r) {
        r.resetBatchSize();
      }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), cn.DEBUG = cn.DEBUG || this.get_config("debug");
    }
  };
  ce.prototype.get_config = function(t10) {
    return this.config[t10];
  };
  ce.prototype._run_hook = function(t10) {
    var e = (this.config.hooks[t10] || Nb).apply(this, en.call(arguments, 1));
    return typeof e > "u" && (this.report_error(t10 + " hook did not return a value"), e = null), e;
  };
  ce.prototype.get_property = function(t10) {
    return this.persistence.props[t10];
  };
  ce.prototype.toString = function() {
    var t10 = this.get_config("name");
    return t10 !== nr && (t10 = nr + "." + t10), t10;
  };
  ce.prototype._event_is_disabled = function(t10) {
    return T.isBlockedUA(ur) || this._flags.disable_all_events || T.include(this.__disabled_events, t10);
  };
  ce.prototype._gdpr_init = function() {
    var t10 = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
    t10 && T.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({ persistence_type: "cookie" }) && this.opt_in_tracking({ enable_persistence: false }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({ persistence_type: "cookie" }) && this.opt_out_tracking({ clear_persistence: false }), this.clear_opt_in_out_tracking({
      persistence_type: "cookie",
      enable_persistence: false
    })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({ clear_persistence: true }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || T.cookie.get("mp_optout")) && (T.cookie.remove("mp_optout"), this.opt_out_tracking({
      clear_persistence: this.get_config("opt_out_persistence_by_default")
    }));
  };
  ce.prototype._gdpr_update_persistence = function(t10) {
    var e;
    if (t10 && t10.clear_persistence)
      e = true;
    else if (t10 && t10.enable_persistence)
      e = false;
    else
      return;
    !this.get_config("disable_persistence") && this.persistence.disabled !== e && this.persistence.set_disabled(e), e && T.each(this.request_batchers, function(r) {
      r.clear();
    });
  };
  ce.prototype._gdpr_call_func = function(t10, e) {
    return e = T.extend({
      track: T.bind(this.track, this),
      persistence_type: this.get_config("opt_out_tracking_persistence_type"),
      cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
      cookie_expiration: this.get_config("cookie_expiration"),
      cross_site_cookie: this.get_config("cross_site_cookie"),
      cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
      cookie_domain: this.get_config("cookie_domain"),
      secure_cookie: this.get_config("secure_cookie"),
      ignore_dnt: this.get_config("ignore_dnt")
    }, e), T.localStorage.is_supported() || (e.persistence_type = "cookie"), t10(this.get_config("token"), {
      track: e.track,
      trackEventName: e.track_event_name,
      trackProperties: e.track_properties,
      persistenceType: e.persistence_type,
      persistencePrefix: e.cookie_prefix,
      cookieDomain: e.cookie_domain,
      cookieExpiration: e.cookie_expiration,
      crossSiteCookie: e.cross_site_cookie,
      crossSubdomainCookie: e.cross_subdomain_cookie,
      secureCookie: e.secure_cookie,
      ignoreDnt: e.ignore_dnt
    });
  };
  ce.prototype.opt_in_tracking = function(t10) {
    t10 = T.extend({
      enable_persistence: true
    }, t10), this._gdpr_call_func(Cb, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.opt_out_tracking = function(t10) {
    t10 = T.extend({
      clear_persistence: true,
      delete_user: true
    }, t10), t10.delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(Tb, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.has_opted_in_tracking = function(t10) {
    return this._gdpr_call_func(Ob, t10);
  };
  ce.prototype.has_opted_out_tracking = function(t10) {
    return this._gdpr_call_func(H0, t10);
  };
  ce.prototype.clear_opt_in_out_tracking = function(t10) {
    t10 = T.extend({
      enable_persistence: true
    }, t10), this._gdpr_call_func(Ib, t10), this._gdpr_update_persistence(t10);
  };
  ce.prototype.report_error = function(t10, e) {
    et.error.apply(et.error, arguments);
    try {
      !e && !(t10 instanceof Error) && (t10 = new Error(t10)), this.get_config("error_reporter")(t10, e);
    } catch (r) {
      et.error(r);
    }
  };
  ce.prototype.init = ce.prototype.init;
  ce.prototype.reset = ce.prototype.reset;
  ce.prototype.disable = ce.prototype.disable;
  ce.prototype.time_event = ce.prototype.time_event;
  ce.prototype.track = ce.prototype.track;
  ce.prototype.track_links = ce.prototype.track_links;
  ce.prototype.track_forms = ce.prototype.track_forms;
  ce.prototype.track_pageview = ce.prototype.track_pageview;
  ce.prototype.register = ce.prototype.register;
  ce.prototype.register_once = ce.prototype.register_once;
  ce.prototype.unregister = ce.prototype.unregister;
  ce.prototype.identify = ce.prototype.identify;
  ce.prototype.alias = ce.prototype.alias;
  ce.prototype.name_tag = ce.prototype.name_tag;
  ce.prototype.set_config = ce.prototype.set_config;
  ce.prototype.get_config = ce.prototype.get_config;
  ce.prototype.get_property = ce.prototype.get_property;
  ce.prototype.get_distinct_id = ce.prototype.get_distinct_id;
  ce.prototype.toString = ce.prototype.toString;
  ce.prototype.opt_out_tracking = ce.prototype.opt_out_tracking;
  ce.prototype.opt_in_tracking = ce.prototype.opt_in_tracking;
  ce.prototype.has_opted_out_tracking = ce.prototype.has_opted_out_tracking;
  ce.prototype.has_opted_in_tracking = ce.prototype.has_opted_in_tracking;
  ce.prototype.clear_opt_in_out_tracking = ce.prototype.clear_opt_in_out_tracking;
  ce.prototype.get_group = ce.prototype.get_group;
  ce.prototype.set_group = ce.prototype.set_group;
  ce.prototype.add_group = ce.prototype.add_group;
  ce.prototype.remove_group = ce.prototype.remove_group;
  ce.prototype.track_with_groups = ce.prototype.track_with_groups;
  ce.prototype.start_batch_senders = ce.prototype.start_batch_senders;
  ce.prototype.stop_batch_senders = ce.prototype.stop_batch_senders;
  Me.prototype.properties = Me.prototype.properties;
  Me.prototype.update_search_keyword = Me.prototype.update_search_keyword;
  Me.prototype.update_referrer_info = Me.prototype.update_referrer_info;
  Me.prototype.get_cross_subdomain = Me.prototype.get_cross_subdomain;
  Me.prototype.clear = Me.prototype.clear;
  var di = {}, Fb = function() {
    T.each(di, function(t10, e) {
      e !== nr && (Pt[e] = t10);
    }), Pt._ = T;
  }, jb = function() {
    Pt.init = function(t10, e, r) {
      if (r)
        return Pt[r] || (Pt[r] = di[r] = kc(t10, e, r), Pt[r]._loaded()), Pt[r];
      var n = Pt;
      di[nr] ? n = di[nr] : t10 && (n = kc(t10, e, nr), n._loaded(), di[nr] = n), Pt = n, Pu === Mb && (Dt[nr] = Pt), Fb();
    };
  }, Wb = function() {
    function t10() {
      t10.done || (t10.done = true, $0 = true, Z0 = false, T.each(di, function(n) {
        n._dom_loaded();
      }));
    }
    function e() {
      try {
        rt.documentElement.doScroll("left");
      } catch {
        setTimeout(e, 1);
        return;
      }
      t10();
    }
    if (rt.addEventListener)
      rt.readyState === "complete" ? t10() : rt.addEventListener("DOMContentLoaded", t10, false);
    else if (rt.attachEvent) {
      rt.attachEvent("onreadystatechange", t10);
      var r = false;
      try {
        r = Dt.frameElement === null;
      } catch {
      }
      rt.documentElement.doScroll && r && e();
    }
    T.register_event(Dt, "load", t10, true);
  };
  function Ub() {
    return Pu = Q0, Pt = new ce(), jb(), Pt.init(), Wb(), Pt;
  }
  var zb = Ub(), no = zb;
  function Du() {
    return typeof window < "u" ? window.location.host.indexOf("discordsays.com") !== -1 : false;
  }
  let pd = false;
  function Vb(t10) {
    var r;
    if (pd)
      return;
    let e = "https://ws.joinplayroom.com";
    if ((r = define_process_env_default) != null && r.REACT_APP_SERVER) {
      const n = define_process_env_default.REACT_APP_SERVER.split("://");
      e = `${n[0] === "wss" ? "https" : "http"}://${n[1]}`;
    }
    t10 && (e = t10), no.init("2647310162474a4f7ca66a277c543032", {
      debug: false,
      api_host: `${e}/__mix`
    }), pd = true;
  }
  Vb(
    Du() ? `${window.location.protocol}//${window.location.host}/.proxy/_ws` : null
  );
  let ds = () => {
    var t10;
    return define_process_env_default.NODE_ENV === "production" || typeof window < "u" && ((t10 = window == null ? void 0 : window._PLAYROOM_CONFIG) == null ? void 0 : t10.sdkMode);
  }, mi = {
    identify: (t10) => {
      try {
        ds() && no.identify(t10);
      } catch (e) {
        console.log(e);
      }
    },
    alias: (t10) => {
      try {
        ds() && no.alias(t10);
      } catch (e) {
        console.log(e);
      }
    },
    track: (t10, e) => {
      try {
        ds() && no.track(t10, e);
      } catch (r) {
        console.log(r);
      }
    },
    people: {
      set: (t10) => {
        try {
          ds() && no.people.set(t10);
        } catch (e) {
          console.log(e);
        }
      }
    }
  };
  var da = {}, qb = {
    get exports() {
      return da;
    },
    set exports(t10) {
      da = t10;
    }
  }, Cc = {}, Hb = {
    get exports() {
      return Cc;
    },
    set exports(t10) {
      Cc = t10;
    }
  };
  (function() {
    var t10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = {
      // Bit-wise rotation left
      rotl: function(r, n) {
        return r << n | r >>> 32 - n;
      },
      // Bit-wise rotation right
      rotr: function(r, n) {
        return r << 32 - n | r >>> n;
      },
      // Swap big-endian to little-endian and vice versa
      endian: function(r) {
        if (r.constructor == Number)
          return e.rotl(r, 8) & 16711935 | e.rotl(r, 24) & 4278255360;
        for (var n = 0; n < r.length; n++)
          r[n] = e.endian(r[n]);
        return r;
      },
      // Generate an array of any length of random bytes
      randomBytes: function(r) {
        for (var n = []; r > 0; r--)
          n.push(Math.floor(Math.random() * 256));
        return n;
      },
      // Convert a byte array to big-endian 32-bit words
      bytesToWords: function(r) {
        for (var n = [], i = 0, o = 0; i < r.length; i++, o += 8)
          n[o >>> 5] |= r[i] << 24 - o % 32;
        return n;
      },
      // Convert big-endian 32-bit words to a byte array
      wordsToBytes: function(r) {
        for (var n = [], i = 0; i < r.length * 32; i += 8)
          n.push(r[i >>> 5] >>> 24 - i % 32 & 255);
        return n;
      },
      // Convert a byte array to a hex string
      bytesToHex: function(r) {
        for (var n = [], i = 0; i < r.length; i++)
          n.push((r[i] >>> 4).toString(16)), n.push((r[i] & 15).toString(16));
        return n.join("");
      },
      // Convert a hex string to a byte array
      hexToBytes: function(r) {
        for (var n = [], i = 0; i < r.length; i += 2)
          n.push(parseInt(r.substr(i, 2), 16));
        return n;
      },
      // Convert a byte array to a base-64 string
      bytesToBase64: function(r) {
        for (var n = [], i = 0; i < r.length; i += 3)
          for (var o = r[i] << 16 | r[i + 1] << 8 | r[i + 2], s = 0; s < 4; s++)
            i * 8 + s * 6 <= r.length * 8 ? n.push(t10.charAt(o >>> 6 * (3 - s) & 63)) : n.push("=");
        return n.join("");
      },
      // Convert a base-64 string to a byte array
      base64ToBytes: function(r) {
        r = r.replace(/[^A-Z0-9+\/]/ig, "");
        for (var n = [], i = 0, o = 0; i < r.length; o = ++i % 4)
          o != 0 && n.push((t10.indexOf(r.charAt(i - 1)) & Math.pow(2, -2 * o + 8) - 1) << o * 2 | t10.indexOf(r.charAt(i)) >>> 6 - o * 2);
        return n;
      }
    };
    Hb.exports = e;
  })();
  var Tc = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function(t10) {
        return Tc.bin.stringToBytes(unescape(encodeURIComponent(t10)));
      },
      // Convert a byte array to a string
      bytesToString: function(t10) {
        return decodeURIComponent(escape(Tc.bin.bytesToString(t10)));
      }
    },
    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function(t10) {
        for (var e = [], r = 0; r < t10.length; r++)
          e.push(t10.charCodeAt(r) & 255);
        return e;
      },
      // Convert a byte array to a string
      bytesToString: function(t10) {
        for (var e = [], r = 0; r < t10.length; r++)
          e.push(String.fromCharCode(t10[r]));
        return e.join("");
      }
    }
  }, gd = Tc;
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var Yb = function(t10) {
    return t10 != null && (e1(t10) || Kb(t10) || !!t10._isBuffer);
  };
  function e1(t10) {
    return !!t10.constructor && typeof t10.constructor.isBuffer == "function" && t10.constructor.isBuffer(t10);
  }
  function Kb(t10) {
    return typeof t10.readFloatLE == "function" && typeof t10.slice == "function" && e1(t10.slice(0, 0));
  }
  (function() {
    var t10 = Cc, e = gd.utf8, r = Yb, n = gd.bin, i = function(o, s) {
      o.constructor == String ? s && s.encoding === "binary" ? o = n.stringToBytes(o) : o = e.stringToBytes(o) : r(o) ? o = Array.prototype.slice.call(o, 0) : !Array.isArray(o) && o.constructor !== Uint8Array && (o = o.toString());
      for (var a = t10.bytesToWords(o), l = o.length * 8, c = 1732584193, u = -271733879, f = -1732584194, d = 271733878, h = 0; h < a.length; h++)
        a[h] = (a[h] << 8 | a[h] >>> 24) & 16711935 | (a[h] << 24 | a[h] >>> 8) & 4278255360;
      a[l >>> 5] |= 128 << l % 32, a[(l + 64 >>> 9 << 4) + 14] = l;
      for (var g = i._ff, p = i._gg, y = i._hh, b = i._ii, h = 0; h < a.length; h += 16) {
        var x = c, S = u, O = f, _ = d;
        c = g(c, u, f, d, a[h + 0], 7, -680876936), d = g(d, c, u, f, a[h + 1], 12, -389564586), f = g(f, d, c, u, a[h + 2], 17, 606105819), u = g(u, f, d, c, a[h + 3], 22, -1044525330), c = g(c, u, f, d, a[h + 4], 7, -176418897), d = g(d, c, u, f, a[h + 5], 12, 1200080426), f = g(f, d, c, u, a[h + 6], 17, -1473231341), u = g(u, f, d, c, a[h + 7], 22, -45705983), c = g(c, u, f, d, a[h + 8], 7, 1770035416), d = g(d, c, u, f, a[h + 9], 12, -1958414417), f = g(f, d, c, u, a[h + 10], 17, -42063), u = g(u, f, d, c, a[h + 11], 22, -1990404162), c = g(c, u, f, d, a[h + 12], 7, 1804603682), d = g(d, c, u, f, a[h + 13], 12, -40341101), f = g(f, d, c, u, a[h + 14], 17, -1502002290), u = g(u, f, d, c, a[h + 15], 22, 1236535329), c = p(c, u, f, d, a[h + 1], 5, -165796510), d = p(d, c, u, f, a[h + 6], 9, -1069501632), f = p(f, d, c, u, a[h + 11], 14, 643717713), u = p(u, f, d, c, a[h + 0], 20, -373897302), c = p(c, u, f, d, a[h + 5], 5, -701558691), d = p(d, c, u, f, a[h + 10], 9, 38016083), f = p(f, d, c, u, a[h + 15], 14, -660478335), u = p(u, f, d, c, a[h + 4], 20, -405537848), c = p(c, u, f, d, a[h + 9], 5, 568446438), d = p(d, c, u, f, a[h + 14], 9, -1019803690), f = p(f, d, c, u, a[h + 3], 14, -187363961), u = p(u, f, d, c, a[h + 8], 20, 1163531501), c = p(c, u, f, d, a[h + 13], 5, -1444681467), d = p(d, c, u, f, a[h + 2], 9, -51403784), f = p(f, d, c, u, a[h + 7], 14, 1735328473), u = p(u, f, d, c, a[h + 12], 20, -1926607734), c = y(c, u, f, d, a[h + 5], 4, -378558), d = y(d, c, u, f, a[h + 8], 11, -2022574463), f = y(f, d, c, u, a[h + 11], 16, 1839030562), u = y(u, f, d, c, a[h + 14], 23, -35309556), c = y(c, u, f, d, a[h + 1], 4, -1530992060), d = y(d, c, u, f, a[h + 4], 11, 1272893353), f = y(f, d, c, u, a[h + 7], 16, -155497632), u = y(u, f, d, c, a[h + 10], 23, -1094730640), c = y(c, u, f, d, a[h + 13], 4, 681279174), d = y(d, c, u, f, a[h + 0], 11, -358537222), f = y(f, d, c, u, a[h + 3], 16, -722521979), u = y(u, f, d, c, a[h + 6], 23, 76029189), c = y(c, u, f, d, a[h + 9], 4, -640364487), d = y(d, c, u, f, a[h + 12], 11, -421815835), f = y(f, d, c, u, a[h + 15], 16, 530742520), u = y(u, f, d, c, a[h + 2], 23, -995338651), c = b(c, u, f, d, a[h + 0], 6, -198630844), d = b(d, c, u, f, a[h + 7], 10, 1126891415), f = b(f, d, c, u, a[h + 14], 15, -1416354905), u = b(u, f, d, c, a[h + 5], 21, -57434055), c = b(c, u, f, d, a[h + 12], 6, 1700485571), d = b(d, c, u, f, a[h + 3], 10, -1894986606), f = b(f, d, c, u, a[h + 10], 15, -1051523), u = b(u, f, d, c, a[h + 1], 21, -2054922799), c = b(c, u, f, d, a[h + 8], 6, 1873313359), d = b(d, c, u, f, a[h + 15], 10, -30611744), f = b(f, d, c, u, a[h + 6], 15, -1560198380), u = b(u, f, d, c, a[h + 13], 21, 1309151649), c = b(c, u, f, d, a[h + 4], 6, -145523070), d = b(d, c, u, f, a[h + 11], 10, -1120210379), f = b(f, d, c, u, a[h + 2], 15, 718787259), u = b(u, f, d, c, a[h + 9], 21, -343485551), c = c + x >>> 0, u = u + S >>> 0, f = f + O >>> 0, d = d + _ >>> 0;
      }
      return t10.endian([c, u, f, d]);
    };
    i._ff = function(o, s, a, l, c, u, f) {
      var d = o + (s & a | ~s & l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._gg = function(o, s, a, l, c, u, f) {
      var d = o + (s & l | a & ~l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._hh = function(o, s, a, l, c, u, f) {
      var d = o + (s ^ a ^ l) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._ii = function(o, s, a, l, c, u, f) {
      var d = o + (a ^ (s | ~l)) + (c >>> 0) + f;
      return (d << u | d >>> 32 - u) + s;
    }, i._blocksize = 16, i._digestsize = 16, qb.exports = function(o, s) {
      if (o == null)
        throw new Error("Illegal argument " + o);
      var a = t10.wordsToBytes(i(o, s));
      return s && s.asBytes ? a : s && s.asString ? n.bytesToString(a) : t10.bytesToHex(a);
    };
  })();
  const Ln = {
    roomLimitExceed: {
      code: 4444,
      reason: "ROOM_LIMIT_EXCEEDED"
    },
    playerKicked: {
      code: 4999,
      reason: "PLAYER_KICKED"
    },
    unknown: {
      code: 0,
      reason: "UNKNOWN"
    }
  };
  function Xb(t10, e) {
    e || (e = {}), typeof e == "function" && (e = { cmp: e });
    var r = typeof e.cycles == "boolean" ? e.cycles : false, n = e.cmp && /* @__PURE__ */ function(o) {
      return function(s) {
        return function(a, l) {
          var c = { key: a, value: s[a] }, u = { key: l, value: s[l] };
          return o(c, u);
        };
      };
    }(e.cmp), i = [];
    return function o(s) {
      if (s && s.toJSON && typeof s.toJSON == "function" && (s = s.toJSON()), s !== void 0) {
        if (typeof s == "number")
          return isFinite(s) ? "" + s : "null";
        if (typeof s != "object")
          return JSON.stringify(s);
        var a, l;
        if (Array.isArray(s)) {
          for (l = "[", a = 0; a < s.length; a++)
            a && (l += ","), l += o(s[a]) || "null";
          return l + "]";
        }
        if (s === null)
          return "null";
        if (i.indexOf(s) !== -1) {
          if (r)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var c = i.push(s) - 1, u = Object.keys(s).sort(n && n(s));
        for (l = "", a = 0; a < u.length; a++) {
          var f = u[a], d = o(s[f]);
          d && (l && (l += ","), l += JSON.stringify(f) + ":" + d);
        }
        return i.splice(c, 1), "{" + l + "}";
      }
    }(t10);
  }
  function t1(t10) {
    return Object.keys(t10).forEach((e) => {
      t10[e] && typeof t10[e] == "object" ? t1(t10[e]) : (t10[e] === void 0 || t10[e] === null) && delete t10[e];
    }), t10;
  }
  function Jb(t10, e) {
    return Object.keys(t10).map(function(r) {
      return e + encodeURIComponent(r) + "=" + encodeURIComponent(t10[r]);
    }).join("&");
  }
  function Qb(t10) {
    const e = t10 != null && t10.profile ? Jb(t10.profile, "profile_") : "", r = t10 != null && t10.reconnectGracePeriod ? `reconnectGracePeriod=${t10.reconnectGracePeriod}` : "", n = t10 != null && t10.maxPlayersPerRoom ? `maxPlayersPerRoom=${t10.maxPlayersPerRoom}` : "", i = t10 != null && t10.gameId ? `gameId=${t10.gameId}` : "", o = sessionStorage.getItem("pr_dcd_jwt"), s = o ? `discord_jwt=${o}` : "";
    return [
      e,
      r,
      n,
      i,
      s
    ].filter(Boolean).join("&");
  }
  function Oc(t10, e = true) {
    let r = "wss://ws.joinplayroom.com";
    return Du() && (r = `wss://${window.location.host}/.proxy/_ws`), t10 != null && t10.websocketBaseUrl && (r = t10 == null ? void 0 : t10.websocketBaseUrl), {}.VITE_APP_SERVER && (r = {}.VITE_APP_SERVER), e ? r : r.replace("wss://", "https://").replace("ws://", "http://");
  }
  class Ul extends gu {
    constructor({
      isHost: e,
      roomId: r,
      isSpectator: n,
      letEveryoneWriteState: i = false,
      enableDeltaCompression: o = false,
      sdkOptions: s
    }) {
      super(), this.hostname = Oc(s), this.isHost = e, this.isSpectator = n, this.roomId = r, this.myId = yb(), this.renderServerId = null, this.lastSeenTimestamp = 0, this.lastUpdateOrderSeen = 0, this.lastUpdateSyncMessageSeen = void 0, this.enableDeltaCompression = o, this.sdkOptions = s, this.playerStates = {}, this.autoAdmitPlayers = true, this.waitingPlayerStates = {}, this.syncIntervalTime = p0.SyncIntervalTime, this.pendingDeletionPlayerIds = [], this.spectatorStates = {}, this.ignoreNextSync = false, this.bootDate = Date.now(), this.wsHeartbeatInterval = 0, this.iUpdatedStateAt = {}, this.requestSyncs = true, this.rpcIdWasCalled = {}, this.rpcCallbacks = {}, this.globalState = JSON.parse(
        JSON.stringify((s == null ? void 0 : s.defaultStates) ?? {})
      ), this.defaultGlobalState = JSON.parse(
        JSON.stringify((s == null ? void 0 : s.defaultStates) ?? {})
      ), this.globalStateReadTime = {}, this.letEveryoneWriteState = i, this.reconnectAttempts = 0, this.joinWebsocket(), mi.identify(F0());
    }
    isRenderServer() {
      return this.myId === this.renderServerId;
    }
    stateHash(e) {
      let r = JSON.stringify(e || this.getAllState());
      const n = ["defaultPlayersStates", "defaultGlobalState"];
      let i = t1(
        JSON.parse(r)
      );
      return n.forEach((o) => {
        delete i[o];
      }), da(Xb(i));
    }
    getBootDate() {
      return this.bootDate;
    }
    getAllState() {
      var e = {
        ...this.globalState,
        defaultGlobalState: this.defaultGlobalState,
        defaultPlayersStates: {},
        __players: {}
      };
      return Object.keys(this.playerStates).forEach((r) => {
        e.__players[r] = this.playerStates[r].getState(), e.defaultPlayersStates[r] = this.playerStates[r].getDefaultState();
      }), Object.keys(this.waitingPlayerStates).length > 0 ? (e.waitingPlayers = [], Object.keys(this.waitingPlayerStates).forEach((r) => {
        e.waitingPlayers.push(this.waitingPlayerStates[r].id);
      })) : delete e.waitingPlayers, e;
    }
    broadcastGlobalState(e = false) {
      const r = this.getAllState();
      let n = { sync: r, o: this.stateHash(r) };
      e && (n.force = true), this.websocketSend(JSON.stringify(n));
    }
    joinWebsocket(e = false) {
      let r = new WebSocket(
        this.hostname + "/api/room/" + this.roomId + "/websocket/" + (this.myId || "new") + // re-use the id I had previously (if any)
        (this.isHost && !e ? "/host" : "") + // make me host (if isHost is set)
        (this.isSpectator ? "/spectator" : "") + (this.sdkOptions ? "?" + Qb(this.sdkOptions) : "")
      );
      r.addEventListener("open", (n) => {
        this.reconnectAttempts = 0, this.emit("connection_opened"), this.ws = r, this.wsHeartbeatInterval = setInterval(() => {
          if (this.isRenderServerOrHostIfNotCasting)
            this.websocketSend(JSON.stringify({ beat: Date.now() })), this.broadcastGlobalState();
          else if (this.requestSyncs) {
            if (this.ignoreNextSync) {
              this.ignoreNextSync = false;
              return;
            }
            const i = this.stateHash();
            this.enableDeltaCompression ? this.websocketSend(
              JSON.stringify({
                beat: Date.now(),
                syncO: i
              })
            ) : this.websocketSend(JSON.stringify({ beat: Date.now() }));
          }
        }, this.syncIntervalTime);
      }), r.addEventListener("error", (n) => {
        throw new Error(n.error);
      }), r.onerror = (n) => {
        throw new Error(
          n.message + " " + (this.hostname + "/api/room/" + this.roomId + "/websocket/" + (this.myId || "new") + // re-use the id I had previously (if any)
          (this.isHost ? "/host" : "") + // make me host (if isHost is set)
          (this.isSpectator ? "/spectator" : ""))
        );
      }, r.addEventListener("message", (n) => {
        var s;
        let i = JSON.parse(n.data);
        if (i.error)
          this.emit("error", { type: "websocket", error: i.error });
        else if (i.newId) {
          if (this.myId = i.newId, xt.set("myId", i.newId), !this.playerStates[this.myId] && !this.isSpectator && (this.playerStates[this.myId] = this.createPlayerState(this.myId)), i.profile && !this.isSpectator) {
            var o = this.playerStates[this.myId].getState("profile") || {};
            this.playerStates[this.myId].setState("profile", {
              ...o,
              ...i.profile
            });
          }
          i.bootDate && (this.bootDate = i.bootDate), this.isHost ? (this.emit("before_initial_sync"), this.broadcastGlobalState(), this.once("sync", (a) => {
            this.emit("connected");
          })) : this.emit("connected");
        } else if (i.joined && this.isRenderServerOrHostIfNotCasting)
          if (this.autoAdmitPlayers) {
            if (!this.playerStates[i.joined]) {
              this.playerStates[i.joined] = this.createPlayerState(
                i.joined,
                false,
                i.proxyBy,
                i.profile
              );
              let a = this.getState("__pOrder") || [];
              a.includes(i.joined) || (a.push(i.joined), this.setState("__pOrder", a));
            }
            this.emitPlayerJoined(this.playerStates[i.joined]);
          } else
            this.pendingDeletionPlayerIds.includes(i.joined) && this.playerStates[i.joined] ? this.playerStates[i.joined].startWebrtc() : this.waitingPlayerStates[i.joined] = this.createPlayerState(
              i.joined
            ), this.pendingDeletionPlayerIds.includes(i.joined) && (this.pendingDeletionPlayerIds = this.pendingDeletionPlayerIds.filter(
              (a) => a !== i.joined
            ));
        else if (i.renderServerUpdate)
          this.renderServerId !== i.renderServerUpdate && (this.renderServerId = i.renderServerUpdate, this.bootDate = i.bootDate, this.isRenderServer() ? (Object.keys(this.playerStates).forEach((a) => {
            this.playerStates[a].startWebrtc();
          }), Object.keys(this.spectatorStates).forEach((a) => {
            this.spectatorStates[a].startWebrtc();
          })) : this.playerStates[this.myId].startWebrtc());
        else if (i.hostUpdate)
          this.isHost = i.hostUpdate === this.myId, this.emit("host_updated", this.isHost), this.isHost && this.isRenderServerOrHostIfNotCasting ? Object.keys(this.playerStates).forEach((a) => {
            this.playerStates[a].startWebrtc();
          }) : this.isSpectator || this.playerStates[this.myId].startWebrtc();
        else if (i.hostUpdateFailed)
          this.emit("host_updated_failed", i.hostUpdateFailed);
        else if (i.spectator)
          this.spectatorStates[i.spectator] || (this.spectatorStates[i.spectator] = this.createPlayerState(
            i.spectator,
            true
          ), this.emit("spectator_joined", this.spectatorStates[i.spectator]));
        else if (i.quit)
          this.playerStates[i.quit] && this.isRenderServerOrHostIfNotCasting && this.autoAdmitPlayers && this.playerStates[i.quit].disconnect(), this.playerStates[i.quit] && this.isRenderServerOrHostIfNotCasting && !this.autoAdmitPlayers && this.pendingDeletionPlayerIds.push(i.quit), this.waitingPlayerStates[i.quit] && this.waitingPlayerStates[i.quit].disconnect(), Ce("pquit", i.quit, this.renderServerId), this.renderServerId, i.quit;
        else if (i.signal)
          this.isRenderServerOrHostIfNotCasting && this.myId !== i.id && (this.playerStates[i.id] || this.spectatorStates[i.id]) ? (Ce(
            "signal to host",
            i.signal,
            `from ${this.playerStates[i.id] ? "player" : ""}${this.spectatorStates[i.id] ? "spectator" : ""}`
          ), this.playerStates[i.id] && this.playerStates[i.id].signal(i.signal), this.spectatorStates[i.id] && this.spectatorStates[i.id].signal(i.signal)) : !this.isRenderServerOrHostIfNotCasting && this.myId === i.for && (Ce("signal to client", i.signal), this.playerStates[this.myId] && this.playerStates[this.myId].signal(i.signal), this.spectatorStates[this.myId] && this.spectatorStates[this.myId].signal(i.signal));
        else if (i.pinput && this.isRenderServerOrHostIfNotCasting)
          this.passPlayerInput(i.id, i.pinput);
        else if (i.pong && this.isRenderServer())
          this.playerStates[i.id] && this.playerStates[i.id].handlePingResponse(i);
        else if (i.ping && !this.isRenderServer() && i.for === this.myId)
          this.websocketSend(
            JSON.stringify({
              pong: i.ping
            })
          );
        else if (i.pstate)
          this.setPlayerState(i);
        else if (i.gstate)
          this.setLocalStateFromServerGlobalState(i.gstate[0], i.gstate[1]);
        else if (i.sync) {
          if (this.emit("sync", i.sync), !this.isRenderServerOrHostIfNotCasting) {
            const { defaultGlobalState: a, ...l } = i.sync;
            this.setFullLocalState(l, i.o), this.setFullDefaultLocalState(a, i.o);
          }
          this.emit("post_sync", i.sync);
        } else if (i.dsync) {
          const a = j0.applyObjectPatch(this.getAllState(), i.dsync);
          this.emit("sync", a), this.emit("dsync", a), this.setFullLocalState(a, i.o), this.emit("post_dsync", a);
        } else
          i.kick ? this.myId === i.kick || this.isRenderServerOrHostIfNotCasting && ((s = this.playerStates[i.kick]) != null && s.isProxyPlayer()) && this.removeProxyPlayer(i.kick) : i.rpc ? this.rpcHandle(i, true) : i.rpcResp ? this.rpcResponseHandle(i, true) : i.default_gstate ? this.setLocalDefaultState(
            i.default_gstate[0],
            i.default_gstate[1]
          ) : i.default_pstate ? this.setDefaultPlayerState(i) : i.timestamp > this.lastSeenTimestamp && (this.emit("message", { type: "reliable", data: i }), this.lastSeenTimestamp = i.timestamp);
      }), r.addEventListener("close", (n) => {
        const i = Object.values(Ln).map(
          (o) => o.code
        );
        Ce("WebSocket closed, reconnecting:", n.code, n.reason), clearInterval(this.wsHeartbeatInterval), n.code === 4e3 ? (this.emit("permission_error"), this.disconnect(n.code)) : n.code === 4001 || n.code === 4002 ? this.disconnect(n.code) : n.reason === "PLAYER_KICKED" ? this.disconnect(n.code, n.reason) : this.wasDisconnectedManually ? (Ce("Websocket was closed manually, not reconnecting"), clearInterval(this.wsHeartbeatInterval)) : i.indexOf(n.code) === -1 && this.reconnectAttempts < 3 ? (clearInterval(this.wsHeartbeatInterval), this.reconnectAttempts++, setTimeout(
          () => {
            var s;
            const o = JSON.parse(
              JSON.stringify((s = this.playerStates[this.myId]) == null ? void 0 : s.getState())
            ) || {};
            this.joinWebsocket(true), this.isRenderServerOrHostIfNotCasting || this.once("post_dsync", (a) => {
              Object.keys(o).forEach((l) => {
                var c;
                (c = this.playerStates[this.myId]) == null || c.setState(
                  l,
                  o[l],
                  true
                );
              });
            });
          },
          this.isHost ? 1e3 : 1500
        )) : this.disconnect(n.code);
      }), r.addEventListener("error", (n) => {
        Ce("WebSocket error, reconnecting:", n, typeof n), clearInterval(this.wsHeartbeatInterval);
      });
    }
    get isRenderServerOrHostIfNotCasting() {
      return !!(this.isRenderServer() || !this.getState("casting") && this.isHost);
    }
    setAutoAdmitPlayers(e) {
      this.isRenderServerOrHostIfNotCasting && this.autoAdmitPlayers !== e && (Ce("setAutoAdmitPlayers", e), !this.autoAdmitPlayers && e && (Object.keys(this.waitingPlayerStates).length > 0 && Object.keys(this.waitingPlayerStates).forEach((r) => {
        this.playerStates[r] = this.waitingPlayerStates[r], this.emitPlayerJoined(this.playerStates[r]);
      }), this.waitingPlayerStates = {}, this.pendingDeletionPlayerIds.forEach((r) => {
        this.playerStates[r] && this.playerStates[r].disconnect();
      }), this.pendingDeletionPlayerIds = []), this.autoAdmitPlayers = e);
    }
    addProxyPlayer() {
      if (this.isRenderServerOrHostIfNotCasting) {
        var e = ja(9);
        return this.broadcast({ joined: e }, true), this.playerStates[e] = this.createPlayerState(e, false, true), this.playerStates[e];
      }
    }
    removeProxyPlayer(e) {
      this.playerStates[e] && this.broadcast({ quit: e }, true);
    }
    kickPlayer(e, r) {
      this.broadcast({ kick: e }, true);
      const n = this.on("player_quit", (i) => {
        i === e && (n(), r());
      });
    }
    transferHost(e, r, n) {
      this.broadcast({ transfer: e }, true), this.once("host_updated", () => {
        r();
      }), this.once("host_updated_failed", (i) => {
        n(i);
      });
    }
    createPlayerState(e, r, n = false, i) {
      var a, l, c;
      let o = JSON.parse(
        JSON.stringify(((a = this.sdkOptions) == null ? void 0 : a.defaultPlayerStates) ?? {})
      );
      i && (o.profile = i);
      var s = new pb({
        websocketSend: (u) => this.websocketSend(u),
        id: e,
        myId: this.myId,
        // isHost: this.isHost,
        isRenderServer: () => this.isRenderServer(),
        isRenderServerOrHostIfNotCasting: () => this.isRenderServerOrHostIfNotCasting,
        playerIsSpectator: r,
        playerIsProxy: n,
        broadcastUnreliable: this.broadcastUnreliable.bind(this),
        setPlayerState: this.setPlayerState.bind(this),
        getBootDate: this.getBootDate.bind(this),
        avatarList: (l = this.sdkOptions) == null ? void 0 : l.avatars,
        kickPlayer: this.kickPlayer.bind(this),
        state: o,
        defaultPlayerState: JSON.parse(
          JSON.stringify(((c = this.sdkOptions) == null ? void 0 : c.defaultPlayerStates) ?? {})
        )
      });
      return (this.isRenderServerOrHostIfNotCasting || e === this.myId) && (Ce(
        "startWebrtc::createPlayerState",
        e,
        this.isRenderServerOrHostIfNotCasting
      ), s.startWebrtc()), s.on("quit", () => {
        Ce("pquit", s.id), delete this.playerStates[s.id], this.emit("players", this.playerStates), this.emit("player_quit", s.id), this.waitingPlayerStates[s.id] && delete this.waitingPlayerStates[s.id];
      }), s.on("global_state_unreliable", (u) => {
        this.setLocalState(u[0], u[1], true);
      }), s.on("rpc_call_unreliable", this.rpcHandle.bind(this)), s;
    }
    emitPlayerJoined(e) {
      bb(e, "profile").then(() => {
        this.emit("joined", e), this.emit("players", this.playerStates);
      });
    }
    broadcastUnreliable(e) {
      Object.keys(this.playerStates).forEach((r) => {
        if (r !== this.myId)
          try {
            Ce("broadcast unreliable", r, e), this.playerStates[r].send(e, false, true);
          } catch (n) {
            Ce(n);
          }
      });
    }
    websocketSend(e) {
      try {
        this.ws.send(e);
      } catch (r) {
        Ce(r);
      }
    }
    rpcHandle(e, r) {
      this.rpcIdWasCalled[e.rid] || (this.rpcIdWasCalled[e.rid] = true, this.emit("rpc", e, r));
    }
    rpcCall(e, r) {
      return this.ws && this.websocketSend(JSON.stringify(e)), new Promise((n, i) => {
        this.rpcCallbacks[e.rid] = {
          resolve: (o) => {
            r && r(o), n(o);
          },
          reject: i
        };
      });
    }
    rpcResponse(e) {
      this.ws && this.websocketSend(JSON.stringify(e));
    }
    rpcResponseHandle(e) {
      this.rpcCallbacks[e.rid] && (this.rpcCallbacks[e.rid].resolve(e.rpcResp), delete this.rpcCallbacks[e.rid]);
    }
    broadcast(e, r) {
      r ? this.ws && this.websocketSend(JSON.stringify(e)) : (Object.keys(this.spectatorStates).forEach((n) => {
        n !== this.myId && this.spectatorStates[n].send(e, r);
      }), Object.keys(this.playerStates).forEach((n) => {
        n !== this.myId && this.playerStates[n].send(e, r);
      }));
    }
    // used by non-hosts, to setState about other players
    setPlayerState(e) {
      var r = false;
      this.playerStates[e.pstate] && (r = this.playerStates[e.pstate].setLocalState(
        e.d[0],
        e.d[1],
        e.o
      )), this.waitingPlayerStates[e.pstate] && (r = this.waitingPlayerStates[e.pstate].setLocalState(
        e.d[0],
        e.d[1],
        e.o
      )), r && (this.ignoreNextSync = true);
    }
    // used by host, triggered when user input is sent to us (via network or controller(for local player))
    passPlayerInput(e, r) {
      this.playerStates[e] ? this.playerStates[e].handleInput(r, true) : this.waitingPlayerStates[e] && this.waitingPlayerStates[e].handleInput(r, true);
    }
    getState(e) {
      return e ? typeof this.globalState[e] == "object" ? JSON.parse(JSON.stringify(this.globalState[e])) : this.globalState[e] : this.globalState || {};
    }
    // public method to change state object (used by host only). This is then synced with all clients.
    setState(e, r, n = true) {
      const i = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r, o = this.setLocalState(e, i);
      (this.isHost || this.isRenderServer() || this.letEveryoneWriteState) && o && (this.iUpdatedStateAt[e] = Date.now(), this.broadcast({ gstate: [e, i] }, n));
    }
    // update local state from the server globalThis state
    setLocalStateFromServerGlobalState(e, r) {
      switch (e) {
        case "round.timer": {
          const n = this.getState("round.timer"), i = r > n ? r : n;
          this.setLocalState(e, i);
          break;
        }
        default: {
          this.setLocalState(e, r);
          break;
        }
      }
    }
    // just change local state without broadcasting
    setLocalState(e, r, n = false) {
      return JSON.stringify(this.globalState[e]) === JSON.stringify(r) ? false : (r === void 0 ? delete this.globalState[e] : this.globalState[e] = r, n && (this.ignoreNextSync = true), this.emit("state", this.globalState, e), true);
    }
    // used to change all of local state to what came from server
    setFullLocalState(e, r) {
      this.lastUpdateOrderSeen = r, this.lastUpdateSyncMessageSeen = JSON.parse(JSON.stringify(e)), this.isHost && (e.path = e.path || this.globalState.path);
      var n = e.__players || {};
      delete e.__players, Object.keys(e).forEach((i) => {
        (!this.iUpdatedStateAt[i] || this.iUpdatedStateAt[i] + this.syncIntervalTime < Date.now()) && this.setLocalState(i, e[i]);
      }), Object.keys(this.globalState).forEach((i) => {
        var o;
        (!this.iUpdatedStateAt[i] || this.iUpdatedStateAt[i] + this.syncIntervalTime < Date.now()) && !e[i] && e[i] !== 0 && (Ce("set default states for the globalState"), this.setLocalState(i, (o = this.defaultGlobalState) == null ? void 0 : o[i]));
      }), Object.keys(n).forEach((i) => {
        var o;
        this.playerStates[i] || (this.playerStates[i] = this.createPlayerState(i), this.emitPlayerJoined(this.playerStates[i])), this.playerStates[i].setFullLocalState(
          n[i],
          r
        ), (o = e == null ? void 0 : e.defaultPlayersStates) != null && o[i] && this.playerStates[i].setFullDefaultLocalState(
          e.defaultPlayersStates[i],
          r
        );
      }), Object.keys(this.playerStates).forEach((i) => {
        i !== this.myId && !n[i] && (e.waitingPlayers || []).indexOf(i) === -1 && (Ce("player removed in state, disconnecting them", i), this.playerStates[i].disconnect());
      });
    }
    getDefaultState(e) {
      return e ? typeof this.defaultGlobalState[e] == "object" ? JSON.parse(JSON.stringify(this.defaultGlobalState[e])) : this.defaultGlobalState[e] : this.defaultGlobalState || {};
    }
    /**
     * store default globalThis states. This will come in handy when we reset the states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      const n = typeof r == "object" ? JSON.parse(JSON.stringify(r)) : r, i = this.setLocalDefaultState(e, n);
      (this.isHost || this.isRenderServer() || this.letEveryoneWriteState) && i && this.broadcast({ default_gstate: [e, n] }, true);
    }
    setLocalDefaultState(e, r) {
      return JSON.stringify(this.defaultGlobalState[e]) === JSON.stringify(r) ? false : (r == null ? delete this.defaultGlobalState[e] : this.defaultGlobalState[e] = r, true);
    }
    setFullDefaultLocalState(e) {
      this.defaultGlobalState = {
        ...this.defaultGlobalState,
        ...e
      };
    }
    setDefaultPlayerState(e) {
      this.playerStates[e.default_pstate] && this.playerStates[e.default_pstate].setDefaultLocalState(
        e.d[0],
        e.d[1],
        e.o
      );
    }
    getHostname(e = true) {
      return Oc(this.sdkOptions, e);
    }
    disconnect(e, r) {
      Ce("disconnecting with eventCode:", e, r), r === "MANUAL_DISCONNECT" && (this.wasDisconnectedManually = true), this.emit("disconnected", { eventCode: e, reason: r }), Object.keys(this.playerStates).forEach((n) => {
        this.playerStates[n].disconnect({ eventCode: e });
      }), Object.keys(this.waitingPlayerStates).forEach((n) => {
        this.waitingPlayerStates[n].disconnect({ eventCode: e });
      }), this.ws && this.ws.close();
    }
  }
  function ha(t10, e) {
    e || (e = "123456789ABCDEFGHIJKLMNPQRSTUVWXYZ");
    for (var r = "", n = t10; n > 0; --n)
      r += e[Math.floor(Math.random() * e.length)];
    return r;
  }
  const Gb = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Vi = {
    ROOMSTATE: "ROOMSTATE",
    GAMESTATE: "GAMESTATE",
    USERSTATE: "USERSTATE"
  }, Zb = {
    ROOMSTATE: "Room",
    GAMESTATE: "Game",
    USERSTATE: "User"
  };
  async function $b(t10) {
    var e, r;
    if (t10.t = Date.now(), t10.timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone, t10.localTime = (/* @__PURE__ */ new Date()).toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }), t10.weekday = Gb[(/* @__PURE__ */ new Date()).getDay()], typeof window < "u" && ((e = window == null ? void 0 : window._PLAYROOM_CONFIG) != null && e.sdkMode)) {
      if (t10.sdkMode = true, t10.sdkVersion = (r = window == null ? void 0 : window._PLAYROOM_CONFIG) == null ? void 0 : r.sdkVersion, define_process_env_default.NODE_ENV !== "production")
        return Ce("analytics:", t10);
      try {
        mi.track(
          `${Zb[t10.type]}: ${t10.event || ""}`,
          t10
        );
      } catch (n) {
        console.error(n);
      }
    }
  }
  function md(t10, e) {
    return Oc(t10, false) + e;
  }
  let jr, ir, pa;
  async function e3(t10, e, r) {
    if (!t10.gameId) {
      r("gameId is required for Discord mode");
      return;
    }
    if (!Du()) {
      console.warn(
        "Discord mock mode is active. To see the Discord mode in action, run the game inside Discord."
      );
      let a = {
        ...t10,
        skipLobby: true
      };
      e(a);
      return;
    }
    let n = null, i = typeof t10.discord == "object" ? t10.discord : {};
    i.scope ? (i.scope.includes("identify") || i.scope.push("identify"), i.scope.includes("guilds.members.read") || i.scope.push("guilds.members.read")) : i.scope = [
      "identify",
      "guilds.members.read",
      "applications.commands"
      // this scope enables features like DM
    ], i.prompt || (i.prompt = "none"), i.state || (i.state = "");
    let o;
    try {
      pa = await c3();
      const { DiscordSDK: a } = pa, l = await fetch(
        `${md(t10, "/api/discord/client_id")}?gameId=${t10.gameId}`
      ), { client_id: c } = await l.json(), u = new a(c);
      await u.ready();
      const { code: f } = await u.commands.authorize({
        ...i,
        client_id: c,
        response_type: "code"
      });
      ir = u, o = "DCRD_" + ir.instanceId, t10.persistentMode && (o = "PER_" + o);
      const d = await fetch(
        `${md(t10, "/api/discord/auth")}?gameId=${t10.gameId}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            code: f,
            redirect_uri: window.location.href,
            roomId: o
          })
        }
      ), { access_token: h, jwt: g } = await d.json();
      g && sessionStorage.setItem("pr_dcd_jwt", g), jr = await ir.commands.authenticate({
        access_token: h
      }), n = await t3(), n._discord_id && xt.set("myId", "DCD-" + n._discord_id);
    } catch (a) {
      r(a);
      return;
    }
    let s = {
      ...t10,
      skipLobby: true,
      roomCode: o,
      profile: n
    };
    e(s);
  }
  async function t3() {
    if (!jr)
      return { name: "", photo: "", _discord_id: "" };
    const t10 = jr.user;
    let e = null, r = "";
    if (ir != null && ir.guildId) {
      const { user: i, avatarSrc: o } = await r3({ auth: jr });
      e = i, r = o;
    }
    if (!e) {
      const { user: i, avatarSrc: o } = await n3({ auth: jr });
      e = i, r = o;
    }
    return r || (r = i3(t10)), { name: o3({ discordUser: e }) ?? "", photo: r, _discord_id: t10.id };
  }
  async function r3(t10) {
    try {
      const { auth: e } = t10, r = e.user, i = await (await fetch(
        `https://discord.com/api/users/@me/guilds/${ir.guildId}/member`,
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${e.access_token}`
          }
        }
      )).json();
      let o = "";
      return i != null && i.avatar ? o = `https://cdn.discordapp.com/guilds/${ir.guildId}/users/${r.id}/avatars/${i.avatar}.png?size=256` : r != null && r.avatar && (o = r1(r)), { avatarSrc: o, user: i };
    } catch (e) {
      return console.log(e), { avatarSrc: "", user: null };
    }
  }
  async function n3(t10) {
    try {
      const { auth: e } = t10, r = e.user;
      let n = "";
      return r.avatar && (n = r1(r)), { avatarSrc: n, user: r };
    } catch (e) {
      return console.log(e), { avatarSrc: "", user: null };
    }
  }
  function i3(t10) {
    const e = parseInt(t10.discriminator);
    return `https://cdn.discordapp.com/embed/avatars/${Number.isNaN(e) ? 0 : e % 5}.png`;
  }
  function r1(t10) {
    return `https://cdn.discordapp.com/avatars/${t10.id}/${t10 == null ? void 0 : t10.avatar}.png?size=256`;
  }
  function o3(t10) {
    var r, n;
    const { discordUser: e } = t10;
    return e ? s3(e) ? (e == null ? void 0 : e.nick) || ((r = e == null ? void 0 : e.user) == null ? void 0 : r.global_name) || ((n = e == null ? void 0 : e.user) == null ? void 0 : n.username) : a3(e) ? (e == null ? void 0 : e.global_name) || (e == null ? void 0 : e.username) : "" : "";
  }
  function s3(t10) {
    return "nick" in t10;
  }
  function a3(t10) {
    return "global_name" in t10 || "username" in t10;
  }
  async function sE() {
    if (!ir || !pa)
      throw new Error(
        "Discord not initialized. Call insertCoin() first with 'discord' option set."
      );
    const { PermissionUtils: t10, Permissions: e } = pa;
    try {
      const { permissions: r } = await ir.commands.getChannelPermissions();
      if (t10.can(e.CREATE_INSTANT_INVITE, r))
        await ir.commands.openInviteDialog();
      else
        throw console.warn("User does not have CREATE_INSTANT_INVITE permissions"), new Error("User does not have CREATE_INSTANT_INVITE permissions");
    } catch {
      throw new Error("Failed to open invite dialog");
    }
  }
  function l3() {
    return ir;
  }
  function aE() {
    return jr == null ? void 0 : jr.access_token;
  }
  function lE() {
    return jr;
  }
  async function c3() {
    return await Promise.resolve().then(() => index);
  }
  class u3 extends gu {
    constructor(e = {}) {
      super(), this.connection = false, this.currentRoom = false, this.isConnected = false, this.singlePlayerMode = false, this.letEveryoneWriteState = false, this.sdkOptions = e;
    }
    createRoom(e, r = false, n = false) {
      this.letEveryoneWriteState = r, e || (e = this._generateRoomId()), e = e.toUpperCase(), this.connection = new Ul({
        isHost: true,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: n,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    isRenderServer() {
      if (this.connection)
        return this.connection.isRenderServer();
    }
    // Abstracted helper functions
    get isMultiplayerCastScreen() {
      return !!(!this.singlePlayerMode && this.isSpectator() && !this.isHost());
    }
    get isHost() {
      return this.connection ? this.connection.isHost : false;
    }
    get isSpectator() {
      return this.connection ? this.connection.isSpectator : false;
    }
    get isRenderServerOrHostIfNotCasting() {
      return !!(this.connection && this.connection.isRenderServerOrHostIfNotCasting);
    }
    listenToEvents() {
      this.connection.on("joined", (e) => {
        this.emit("joined", e), this.isRenderServerOrHostIfNotCasting && this.roomLog(Vi.ROOMSTATE, "player_joined", {
          playerId: e.id
        });
      }), this.connection.on("player_quit", (e) => {
        this.isRenderServerOrHostIfNotCasting && this.roomLog(Vi.ROOMSTATE, "player_quit", {
          playerId: e
        });
      }), this.connection.on("state", (e, r) => {
        this.emit("state", e, r);
      }), this.connection.on("host_updated", (e) => {
        e && (this.getState("uid") || (this.setState("uid", ja(7)), this.setState("id", this.currentRoom), this.setState("meta", {
          creatorUserId: this.connection.myId,
          creatorPermId: F0()
        })));
      }), this.connection.on("rpc", (e) => {
        this.emit("rpc", e);
      }), this.connection.on("connected", () => {
        this.isConnected = true, this.emit("connected"), this.isHost && (this.emit("room_created", { id: this.currentRoom }), this.roomLog(Vi.ROOMSTATE, "room_created", {
          host: this.connection.myId
        }));
      }), this.connection.on("reconnecting", () => {
        this.emit("reconnecting");
      }), this.connection.on("permission_error", () => {
        this.isHost ? this.createRoom() : (this.isConnected = false, this.emit("permission_error"));
      }), this.connection.on("host_left", () => {
        this.isConnected = false, this.emit("host_left");
      }), this.connection.on("disconnected", (e) => {
        this.isConnected = false, this.emit("disconnected", e);
      }), this.connection.on("players", (e) => {
        Object.keys(this.connection.playerStates).length > 0 && (this.singlePlayerMode = false), this.emit("players", e);
      }), this.connection.on("host_updated", (e) => {
        this.emit("host_updated", e);
      });
    }
    _waitforConnection() {
      return new Promise((e) => {
        this.isConnected ? e() : this.once("connected", e);
      });
    }
    on(e, r, n) {
      return e === "joined" && this._waitforConnection().then(() => {
        const i = this.getState("__pOrder") || [];
        Object.keys(
          this.connection.playerStates
        ).sort((s, a) => {
          const l = i.indexOf(s), c = i.indexOf(a);
          return l === -1 && c === -1 ? 0 : l === -1 ? 1 : c === -1 ? -1 : l - c;
        }).forEach((s) => {
          r(this.connection.playerStates[s]);
        });
      }), e === "players" && this._waitforConnection().then(() => {
        r(this.connection.playerStates);
      }), super.on(e, r, n);
    }
    once(e, r) {
      return e === "connection_initiated" && this.connection && r(), super.once(e, r);
    }
    setDeltaCompression(e) {
      this.connection.enableDeltaCompression = e;
    }
    joinRoom(e, r = false, n = false) {
      this.letEveryoneWriteState = r, e || (e = this._generateRoomId()), e = e.toUpperCase(), this.connection = new Ul({
        isHost: false,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: n,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    _generateRoomId() {
      var e;
      return (e = this.sdkOptions) != null && e.persistentMode ? `PER_${ha(26)}` : ha(4);
    }
    spectateRoom(e, r, n = false, i = false) {
      this.letEveryoneWriteState = n, e || (e = this._generateRoomId()), r && (this.singlePlayerMode = true), e = e.toUpperCase(), this.connection = new Ul({
        isSpectator: true,
        roomId: e,
        letEveryoneWriteState: this.letEveryoneWriteState,
        enableDeltaCompression: i,
        sdkOptions: this.sdkOptions
      }), this.currentRoom = e, this.listenToEvents(), this.emit("connection_initiated");
    }
    leaveRoom() {
      this.connection.disconnect(void 0, "MANUAL_DISCONNECT"), this.currentRoom = false, delete this.connection;
    }
    getState(e) {
      return this.connection ? e ? this.connection.getState(e) : this.connection.getState() : e === void 0 ? {} : void 0;
    }
    // get default globalThis state
    getDefaultState(e) {
      return this.connection ? e ? this.connection.getDefaultState(e) : this.connection.getDefaultState() : e === void 0 ? {} : void 0;
    }
    // host only: public method to change state object. This is then synced with all clients.
    setState(e, r, n = true) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setState(e, r, n));
    }
    /**
     * store default globalThis states. This will come in handy when we reset the states,
     * we will replace the states with these default states.
     */
    setDefaultState(e, r) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setDefaultState(e, r));
    }
    setRoundState(e, r, n = true) {
      this.connection && (this.isSpectator && !this.isRenderServer() || this.connection.setState(`round.${e}`, r, n));
    }
    getRoundState(e) {
      if (!this.connection)
        return {};
      if (e)
        return this.connection.getState(`round.${e}`);
      {
        let r = {};
        return Object.keys(this.connection.getState()).forEach((n) => {
          n.startsWith("round.") && (r[n.substring(6)] = this.connection.getState(n));
        }), r;
      }
    }
    resetRoundState() {
      Object.keys(this.connection.getState()).forEach((e) => {
        e.startsWith("round.") && this.connection.setState(e, void 0);
      }), Object.keys(this.connection.playerStates).forEach((e) => {
        this.connection.playerStates[e].resetRoundState();
      }), Object.keys(this.connection.spectatorStates).forEach((e) => {
        this.connection.spectatorStates[e].resetRoundState();
      });
    }
    // host only: we maintain a running log of winner per game, we use this to calculate leaderboard score
    addToWinLog(e, r) {
      let n = this.getState("winslog") || [];
      const i = Date.now();
      if (Ce("winnerPlayerId in addToWinLog:", r), typeof r == "object") {
        const o = r.map((s, a) => (this.gameLog("winner", { winnerId: s, gameId: e }), [e, s, i]));
        n = n.concat(o);
      } else
        this.gameLog("winner", { winnerId: r, gameId: e }), n.push([e, r, i]);
      Ce("currentLog (to be winslog): ", n), this.setState("winslog", n);
    }
    getMyPlayerState() {
      if (this.connection)
        return this.isSpectator ? this.connection.spectatorStates[this.connection.myId] : this.connection.playerStates[this.connection.myId];
    }
    // RenderServer only: add a stream to all spectator's webrtc
    addRenderStream(e) {
      if (!this.isRenderServer)
        return;
      const r = Object.values(this.connection.spectatorStates).filter(
        (i) => i.id !== this.connection.myId
      );
      return Ce("addRenderStream", r), r.forEach((i) => i.peer.addStream(e)), this.connection.on("spectator_joined", (i) => {
        Ce("spectator_joined", i), i.once("webrtc_connected", () => {
          setTimeout(() => {
            Ce("adding stream"), i.peer.addStream(e);
          }, 5e3);
        });
      });
    }
    // RenderServer only: remove a stream to all spectator's webrtc
    removeRenderStream(e) {
      if (!this.isRenderServer)
        return;
      const r = Object.values(this.connection.spectatorStates).filter(
        (n) => n.id !== this.connection.myId
      );
      Ce("removeRenderStream", r), r.forEach((n) => n.peer.removeStream(e));
    }
    getPlayers() {
      return this.connection ? this.singlePlayerMode ? this.connection.spectatorStates : this.connection.playerStates : {};
    }
    attachController(e) {
      this.detachControllerLegacy();
      var r = this.connection.playerStates[this.connection.myId];
      r && r.attachControllerLegacy(e);
    }
    detachControllerLegacy() {
      var e = this.connection.playerStates[this.connection.myId];
      e && e.detachControllerLegacy();
    }
    navigate(e, r) {
      if (this.connection && (this.isRenderServer() || this.isHost)) {
        var n = { pathname: e };
        r && (n.state = JSON.stringify(r)), this.setState("path", n), this.roomLog(Vi.ROOMSTATE, "navigate", n);
      }
    }
    async roomLog(e, r, n) {
      var i;
      if (this.connection && this.isRenderServerOrHostIfNotCasting) {
        const o = { ...n };
        o.type = e, o.event = r, o.roomId = this.currentRoom, o.roomUid = this.getState("uid"), this.getState("meta") && (n = { ...n, ...this.getState("meta") });
        const s = Object.keys(this.getPlayers());
        o.playersInRoom = s.length, this.getState("playlist") && (o.playlist = this.getState("playlist")), (i = this.sdkOptions) != null && i.gameId && (o.gameId = this.sdkOptions.gameId), await $b(o);
      }
    }
    async gameLog(e, r) {
      this.connection && this.isRenderServerOrHostIfNotCasting && (r = r || {}, await this.roomLog(Vi.GAMESTATE, e, r, true));
    }
    shareEditorConfigurationWithAllClients(e, r, n) {
      this.connection && this.connection.setState(e, r, n);
    }
    setSDKOptions(e) {
      this.sdkOptions = e;
    }
    _getPersistentRoomId() {
      var r, n, i;
      if ((r = this.sdkOptions) != null && r.discord) {
        var e = l3();
        return e ? `PER_DCRD_G${(n = this.sdkOptions) == null ? void 0 : n.gameId}_${e.guildId || e.channelId}` : `PER_${(i = this.sdkOptions) == null ? void 0 : i.gameId}_${this.currentRoom}`;
      }
      return this.currentRoom;
    }
    async setPersistentData(e, r) {
      if (!this.connection)
        return;
      const n = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_set", o = await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e,
          value: r
        })
      });
      if (o.status !== 200)
        throw new Error("Failed to set persistent state");
      {
        const s = await o.json();
        return s.data ? s.data[0] : void 0;
      }
    }
    async getPersistentData(e) {
      if (!this.connection)
        return;
      const r = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_get", i = await fetch(r, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e
        })
      });
      if (i.status !== 200)
        throw new Error("Failed to get persistent state");
      {
        const o = await i.json();
        return o.data ? o.data[0] : void 0;
      }
    }
    async insertPersistentData(e, r) {
      if (!this.connection)
        return;
      const n = this.connection.getHostname(false) + "/api/room/" + this._getPersistentRoomId() + "/persistence_insert", o = await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          key: e,
          value: r
        })
      });
      if (o.status !== 200)
        throw new Error("Failed to insert persistent state");
      return (await o.json()).index;
    }
  }
  const Ie = (() => {
    let t10 = null;
    const e = (r) => {
      var n;
      return t10 && !((n = t10 == null ? void 0 : t10.getState) != null && n.call(t10, "__launched")) && r && t10.setSDKOptions(r), t10 || (t10 = new u3(r)), t10;
    };
    return e.reset = () => {
      t10 = null;
    }, e;
  })();
  function zl(t10, e) {
    return Object.keys(t10).map((i) => t10[i]).sort((i, o) => {
      const s = e.indexOf(i.id), a = e.indexOf(o.id);
      return s === -1 && a === -1 ? 0 : s === -1 ? 1 : a === -1 ? -1 : s - a;
    });
  }
  function Va(t10) {
    const e = Ie(), [r, n] = reactExports.useState(
      zl(e.getPlayers(), e.getState("__pOrder") || [])
    );
    return n1(() => {
      t10 && n(
        zl(
          e.getPlayers(),
          e.getState("__pOrder") || []
        )
      );
    }), reactExports.useEffect(() => e.on(
      "players",
      (o) => {
        n(
          zl(o, e.getState("__pOrder") || [])
        );
      },
      true
    ), []), r;
  }
  function f3(t10, e) {
    const r = Ie(), n = r.getDefaultState(t10) ?? e;
    n !== void 0 && r.getState(t10) === void 0 && r.setDefaultState(t10, n);
    const [i, o] = reactExports.useState(
      r.getState(t10) !== void 0 ? r.getState(t10) : n
    );
    return reactExports.useEffect(() => (r.getState(t10) !== i && o(r.getState(t10) ?? n), r.on("state", (a, l) => {
      t10 && l === t10 ? a !== a[l] && o(a[l]) : t10 || o(a);
    })), []), i;
  }
  function n1(t10) {
    const e = Ie();
    reactExports.useEffect(() => {
      var r = [];
      return r.push(
        e.on(
          "joined",
          (n) => {
            r.push(
              n.on(
                "state",
                (i, o) => {
                  t10(n.id, i, n.state, n);
                },
                true
              )
            );
          },
          true
        )
      ), () => {
        r.forEach((n) => n());
      };
    }, []);
  }
  function d3(t10, e, r) {
    const n = t10.getDefaultState(e) ?? r;
    n !== void 0 && t10.getState(e) === void 0 && t10.setDefaultState(e, n);
    const [i, o] = reactExports.useState(
      t10.getState(e) !== void 0 ? t10.getState(e) : n
    );
    return reactExports.useEffect(() => {
      const s = t10.getState(e) ?? n;
      o(s), t10.setState(e, s);
    }, []), reactExports.useEffect(() => t10.on("state", (a, l) => {
      a === e && o(t10.getState(e));
    }), []), i;
  }
  function h3(t10, e, r) {
    const [n, i] = reactExports.useState(Math.random());
    return reactExports.useEffect(() => {
      const o = t10.map(
        (s) => s.on(
          "state",
          (a, l) => {
            a === e && i(Math.random());
          },
          true
        )
      );
      return () => {
        o.forEach((s) => s());
      };
    }, [t10, e]), (t10 == null ? void 0 : t10.map((o) => ({
      playerId: o.id,
      state: o.getState(e)
    }))) || r || [];
  }
  function cE(t10) {
    const e = Va();
    return h3(e, t10, void 0).map((n) => ({
      player: e.find((i) => i.id === n.playerId),
      state: n.state
    }));
  }
  function Mu() {
    const t10 = Ie(), [e, r] = reactExports.useState(t10.isHost);
    return reactExports.useEffect(() => (setTimeout(() => {
      r(t10.isHost);
    }, 50), t10.on("host_updated", () => {
      r(t10.isHost);
    })), [t10.isHost]), e;
  }
  function yi(t10, e) {
    return [
      f3(t10, e),
      (r, n) => Ie().setState(t10, r, n)
    ];
  }
  function uE(t10, e, r) {
    return [
      d3(t10, e, r),
      (n, i) => t10.setState(e, n, i)
    ];
  }
  async function fE(t10 = []) {
    return new Promise((e, r) => {
      try {
        const n = Ie(), i = [
          "id",
          "meta",
          "uid",
          "__launched",
          "casting",
          "__pOrder"
        ], o = n.getState();
        Object.keys(o).forEach((s) => {
          if (!i.includes(s) && !t10.includes(s)) {
            const a = n.getDefaultState(s);
            n.setState(s, a);
          }
        }), e(true);
      } catch (n) {
        r(n);
      }
    });
  }
  function dE(t10 = []) {
    return new Promise((e, r) => {
      try {
        const n = Ie(), i = [
          "profile",
          "__proxyBy",
          "__gamepad",
          "__bot"
        ], o = n == null ? void 0 : n.getPlayers();
        Object.keys(o).forEach((s) => {
          var l;
          const a = (l = o[s]) == null ? void 0 : l.state;
          a && Object.keys(a).forEach((c) => {
            if (!i.includes(c) && !t10.includes(c)) {
              const u = o[s].getDefaultState(c);
              o[s].setState(c, u);
            }
          });
        }), e(true);
      } catch (n) {
        r(n);
      }
    });
  }
  function hE(t10) {
    return Ie().on("joined", t10);
  }
  function pE(t10) {
    return Ie().on("live:tiktok:msg", t10);
  }
  function gE(t10, e, r) {
    Ie().setState(t10, e, r);
  }
  function mE(t10) {
    return Ie().getState(t10);
  }
  function yE() {
    return Ie().isHost;
  }
  function p3() {
    return Ie().isSpectator;
  }
  function i1(t10, e) {
    const n = Ie().getMyPlayerState();
    e ? n.handleKeyDown(t10) : n.handleKeyUp(t10);
  }
  function bE(t10) {
    i1(t10, true);
  }
  function vE(t10) {
    i1(t10, false);
  }
  function Hn() {
    return Ie().getMyPlayerState();
  }
  function o1(t10) {
    return t10.replace(
      /https:\/\/play\.joinplayroom\.app\/games\//,
      ""
    ).split("/")[0];
  }
  function s1(t10) {
    const e = /https:\/\/play\.joinplayroom\.app/;
    return new RegExp(e, "g").test(t10);
  }
  function g3(t10, e) {
    return s1(t10) ? `https://joinplayroom.com/launch/${o1(t10)}/R${e ?? ""}` : `${t10}R${e ?? ""}`;
  }
  function m3(t10, e) {
    return s1(t10) ? `https://joinplayroom.com/app-launcher.html?game=${o1(t10)}&room=R${e}` : `${t10}R${e ?? ""}`;
  }
  function AE() {
    return Ie().currentRoom;
  }
  function wE(t10) {
    return Ie().connection.on("disconnected", (r) => {
      let n;
      Object.values(Ln).forEach((i) => {
        r.eventCode === i.code && (n = i);
      }), t10(n || Ln.unknown);
    });
  }
  const go = {
    ALL: 0,
    OTHERS: 1,
    HOST: 2
  };
  function y3(t10, e) {
    const r = Ie();
    return r.on("rpc", async (n) => {
      const [i, o, s, a] = n.rpc, l = n.rid;
      if (o !== t10)
        return;
      switch (a) {
        case go.ALL:
          break;
        case go.OTHERS:
          if (i === r.getMyPlayerState().id)
            return;
          break;
        case go.HOST:
          if (!r.isHost)
            return;
          break;
        default:
          return;
      }
      const c = r.getPlayers()[i], u = await e(s, c, a);
      u !== void 0 && r.connection.rpcResponse({ rpcResp: u, rid: l });
    });
  }
  function b3(t10, e, r = go.ALL, n) {
    const i = Ie(), o = ha(5);
    return i.connection.rpcCall(
      {
        rpc: [
          i.getMyPlayerState().id,
          // sender
          t10,
          // RPC identifier
          e,
          // RPC payload,
          r
          // RPC mode
        ],
        rid: o
      },
      n
    );
  }
  function v3(t10, e) {
    return Ie().setPersistentData(t10, e);
  }
  function a1(t10) {
    return Ie().getPersistentData(t10);
  }
  function A3(t10, e) {
    return Ie().insertPersistentData(t10, e);
  }
  const xE = {
    Mode: go,
    register: y3,
    call: b3
  };
  async function _E() {
    const t10 = Ie();
    if (t10.isHost)
      return t10.setState("__matchmakingqueue", true), new Promise((e, r) => {
        t10.once("matchmaking_room_joined", e);
      });
    throw new Error("Only host can start matchmaking");
  }
  async function SE(t10) {
    const e = Ie();
    return new Promise((r, n) => {
      if (typeof t10 != "string" && n("Input is not of the string type."), e.isHost) {
        if (!e.connection.playerStates[t10]) {
          n(`Player: ${t10} is not belonged to this room.`);
          return;
        }
      } else {
        n("Only the host can transfer.");
        return;
      }
      e.connection.transferHost(t10, r, n);
    });
  }
  function w3() {
    const t10 = navigator.userAgent || navigator.vendor || window.opera, e = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(t10), r = /iPhone|iPad|iPod/i.test(t10) && !window.MSStream && (window.navigator.standalone || t10.includes("Safari") && !t10.includes("CriOS") && !t10.includes("FxiOS")), n = /android/i.test(t10) && t10.includes("wv");
    return e || r || n;
  }
  const x3 = {
    listen: true
  };
  class _3 {
    constructor(e, r = x3) {
      this.playerState = e, this.keyboardConfig = r, this.keysPressed = /* @__PURE__ */ new Set(), this.debounceTimeout = 0, this.debounceDelay = 20, this.validCombinations = /* @__PURE__ */ new Set([
        "S",
        "DS",
        "D",
        "DW",
        "W",
        "AW",
        "A",
        "AS"
      ]), this.state = { isPressed: false, angle: 0, keysPressed: "" }, this.handleKeyDown = this.handleKeyDown.bind(this), this.handleKeyUp = this.handleKeyUp.bind(this), this.updateState = this.updateState.bind(this), this.debounceUpdate = this.debounceUpdate.bind(this), this.playerState.id === Hn().id && this.keyboardConfig.listen && this.listen();
    }
    handleKeyDown(e) {
      const r = e.key.toUpperCase();
      ["W", "A", "S", "D"].includes(r) && (this.keysPressed.add(r), this.debounceUpdate());
    }
    handleKeyUp(e) {
      const r = e.key.toUpperCase();
      ["W", "A", "S", "D"].includes(r) && (this.keysPressed.delete(r), this.debounceUpdate());
    }
    debounceUpdate() {
      clearTimeout(this.debounceTimeout), this.debounceTimeout = window.setTimeout(
        this.updateState,
        this.debounceDelay
      );
    }
    updateState() {
      const e = Array.from(this.keysPressed).sort().join("");
      let r = this.state.angle;
      switch (e) {
        case "S":
          r = 0;
          break;
        case "DS":
          r = Math.PI / 4;
          break;
        case "D":
          r = Math.PI / 2;
          break;
        case "DW":
          r = 3 * Math.PI / 4;
          break;
        case "W":
          r = Math.PI;
          break;
        case "AW":
          r = 5 * Math.PI / 4;
          break;
        case "A":
          r = -Math.PI / 2;
          break;
        case "AS":
          r = -Math.PI / 4;
          break;
      }
      this.state = {
        isPressed: this.validCombinations.has(e),
        // Check if keys form a valid combination
        angle: r,
        keysPressed: e
      }, this.playerState.id === Hn().id && (this.playerState.setState("ctr-joystick", this.state.isPressed), this.playerState.setState("ctr-angle", this.state.angle), this.playerState.setState("ctr-keys", this.state.keysPressed));
    }
    isPressed() {
      return this.playerState.getState("ctr-joystick") || false;
    }
    angle() {
      return this.playerState.getState("ctr-angle") || 0;
    }
    keys() {
      return this.playerState.getState("ctr-keys") || "";
    }
    listen() {
      window.addEventListener("keydown", this.handleKeyDown), window.addEventListener("keyup", this.handleKeyUp);
    }
    destroy() {
      clearTimeout(this.debounceTimeout), window.removeEventListener("keydown", this.handleKeyDown), window.removeEventListener("keyup", this.handleKeyUp), this.playerState.setState("ctr-joystick", false), this.playerState.setState("ctr-angle", 0), this.playerState.setState("ctr-keys", "");
    }
  }
  function qi(t10) {
    let e = {};
    return t10.type === "pointerdown" || t10.type === "pointermove" || t10.type === "pointerup" ? e.changedTouches = [
      {
        clientX: t10.clientX,
        clientY: t10.clientY,
        identifier: t10.pointerId
      }
    ] : (t10.type === "touchstart" || t10.type === "touchmove" || t10.type === "touchend") && (e = t10), e;
  }
  function S3(t10) {
    var e = Math.PI / 2, r, n;
    t10 > -e && t10 < e ? r = "right" : r = "left", t10 > 0 ? n = "up" : n = "down";
    let i = {};
    return r && (i.x = r), n && (i.y = n), i;
  }
  function E3(t10) {
    var e = Math.PI / 4, r;
    return t10 > e && t10 < e * 3 ? r = "up" : t10 > -e && t10 <= e ? r = "right" : t10 > -e * 3 && t10 <= -e ? r = "down" : r = "left", r;
  }
  const hs = {
    userSelect: "none",
    position: "fixed",
    transition: "opacity 0.3s 0.1s",
    willChange: "opacity",
    height: "70px",
    width: "95px",
    right: "0px",
    backgroundSize: "25px",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    fontSize: "15px",
    fontFamily: "sans-serif"
  }, ps = {
    position: "absolute",
    top: "calc(50% - 30px)",
    left: "calc(50% - 30px)",
    height: "60px",
    width: "60px",
    border: "2px solid #fff",
    borderRadius: "10px",
    boxSizing: "border-box",
    opacity: "0.25",
    willChange: "opacity"
  }, yd = {
    position: "absolute",
    backgroundSize: "25px",
    top: "10px",
    left: "10px",
    width: "calc(100% - 20px)",
    height: "calc(100% - 20px)",
    display: "flex",
    backgroundRepeat: "no-repeat",
    color: "#fff",
    fontSize: "15px",
    fontFamily: "sans-serif"
  }, gs = [
    {
      element: { ...hs, bottom: "15px" },
      border: { ...ps }
    },
    {
      element: { ...hs, bottom: "calc(70px + 15px)" },
      border: { ...ps }
    },
    {
      element: { ...hs, bottom: "calc(70px * 2 + 15px)" },
      border: { ...ps }
    },
    {
      element: { ...hs, bottom: "calc(70px * 3 + 15px)" },
      border: { ...ps }
    }
  ], Ic = {
    type: "angular",
    buttons: [],
    zones: {},
    keyboard: true
  };
  function k3(t10 = {}) {
    if (t10.type = t10.type || Ic.type, t10.zones = t10.zones || Ic.zones, t10.buttons && t10.buttons.length > 0) {
      if (gs.length < t10.buttons.length)
        throw new Error(`Only ${gs.length} buttons are supported.`);
      t10.buttons = t10.buttons.map((e, r) => {
        var i, o;
        let n = {
          ...e,
          css: {
            element: {
              ...gs[r].element,
              ...(i = e.css) == null ? void 0 : i.element
            },
            border: { ...gs[r].border, ...(o = e.css) == null ? void 0 : o.border }
          }
        };
        return e.icon && (n.css.element.backgroundImage = `url(${e.icon})`), n;
      });
    }
    return t10;
  }
  class Pc {
    constructor(e, r = Ic) {
      var n, i, o;
      this.buttons = {}, this.joystick = {}, this.playerState = e, this.multiplayer = Ie(), this.allowGamepads = (i = (n = this.multiplayer) == null ? void 0 : n.sdkOptions) == null ? void 0 : i.allowGamepads, this.requestAnimationFrameId = null, this.allowGamepads && (!r.buttons || r.buttons.length === 0) && (r.buttons = [
        { id: "button1", label: "A" },
        { id: "button2", label: "B" },
        { id: "button3", label: "X" },
        { id: "button4", label: "Y" }
      ]), r = k3(r), this.validateConfig(r), this.config = r, this.multiplayer.sdkOptions && (this.multiplayer.sdkOptions.joystickConfig = this.config), e.id === Hn().id && this.initControls(r), (o = this.config) != null && o.keyboard && (this.keyboardControllerInstance = new _3(this.playerState));
    }
    validateConfig(e) {
      if (this.allowGamepads && e.zones && Object.keys(e.zones).length > 0)
        throw new Error(
          "Joystick zones don't work when allowGamepads is enabled"
        );
    }
    isAnyButtonPressed() {
      return (this.config.buttons || []).some((e) => this.isPressed(e.id));
    }
    isPressed(e) {
      return this.playerState.getState("ctr-" + e) || false;
    }
    isJoystickPressed() {
      return this.isPressed("joystick") || false;
    }
    angle() {
      return this.playerState.getState("ctr-angle") || 0;
    }
    dpad() {
      return this.playerState.getState("ctr-dpad") || {};
    }
    initControls(e) {
      (w3() || !e.keyboard) && this.setupJoystick(e.zones), e.buttons && e.buttons.length > 0 && e.buttons.forEach((r) => {
        this.setupButton(r);
      });
    }
    setupJoystick(e) {
      this.joystick.active = false, this.joystick.$element = document.createElement("div"), this.joystick.$element.id = "pr-joystick", this.joystick.$element.style.userSelect = "none", this.joystick.$element.style.position = "fixed", this.joystick.$element.style.bottom = "10px", this.joystick.$element.style.left = "10px", this.joystick.$element.style.width = "170px", this.joystick.$element.style.height = "170px", this.joystick.$element.style.borderRadius = "50%", this.joystick.$element.style.transition = "opacity 0.3s 0.0s", this.joystick.$element.style.willChange = "opacity", document.body.appendChild(this.joystick.$element), this.joystick.$cursor = document.createElement("div"), this.joystick.$cursor.style.position = "absolute", this.joystick.$cursor.style.top = "calc(50% - 30px)", this.joystick.$cursor.style.left = "calc(50% - 30px)", this.joystick.$cursor.style.width = "60px", this.joystick.$cursor.style.height = "60px", this.joystick.$cursor.style.border = "2px solid #ffffff", this.joystick.$cursor.style.borderRadius = "50%", this.joystick.$cursor.style.boxSizing = "border-box", this.joystick.$cursor.style.pointerEvents = "none", this.joystick.$cursor.style.willChange = "transform", this.joystick.$element.appendChild(this.joystick.$cursor), this.joystick.$limit = document.createElement("div"), this.joystick.$limit.style.position = "absolute", this.joystick.$limit.style.top = "calc(50% - 75px)", this.joystick.$limit.style.left = "calc(50% - 75px)", this.joystick.$limit.style.width = "150px", this.joystick.$limit.style.height = "150px", this.joystick.$limit.style.border = "2px solid #ffffff", this.joystick.$limit.style.borderRadius = "50%", this.joystick.$limit.style.opacity = "0.25", this.joystick.$limit.style.pointerEvents = "none", this.joystick.$limit.style.boxSizing = "border-box", this.joystick.$element.appendChild(this.joystick.$limit), Object.keys(e).forEach((r) => {
        const n = e[r], i = document.createElement("div");
        Object.keys(yd).forEach((o) => {
          i.style[o] = yd[o];
        }), n.icon && (i.style.backgroundImage = `url(${n.icon})`), r === "up" && (i.style.backgroundPosition = "center top", i.style.justifyContent = "center", i.style.alignItems = "flex-start"), r === "down" && (i.style.backgroundPosition = "center bottom", i.style.justifyContent = "center", i.style.alignItems = "flex-end"), r === "left" && (i.style.backgroundPosition = "left center", i.style.justifyContent = "flex-start", i.style.alignItems = "center"), r === "right" && (i.style.backgroundPosition = "right center", i.style.justifyContent = "flex-end", i.style.alignItems = "center"), n.label && (i.innerHTML = n.label), this.joystick.$limit.appendChild(i);
      }), this.joystick.angle = {}, this.joystick.angle.offset = Math.PI * 0.5, this.joystick.angle.center = {}, this.joystick.angle.center.x = 0, this.joystick.angle.center.y = 0, this.joystick.angle.current = {}, this.joystick.angle.current.x = 0, this.joystick.angle.current.y = 0, this.joystick.angle.originalValue = 0, this.joystick.angle.value = -Math.PI * 0.5, this.joystick.resize = () => {
        const r = this.joystick.$element.getBoundingClientRect();
        this.joystick.angle.center.x = r.left + r.width * 0.5, this.joystick.angle.center.y = r.top + r.height * 0.5;
      }, window.addEventListener("resize", this.joystick.resize), this.joystick.resize(), this.updateJoystick(), this.joystick.events = {}, this.joystick.touchIdentifier = null, this.joystick.events.touchstart = (r) => {
        r.preventDefault();
        const n = qi(r).changedTouches[0];
        n && (this.joystick.active = true, this.playerState.setState("ctr-joystick", true), this.joystick.touchIdentifier = n.identifier, this.joystick.angle.current.x = n.clientX, this.joystick.angle.current.y = n.clientY, this.joystick.$limit.style.opacity = "0.5", document.addEventListener("pointerup", this.joystick.events.touchend), document.addEventListener("touchend", this.joystick.events.touchend), document.addEventListener(
          "pointermove",
          this.joystick.events.touchmove,
          { passive: false }
        ), document.addEventListener("touchmove", this.joystick.events.touchmove, {
          passive: false
        }));
      }, this.joystick.events.touchmove = (r) => {
        r.preventDefault();
        const i = [...qi(r).changedTouches].find(
          (o) => o.identifier === this.joystick.touchIdentifier
        );
        i && (this.joystick.angle.current.x = i.clientX, this.joystick.angle.current.y = i.clientY);
      }, this.joystick.events.touchend = (r) => {
        [...qi(r).changedTouches].find(
          (o) => o.identifier === this.joystick.touchIdentifier
        ) && (this.joystick.active = false, this.playerState.setState("ctr-joystick", false), this.config.type === "dpad" && this.playerState.setState("ctr-dpad", void 0), this.config.zones && Object.keys(this.config.zones).forEach((o) => {
          this.playerState.setState(
            `ctr-${this.config.zones[o].id}`,
            false
          );
        }), this.joystick.$limit.style.opacity = "0.25", this.joystick.$cursor.style.transform = "translateX(0px) translateY(0px)", document.removeEventListener(
          "pointerup",
          this.joystick.events.touchend
        ), document.removeEventListener("touchend", this.joystick.events.touchend));
      }, this.joystick.$element.addEventListener(
        "pointerdown",
        this.joystick.events.touchstart,
        { passive: false }
      ), this.joystick.$element.addEventListener(
        "touchstart",
        this.joystick.events.touchstart,
        { passive: false }
      );
    }
    setupButton({ id: e, label: r, css: n }) {
      let i = {};
      i.id = e, i.value = false, i.$element = document.createElement("div"), r && (i.$element.innerHTML = r), Object.keys(n.element).forEach((o) => {
        i.$element.style[o] = n.element[o];
      }), document.body.appendChild(i.$element), i.$border = document.createElement("div"), Object.keys(n.border).forEach((o) => {
        i.$border.style[o] = n.border[o];
      }), i.$element.appendChild(i.$border), i.events = {}, i.touchIdentifier = null, i.events.touchstart = (o) => {
        o.preventDefault();
        const s = qi(o).changedTouches[0];
        s && (i.touchIdentifier = s.identifier, i.value = true, this.playerState.setState(`ctr-${i.id}`, true), i.$border.style.opacity = "0.5", document.addEventListener("pointerup", i.events.touchend), document.addEventListener("touchend", i.events.touchend));
      }, i.events.touchend = (o) => {
        [...qi(o).changedTouches].find(
          (l) => l.identifier === i.touchIdentifier
        ) && (i.value = false, this.playerState.setState(`ctr-${i.id}`, false), i.$border.style.opacity = "0.25", document.removeEventListener("pointerup", i.events.touchend), document.removeEventListener("touchend", i.events.touchend));
      }, i.$element.addEventListener("pointerdown", i.events.touchstart), i.$element.addEventListener("touchstart", i.events.touchstart), this.buttons[i.id] = i;
    }
    updateJoystick() {
      if (this.joystick.active) {
        if (this.joystick.angle.originalValue = -Math.atan2(
          this.joystick.angle.current.y - this.joystick.angle.center.y,
          this.joystick.angle.current.x - this.joystick.angle.center.x
        ), this.joystick.angle.value = this.joystick.angle.originalValue + this.joystick.angle.offset, this.config.type === "angular" ? this.playerState.setState("ctr-angle", this.joystick.angle.value) : this.config.type === "dpad" && this.playerState.setState(
          "ctr-dpad",
          S3(this.joystick.angle.originalValue)
        ), this.config.zones) {
          let o = E3(
            this.joystick.angle.originalValue
          );
          this.config.zones[o] && this.playerState.setState(
            `ctr-${this.config.zones[o].id}`,
            true
          ), Object.keys(this.config.zones).forEach((s) => {
            s !== o && this.playerState.setState(
              `ctr-${this.config.zones[s].id}`,
              false
            );
          });
        }
        const e = Math.hypot(
          this.joystick.angle.current.y - this.joystick.angle.center.y,
          this.joystick.angle.current.x - this.joystick.angle.center.x
        );
        let r = e;
        r > 20 && (r = 20 + Math.log(e - 20) * 5), r > 43 && (r = 43);
        const n = Math.sin(this.joystick.angle.originalValue + Math.PI * 0.5) * r, i = Math.cos(this.joystick.angle.originalValue + Math.PI * 0.5) * r;
        this.joystick.$cursor.style.transform = `translateX(${n}px) translateY(${i}px)`;
      }
      this.requestAnimationFrameId = window.requestAnimationFrame(
        this.updateJoystick.bind(this)
      );
    }
    destroy() {
      var e, r;
      this.requestAnimationFrameId && (cancelAnimationFrame(this.requestAnimationFrameId), this.requestAnimationFrameId = null), this.joystick.$element.remove(), Object.values(this.buttons).forEach((n) => {
        n.$element.remove();
      }), window.removeEventListener("resize", this.joystick.resize), this.buttons = {}, this.joystick = {}, this.playerState.setState("ctr-joystick", false), this.playerState.setState("ctr-dpad", void 0), this.playerState.setState("ctr-angle", 0), (e = this.config) != null && e.keyboard && ((r = this.keyboardControllerInstance) == null || r.destroy());
    }
  }
  function qa(t10, e, r) {
    t10 += "";
    var n = { "00": { A: { env: ["#ff2f2b"], clo: ["#fff", "#000"], head: ["#fff"], mouth: ["#fff", "#000", "#000"], eyes: ["#000", "none", "#00FFFF"], top: ["#fff", "#fff"] }, B: { env: ["#ff1ec1"], clo: ["#000", "#fff"], head: ["#ffc1c1"], mouth: ["#fff", "#000", "#000"], eyes: ["#FF2D00", "#fff", "none"], top: ["#a21d00", "#fff"] }, C: { env: ["#0079b1"], clo: ["#0e00b1", "#d1fffe"], head: ["#f5aa77"], mouth: ["#fff", "#000", "#000"], eyes: ["#0c00de", "#fff", "none"], top: ["#acfffd", "#acfffd"] } }, "01": { A: { env: ["#a50000"], clo: ["#f06", "#8e0039"], head: ["#85492C"], mouth: ["#000"], eyes: ["#000", "#ff9809"], top: ["#ff9809", "#ff9809", "none", "none"] }, B: { env: ["#40E83B"], clo: ["#00650b", "#62ce5a"], head: ["#f7c1a6"], mouth: ["#6e1c1c"], eyes: ["#000", "#ff833b"], top: ["#67FFCC", "none", "none", "#ecff3b"] }, C: { env: ["#ff2c2c"], clo: ["#fff", "#000"], head: ["#ffce8b"], mouth: ["#000"], eyes: ["#000", "#0072ff"], top: ["#ff9809", "none", "#ffc809", "none"] } }, "02": { A: { env: ["#ff7520"], clo: ["#d12823"], head: ["#fee3c5"], mouth: ["#d12823"], eyes: ["#000", "none"], top: ["#000", "none", "none", "#FFCC00", "red"] }, B: { env: ["#ff9700"], clo: ["#000"], head: ["#d2ad6d"], mouth: ["#000"], eyes: ["#000", "#00ffdc"], top: ["#fdff00", "#fdff00", "none", "none", "none"] }, C: { env: ["#26a7ff"], clo: ["#d85cd7"], head: ["#542e02"], mouth: ["#f70014"], eyes: ["#000", "magenta"], top: ["#FFCC00", "#FFCC00", "#FFCC00", "#ff0000", "yellow"] } }, "03": { A: { env: ["#6FC30E"], clo: ["#b4e1fa", "#5b5d6e", "#515262", "#a0d2f0", "#a0d2f0"], head: ["#fae3b9"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#8eff45", "#8eff45", "none", "none"] }, B: { env: ["#00a58c"], clo: ["#000", "none", "none", "none", "none"], head: ["#FAD2B9"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#FFC600", "none", "#FFC600", "none"] }, C: { env: ["#ff501f"], clo: ["#000", "#ff0000", "#ff0000", "#7d7d7d", "#7d7d7d"], head: ["#fff3dc"], mouth: ["#d2001b", "none"], eyes: ["#000"], top: ["#D2001B", "none", "none", "#D2001B"] } }, "04": { A: { env: ["#fc0"], clo: ["#901e0e", "#ffbe1e", "#ffbe1e", "#c55f54"], head: ["#f8d9ad"], mouth: ["#000", "none", "#000", "none"], eyes: ["#000"], top: ["#583D00", "#AF892E", "#462D00", "#a0a0a0"] }, B: { env: ["#386465"], clo: ["#fff", "#333", "#333", "#333"], head: ["#FFD79D"], mouth: ["#000", "#000", "#000", "#000"], eyes: ["#000"], top: ["#27363C", "#5DCAD4", "#314652", "#333"] }, C: { env: ["#DFFF00"], clo: ["#304267", "#aab0b1", "#aab0b1", "#aab0b1"], head: ["#e6b876"], mouth: ["#50230a", "#50230a", "#50230a", "#50230a"], eyes: ["#000"], top: ["#333", "#afafaf", "#222", "#6d3a1d"] } }, "05": { A: { env: ["#a09300"], clo: ["#c7d4e2", "#435363", "#435363", "#141720", "#141720", "#e7ecf2", "#e7ecf2"], head: ["#f5d4a6"], mouth: ["#000", "#cf9f76"], eyes: ["#000", "#000", "#000", "#000", "#000", "#000", "#fff", "#fff", "#fff", "#fff", "#000", "#000"], top: ["none", "#fdff00"] }, B: { env: ["#b3003e"], clo: ["#000", "#435363", "#435363", "#000", "none", "#e7ecf2", "#e7ecf2"], head: ["#f5d4a6"], mouth: ["#000", "#af9f94"], eyes: ["#9ff3ff;opacity:0.96", "#000", "#9ff3ff;opacity:0.96", "#000", "#2f508a", "#000", "#000", "#000", "none", "none", "none", "none"], top: ["#ff9a00", "#ff9a00"] }, C: { env: ["#884f00"], clo: ["#ff0000", "#fff", "#fff", "#141720", "#141720", "#e7ecf2", "#e7ecf2"], head: ["#c57b14"], mouth: ["#000", "#cf9f76"], eyes: ["none", "#000", "none", "#000", "#5a0000", "#000", "#000", "#000", "none", "none", "none", "none"], top: ["#efefef", "none"] } }, "06": { A: { env: ["#8acf00"], clo: ["#ee2829", "#ff0"], head: ["#ffce73"], mouth: ["#fff", "#000"], eyes: ["#000"], top: ["#000", "#000", "none", "#000", "#ff4e4e", "#000"] }, B: { env: ["#00d2a3"], clo: ["#0D0046", "#ffce73"], head: ["#ffce73"], mouth: ["#000", "none"], eyes: ["#000"], top: ["#000", "#000", "#000", "none", "#ffb358", "#000", "none", "none"] }, C: { env: ["#ff184e"], clo: ["#000", "none"], head: ["#ffce73"], mouth: ["#ff0000", "none"], eyes: ["#000"], top: ["none", "none", "none", "none", "none", "#ffc107", "none", "none"] } }, "07": { A: { env: ["#00deae"], clo: ["#ff0000"], head: ["#ffce94"], mouth: ["#f73b6c", "#000"], eyes: ["#e91e63", "#000", "#e91e63", "#000", "#000", "#000"], top: ["#dd104f", "#dd104f", "#f73b6c", "#dd104f"] }, B: { env: ["#181284"], clo: ["#491f49", "#ff9809", "#491f49"], head: ["#f6ba97"], mouth: ["#ff9809", "#000"], eyes: ["#c4ffe4", "#000", "#c4ffe4", "#000", "#000", "#000"], top: ["none", "none", "#d6f740", "#516303"] }, C: { env: ["#bcf700"], clo: ["#ff14e4", "#000", "#14fffd"], head: ["#7b401e"], mouth: ["#666", "#000"], eyes: ["#00b5b4", "#000", "#00b5b4", "#000", "#000", "#000"], top: ["#14fffd", "#14fffd", "#14fffd", "#0d3a62"] } }, "08": { A: { env: ["#0df"], clo: ["#571e57", "#ff0"], head: ["#f2c280"], eyes: ["#795548", "#000"], mouth: ["#ff0000"], top: ["#de3b00", "none"] }, B: { env: ["#B400C2"], clo: ["#0D204A", "#00ffdf"], head: ["#ca8628"], eyes: ["#cbbdaf", "#000"], mouth: ["#1a1a1a"], top: ["#000", "#000"] }, C: { env: ["#ffe926"], clo: ["#00d6af", "#000"], head: ["#8c5100"], eyes: ["none", "#000"], mouth: ["#7d0000"], top: ["#f7f7f7", "none"] } }, "09": { A: { env: ["#4aff0c"], clo: ["#101010", "#fff", "#fff"], head: ["#dbbc7f"], mouth: ["#000"], eyes: ["#000", "none", "none"], top: ["#531148", "#531148", "#531148", "none"] }, B: { env: ["#FFC107"], clo: ["#033c58", "#fff", "#fff"], head: ["#dbc97f"], mouth: ["#000"], eyes: ["none", "#fff", "#000"], top: ["#FFEB3B", "#FFEB3B", "none", "#FFEB3B"] }, C: { env: ["#FF9800"], clo: ["#b40000", "#fff", "#fff"], head: ["#E2AF6B"], mouth: ["#000"], eyes: ["none", "#fff", "#000"], top: ["#ec0000", "#ec0000", "none", "none"] } }, 10: { A: { env: ["#104c8c"], clo: ["#354B65", "#3D8EBB", "#89D0DA", "#00FFFD"], head: ["#cc9a5c"], mouth: ["#222", "#fff"], eyes: ["#000", "#000"], top: ["#fff", "#fff", "none"] }, B: { env: ["#0DC15C"], clo: ["#212121", "#fff", "#212121", "#fff"], head: ["#dca45f"], mouth: ["#111", "#633b1d"], eyes: ["#000", "#000"], top: ["none", "#792B74", "#792B74"] }, C: { env: ["#ffe500"], clo: ["#1e5e80", "#fff", "#1e5e80", "#fff"], head: ["#e8bc86"], mouth: ["#111", "none"], eyes: ["#000", "#000"], top: ["none", "none", "#633b1d"] } }, 11: { A: { env: ["#4a3f73"], clo: ["#e6e9ee", "#f1543f", "#ff7058", "#fff", "#fff"], head: ["#b27e5b"], mouth: ["#191919", "#191919"], eyes: ["#000", "#000", "#57FFFD"], top: ["#ffc", "#ffc", "#ffc"] }, B: { env: ["#00a08d"], clo: ["#FFBA32", "#484848", "#4e4e4e", "#fff", "#fff"], head: ["#ab5f2c"], mouth: ["#191919", "#191919"], eyes: ["#000", "#ff23fa;opacity:0.39", "#000"], top: ["#ff90f4", "#ff90f4", "#ff90f4"] }, C: { env: ["#22535d"], clo: ["#000", "#ff2500", "#ff2500", "#fff", "#fff"], head: ["#a76c44"], mouth: ["#191919", "#191919"], eyes: ["#000", "none", "#000"], top: ["none", "#00efff", "none"] } }, 12: { A: { env: ["#2668DC"], clo: ["#2385c6", "#b8d0e0", "#b8d0e0"], head: ["#ad8a60"], mouth: ["#000", "#4d4d4d"], eyes: ["#7fb5a2", "#d1eddf", "#301e19"], top: ["#fff510", "#fff510"] }, B: { env: ["#643869"], clo: ["#D67D1B", "#b8d0e0", "#b8d0e0"], head: ["#CC985A", "none0000"], mouth: ["#000", "#ececec"], eyes: ["#1f2644", "#9b97ce", "#301e19"], top: ["#00eaff", "none"] }, C: { env: ["#F599FF"], clo: ["#2823C6", "#b8d0e0", "#b8d0e0"], head: ["#C7873A"], mouth: ["#000", "#4d4d4d"], eyes: ["#581b1b", "#FF8B8B", "#000"], top: ["none", "#9c0092"] } }, 13: { A: { env: ["#d10084"], clo: ["#efedee", "#00a1e0", "#00a1e0", "#efedee", "#ffce1c"], head: ["#b35f49"], mouth: ["#3a484a", "#000"], eyes: ["#000"], top: ["#000", "none", "#000", "none"] }, B: { env: ["#E6C117"], clo: ["#efedee", "#ec0033", "#ec0033", "#efedee", "#f2ff05"], head: ["#ffc016"], mouth: ["#4a3737", "#000"], eyes: ["#000"], top: ["#ffe900", "#ffe900", "none", "#ffe900"] }, C: { env: ["#1d8c00"], clo: ["#e000cb", "#fff", "#fff", "#e000cb", "#ffce1c"], head: ["#b96438"], mouth: ["#000", "#000"], eyes: ["#000"], top: ["#53ffff", "#53ffff", "none", "none"] } }, 14: { A: { env: ["#fc0065"], clo: ["#708913", "#fdea14", "#708913", "#fdea14", "#708913"], head: ["#DEA561"], mouth: ["#444", "#000"], eyes: ["#000"], top: ["#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f", "#32393f"] }, B: { env: ["#81f72e"], clo: ["#ff0000", "#ffc107", "#ff0000", "#ffc107", "#ff0000"], head: ["#ef9831"], mouth: ["#6b0000", "#000"], eyes: ["#000"], top: ["#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "#FFFAAD", "none", "none", "none", "none"] }, C: { env: ["#00D872"], clo: ["#590D00", "#FD1336", "#590D00", "#FD1336", "#590D00"], head: ["#c36c00"], mouth: ["#56442b", "#000"], eyes: ["#000"], top: ["#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "#004E4C", "none", "none", "none", "none", "none", "none", "none", "none"] } }, 15: { A: { env: ["#111"], clo: ["#000", "#00FFFF"], head: ["#755227"], mouth: ["#fff", "#000"], eyes: ["black", "#008;opacity:0.67", "aqua"], top: ["#fff", "#fff", "#fff", "#fff", "#fff"] }, B: { env: ["#00D0D4"], clo: ["#000", "#fff"], head: ["#755227"], mouth: ["#fff", "#000"], eyes: ["black", "#1df7ff;opacity:0.64", "#fcff2c"], top: ["#fff539", "none", "#fff539", "none", "#fff539"] }, C: { env: ["#DC75FF"], clo: ["#000", "#FFBDEC"], head: ["#997549"], mouth: ["#fff", "#000"], eyes: ["black", "black", "aqua"], top: ["#00fffd", "none", "none", "none", "none"] } } }, i = [], o = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 231 231">', s = "</svg>", a = '<path d="M33.83,33.83a115.5,115.5,0,1,1,0,163.34,115.49,115.49,0,0,1,0-163.34Z" style="fill:#01;"/>', l = '<path d="m115.5 51.75a63.75 63.75 0 0 0-10.5 126.63v14.09a115.5 115.5 0 0 0-53.729 19.027 115.5 115.5 0 0 0 128.46 0 115.5 115.5 0 0 0-53.729-19.029v-14.084a63.75 63.75 0 0 0 53.25-62.881 63.75 63.75 0 0 0-63.65-63.75 63.75 63.75 0 0 0-0.09961 0z" style="fill:#000;"/>', c = "stroke-linecap:round;stroke-linejoin:round;stroke-width:";
    i["00"] = [], i["00"].env = a, i["00"].clo = '<path d="m141.74 195a114.93 114.93 0 0 1 37.912 16.45l0.07 0.05c-1.17 0.79-2.3601 1.55-3.5601 2.29a115.55 115.55 0 0 1-120.95 0.21q-2.0001-1.23-4.0002-2.54a114.79 114.79 0 0 1 38.002-16.5 116.21 116.21 0 0 1 15.791-2.49v-14.57c1.32 0.22 2.6501 0.39 4.0002 0.51 2.0001 0.19 4.0002 0.28 6.1202 0.29a64.333 64.33 0 0 0 8.8804-0.62c0.67003-0.09 1.3401-0.2 2.0001-0.31v14.69a118 118 0 0 1 15.741 2.54z" style="fill:#fff;"/><path d="m79.292 212a3.4601 3.46 0 0 0 3.8902 5.07 3.3801 3.38 0 0 0 2.1001-1.61 3.4701 3.47 0 0 0-1.2801-4.72 3.4201 3.42 0 0 0-2.6201-0.34 3.5101 3.51 0 0 0-2.0901 1.6zm60.122 0.46a3.4901 3.49 0 0 0 1.21 4.7h0.06a3.4601 3.46 0 0 0 4.7202-1.27l0.07-0.13a3.4601 3.46 0 0 0-1.34-4.6 3.4601 3.46 0 0 0-2.5801-0.32 3.5301 3.53 0 0 0-2.1001 1.61zm9.8004 5.7 5.8602 5.87c-1.39 0.5-2.7901 1-4.2102 1.44l-4.4802-4.47a7.5203 7.52 0 0 1-1.9401 0.81 7.8303 7.83 0 0 1-6.0002-0.79 7.8703 7.87 0 0 1-2.9201-10.69v-0.07a7.8903 7.89 0 0 1 10.77-2.88l0.12 0.07a7.8603 7.86 0 0 1 2.7901 10.62v0.07zm-37.701-2.36-9.5004 9.51v4.9c-1.35-0.16-2.6801-0.33-4.0002-0.54v-6l0.58002-0.58 10.1-10.09a7.8703 7.87 0 1 1 2.8401 2.86zm7.3203-5.91a3.4601 3.46 0 1 0-1.6101 2.1 3.3801 3.38 0 0 0 1.6101-2.1zm-29.741 7.82 3.0901 3.1 0.59002 0.59v7.36c-1.3401-0.26-2.6801-0.55-4.0002-0.87v-4.84l-2.5101-2.51a7.5203 7.52 0 0 1-1.9401 0.81 7.8803 7.88 0 1 1 1.9101-14.43 7.8703 7.87 0 0 1 2.8901 10.75z" style="fill:#1a1a1a;"/>', i["00"].head = l, i["00"].mouth = '<path d="m94.19 136.84h42.632a3.7801 3.78 0 0 1 3.7802 3.78v3.22a15.231 15.23 0 0 1-15.211 15.16h-19.781a15.251 15.25 0 0 1-15.221-15.16v-3.22a3.8002 3.8 0 0 1 3.7802-3.78z" style="fill:#fff;' + c + '3px;stroke:#1a1a1a;"/><path d="m130.96 136.84v21.16m-30.911-21.16v21.16m10.34-21.16v22.16m10.31-22.2v22.2" style="fill:none;' + c + '3px;stroke:#1a1a1a;"/>', i["00"].eyes = '<path d="m83.739 83.92h63.533a19.101 19.1 0 0 1 19.051 19 19.111 19.11 0 0 1-19.051 19h-63.533a19.091 19.09 0 0 1-19.001-19 19.091 19.09 0 0 1 19.001-19z" style="fill:#1a1a1a;"/><path d="m140.23 93.54a9.3804 9.38 0 1 0 9.3804 9.38 9.3804 9.38 0 0 0-9.3804-9.38zm-49.402 0a9.3804 9.38 0 1 0 9.3804 9.38 9.3904 9.39 0 0 0-9.3804-9.38z" style="fill:#e6e7e8;"/><rect x="79.795" y="98.627" width="71.471" height="8.5859" ry="4.2929" style="fill:#b3b3b3;"/>', i["00"].top = '<path d="m32.902 67.662c-0.36295 1.7227-6.2342 30.695 5.6133 52.596 4.5843 8.4743 9.0081 13.239 12.75 15.893a67.7 67.7 0 0 1-3.4688-21.35 67.7 67.7 0 0 1 2.332-17.658c-4.4914-2.4646-10.868-6.9012-13.834-13.52-4.1626-9.285-3.6155-14.673-3.3926-15.961zm165.19 0c0.22292 1.2882 0.77005 6.6759-3.3926 15.961-2.9664 6.6183-9.3426 11.055-13.834 13.52a67.7 67.7 0 0 1 2.332 17.658 67.7 67.7 0 0 1-3.4688 21.35c3.7419-2.6532 8.1657-7.4183 12.75-15.893 11.847-21.9 5.9762-50.873 5.6133-52.596z" style="fill:#fff;"/><path d="m115.73 13.191c-7.3787-0.13351-13.509 5.7888-13.631 13.168-0.10128 5.8827 3.4508 10.518 8.0566 12.52 1.061 0.46115 2.1869 0.78009 3.3418 0.95703v8.4291c0.66778-0.02035 1.3358-0.03077 2.0039-0.03125 0.66547-9e-5 1.3309 0.0097 1.9961 0.0293v-8.4115c2.6002-0.38406 5.1586-1.5484 7.3086-3.625 4.2322-4.0878 4.9991-9.8755 3.1582-14.549-1.8407-4.6726-6.3502-8.3834-12.232-8.4863z" style="fill:#fff;"/>', i["01"] = [], i["01"].env = a, i["01"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0 10.76 11.75 19.48 26.25 19.48s26.25-8.72 26.25-19.48z" style="fill:#1a1a1a;"/><path d="m92.502 194.27v0.70391c0 4.3033 2.4373 8.2583 6.3807 11.183 4.2199 3.1204 10.106 5.0508 16.661 5.0508 6.548 0 12.434-1.9303 16.654-5.0508 3.9434-2.9245 6.388-6.8795 6.388-11.183v-0.67489c1.0768 0.21771 2.1463 0.44994 3.2158 0.69666h-7e-3c1.0695 0.24672 2.1318 0.50798 3.1867 0.791-0.27648 6.103-3.6524 11.553-8.9708 15.493-5.2821 3.9114-12.521 6.328-20.466 6.328-7.9449 0-15.184-2.4165-20.474-6.328-5.333-3.9477-8.7089-9.4194-8.9708-15.544 1.055-0.27577 2.1099-0.53702 3.1722-0.78376 1.0695-0.23947 2.1463-0.46443 3.2304-0.68213z" style="fill:#b3b3b3;"/>', i["01"].head = l, i["01"].mouth = '<path d="m100.35 143.85a7.67 7.67 0 0 0 7.58 7.7v0a7.66 7.66 0 0 0 7.57-7.7 7.66 7.66 0 0 0 7.57 7.7v0a7.67 7.67 0 0 0 7.58-7.7" style="fill:none;' + c + '6.3998px;stroke:#333;"/>', i["01"].eyes = '<path d="m78.73 111a10.9 10.9 0 0 1 15.19 0m43.16 0a10.9 10.9 0 0 1 15.19 0" style="fill:none;' + c + '6.1999px;stroke:#333;"/><path d="m79.804 123.74h7.07m57.273 0h7.05" style="fill:none;' + c + '5.9998px;stroke:#b8b8b8;"/>', i["01"].top = '<path d="m57.534 142.03c-6.9383-31.75-0.57294-52.577 14.174-62.344 22.562-12.283 62.082-12.222 83.484-1.8846 21.348 11.177 22.124 37.396 18.498 63.733 8.1279-14.155 13.164-31.598 14.085-48.902 1.0828-11.795-1.1756-18.866-7.4833-27.972-26.465-37.685-103.45-31.56-129.66-2.8372-7.8504 9.4615-9.6006 17.478-9.275 26.667 1.0024 18.667 6.9688 38.508 16.18 53.54z" style="fill:#b3b3b3;"/><path d="m111.26 3.0423c-6.013 0.1128-12.629 2.6924-15.291 7.9082-1.1676 3.2383-1.6758 6.2069-1.6758 8.8926 0.89228-0.2661 1.8005-0.5164 2.7266-0.7441 3.7502-1.0672 7.4851-1.7135 11.129-1.9981 1.1007-0.086 2.1953-0.1391 3.2773-0.1601h2e-3c5.6969-0.1133 11.09 0.6603 15.904 2.0527 0.0552-3.042-0.70696-5.9824-2.1738-8.5-1.8411-3.1599-4.7033-5.5568-8.4297-6.8262-1.6883-0.4952-3.5163-0.662-5.4688-0.625zm3.0664 17.449c-0.69317-0.01-1.3919-0.01-2.0938 0h-2e-3c-1.1591 0.019-2.3326 0.064-3.5117 0.1386-3.9035 0.246-7.9025 0.8061-11.92 1.7285-15.159 3.0075-26.469 9.9279-22.068 19.682 22.891-8.7773 52.315-10.403 76.023-2.2129 2.1414-9.5529-14.939-19.081-36.428-19.34z" style="fill:#b3b3b3;"/><path d="m165.62 16.981c-0.8575 0-1.9406 0.54389-3.3476 1.3574-7.3382 4.7652-13.452 10.867-19.516 18.363 9.2734 2.1825 17.903 5.6706 25.213 10.604 1.1512-9.1263 1.9137-18.503 0.055-26.996-0.57-2.4184-1.3017-3.3267-2.4043-3.3281zm-104.09 1.6934c-1.1026 0-1.8342 0.91165-2.4043 3.3301-1.8794 8.5869-1.0806 18.078 0.092 27.299 7.0559-4.6638 15.687-8.3667 25.111-10.984-6.043-7.4601-12.139-13.537-19.451-18.285-1.407-0.81353-2.4901-1.3605-3.3477-1.3594z" style="fill:#b3b3b3;"/><path d="m162.45 16.686c-2.3175 2e-3 -4.6276 0.57608-6.8926 1.668-8.4768 6.0155-11.113 13.349-10.133 19.787 10.323 2.7077 19.762 7.0658 27.346 13.279 9.848-4.9363 11.32-17.137 4.6152-25.852-4.7104-6.1222-9.8371-8.8878-14.936-8.8828zm-97.318 4.1387c-2.4569 0.0556-5.1642 0.54474-8.1172 1.5176-13.487 4.4433-19.06 21.215-3.6484 31.84 7.2476-6.0694 16.961-10.896 27.892-14.229 0.2193-3.3241-0.3201-7.0817-1.8691-11.236-2.8049-4.8445-7.2233-7.721-13.221-7.8906-0.3408-0.01-0.6861-0.01-1.0371-2e-3z" style="fill:#b3b3b3;"/>', i["02"] = [], i["02"].env = a, i["02"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0 10.76 11.75 19.48 26.25 19.48s26.25-8.72 26.25-19.48z" style="fill:#5a5a5a;"/>', i["02"].head = l, i["02"].mouth = '<path d="m115.5 161.71c-8.24 0-14.46-4.15-19.19-11.25 3.37-2.44 6.51-4.57 10-6.79a5.25 5.25 0 0 1 5.48-0.17 28.19 28.19 0 0 1 3.68 2.75 28.19 28.19 0 0 1 3.68-2.75 5.25 5.25 0 0 1 5.48 0.17c3.52 2.22 6.66 4.35 10 6.79-4.74 7.1-11 11.25-19.19 11.25z" style="fill:#5a5a5a;"/>', i["02"].eyes = '<path d="m172.7 90.75h-6.54c-0.14-0.1-0.26-0.22-0.4-0.3-4.48-2.76-22.75-2.11-33.71 1.2-1 0.3-1.91 0.61-2.75 0.94-1.8937 0.79244-3.8739 1.3597-5.9 1.69-5.5051 0.79002-10.403 0.79002-15.908 0-2.0261-0.33034-4.0063-0.89756-5.9-1.69-0.84-0.33-1.76-0.64-2.75-0.94-11-3.31-29.23-4-33.71-1.2-0.13832 0.08869-0.2688 0.18906-0.39 0.3h-6.55c-1.1046 0-2 0.89543-2 2v4.66c-0.0013 0.98185 0.49088 1.8986 1.31 2.44l1.9 1.27c0.59238 0.38889 0.93475 1.0622 0.9 1.77-0.14175 5.4854 0.88072 10.939 3 16 3.58 8.38 16 10.9 24.93 10.9 2.6976 0.0771 5.3921-0.2361 8-0.93 4.35-1.43 8.24-7.36 10.45-12.42 1.7607-3.8506 2.7493-8.009 2.91-12.24 7.3e-4 -0.7138 0.38183-1.3731 1-1.73 3.2281-1.951 6.5798-1.951 9.8079 0 0.61817 0.3569 0.99927 1.0162 1 1.73 0.16067 4.231 1.1493 8.3894 2.91 12.24 2.21 5.06 6.1 11 10.45 12.42 2.6079 0.6939 5.3024 1.0071 8 0.93 8.92 0 21.35-2.52 24.93-10.9 2.1193-5.0614 3.1418-10.515 3-16-0.0348-0.70778 0.30762-1.3811 0.9-1.77l1.9-1.27c0.81913-0.54136 1.3113-1.4582 1.31-2.44v-4.6c0.0336-1.1048-0.83521-2.0274-1.94-2.06z" style="fill:#1a1a1a;' + c + '2.5;stroke:#b3b3b3;"/>', i["02"].top = '<path d="m124.22 13.61c-19.783 0-36.945 8.0887-39.695 24.106-15.332 0.23539-31.831 2.7712-41.663 15.782-6.0238 7.9604-7.0402 19.901-6.8476 31.724 0.46007 28.503 10.742 64.228-4.3012 89.714 16.584 5.7777 43.086 10.742 73.59 11.662v-8.6558c-1.851-0.35308-3.6592-0.78105-5.4353-1.2732-30.953-8.4632-50.672-36.635-47.259-68.669 1.5514-10.603 4.6221-19.665 10.025-27.69 5.3818-7.9925 13.267-15.717 23.892-21.41 0.40658 0.72757 1.9901 3.5843 2.4074 4.3012 7.5003 12.775 17.986 23.849 33.157 26.866 12.433 2.4609 23.849 3.4666 36.346 1.1555 4.2584-0.78106 10.667-2.3967 14.851-2.4181 14.861 33.404-1.0806 75.035-40.668 87.457-2.2255 0.70616-4.5258 1.316-6.8904 1.8189 0 2.707-0.0428 5.6493-0.0642 8.5274 23.603-0.72757 48.682-4.0444 72.874-11.234-18.521-32.152 0.81315-89.083-10.036-121.46-9.0731-26.973-38.85-40.315-64.282-40.305z" style="fill:#c5c5c5;"/><path d="m33.147 172.32c-2.6535 5.1143-6.088 9.9504-10.1 12.411 7.8427 10.453 17.387 19.516 28.257 26.781 16.038-10.731 35.629-17.055 54-18.606v-9.0089c-30.065-0.94155-56.108-5.8847-72.157-11.577zm164.06 0.55637c-23.731 7.0723-48.361 10.325-71.525 11.042-0.0321 3.1242-0.0535 6.2377-0.0107 9.0517 19.227 1.7226 37.908 7.8534 53.989 18.542 0.0107 0 0.0107 0 0.0214 0.0107 10.731-7.1686 20.179-16.081 27.958-26.374-4.2798-2.3967-7.832-6.9653-10.432-12.272z" style="fill:#c5c5c5;"/><path d="m50.02 46.5c-2.9297 1.9143-6.1313 3.8826-10.154 7.9805-14.091 14.359-16.145 27.701-6.1406 44.018 4.2049 6.8583 6.1414 13.706-0.24609 20.5-7.7143 8.1957-21.559 4.2912-21.537 16.061 0.0214 8.613 15.063 7.9178 22.531 13.984 3.7662 3.0707 5.0836 8.3992 2.0664 12.508-4.2156 5.7456-16.006 7.3715-22.629 8.9336 5.8811 10.843 13.45 20.638 22.355 29.033l0.0039 0.0234 0.0059-0.0137c2e-3 2e-3 0.0038 4e-3 0.0059 6e-3 0.0034-0.0112 0.0063-0.0219 0.0098-0.0332 14.775-12.218 20.268-20.965 49.461-28.434-17.404-10.258-30.68-27.122-24.143-35.34 4.4123-5.5444 5.6612-7.8633 6.4062-12.078 2.3582-13.339-10.208-22.335-9.2363-32.715 1.9432-8.2346 11.379-11.173 16.947-15.115 5.4577-3.9082 9.8014-8.7695 10.799-16.918-13.558-4.8896-17.609-5.8617-36.506-12.4zm140.87 19.357c-3.4404-0.91243-23.311 122.43 4.4121 133.14 8.9661-8.5809 16.552-18.584 22.404-29.658 0-0.31029-25.133-3.9922-25.979-14.018-0.10699-1.1769 0.11822-1.4855 0.86718-2.502 6.6764-9.2122 30.716-11.416 29.646-23.496-0.27818-3.1563-4.1617-5.2334-6.7402-6.4531-12.155-5.767-32.942-9.6494-15.031-24.543 9.2122-7.3505 10.43-8.4323 0.59766-14.691-9.4583-6.0238-9.394-11.993-9.7578-16.326-0.0767-0.93035-0.22089-1.4003-0.41992-1.4531z" style="fill:#c5c5c5;"/><path d="m133.83 39.909c-11.33 1.393-9.5492 16.204-2e-3 16.643-4.5102 10.717 9.0165 16.181 14.441 8.3125 6.562 8.6765 18.596 0.94751 14.457-8.3125 11.718-1.5381 9.2769-16.099 0-16.643 4.503-10.867-9.4883-16.101-14.457-8.3301-6.8832-9.0411-18.509-0.47321-14.439 8.3301z" style="fill:#333;"/><path d="m153.86 48.222c0-3.0528-2.5184-5.5648-5.5791-5.5648-3.0783 0-5.5793 2.512-5.5793 5.5648 0 3.0703 2.501 5.5648 5.5793 5.5648 3.0606 0 5.5791-2.4946 5.5791-5.5648z" style="fill:#f9f9f9;"/>', i["03"] = [], i["03"].env = a, i["03"].clo = '<path d="m141.75 195c13.563 3.1499 26.439 8.7409 38 16.5-38.873 26.001-89.587 26.001-128.46 0 11.561-7.7591 24.437-13.35 38-16.5 8.4869 8.8011 26.21 25.619 26.21 25.619s17.603-16.972 26.25-25.619z" style="fill:#d6d6d6;"/><path d="m109 230.81 1.6836-14.33h9.6328l1.6836 14.33c-2.16 0.12-4.33 0.19-6.51 0.19s-4.35-0.07-6.51-0.19z" style="fill:#5e5e5e;"/><path d="m124.17 210.6h-17.349v5.53a3.8828 3.29 0 0 0 3.8828 3.29h9.583a3.8828 3.29 0 0 0 3.8828-3.29z" style="fill:#535353;"/><path d="m140.57 190.36-25.066 20.245c5.9686 3.2455 11.597 7.0814 16.8 11.45 1.5989 1.3338 3.9762 1.1189 5.31-0.48 0.21005-0.25749 0.38802-0.53956 0.52999-0.84l10.826-23.805-4-6c-0.90256-1.351-2.7298-1.7137-4.08-0.81-0.11612 0.0786-0.22641 0.16549-0.33 0.26z" style="fill:#c6c6c6;"/><path d="m90.434 190.36 25.066 20.245c-5.9686 3.2455-11.597 7.0814-16.8 11.45-1.5989 1.3338-3.9762 1.1189-5.31-0.48-0.21005-0.25749-0.38802-0.53956-0.52999-0.84l-10.826-23.805 4-6c0.90256-1.351 2.7298-1.7137 4.08-0.81 0.11612 0.0786 0.22641 0.16549 0.33 0.26z" style="fill:#c6c6c6;"/>', i["03"].head = l, i["03"].mouth = '<path d="m136.21 147.09a21.77 21.77 0 0 1-40.13 0z" style="fill:#fff;' + c + '3.4999px;stroke:#000;"/>', i["03"].eyes = '<path d="m145.39 104.7-11.52 11.2h17.26m-65.52-11.2 11.52 11.2h-17.26" style="fill:none;' + c + '5.4998px;stroke:#000;"/>', i["03"].top = '<path d="m43.891 77.836c-5.1124 28.237 2.1347 61.004 24.792 81.332-6.2362-12.503-9.5362-33.948-9.4887-45.458-0.50203-37.473 41.439-46.335 56.149-17.614 18.8-31.2 52.825-16.872 54.062 13.714 0.56018 13.844-0.43568 25.598-7.0962 48.966 18.372-12.47 28.012-53.959 23.545-80.941-47.486-2.2552-94.831-2.5724-141.96 0z" style="fill:#1a1a1a;"/><path d="m111.26 12.782c-18.508 0.0791-32.594 3.6163-32.594 3.6163 24.513 5.6002 32.807 10.504 31.743 19.835-0.87227 9.702-11.092 10.875-20.811 11.554-5.2548 0.36414-10.949 0.71523-16.391 1.7525-11.862 2.2818-19.946 4.3736-24.447 11.956-1.7012 2.8662-3.7945 10.428-4.8689 16.34h141.96c-5.7242-38.563-32.557-65.073-74.595-65.054z" style="fill:#1a1a1a;"/><path d="m73.292 44.77c-11.788 2.2816-18.923 5.5444-23.394 13.126-2.8484 6.7586-4.8454 13.238-6.0072 19.939h141.96c-1.9772-14.576-6.8677-28.248-19.277-32.098-28.834-6.3308-63.774-6.3553-93.285-0.96761z" style="fill:#1a1a1a;"/><path d="m165.95 35.642c-11.178 21.829-91.89 19.36-103.98 2.3011-9.703 12.267-15.605 25.883-18.079 39.892h141.96c-3.0096-17.158-9.7424-32.688-19.902-42.193z" style="fill:#1a1a1a;"/>', i["04"] = [], i["04"].env = a, i["04"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l15.71 15.75h21z" style="fill:#949494;"/><path d="m115.45 211.34-10.55 10.54a2.51 2.51 0 0 1-3.5599 0 2 2 0 0 1-0.26999-0.30994l-18.48-25.4 5.8901-5.8899a2.52 2.52 0 0 1 3.5199-0.0791l23.49 21.14z" style="fill:#c0c0c0;"/><path d="m115.45 211.34 10.55 10.54a2.51 2.51 0 0 0 3.5599 0 2 2 0 0 0 0.26999-0.30994l18.48-25.4-5.8901-5.8899a2.52 2.52 0 0 0-3.4699-0.089l-23.49 21.14z" style="fill:#c0c0c0;"/><path d="m158.41 199.58-10.11-3.2401v29.93q5.1601-1.5299 10.11-3.51zm-75.82 26.66v-29.9l-10.1 3.2401v23.14c3.2901 1.3199 6.67 2.4999 10.1 3.5199z" style="fill:#7c7c7c;"/>', i["04"].head = l, i["04"].mouth = '<path d="m118.05 148.38c-1.5064 0.59192-2.595 2.0264-2.6191 3.9863-0.0574 1.3977 0.53421 3.5611 3.6758 5.7949 8.0544 4.9446 21.507 3.6862 21.255-7.1658-4.664 4.8219-10.021 5.6377-14.773 0.73907-1.2328-1.1599-2.3694-2.4032-3.9294-3.1408-1.0946-0.50424-2.2257-0.61071-3.6096-0.21337z" style="fill:#333;"/><path d="m133.61 154.93c3.0731-0.48816 5.5702-2.8457 5.4438-4.5059-0.47801-4.8311-5.7317-3.0917-4.3369-0.31405-2.8103-1.4445-1.8343-3.8862 0.50427-4.7324 2.0509-0.79942 5.0937 0.34314 6.2002 2.6376 2.2229 7.3422-3.4376 11.68-10.384 12.561z" style="fill:#333;"/><path d="m112.81 148.38c1.5064 0.59192 2.595 2.0264 2.6191 3.9863 0.0574 1.3977-0.53421 3.5611-3.6758 5.7949-8.0544 4.9446-21.507 3.6862-21.255-7.1658 4.664 4.8219 10.021 5.6377 14.773 0.73907 1.2328-1.1599 2.3694-2.4032 3.9294-3.1408 1.0946-0.50424 2.2257-0.61071 3.6096-0.21337z" style="fill:#333;"/><path d="m97.252 154.93c-3.0731-0.48816-5.5702-2.8457-5.4438-4.5059 0.47801-4.8311 5.7317-3.0917 4.3369-0.31405 2.8103-1.4445 1.8343-3.8862-0.50427-4.7324-2.0509-0.79942-5.0937 0.34314-6.2002 2.6376-2.2229 7.3422 3.4376 11.68 10.384 12.561z" style="fill:#333;"/>', i["04"].eyes = '<path d="m131.64 114.09 7.5801-7.5801 7.5801 7.5801m-62.6 0 7.5801-7.5801 7.5799 7.5801" style="fill:none;' + c + '6.4998px;stroke:#000;"/>', i["04"].top = '<path d="m137.38 11.148c-12.23 1.9593-18.511 14.606-43.436 9.4915-11.285-3.2054-16.406-3.573-20.389 0.58594-4.1548 4.3384-7.033 12.435-9.8184 21.706-2.1354 7.4136-3.7187 14.381-4.7461 21.646h112.7c-3.4878-24.293-10.822-43.281-25.182-51.061-3.5314-1.623-6.5274-2.2959-9.1289-2.3613z" style="fill:#b3b3b3;"/><path d="m114.37 43.383c-19.445 0.088-38.524 2.0724-52.379 5.6992-1.2766 4.5795-2.4317 10.169-3.2285 16.807h113.11c-0.83731-6.0107-1.9164-11.674-3.3184-16.924-15.229-3.8842-34.873-5.6693-54.18-5.582z" style="fill:#e6e6e6;"/><path d="m115.5 55.773c-58.39 0-105.73 15.476-105.73 34.57h0.0312c0 11.295 16.496 21.319 42.126 27.627-0.10331-7.7704 2.788-21.904 5.2734-31.031 6.0935-1.7168 6.9294-1.8971 13.167-2.9919 14.874-2.8256 29.99-4.2037 45.133-4.1153 15.143-0.0884 30.259 1.2897 45.133 4.1153 6.2372 1.0947 7.2065 1.2751 13.3 2.9919 2.4854 9.1267 5.3768 23.26 5.2734 31.031 25.63-6.3082 41.993-16.332 41.993-27.627h0.0312c0-19.093-47.34-34.57-105.73-34.57z" style="fill:#818181;"/><path d="m72.088 83.533c-6.9765 1.1147-13.357 2.856-18.439 4.3477-1.1861 7.415-2.0038 18.858-1.8926 26.293 4.3278-0.62795 10.155-1.3644 13.295-1.6465-0.40554 0.30198 2.7344-17.827 7.0371-28.994zm86.824 0c4.3028 11.167 7.4426 29.296 7.0371 28.994 3.1396 0.28213 8.9671 1.0185 13.295 1.6465 0.11119-7.4351-0.70652-18.878-1.8926-26.293-5.0822-1.4916-11.463-3.2329-18.439-4.3477z" style="fill:#434343;"/>', i["05"] = [], i["05"].env = a, i["05"].clo = '<path d="m141.75 194.98a114.79 114.78 0 0 1 38 16.498 115.53 115.52 0 0 1-128.46 0 114.79 114.78 0 0 1 38-16.498l15.71 15.748h21z" style="fill:#d2d2d2;"/><path d="m70 200.88v20.77c-2.22-0.95325-4.3999-1.9698-6.5399-3.0496h-0.10088v-14.621c2.17-1.1 4.39-2.1399 6.64-3.0996z" style="fill:#505050;"/><path d="m161 200.88v20.77c1.9-0.80986 3.7702-1.6798 5.6201-2.5898l0.0989-0.0494 0.82005-0.40997h0.10088v-14.621c-2.17-1.1-4.39-2.1399-6.6402-3.0996z" style="fill:#505050;"/><polygon transform="matrix(1 0 0 .99987 4e-5 -3e-5)" points="97.32 201.93 115.5 223.72 133.68 201.93" style="fill:#171717;"/><path d="m111.2 230.88 1.31-16.908c0.32992 1.2798 5.6399 1.2798 5.9999 0l1.3201 16.938c-1.4301 0.0494-2.8601 0.089-4.3 0.089s-2.87 0-4.3-0.089z" style="fill:#171717;"/><path d="m115.49 201.79v0.0692l-7.55 12.678-7.0001 11.809-19.19-26.487c0.60999-0.42995 1.22-0.89985 1.8001-1.3899a52 51.993 0 0 0 10.07-10.619l21.79 13.878z" style="fill:#ebebeb;"/><path d="m149.24 199.86-19.08 26.517-7.0001-11.809-7.57-12.678-0.0593-0.10086 21.94-13.998a52.21 52.203 0 0 0 10.08 10.699c0.58013 0.47009 1.1502 0.92002 1.7301 1.3399z" style="fill:#ebebeb;"/>', i["05"].head = l, i["05"].mouth = '<path d="m122.83 151.88a10.49 10.489 0 0 1-14.66 0" style="fill:none;' + c + '6.1996px;stroke:#333;"/>', i["05"].eyes = '<path d="m70.959 94.985h35.031c2.4086 1e-5 4.3612 1.9523 4.3612 4.3606l-2.5864 17.511c-0.3515 2.3799-1.7218 4.3606-3.8457 4.3606h-30.9c-2.1239-1e-5 -3.8457-1.9523-3.8457-4.3606l-2.5864-17.511c1e-5 -2.4082 1.9526-4.3606 4.3612-4.3606z" style="fill:#1a1a1a;' + c + '3.0045px;stroke:#333;"/><path d="m160.05 94.985h-35.031c-2.4086 1e-5 -4.3612 1.9523-4.3612 4.3606l2.5864 17.511c0.35149 2.3799 1.7218 4.3606 3.8457 4.3606h30.9c2.1239-1e-5 3.8457-1.9523 3.8457-4.3606l2.5864-17.511c-1e-5 -2.4082-1.9526-4.3606-4.3612-4.3606z" style="fill:#1a1a1a;' + c + '3.0045px;stroke:#333;"/><path d="m90.607 102.35a4.6337 4.6332 0 1 0 4.6892 4.6337 4.6337 4.6332 0 0 0-4.6892-4.6337zm49.72 0a4.6337 4.6332 0 1 0 4.6444 4.6337 4.6337 4.6332 0 0 0-4.6444-4.6337z" style="fill:#1a1a1a;"/><path d="m70.66 94.985h-11.775" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m172.13 94.985h-19.484" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m109.32 106.2c4.2045-2.427 9.3036-1.913 12.353-0.0258" style="fill:none;' + c + '3.0045px;stroke:#333;"/><path d="m148.33 109.79-5.7626-8.2324" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m156.27 105-2.403-3.4328" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m82.748 114.34-8.9489-12.784" style="fill:none;' + c + '4;stroke:#fff;"/><path d="m91.408 109.79-5.7626-8.2324" style="fill:none;' + c + '4;stroke:#fff;"/>', i["05"].top = '<path d="m41.835 75.131c-2.8674 12.582 1.2304 27.241 6.0238 39.031 0.25861 0.63658 0.51208 1.3075 0.79989 1.9683 0.71726 1.658 2.1184 3.9751 3.0038 3.9266 0.56895-0.0312 0.71637-1.5512 1.0228-3.1562 2.1988-19.097 8.8981-27.915 15.636-38.107 2.8783-4.0645 3.8616-7.2293 1.0644-9.9325-6.3236-3.5596-14.924-2.8574-21.367-0.67406-3.2312 1.4765-5.2427 3.4773-6.1842 6.9439zm125.65-8.5679c7.65-0.70616 19.714-0.1307 21.694 8.5679 1.455 6.4083 0.26915 17.747-1.0542 24.579-1.1961 5.3203-3.8066 14.231-7.8782 19.75-0.5565 0.44544-0.96888 0.13656-1.4159-1.1606-0.90692-3.0353-1.4298-7.8372-2.2556-10.727-3.4822-12.79-8.2195-21.875-14.429-29.94-5.5782-6.8415-4.2152-9.7207 5.3393-11.069z" style="fill:#4d4d4d;"/><path d="m112.27 73.826c-18.585-7.5217-34.987-14.797-48.939 5.018-4.9752 7.083-3.7876 8.8056-4.9217 0.0749-1.637-12.476-4.7505-34.174 1.9259-45.194 7.6822-12.7 19.323-13.128 31.039-5.3818 10.796 7.7784 24.277 14.647 38.015 12.219 12.732-2.2576 15.835-7.7464 15.707-19.912-0.0215-2.6-0.0963-5.2106-0.2033-7.7999 13.631 3.9267 24.609 14.776 26.513 29.049 0.88804 6.6336 0.26749 12.722-1.9259 19.013-5.9702 17.108-30.119 20.896-45.74 16.841-3.9588-1.0378-7.6822-2.4181-11.47-3.9267z" style="fill:#4d4d4d;"/>', i["06"] = [], i["06"].env = a, i["06"].clo = '<path d="m115.5 231a115 115 0 0 0 64.23-19.5 114.79 114.79 0 0 0-38-16.5l-2.41-9a125.19 125.19 0 0 0-13.32-2.28v8.75q3.52 0.32 7 0.84l-17.5 17.48-17.5-17.48q3.45-0.52 7-0.84v-8.75a125.55 125.55 0 0 0-13.34 2.28l-2.41 9a114.79 114.79 0 0 0-38 16.5 114.94 114.94 0 0 0 64.25 19.5z" style="fill:#646464;"/><path d="m132.98 193.33-36.185 36.155-2.4-0.42 36.108-36.081z" style="fill:#e3e3e3;"/>', i["06"].head = l, i["06"].mouth = '<path d="m127.84 146.73c-2.24 8.93-6.92 15.08-12.34 15.08s-10.1-6.15-12.34-15.08z" style="fill:#fff;' + c + '2.9999px;stroke:#1a1a1a;"/>', i["06"].eyes = '<path d="m129.31 114.14 20-5.37m-47.66 5.37-20-5.37" style="fill:none;' + c + '4.9998px;stroke:#1a1a1a;"/>', i["06"].top = '<path d="m169.65 90.998c3.137 11.94 4.9371 36.484-3.4118 58.213l5.129 3.1164c10.044-15.199 14.959-39.163 13.943-61.33z" style="fill:#1a1a1a;"/><path d="m45.081 90.989c-0.88085 4.9304-0.87534 14.953-0.15027 21.75 2.1318 19.98 16.671 42.505 16.671 42.505l5.7352-4.4331s-13.244-31.348-6.0571-52.751c0.52108-1.5517 0.95592-2.916 1.3462-4.1835z" style="fill:#1a1a1a;"/><path d="m117 3.4883c-8.2136-0.19887-19.13 7.933-18.494 9.3516 1.6214 3.6186 11.176 22.55 11.889 23.963h10.148c2.6022-6.3102 11.32-26.531 11.32-26.531s-4.1382-4.138-12.416-6.4375c-0.77605-0.21556-1.5976-0.32513-2.4473-0.3457z" style="fill:#1a1a1a;"/><path d="m115.95 4.5428c-3.1563 0-6.3123 0.57462-9.2165 1.715-5.8084 2.2817-10.532 6.808-12.779 12.245v-5e-3c-1.8166 4.397-2.0233 9.3441-0.58058 13.857 0.69352 2.1687 1.7693 4.2296 3.1533 6.0968h38.893c0.71032-0.95769 1.3441-1.9641 1.8787-3.0144 2.6811-5.2673 2.9296-11.542 0.67253-16.975-2.257-5.4337-6.9893-9.9522-12.802-12.224-2.9064-1.1335-6.0633-1.6987-9.2196-1.6956z" style="fill:#1a1a1a;"/><path d="m92.512 28.125c0.13387 1.4318 0.41877 2.8511 0.85962 4.2306 1.4429 4.5127 4.5278 8.5654 8.6411 11.353 4.1135 2.7873 9.2311 4.2913 14.336 4.2165 5.1052-0.0764 10.168-1.7333 14.181-4.6419 2.8754-2.0834 5.2132-4.7932 6.7665-7.8447 1.2005-2.3586 1.9085-4.9188 2.127-7.5156-15.037-2.6407-31.421-3.4671-46.912 0.20253z" style="fill:#b3b3b3;"/><path d="m34.426 90.63c14.714 4.0779 22.683 6.4085 45.254 7.4257 2.5318-18.185 4.6689-28.672 10.023-38.352 3.2025 13.403 3.8346 25.22 2.9106 42.253l11.172-0.23161c1.4706-11.886 3.8989-29.213 2.1636-42.021 10.416 12.631 11.373 23.624 13.077 39.726 30.174-0.76004 59.808-4.5121 77.845-10.128-10.76-38.608-41.475-55.66-80.38-56.104-38.182-0.45134-74.543 22.405-82.065 57.432z" style="fill:#1a1a1a;"/>', i["07"] = [], i["07"].env = a, i["07"].clo = '<path d="m88.18 194.11c-4.2079 1.021-8.3545 2.2792-12.42 3.7695v26.072a115.5 115.5 0 0 0 79.48 0v-26.072c-4.0858-1.4904-8.2529-2.7486-12.48-3.7695v8.7051c0 9.3888-7.6112 17-17 17h-20.58c-9.3888 0-17-7.6112-17-17v-8.7051z" style="fill:#efefef;"/>', i["07"].head = l, i["07"].mouth = '<polygon points="121.61 160.74 109.39 160.74 115.5 171.31" style="fill:#797979;"/><path d="m132.64 144.06a34.42 34.42 0 0 1-34.24 0" style="fill:none;' + c + '5.9998px;stroke:#000;"/>', i["07"].eyes = '<path d="m170.25 100c1.69 9.62-4.79 29.23-22.4 29.23-6.81 0-15-3.66-20.23-10-4.34-5.33-7.56-12.87-6.2-19.45 1.63-7.89 7.07-11.45 14.67-12.92a68.16 68.16 0 0 1 12.52-1c10.77 0 19.78 3.61 21.64 14.22z" style="fill:#565656;stroke-width:3.99px;stroke:#000;"/><path d="m60.75 100c-1.69 9.62 4.79 29.23 22.4 29.23 6.81 0 15-3.66 20.23-10 4.34-5.33 7.56-12.87 6.2-19.45-1.63-7.89-7.07-11.45-14.67-12.92a68.16 68.16 0 0 0-12.52-1c-10.77 0-19.78 3.61-21.64 14.22z" style="fill:#565656;stroke-width:3.99px;stroke:#000;"/><line x1="100.2" x2="130.8" y1="87.92" y2="87.92" style="fill:none;' + c + '3.99px;stroke:#000;"/><path d="m109.87 101.73c0-2.59 2.52-4.69 5.63-4.69s5.63 2.1 5.63 4.69" style="fill:none;stroke-width:3.99px;stroke:#000;"/>', i["07"].top = '<path d="m30.622 70.381c2.0971-3.9374 4.6649-7.9604 7.6822-12.037 3.0172-4.0765 6.0987-7.6929 9.2229-10.817l22.897 22.897c-4.4402 4.4403-8.2278 9.5439-11.213 15.14z" style="fill:#999;"/><path d="m160.58 70.423 22.907-22.897c3.1242 3.1242 6.2056 6.7406 9.2229 10.817 3.0065 4.0765 5.5744 8.0994 7.6715 12.037l-28.578 15.182c-2.9851-5.5958-6.7727-10.689-11.224-15.14z" style="fill:#999;"/><path d="m92.411 15.247c3.8197-0.87736 7.6715-1.5407 11.534-1.9794 4.0765-0.46007 7.9282-0.69546 11.555-0.69546 1.53 0 3.1563 0.0428 4.8682 0.1391l1.851 22.255 5.767-21.57c3.1028 0.37449 6.0666 0.86666 8.8912 1.4658l-10.55 49.763c-1.9259-0.41729-3.702-0.70617-5.3176-0.87736-1.423-0.14979-3.2633-0.22468-5.5102-0.22468-2.2362 0-4.237 0.10699-5.981 0.29958-1.9473 0.22469-3.8732 0.55636-5.767 0.99504z" style="fill:#999;"/><path d="m92.411 15.247c1.9152-0.43869 4.023-0.84526 6.3233-1.2304 2.065-0.34238 4.1514-0.62057 6.2698-0.84525l5.1785 50.565c-1.0913 0.10699-2.1827 0.25679-3.2954 0.43868-0.86665 0.14979-1.9152 0.36378-3.1349 0.64196z" style="fill:#4d4d4d;"/>', i["08"] = [], i["08"].env = a, i["08"].clo = '<path d="m141.89 195a114.79 114.79 0 0 1 38 16.5 115.55 115.55 0 0 1-128.47 0 114.79 114.79 0 0 1 38-16.5l15.75 15.75h21z" style="fill:#353535;"/><path d="m146.4 196.14-17.4 17.44-1.17 1.17h-24.34l-1.18-1.17-17.43-17.44c1.49-0.41 3-0.79 4.51-1.14l4.67-1 12.74 12.74h17.69l12.73-12.74 4.67 1c1.52 0.35 3 0.73 4.51 1.14z" style="fill:#919191;"/>', i["08"].head = l, i["08"].mouth = '<path d="m115.68 160.64c7.08 0 13.11-4.93 15.46-11.84a2.14 2.14 0 0 0-1.51-2.6101 2.3 2.3 0 0 0-0.73995-0.0593h-26.42a2.12 2.12 0 0 0-2.31 1.9099 1.85 1.85 0 0 0 0.0593 0.73995c2.3401 6.9301 8.3802 11.86 15.46 11.86z" style="fill:#2f2f2f;"/>', i["08"].eyes = '<path d="m145.38 95.628c-5.1601 2.2597-11.03 2.2597-16.19 0m-47.29 1.75c5.1755-2.2694 11.065-2.2694 16.24 0" style="fill:none;' + c + '5.9998px;stroke:#5e5e5e;"/><path d="m90.016 106.28c-4.4506-0.0105-6.6902 5.3657-3.5508 8.5195 3.1394 3.1539 8.5252 0.93887 8.5352-3.5117 0.0063-2.7522-2.2204-4.9898-4.9727-4.9961l-0.011719-0.01172zm47.281 0c-4.4506-0.0105-6.6902 5.3657-3.5508 8.5195 3.1394 3.1539 8.5252 0.93887 8.5352-3.5117 6e-3 -2.7522-2.2204-4.9898-4.9727-4.9961l-0.01171-0.01172z" style="fill:#1a1a1a;"/>', i["08"].top = '<path d="m108.37 22.019c-6.2698-12.829-17.151-13.396-18.949 1.1769-11.448-9.4583-26.021-4.483-20.361 12.422-12.251-7.9282-24.919 1.7761-17.076 20.853-27.08 2.3646-22.715 24.726-10.111 31.435-9.9002 3.3566-10.701 9.4006-8.464 14.497 2.6574 4.7842 9.0126 6.4737 11.545 9.6519-6.624 0.59419-8.4112 5.6011-5.7404 9.5192 1.6896 2.4787 5.2756 4.2218 8.5971 5.5455 1.0485 0.40658 3.702 1.2732 3.9053 2.4181 0.18744 1.2156-6.7884 3.0055-5.7281 5.2612 0.60648 1.4227 1.7764 2.7151 2.6466 3.7156 1.2807 1.6595 10.755 8.0351 9.4583 4.2049-1.0271-3.7234-2.2148-7.4682-3.1456-11.192-1.1662-5.3069-1.7868-10.721-1.102-16.156 1.4223-5.455 5.069-4.4265 7.7837-8.3588 3.5264-5.7505 2.0296-11.614 2.124-13.575 0.107-1.7868 1.5407-1.1876 3.1884-1.4337 4.3868-0.64196 7.0081-2.1185 8.8377-6.2698 0.77035-1.9259 0.62057-9.7578 0.52426-11.78 0.36378-4.6328 4.1835 0 6.548 0.64196 3.2633 0.88805 6.8797 0.21399 9.0731-2.5037 1.7547-2.3753 2.0864-2.8888 4.6114-0.80245 2.6856 2.2148 4.0979 3.1349 7.6929 3.274 5.5637 0.20329 8.7735-6.2698 11.32-5.6386 3.5201 0.87735 3.6057 5.4567 10.261 4.8682 2.386-0.20329 3.8304-0.86665 5.4032-2.6428 0.88805-0.99505 1.958-2.5037 3.4345-2.6214 1.4658-0.1177 2.3218 2.3646 3.0065 3.4452 1.1926 2.6755 4.0295 3.6513 6.2377 3.3168 1.958-0.17119 3.854-1.4115 5.4268-2.4707 0.99679-0.66102 1.8284-0.81128 1.9256 0.2071 0.29592 2.2271 0.0862 7.7025 0.1596 8.4821 0.10556 8.4609 5.37 10.569 13.223 10.333-0.31871 3.7464 0.0583 11.28 5.4353 14.562 3.9481 2.7604 6.6657 1.2732 6.7299 7.8534 7e-3 6.1914-0.43693 13.061-1.2946 18.189-0.69547 4.0444-1.2412 6.4838-2.5251 10.378-0.64196 1.9152-0.81315 1.9687 1.4123 1.0699 7.1472-3.1456 10.539-11.48 8.3562-18.842-0.43869-2.0436 0.84525-1.7226 2.8781-2.6106 9.5248-4.2363 8.1264-11.335-0.75967-14.273 11.988-3.0926 13.886-8.9002 6.6871-15.375 7.3077-5.9168 3.6378-16.177-2.8032-16.991 12.422-7.0937 5.7349-22.062-5.1036-18.499 4.1728-12.037-5.5637-26.203-21.121-16.894 6.9653-11.373 2.065-22.661-12.101-10.785-3.4559-18.382-15.14-16.584-23.902-5.018 0.09435-20.075-16.001-17.42-18.146-2.5892z" style="fill:#1a1a1a;"/><path d="m5.4353 80.502c7.4468 9.1373 15.632 8.8912 15.632 8.8912s-6.0772 3.7983-6.8369 9.8755c-0.75966 6.088 4.5579 9.6295 8.0994 10.646 3.5522 1.0058 7.0937-2.7925 7.0937-2.7925s-5.8312 10.646-1.5193 15.964c4.3012 5.3176 11.908 3.0386 11.908 3.0386s-5.3283 10.132 1.0057 14.187c5.8312 3.7234 18.542 7.6715 20.511 8.2706-6.0666-9.7472-9.576-21.249-9.576-33.575v-0.0428c0-35.201 28.546-63.747 63.747-63.747 35.212 0 63.758 28.546 63.758 63.747 0 12.476-3.5843 24.116-9.7899 33.949h0.53496s13.931-1.0057 16.21-9.3727c2.279-8.3562 0.75967-9.8756 0.75967-9.8756s10.635 2.0329 13.417-7.5966l2.7926-9.6295s10.132 0 10.892-7.083c0.75963-7.0937-7.0295-12.411-7.0295-12.411s11.459 0.82385 14.498-10.453c1.0164-3.7555 0.83456-8.2171 0.1391-12.497-17.665-41.161-58.569-69.995-106.18-69.995-30.632 0-60.034 12.187-81.679 33.831v0.0107c-13.171 13.171-22.833 29.22-28.386 46.66z" style="fill:#1a1a1a;"/>', i["09"] = [], i["09"].env = a, i["09"].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l13.85 13.85v-1.2h17.86v3.1h5z" style="fill:#333;"/><polygon points="115.36 207.65 123.37 224.2 148.3 196.86 143.08 189.95" style="fill:#fff;"/><polygon points="115.36 207.65 107.35 224.2 82.42 196.86 87.63 189.95" style="fill:#fff;"/>', i["09"].head = l, i["09"].mouth = '<path d="m126.28 149.82c-6.16 2.43-15.52 2.42-21.56 0" style="fill:none;' + c + '5.9998px;stroke:#1c1c1c;"/>', i["09"].eyes = '<path d="m83.527 103.98v10h10v-10h-10zm53.945 0v10h10v-10h-10z" style="fill:#1a1a1a;"/><path d="m56.621 94.906v11.688h5.3418v6.4922h5.3418v6.1055h5.3223v6.2324h26.846v-6.2324h5.3047v-6.1055h5.1445v-6.0039h11.154v6.0039h5.1446v6.1055h5.3066v6.2324h26.846v-6.2324h5.3203v-6.1055h5.3438v-6.4922h5.3418v-11.688z" style="fill:#1a1a1a;"/><path d="m67.387 100.65v5.9394h5.1992v-5.9394zm5.1992 5.9394v6.4922h5.4238v-6.4922zm5.4238 0h5.1992v-5.9394h-5.1992zm5.1992 0v6.4922h5.4258v-6.4922zm5.4258 6.4922v6.1055h5.1426v-6.1055zm-10.625 0v6.1055h5.1445v-6.1055zm48.281-12.432v5.9394h5.1992v-5.9394zm5.1992 5.9394v6.4922h5.4238v-6.4922zm5.4238 0h5.1992v-5.9394h-5.1992zm5.1992 0v6.4922h5.4258v-6.4922zm5.4258 6.4922v6.1055h5.1426v-6.1055zm-10.625 0v6.1055h5.1445v-6.1055z" style="fill:#fff;"/>', i["09"].top = '<path d="m157.79 67.5a61.31 61.31 0 0 1-42.79 17.43h-55.7c18.16-37.74 68.27-46.85 98.49-17.43z" style="fill:#4d4d4d;"/><path d="m122.93 7.0078c-10.503-0.15729-21.09 1.6448-29.545 5.4316-17.141 7.8999-32.169 23.297-43.973 38.779-5.1703 6.8631-8.7779 13.46-8.1855 18.395 0.93114 12.312 10.372 26.483 11.068 36.9 15.663-72.081 105.99-70.452 124.91-7.0525l4e-3 0.0156c5.616-10.926 8.0682-20.188 8.352-27.653 0.43654-15.607-7.8088-21.149-21.735-28.249 1.7934-3.7704 1.7273-7.5023 2.0625-10.154-0.79964-7.8568-3.6796-13.51-10.43-17.758-5.9434-3.7404-13.06-6.0867-18.463-7.2266-4.5319-0.87895-9.2901-1.3562-14.064-1.4277z" style="fill:#4d4d4d;"/><path d="m42.426 75.338c0.52158 18.689 10.557 74.338-18.115 101.25 12.38 10.603 28.352 19.061 46.025 24.594 11.032-4.6874 22.88-7.4147 34.817-8.5046l0.0633-14.477c-22.49-4.3813-40.766-18.898-48.862-39.967-8.096-21.07-4.7931-44.72 9.2478-62.393zm124.67 2.7207c7.8997 10.886 11.743 24.64 11.787 37.441-0.36632 30.178-22.389 57.576-53.12 62.708l0.0238 14.471c12.282 1.1216 24.518 3.9888 35.825 8.9128 15.488-5.1448 30.007-13.325 42.396-25.043-13.136-22.051-23.282-63.045-18.694-101.55z" style="fill:#4d4d4d;"/><path d="m143.61 46.383c-11.639 0.12482-20.998 1.8906-20.998 1.8906l-9 3.5059c0.63003-0.0191 1.2603-0.0289 1.8906-0.0293h0.0996c35.169 0.055 60.959 27.235 63.283 63.383 7.4e-4 31.157-22.742 57.213-53.106 63.079l-0.0216 14.498c11.567 1.0563 23.154 3.6067 33.887 8.0463 35.952-15.315 55.082-52.303 36.709-68.279-5.018-7.9035-10.44-15.409-9.5544-23.03 5.0545-50.452 0.39626-63.561-43.189-63.064zm-69.966 21.09c-15.286 3.244-17.096 3.73-31.734 6.6953 3.0304 13.081 3.0583 22.274 1.2085 30.012-3.8004 11.361-8.9712 19.787-12.286 28.764-6.8823 22.459-2.9157 31.982 12.093 46.165 8.6595 8.0693 19.861 16.209 30.939 20.647 2.669-1.0316 5.3729-1.9628 8.106-2.792 7.4979-2.275 15.388-3.6535 23.206-4.3673l0.0433-14.393c-23.933-4.5937-44.283-21.98-50.77-45.817-6.3319-23.265 0.51104-48.752 19.195-64.914z" style="fill:#4d4d4d;"/>', i[10] = [], i[10].env = a, i[10].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l15.71 15.75h21z" style="fill:#666;"/><path d="m89.291 195a114.79 114.79 0 0 0-38.002 16.5 115.53 115.53 0 0 0 38.002 16.482zm52.434 0v32.982a115.53 115.53 0 0 0 38-16.482 114.79 114.79 0 0 0-38-16.5z" style="fill:#999;"/><path d="m157.15 199.75c0.2548 7.4501 1.54 14.855 4.9512 21.432a115.53 115.53 0 0 0 17.619-9.6797 114.79 114.79 0 0 0-22.57-11.752zm-83.295 2e-3a114.79 114.79 0 0 0-22.57 11.75 115.53 115.53 0 0 0 17.621 9.6797c3.411-6.5765 4.6944-13.98 4.9492-21.43z" style="fill:#ccc;"/><path d="m99.197 204.97v2e-3l16.302 16.301 16.301-16.301v-2e-3z" style="fill:#fff;"/>', i[10].head = l, i[10].mouth = '<path d="m100.19 152.09c2.8726 4.0616 9.8095 4.7232 15.119-0.45432 5.0656 4.5134 11.167 5.6898 15.495 0.31458" style="fill:none;' + c + '5.8949;stroke:#333;"/><path d="m109.67 135.53c-0.9758 0.0743-2.05 0.45327-3.1485 0.99414-4.3235 2.1399-7.3862 4.2557-10.639 7.1406-0.6251 0.5715 0.1168 0.77785 1.4238 0.87304 5.6967 0.0536 14.384 0.41404 15.098-0.875 1.9251-2.0788 1.7969-5.3303-0.1816-7.3008-0.701-0.67533-1.5769-0.90632-2.5527-0.83203zm11.656 0c-0.9758-0.0743-1.8517 0.1567-2.5527 0.83203-1.9785 1.9705-2.1067 5.222-0.1817 7.3008 0.7142 1.289 9.401 0.9286 15.098 0.875 1.307-0.0952 2.0489-0.30154 1.4238-0.87304-3.2524-2.8849-6.3151-5.0007-10.639-7.1406-1.0985-0.54087-2.1727-0.91985-3.1485-0.99414z" style="fill:#333;"/>', i[10].eyes = '<path d="m97.56 107.84a10.63 10.63 0 0 1-15 0.13l-0.13-0.13" style="fill:none;' + c + '6.3px;stroke:#000;"/><path d="m148.59 107.84a10.63 10.63 0 0 1-15 0.13l-0.13-0.13" style="fill:none;' + c + '6.3px;stroke:#000;"/>', i[10].top = '<path d="m41.668 87.073c-9.2319-0.0231-11.63 6.5104 2.2676 17.66-14.015 1.1231-4.3662 16.457 4.875 24.66 4.0686 3.0199 6.4647 5.4657 5.5078 1.1348-1.2079-4.9178-1.8184-9.9634-1.8184-15.027 3.26e-4 -7.5692 1.2547-15.016 3.7883-22.183 0.57048-1.7876 1.0689-2.0306-0.37721-2.6839-5.5405-2.4478-10.375-3.5511-14.243-3.5608z" style="fill:#ccc;"/><path d="m185.48 89.513c-2.4418-0.11189-5.4618 0.81187-9.5148 3.2121-1.314 0.81729-0.70075 1.995-0.32301 3.2653 3.194 10.982 3.8215 22.462 1.2538 33.628-0.31613 1.688-0.47649 3.569 2.6953 1.3516 7.7016-5.371 19.17-18.734 16.918-26.105-1.4251-3.9177-11.4-0.35546-11.4-0.35546s4.987-4.2755 5.3437-9.6191c0.20048-3.0057-1.5237-5.2189-4.9726-5.377z" style="fill:#ccc;"/><path d="m91.689 36.108c-3.7298-7.3864-9.5859-10.504-17.578-6.7891-9.5194 4.5907-15.629 18.444-13.416 29.232 0 0-8.5511-4.9878-18.17-3.5625-19.623 8.094-1.4102 29.869 10.817 37.342 2.075 1.297 2.5792 1.7432 3.4291-0.37685 2.6746-6.5374 6.1886-12.722 11.297-17.709 4.1039 8.7427 14.629 4.1809 20.006-0.14062 4.4873 9.6838 10.377 6.3535 15.377 3.4785 4.0764 7.8829 10.756 7.25 17.631 0.0625 4.875 4.5625 14.713 4.1867 15.555-3.426 8.4753 2.6244 14.012 10.437 22.962-1.4764 8.8552 6.8221 14.407 16.853 17.122 27.51 0.34 1.554 1.175 0.85565 2.2212 0.44315 10.255-4.286 22.842-15.749 15.705-23.975-3.5623-3.5623-13.539-2.1387-13.539-2.1387s6.77-7.1233 9.2637-18.168c2.4936-11.043-23.514-4.9883-23.514-4.9883s7.4818-5.6993 12.113-13.537c4.6314-7.8378-2.4943-11.756-11.045-11.043-8.5496 0.71204-17.1 7.4805-17.1 7.4805s3.3946-7.8055-3.5625-12.826c-9.5935-6.9234-23.869 6.4121-23.869 6.4121-4.2562-26.835-24.872-6.386-31.707 8.1953z" style="fill:#ccc;"/>', i[11] = [], i[11].env = a, i[11].clo = '<path d="m116 203.13c-0.12 0-0.25 0.12-0.49 0.12s-0.25-0.12-0.49-0.12zm-27.29-8c0.87-0.25 1.72-0.47 2.56-0.69a32.37 32.37 0 0 0 0.3 8.57 21.5 21.5 0 0 0 7 6.88c6.41-6 16.8-6.64 16.8-6.64s10.5 0.58 17 6.69a21.61 21.61 0 0 0 6.93-6.66 32.34 32.34 0 0 0 0.35-8.84l2.13 0.56a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.64 114.64 0 0 1 37.38-16.37z" style="fill:#e9e9e9;"/><path d="m126.15 206-3.92 7.83h-13.46l-3.92-7.83a36.59 36.59 0 0 1 10.65-2.7 35.66 35.66 0 0 1 10.65 2.7z" style="fill:#818181;"/><path d="m124.54 230.65-2.18-16.74h-13.47l-2.19 16.76c2.9 0.22 5.84 0.33 8.8 0.33s6.06-0.12 9-0.35z" style="fill:#989898;"/><path d="m134.84 186s0.86 9.8-19.34 17.26c0 0 15.79 0.86 20.57 11.76 0.12 0.49 9.3-23.26-1.23-29z" style="fill:#fff;"/><path d="m96.16 186c-10.41 5.76-1.35 29.39-1.1 29 4.65-10.78 20.56-11.76 20.56-11.76-20.32-7.45-19.46-17.24-19.46-17.24z" style="fill:#fff;"/>', i[11].head = l, i[11].mouth = '<path d="m118.57 165.14a8.66 8.66 0 0 0-2.76-4.23h-0.62a8 8 0 0 0-2.76 4.22c-0.52 1.89 2.07 10.61 2.76 12.53h0.62c0.64-1.76 3.19-10.82 2.76-12.52z" style="fill:#333;"/><path d="m102.81 152.24a2.4921 2.4921 0 1 1 1.19-4.84l0.21 0.06a37.1 37.1 0 0 0 5.43 1.12 44.52 44.52 0 0 0 11.76 0 37.1 37.1 0 0 0 5.43-1.12 2.4903 2.4903 0 0 1 1.59 4.72l-0.21 0.06a43.08 43.08 0 0 1-6.15 1.29 48.55 48.55 0 0 1-13.08 0 42.79 42.79 0 0 1-6.17-1.29z" style="fill:#333;"/>', i[11].eyes = '<path d="m86.851 100.39a4.94 4.94 0 1 0 4.9297 5 5 5 0 0 0-4.9297-5zm57.221 0a4.94 4.94 0 1 0 4.9394 4.9394 4.94 4.94 0 0 0-4.9394-4.9394z" style="fill:#333;"/><path d="m86.207 89.365c-25.504 0-21.503 6.8561-21.035 19.596 0.80177 18.121 17.763 16.514 21.201 16.639 14.758-0.041 20.518-8.227 22.951-22.932 1.8166-10.731-9.251-13.174-23.117-13.303zm58.598 0c-13.866 0.1284-24.936 2.5717-23.119 13.303 2.4332 14.705 8.1936 22.891 22.951 22.932 3.4383-0.125 20.399 1.4828 21.201-16.639 0-18.965-0.47958-19.596-21.033-19.596z" style="fill:#4d4d4d;"/><path d="m169.87 90.255a0.51 0.51 0 0 0-0.43991-0.52 167.64 167.64 0 0 0-22.6-1.6801c-12 0-27.47 3.7601-30.17 3.7601h-2.4c-1.2499 0-5.29-0.80996-10.45-1.6801a124.35 124.35 0 0 0-19.72-2.08 166.18 166.18 0 0 0-19.31 1.24c-1.56 0.17999-2.69 0.35009-3.2899 0.44009a0.51 0.51 0 0 0-0.44007 0.52l-0.091 6.4501a0.57 0.57 0 0 0 0.33012 0.52l0.73994 0.23992c1.08 0.41992 1.0001 19.85 6.78 24.71 3.4401 2.8599 6.51 4.4899 19.42 4.4899 7.4699 0 12.17-1.9999 16.63-8 3.21-4.32 6.0999-14.55 6.0999-14.55 0.82006-4.07 3.7702-4.52 4.43-4.5801h0.12068c0.11078 0 3.66 0.0593 4.57 4.5801 0 0 2.8599 10.22 6.0699 14.54 4.4601 5.9999 9.1601 8 16.63 8 12.91 0 16-1.63 19.42-4.4901 5.7898-4.86 5.6998-24.29 6.78-24.71l0.73994-0.23993a0.57 0.57 0 0 0 0.32996-0.52l-0.12068-6.4501zm-65 23c-1.9101 4.5-6.8 10.29-13.7 10.64-20.7 0.99985-21.65-4.7401-23-9.3201a31.45 31.45 0 0 1-1.2099-13.18c0.53997-4.5799 1.7-7.2699 3.7801-8.6201a9.3 9.3 0 0 1 4.3499-1.51 85.07 85.07 0 0 1 11.4-0.52 59.23 59.23 0 0 1 9.2099 0.69999c7.37 1.2 12.35 3.7001 12.35 6.1601a46.12 46.12 0 0 1-3.23 15.64zm58 1.3201c-1.34 4.5799-2.29 10.36-23 9.3201-6.91-0.3501-11.81-6.1401-13.71-10.64a46.35 46.35 0 0 1-3.22-15.64c0-3.39 9.43-6.8599 21.56-6.8599 12.13 0 14 0.89996 15.75 1.9999 2.08 1.3502 3.2398 4 3.77 8.6201a31.23 31.23 0 0 1-1.1601 13.17z" style="fill:#333;"/>', i[11].top = '<path d="m156.1 15.879c-0.38556 5.3015-1.7049 9.4762-3.6602 12.76-0.41226 23.773-9.2343 35.229-15.154 42.797l15.062-4.6641c-0.66253 2.8135-2.4628 7.156-0.34766 12.137 1.6334-2.3144 7.9395-5.807 13-3.3477-0.43442 3.5532-0.95271 7.094-1.4512 10.639l8.9648 0.85937c0.83453 3.8792 0.51719 9.3449-0.59961 11.736l5.5508 2.0098c0.20764 2.7646 0.10001 5.4906-0.74609 8.875 8.4545-1.7225 14.213-4.3896 19.641-13.188 2.8639-4.7524 4.9018-10.483 4.7305-17.242-4.1612 4.916-9.6484 7.2485-15.26 10.109 6.507-11.065 8.8648-22.768 8.1367-30.58-7.3456 10.251-11.649 13.06-19.918 16.9 1.2386-11.4 5.5249-18.582 12.461-27.27-11.392-1.3025-16.301 1.4749-24.891 6.4395 4.5466-14.036 2.2208-26.679-5.5195-38.971zm-117.76 28.682c9.3378 3.6366 19.581 9.0234 21.129 18.549-7.6182 0.0414-14.897-3.5072-20.242-7.1894-0.15967 8.2309 2.8451 12.252 6.7734 19.08-7.2127 1.6129-12.084 4.8315-17.471 9.4805 7.2948-0.15715 12.299-1.0502 16.891 4.2793-6.0512 5.0164-11.99 10.79-11.99 19.24 9.257-6.1688 12.495-5.9486 21.137-2.2012 1.2906-8.0996 2.3978-14.872 2.7869-16.435 2.4719-0.73247 3.5247-0.94807 5.9221-1.2938-2.1556-7.4281 1.0996-9.5176 2.4141-11.6l7.543 1.5059c-3.9093-6.1699 2.6565-12.483 7.1445-15.51-4.4474-7.2082-5.6649-11.558-7.377-16.797-11.198-8.2947-23.895-6.2742-34.66-1.1094z" style="fill:#f9f9f9;"/><path d="m101.9 7.6408c-10.047 6.2416-12.441 28.646-12.131 33.289-6.9249-5.8258-7.8992-13.75-7.7695-19.203-9.6235 6.0158-10.666 14.421-9 23.943 1.1061 5.1411 2.3972 10.461 7.377 16.797 2e-3 -1e-3 4e-3 -3e-3 6e-3 -4e-3 2.7742 2.8742 5.4644 5.5941 8.3477 8.3574 0.41187-6.971 0.45449-13.622 7.1856-15.824 3.9532 2.8169 7.4123 5.9388 11.084 9.1035l10.559-10.25c5.6447 3.961 5.4531 6.5652 6.5215 14.104 2.153-1.7546 8.719-9.0037 15.844-10.139 0.98706 4.1261-0.99388 10.308-2.6387 13.621 0 0 14.32-11.846 15.195-27.971 0.33968-6.2599 0.2237-11.146-0.041-14.826-3.2125 5.5652-8.7118 8.7799-13.789 10.15-4.2715-9.2486-2.4785-21.435-0.48047-29.309-12.21 3.0195-20.932 18.337-22.172 25.07-9.2678-7.397-13.605-16.146-14.098-26.91z" style="fill:#f9f9f9;"/>', i[12] = [], i[12].env = a, i[12].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5l26.23 13 26.27-13z" style="fill:#131111;"/><polygon points="115.5 208.03 115.5 207.74 82.72 188.91 80.45 198.86 101.46 222.72" style="fill:#cbcbcb;"/><polygon points="115.5 208.03 115.5 207.74 148.28 188.91 150.55 198.86 129.54 222.72" style="fill:#cbcbcb;"/>', i[12].head = l, i[12].mouth = '<path d="m123.07 154.05a10.61 10.61 0 0 1-15 0.14l-0.14-0.14" style="fill:none;' + c + '6.3px;stroke:#000;"/><path d="m120.1 142.22 0.19-0.11c3-1.87 5.45-2.4 7.3-1.46 2.15 1.1 3.12 3.84 4.84 5.5a5.18 5.18 0 0 0 6.68 0.73m-28.21-4.66-0.19-0.11c-3-1.87-5.45-2.4-7.3-1.46-2.15 1.1-3.12 3.84-4.84 5.5a5.18 5.18 0 0 1-6.68 0.73" style="fill:none;' + c + '5.9998px;stroke:#4d4d4d;"/>', i[12].eyes = '<path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45c0 3.0002 2.74 5.3001 6.0001 5.3001h32.36c7.0901 0 7.44-19.43 13.82-19.43s6.8801 19.44 13.83 19.44h32.36c3.37 0 5.9999-2.4 5.9999-5.3001v-28.46c0.14043-2.9001-2.6-5.2999-5.9-5.2999z" style="fill:#8f8f8f;"/><path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45l104.55-28.45c0-2.9001-2.74-5.2999-5.9999-5.2999z" style="fill:#e3e3e3;"/><path d="m161.73 86.016h-92.51c-3.37 0-6.0001 2.3998-6.0001 5.2999v28.45c0 3.0002 2.74 5.3001 6.0001 5.3001h32.36c7.0901 0 7.44-19.43 13.82-19.43s6.8801 19.44 13.83 19.44h32.36c3.37 0 5.9999-2.4 5.9999-5.3001v-28.46c0.14043-2.9001-2.6-5.2999-5.9-5.2999z" style="fill:none;' + c + '4.0026px;stroke:#232323;"/>', i[12].top = '<path d="m69.834 33.826c-8.2001-0.0626-16.444 2.6753-23.152 7.7038-8.5298 6.9899-12.159 19.61-12.329 32.68-0.2041 15.476 1.6092 34.752 1.7464 51.915 0.10414 13.047 0.53485 25.984-2.9197 33.995-2.4994 5.81-9.0955 9.6006-16.196 12.311 7.9599 2.8301 25.009 2.8094 33.58 1.5393 10.8-1.59 17.238-6.5294 17.159-22.699-0.0911-15.93-1.3894-29.23-1.559-45.83-0.3208-11.983-1.569-24.291 4.9774-33.987 4.2139-6.1265 10.452-10.521 17.116-13.588 3.9292-1.8575 8.0384-3.3083 12.263-4.3297-6.8718-13.574-18.732-19.618-30.687-19.709z" style="fill:#b3b3b3;"/><path d="m90.8 76.246c11.918-17.125 31.996-23.218 49.743-17.488 11.81 3.9496 20.692 13.389 22.313 28.237 0.51051 6.2098 0.63413 12.445 0.37007 18.67-0.23973 11.2-0.72946 23.82-1.0995 34.08-0.82005 22.43 0.0593 35.1 24.589 36.3 8.5635 0.32122 17.137-0.22845 25.59-1.6405h-0.0198c-10.74-3.3799-17.98-15.609-19.3-26.289-1.29-10.41-0.6098-23.43-0.7898-38.091-0.1701-14.96 1.0398-29.819 0.28008-42.089-1.414-22.777-14.947-38.505-34.126-45.152-27.813-7.35-51.083 0.091-61.672 17.343-5.4698 8.9112-7.7413 20.07-5.8788 36.121z" style="fill:#b3b3b3;"/>', i[13] = [], i[13].env = a, i[13].clo = '<path d="M61.11,205.59l3.49,3.69-6.26,6.6A115.45,115.45,0,0,0,72,222.51v-22a115.19,115.19,0,0,0-10.85,5.1Z" style="fill:#eee;"/><path d="M93.24,228.85V199l-4-4A114.43,114.43,0,0,0,72,200.49v22a114.43,114.43,0,0,0,21.28,6.34Z" style="fill:#787878;"/><path d="m159 222.51v-22a114.63 114.63 0 0 0-17.25-5.51l-4 4v29.86a114.16 114.16 0 0 0 21.25-6.35z" style="fill:#787878;"/><path d="m169.89 205.59-3.49 3.69 6.26 6.6a115.45 115.45 0 0 1-13.66 6.63v-22a115.19 115.19 0 0 1 10.85 5.1z" style="fill:#eee;"/><path d="M115.5,219.62A28.5,28.5,0,0,1,87.25,195c2.93-.74,5.92-1.36,8.94-1.87a19.41,19.41,0,0,0,38.62,0c3,.51,6,1.13,8.94,1.87a28.49,28.49,0,0,1-28.25,24.63Z" style="fill:#c9c9c9;"/>', i[13].head = l, i[13].mouth = '<path d="m115.5 153.93a14 14 0 0 1-10.5-4.69 3.4209 3.4209 0 0 1 5-4.67l0.08 0.08 0.08 0.09a7.35 7.35 0 0 0 10.39 0.37l0.37-0.37a3.4206 3.4206 0 1 1 5.23 4.41l-0.08 0.09a14 14 0 0 1-10.53 4.69z" /><path d="m115.27 127.32c-7.6627-0.03-15.251 1.4419-20.646 5.1465-7.62 5.33-9.9053 11.512-14.127 18.109-3.4379 5.2447-9.326 10.024-13.467 6.334 25.425 29.755 71.409 29.786 96.875 0.0664-6.8104 3.9305-11.545-2.47-13.508-6.4004-10.697-17.605-14.115-22.656-35.127-23.256zm-0.26758 8.3984c7.457 0.0802 14.986 1.2966 17.146 5.9522 2.5765 11.319-7.5878 17.454-16.681 17.515-6.09-0.05-12.2-2.3802-15.26-7.7402-6.36-11.16 3.6349-15.607 14.795-15.727z" style="fill:#404040;"/>', i[13].eyes = '<path d="m91.72 97.36v11.4m47.56-11.4v11.4" style="fill:none;' + c + '7.9999px;stroke:#333;"/>', i[13].top = '<path d="m52.107 57.293c-1.3411 14.839-3.8707 52.771 1.3145 72.715-0.67572-43.829 12.389-70.177 62.078-70.187 49.689 0.010061 62.754 26.359 62.078 70.187 5.1852-19.944 2.6556-57.876 1.3145-72.715h-63.393-63.393z" style="fill:#4d4d4d;"/><path d="m52.339 30.629c-1.3825 24.448-2.1216 45.905-1.4497 66.517 9.4643-48.304 112.77-54.916 129.22 0 0.67191-20.612-0.3798-47.256-1.4928-66.517-32.241 14.296-91.346 18.861-126.28 0z" style="fill:#4d4d4d;"/><path d="m115.5 24.92c-22.25 0-44.5 4.2296-56.72 12.69-3.32 2.3-5.0602 6.4392-5.5903 10.269-0.45275 3.23-0.84043 6.7561-1.1785 10.461h126.98c-0.33704-3.7047-0.72492-7.2306-1.1775-10.461-0.53009-3.8301-2.2697-7.9992-5.5897-10.269-12.22-8.4601-34.47-12.69-56.72-12.69z" style="fill:#4d4d4d;"/><path d="m76.521 39.139c21.233 3.3965 33.116-13.392 37.59-31.72 4.3614 17.158 14.175 34.968 36.577 31.584-33.921 20.594-57.646 11.594-74.167 0.1345z" style="fill:#4d4d4d;"/>', i[14] = [], i[14].env = a, i[14].clo = '<path d="m91.92 194.41a101.47 101.47 0 0 1 23.58 17.09 101.47 101.47 0 0 1 23.58-17.09c0.89 0.19 1.78 0.38 2.67 0.59a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5c0.88-0.21 1.78-0.4 2.67-0.59z" style="fill:#757575;"/><path d="m73.65 199.82c16.59 8.23 28.72 18.91 34.27 30.93a114.86 114.86 0 0 1-56.65-19.25 115.06 115.06 0 0 1 22.38-11.68z" style="fill:#d8d8d8;"/><path d="m60.63 205.85c12.35 5.94 21.93 13.44 27.59 21.91a114.7 114.7 0 0 1-36.95-16.26q4.53-3 9.36-5.65z" style="fill:#757575;"/><path d="m157.35 199.82c-16.6 8.23-28.72 18.91-34.27 30.93a114.86 114.86 0 0 0 56.65-19.25 115.06 115.06 0 0 0-22.38-11.68z" style="fill:#d8d8d8;"/><path d="m170.37 205.85c-12.35 5.94-21.93 13.44-27.59 21.91a114.7 114.7 0 0 0 36.95-16.26q-4.53-3-9.36-5.65z" style="fill:#757575;"/>', i[14].head = l, i[14].mouth = '<path d="m115.5 131c-17.71 0.65-27 9.41-29.61 23.69-1 5.62-0.43 7.06 2.76 7.17 22.76 0.76 22.23 18.21 26.85 18.89 4.62-0.68 4.09-18.13 26.85-18.89 3.19-0.11 3.79-1.55 2.76-7.17-2.62-14.28-11.9-23-29.61-23.69zm0 29.31c-10 0-18-5-18-11.17s8.08-11.17 18-11.17 18 5 18 11.17-8.08 11.17-18 11.17z" style="fill:#333;"/><path d="m123.54 148.46a11.53 11.53 0 0 1-16.09 0" style="fill:none;' + c + '6.7998px;stroke:#000;"/>', i[14].eyes = '<path d="m133 108.17h14.17m-63.26 0h14.09m-20.69-8.93a21.31 21.31 0 0 1 27.29 0m21.8 0a21.31 21.31 0 0 1 27.29 0" style="fill:none;' + c + '4.8243px;stroke:#000;"/>', i[14].top = '<path d="m115.5 51.75c-38.702 5.3101-54.215 18.038-59.863 35.101" style="fill:none;' + c + '12;stroke:#333;"/><path d="m115.5 51.75c-7.8393 3.6337-5.5974 16.583-14.341 23.452" style="fill:none;' + c + '12;stroke:#333;"/><path d="m111.35 48.614c-22.634-6.9181-42.457-3.1988-55.733 2.5105" style="fill:none;' + c + '12;stroke:#333;"/><path d="m115.47 54.008c0.1965-6.7774-0.1436-26.309 0.05-38.184" style="fill:none;' + c + '12;stroke:#333;"/><path d="m68.874 28.177c34.115-3.382 41.987 13.321 45.17 19.602" style="fill:none;' + c + '12;stroke:#333;"/><path d="m116.49 48.69c2.8876-6.3019 10.358-21.518 43.469-22.326" style="fill:none;' + c + '12;stroke:#333;"/><path d="m116.92 51.766c1.5094 6.3991 3.4988 15.595 10.088 23.058" style="fill:none;' + c + '12;stroke:#333;"/><path d="m113.81 51.532c22.03-7.8674 46.709-7.3614 59.444-2.0465" style="fill:none;' + c + '12;stroke:#333;"/><path d="m114.53 52.278c36.226 4.8583 52.414 17.092 59.373 33.347" style="fill:none;' + c + '12;stroke:#333;"/><path d="m55.637 86.851c-4.1213 12.452-2.9877 27.213-1.777 43.084" style="fill:none;' + c + '12;stroke:#333;"/><path d="m55.614 51.124c-13.422 5.5019-21.908 16.409-24.712 28.774-1.8322 8.4632-1.9809 18.156-1.6096 28.486" style="fill:none;' + c + '12;stroke:#333;"/><path d="m173.26 49.486c24.917 10.399 26.707 36.537 27.209 59.62" style="fill:none;' + c + '12;stroke:#333;"/><path d="m173.9 85.625c5.4042 12.625 5.2413 27.675 4.5745 43.58" style="fill:none;' + c + '12;stroke:#333;"/><path d="m53.86 129.93c1.293 16.951 2.6738 35.169-2.1664 53.193" style="fill:none;' + c + '12;stroke:#333;"/><path d="m29.292 108.38c0.6173 17.177 2.6722 36.119 0.8158 54.108" style="fill:none;' + c + '12;stroke:#333;"/><path d="m200.47 109.11c0.3586 18.529-1.2751 36.94 1.9231 48.985" style="fill:none;' + c + '12;stroke:#333;"/><path d="m178.48 129.2c-0.7279 17.362-2.0563 35.743 2.6011 53.099" style="fill:none;' + c + '12;stroke:#333;"/>', i[15] = [], i[15].env = a, i[15].clo = '<path d="m141.75 195a114.79 114.79 0 0 1 38 16.5 115.53 115.53 0 0 1-128.46 0 114.79 114.79 0 0 1 38-16.5 115.77 115.77 0 0 1 15.71-2.53v-14.09a63.8 63.8 0 0 0 21 0v14.09a116.6 116.6 0 0 1 15.75 2.53z" style="fill:#1a1a1a;"/><path d="m60.984 205.66 6.2675 2.2051 3.4074-6.819 2.8018-1.1353-3.9911 7.9907 27.222-3.0857 3.2541-11.739 2.1451-0.2692-3.2833 11.819 20.393-1.6011-14.191-15.945v-2.4379l17.606-5.7274 3.3855-0.473v1.47l-19.167 6.2295 14.731 16.542 19.839-7.7432 3.3636 0.8223-21.371 8.34 20.532 13.842 2.6777-21.687 1.9481 0.5604-2.7726 22.378 0.0584 0.0364 8.5075 4.9923-2.4807 0.85145-6.4718-3.7916-1.2987 6.0622-2.1524 0.53125 1.3425-6.2804-17.037 8.8348-5.0271 0.35661 21.59-11.193-20.962-14.133-7.5006 25.457-2.0721-0.0364 7.6392-25.915-21.05 1.652 9.0109 24.052-1.4155-0.0946-0.49615-0.0437-0.073-7e-3 -0.2043-0.0145-8.3688-22.342-10.127 19.242-1.9846-0.52399 10.514-19.962-26.04 2.9547 13.425 16.418-3.4438-1.0625-12.083-14.781-8.1645 5.9675-1.9043-1.077 8.128-5.9385-6.9898-2.4598 2.3348-1.2881zm92.509-7.2556 14.228 20.093-1.8095 0.89514-15.614-22.043z" style="fill:#b2b2b2;"/>', i[15].head = l, i[15].mouth = '<path d="m97.06 144.59a20.15 20.15 0 0 0 36.88 4.53z" style="fill:#fff;' + c + '2.9999px;stroke:#000;"/>', i[15].eyes = '<line x1="85.29" x2="85.29" y1="98.73" y2="109.79" style="fill:none;' + c + '8.7999px;stroke:#000;"/><path d="m108.28 72.16h62.18c9.19 0 13.32 1.21 14.71 8.52 3.61 18.95 2.2 33.49-0.44 43.75a65.07 65.07 0 0 1-5.89 14.78 73.52 73.52 0 0 1-7.06 10.26c-1.8 2.27-5.17 1.21-4.19-1.09 0.14-0.47 0.27-1 0.4-1.48a14.29 14.29 0 0 0 0.52-6.62 12.52 12.52 0 0 0-3.88-6.3c-4.17-3.9-12.81-8.71-32.53-13.66-6.4-1.6-10.69-2.24-11.76-2.79a7.08 7.08 0 0 1-3.85-6.31v-9c0-2.39 0.18-4.55-1.56-6.57s-4.16-2.13-6.65-2.14a6 6 0 0 1-6-6v-9.35a6 6 0 0 1 6-6z" style="fill:#1a1a1a;"/><path d="m135.9 98.73v9.27m15.22-9.29v9.29" style="fill:none;' + c + '7.7998px;stroke:#b2b2b2;"/>', i[15].top = '<path d="m109.99 15.57c-13.46 3.6301-19.789 11.95-24.069 24.08-6.9996-7-8.7307-10.82-7.5606-21.43a41 41 0 0 0-9.2698 24.988c0.0366 7.6776 5.6462 13.939 12.697 15.297-13.315 5.8106-15.258 22.033-14.045 33.524 5.7687-11.861 14.254-20.981 27.258-22.951-0.43017 6.6-2.5099 10.22-7.29 17.66 18.29-2.8601 25.119-7.8199 37.15-18.24 0.46001 0 1.0001 0.089 1.4606 0.12058-0.33023 3.5601-1.0906 6.5598-5.0004 12.46 9.5298-1.32 14.721-5.8006 17.539-11.671 8.8862 0.95314 15.836 6.785 21.26 14.818 1.928-15.211-4.4766-26.6-19.807-34.036 1.4167-2.6974 8.0143-11.925 17.661-15.721-1.424-0.28569-2.8883-0.49486-4.4033-0.61125-5.71-0.41992-13.62-0.99982-24.89 4.1703 2.8501-8.5101 10.21-11 18.05-13.12-15.131-1.2501-28.61-2.5898-40.53 8.1801-1.8997-6.21-0.18055-12.54 3.7889-17.52z" style="fill:#fff;"/><path d="m172.63 69.954c1.2292 14.064 0.93841 29.96 0.34635 45.169 1.7887 6.796 3.0379 13.235 3.8842 18.388l0.13973-0.011c1.0001 6.56 2.3597 13.18 3.2698 19.73 2.0002-6.5699 2.5303-18.25 3.2405-25.43 1.2597-13 1.8296-29.311-0.43017-41.931-0.85041-4.72-2.0007-7.6896-2.0007-8.4796 4.6205 3.5601 8.6606 9.2204 13.001 14.15-0.6751-3.4318-1.347-6.6004-2.0567-9.5273-4.047-5.7183-13.726-12.154-19.393-12.06z" style="fill:#fff;"/><path d="m157.97 34.471c-10.339 2.7579-17.715 13.543-19.132 16.24 15.33 7.4361 20.783 17.96 21.278 33.517 5.9534 8.8179 10.066 20.289 12.857 30.895 0.87636-13.178 1.8186-27.726 0.26566-44.28 2.5698 0.44857 9.1372 1.3934 18.781 11.17-2.1158-8.7321-4.5671-15.31-8.4539-20.283-4.5598-5.8401-10.999-10.431-23.809-13 9.6502-3.34 16.27-0.76993 25.5 2.1301-8.1388-7.4315-16.474-14.219-27.287-16.389z" style="fill:#fff;"/><path d="m61.473 73.354c-7.256-0.77501-13.024 2.3746-16.262 5.3879 0.73789-0.45409 1.3868-0.74208 1.8489-0.74208 0 0-1.5198 10.359-1.6197 11.519-1.56 19.73 0.99957 43.401 6.37 62.471 1.3099 4.6899 1.1895 3.0893 1.8898-0.9107 1.7526-10.061 3.3891-24.703 6.9739-38.864-5.068-17.627-4.2508-32.403 0.79937-38.861z" style="fill:#fff;"/><path d="m69.09 43.21c-0.0253 1.0803-8e-3 2.1612 0.0523 3.2402-3.8402 0-12.46 0.71984-16 2.1598-4.4504 1.8001-8.48 5.4801-11.67 11.83 7.2999-3.94 11.899-3.8502 16.66-1.8102-10.39 3.45-19.52 11.37-20.32 26.9 1.1456-1.5053 4.6079-4.9789 7.1393-6.6285 0.09-0.0587 0.17427-0.10556 0.26167-0.15946 3.7141-2.3211 9.0494-5.1247 15.181-4.9553-5.0501 6.4577-6.6824 20.434 0.28207 38.428 1.7866-7.0567 4.0574-13.994 7.0681-20.184-1e-3 -11.664 2.0764-27.774 15.391-33.585-7.0508-2.1538-12.709-7.991-14.043-15.236z" style="fill:#fff;"/>';
    var u = u || function(S, O) {
      var _ = {}, L = _.lib = {}, N = function() {
      }, j = L.Base = { extend: function(I) {
        N.prototype = this;
        var V = new N();
        return I && V.mixIn(I), V.hasOwnProperty("init") || (V.init = function() {
          V.$super.init.apply(this, arguments);
        }), V.init.prototype = V, V.$super = this, V;
      }, create: function() {
        var I = this.extend();
        return I.init.apply(I, arguments), I;
      }, init: function() {
      }, mixIn: function(I) {
        for (var V in I)
          I.hasOwnProperty(V) && (this[V] = I[V]);
        I.hasOwnProperty("toString") && (this.toString = I.toString);
      }, clone: function() {
        return this.init.prototype.extend(this);
      } }, W = L.WordArray = j.extend({ init: function(I, V) {
        I = this.words = I || [], this.sigBytes = V != O ? V : 4 * I.length;
      }, toString: function(I) {
        return (I || ee).stringify(this);
      }, concat: function(I) {
        var V = this.words, te = I.words, X = this.sigBytes;
        if (I = I.sigBytes, this.clamp(), X % 4)
          for (var H = 0; H < I; H++)
            V[X + H >>> 2] |= (te[H >>> 2] >>> 24 - H % 4 * 8 & 255) << 24 - (X + H) % 4 * 8;
        else if (65535 < te.length)
          for (H = 0; H < I; H += 4)
            V[X + H >>> 2] = te[H >>> 2];
        else
          V.push.apply(V, te);
        return this.sigBytes += I, this;
      }, clamp: function() {
        var I = this.words, V = this.sigBytes;
        I[V >>> 2] &= 4294967295 << 32 - V % 4 * 8, I.length = S.ceil(V / 4);
      }, clone: function() {
        var I = j.clone.call(this);
        return I.words = this.words.slice(0), I;
      }, random: function(I) {
        for (var V = [], te = 0; te < I; te += 4)
          V.push(4294967296 * S.random() | 0);
        return new W.init(V, I);
      } }), G = _.enc = {}, ee = G.Hex = { stringify: function(I) {
        var V = I.words;
        I = I.sigBytes;
        for (var te = [], X = 0; X < I; X++) {
          var H = V[X >>> 2] >>> 24 - X % 4 * 8 & 255;
          te.push((H >>> 4).toString(16)), te.push((15 & H).toString(16));
        }
        return te.join("");
      }, parse: function(I) {
        for (var V = I.length, te = [], X = 0; X < V; X += 2)
          te[X >>> 3] |= parseInt(I.substr(X, 2), 16) << 24 - X % 8 * 4;
        return new W.init(te, V / 2);
      } }, fe = G.Latin1 = { stringify: function(I) {
        var V = I.words;
        I = I.sigBytes;
        for (var te = [], X = 0; X < I; X++)
          te.push(String.fromCharCode(V[X >>> 2] >>> 24 - X % 4 * 8 & 255));
        return te.join("");
      }, parse: function(I) {
        for (var V = I.length, te = [], X = 0; X < V; X++)
          te[X >>> 2] |= (255 & I.charCodeAt(X)) << 24 - X % 4 * 8;
        return new W.init(te, V);
      } }, P10 = G.Utf8 = { stringify: function(I) {
        try {
          return decodeURIComponent(escape(fe.stringify(I)));
        } catch {
          throw Error("Malformed UTF-8 data");
        }
      }, parse: function(I) {
        return fe.parse(unescape(encodeURIComponent(I)));
      } }, z10 = L.BufferedBlockAlgorithm = j.extend({ reset: function() {
        this._data = new W.init(), this._nDataBytes = 0;
      }, _append: function(I) {
        typeof I == "string" && (I = P10.parse(I)), this._data.concat(I), this._nDataBytes += I.sigBytes;
      }, _process: function(I) {
        var V = this._data, te = V.words, X = V.sigBytes, H = this.blockSize, $ = X / (4 * H), $;
        if (I = ($ = I ? S.ceil($) : S.max((0 | $) - this._minBufferSize, 0)) * H, X = S.min(4 * I, X), I) {
          for (var se = 0; se < I; se += H)
            this._doProcessBlock(te, se);
          se = te.splice(0, I), V.sigBytes -= X;
        }
        return new W.init(se, X);
      }, clone: function() {
        var I = j.clone.call(this);
        return I._data = this._data.clone(), I;
      }, _minBufferSize: 0 });
      L.Hasher = z10.extend({ cfg: j.extend(), init: function(I) {
        this.cfg = this.cfg.extend(I), this.reset();
      }, reset: function() {
        z10.reset.call(this), this._doReset();
      }, update: function(I) {
        return this._append(I), this._process(), this;
      }, finalize: function(I) {
        return I && this._append(I), this._doFinalize();
      }, blockSize: 16, _createHelper: function(I) {
        return function(V, te) {
          return new I.init(te).finalize(V);
        };
      }, _createHmacHelper: function(I) {
        return function(V, te) {
          return new U.HMAC.init(I, te).finalize(V);
        };
      } });
      var U = _.algo = {};
      return _;
    }(Math);
    (function(S) {
      for (var O = u, I, _ = (I = O.lib).WordArray, L = I.Hasher, I = O.algo, N = [], j = [], W = function(te) {
        return 4294967296 * (te - (0 | te)) | 0;
      }, G = 2, ee = 0; 64 > ee; ) {
        var fe;
        e: {
          fe = G;
          for (var P10 = S.sqrt(fe), z10 = 2; z10 <= P10; z10++)
            if (!(fe % z10)) {
              fe = false;
              break e;
            }
          fe = true;
        }
        fe && (8 > ee && (N[ee] = W(S.pow(G, 0.5))), j[ee] = W(S.pow(G, 1 / 3)), ee++), G++;
      }
      var U = [], I = I.SHA256 = L.extend({ _doReset: function() {
        this._hash = new _.init(N.slice(0));
      }, _doProcessBlock: function(V, te) {
        for (var X = this._hash.words, H = X[0], $ = X[1], se = X[2], he = X[3], pe = X[4], me = X[5], B = X[6], q = X[7], Z = 0; 64 > Z; Z++) {
          if (16 > Z)
            U[Z] = 0 | V[te + Z];
          else {
            var oe = U[Z - 15], de = U[Z - 2];
            U[Z] = ((oe << 25 | oe >>> 7) ^ (oe << 14 | oe >>> 18) ^ oe >>> 3) + U[Z - 7] + ((de << 15 | de >>> 17) ^ (de << 13 | de >>> 19) ^ de >>> 10) + U[Z - 16];
          }
          oe = q + ((pe << 26 | pe >>> 6) ^ (pe << 21 | pe >>> 11) ^ (pe << 7 | pe >>> 25)) + (pe & me ^ ~pe & B) + j[Z] + U[Z], de = ((H << 30 | H >>> 2) ^ (H << 19 | H >>> 13) ^ (H << 10 | H >>> 22)) + (H & $ ^ H & se ^ $ & se), q = B, B = me, me = pe, pe = he + oe | 0, he = se, se = $, $ = H, H = oe + de | 0;
        }
        X[0] = X[0] + H | 0, X[1] = X[1] + $ | 0, X[2] = X[2] + se | 0, X[3] = X[3] + he | 0, X[4] = X[4] + pe | 0, X[5] = X[5] + me | 0, X[6] = X[6] + B | 0, X[7] = X[7] + q | 0;
      }, _doFinalize: function() {
        var V = this._data, te = V.words, X = 8 * this._nDataBytes, H = 8 * V.sigBytes;
        return te[H >>> 5] |= 128 << 24 - H % 32, te[14 + (H + 64 >>> 9 << 4)] = S.floor(X / 4294967296), te[15 + (H + 64 >>> 9 << 4)] = X, V.sigBytes = 4 * te.length, this._process(), this._hash;
      }, clone: function() {
        var V = L.clone.call(this);
        return V._hash = this._hash.clone(), V;
      } });
      O.SHA256 = L._createHelper(I), O.HmacSHA256 = L._createHmacHelper(I);
    })(Math);
    var f = "";
    if (t10.length == 0)
      return f;
    f = u.SHA256(t10).toString().replace(/\D/g, "").substring(0, 12);
    var d = [];
    for (var h in d.env = f[0] + "" + f[1], d.env = Math.round(0.47 * d.env) + "", d.clo = f[2] + "" + f[3], d.clo = Math.round(0.47 * d.clo) + "", d.head = f[4] + "" + f[5], d.head = Math.round(0.47 * d.head) + "", d.mouth = f[6] + "" + f[7], d.mouth = Math.round(0.47 * d.mouth) + "", d.eyes = f[8] + "" + f[9], d.eyes = Math.round(0.47 * d.eyes) + "", d.top = f[10] + "" + f[11], d.top = Math.round(0.47 * d.top) + "", d) {
      var g = d[h];
      g > 31 ? ((g = g - 32 + "").length == 1 && (g = "0" + g), d[h] = g + "C") : g > 15 ? ((g = g - 16 + "").length == 1 && (g = "0" + g), d[h] = g + "B") : d[h] = (g + "").length == 1 ? "0" + g + "A" : g + "A";
    }
    var p = [];
    for (var h in d) {
      var y = d[h].substring(0, 2), b = d[h].substring(2, 3);
      p[h] = x(h, y, b);
    }
    function x(S, O, _) {
      var L = n[O][_][S], N = i[O][S], j = /#(.*?);/g, W = N.match(j), G = N;
      if (W != null)
        for (var ee = 0; ee < W.length; ee++)
          G = G.replace(W[ee], L[ee] + ";");
      return G;
    }
    return o + p.env + p.head + p.clo + p.top + p.eyes + p.mouth + s;
  }
  function Ha(t10) {
    return "data:image/svg+xml," + encodeURIComponent(t10).replace(/'/g, "%27").replace(/"/g, "%22");
  }
  var wt = {};
  (function(t10) {
    function e(P10, z10) {
      if (!P10)
        throw z10 = z10 || "Assertion failed", typeof Error < "u" ? new Error(z10) : z10;
    }
    var r = false, n = 0, i = function() {
      if (r)
        return r = false, n;
      var P10 = 2 * Math.random() - 1, z10 = 2 * Math.random() - 1, U = P10 * P10 + z10 * z10;
      if (U == 0 || U > 1)
        return i();
      var I = Math.sqrt(-2 * Math.log(U) / U);
      return n = z10 * I, r = true, P10 * I;
    }, o = function(P10, z10) {
      return Math.random() * (z10 - P10) + P10;
    }, s = function(P10, z10) {
      return Math.floor(Math.random() * (z10 - P10) + P10);
    }, a = function(P10, z10) {
      return P10 + i() * z10;
    }, l = function(P10) {
      if (typeof P10 > "u" || isNaN(P10))
        return [];
      if (typeof ArrayBuffer > "u") {
        for (var z10 = new Array(P10), U = 0; U < P10; U++)
          z10[U] = 0;
        return z10;
      } else
        return new Float64Array(P10);
    }, c = function(P10, z10) {
      this.n = P10, this.d = z10, this.w = l(P10 * z10), this.dw = l(P10 * z10);
    };
    c.prototype = {
      get: function(P10, z10) {
        var U = this.d * P10 + z10;
        return e(U >= 0 && U < this.w.length), this.w[U];
      },
      set: function(P10, z10, U) {
        var I = this.d * P10 + z10;
        e(I >= 0 && I < this.w.length), this.w[I] = U;
      },
      setFrom: function(P10) {
        for (var z10 = 0, U = P10.length; z10 < U; z10++)
          this.w[z10] = P10[z10];
      },
      setColumn: function(P10, z10) {
        for (var U = 0, I = P10.w.length; U < I; U++)
          this.w[this.d * U + z10] = P10.w[U];
      },
      toJSON: function() {
        var P10 = {};
        return P10.n = this.n, P10.d = this.d, P10.w = this.w, P10;
      },
      fromJSON: function(P10) {
        this.n = P10.n, this.d = P10.d, this.w = l(this.n * this.d), this.dw = l(this.n * this.d);
        for (var z10 = 0, U = this.n * this.d; z10 < U; z10++)
          this.w[z10] = P10.w[z10];
      }
    };
    var u = function(P10) {
      var z10 = new c(P10.n, P10.d);
      return z10.setFrom(P10.w), z10;
    }, f = function(P10) {
      var z10 = {};
      for (var U in P10)
        P10.hasOwnProperty(U) && (z10[U] = u(P10[U]));
      return z10;
    }, d = function(P10, z10) {
      for (var U = 0, I = P10.n * P10.d; U < I; U++)
        P10.dw[U] !== 0 && (P10.w[U] += -z10 * P10.dw[U], P10.dw[U] = 0);
    }, h = function(P10, z10) {
      for (var U in P10)
        P10.hasOwnProperty(U) && d(P10[U], z10);
    }, g = function(P10) {
      var z10 = {};
      for (var U in P10)
        P10.hasOwnProperty(U) && (z10[U] = P10[U].toJSON());
      return z10;
    }, p = function(P10) {
      var z10 = {};
      for (var U in P10)
        P10.hasOwnProperty(U) && (z10[U] = new c(1, 1), z10[U].fromJSON(P10[U]));
      return z10;
    }, y = function(P10) {
      for (var z10 in P10)
        if (P10.hasOwnProperty(z10)) {
          var U = P10[z10];
          O(U, 0);
        }
    }, b = function(P10) {
      var z10 = 0;
      for (var U in P10)
        if (P10.hasOwnProperty(U)) {
          var I = P10[U];
          z10 += I.dw.length;
        }
      var V = new c(z10, 1), te = 0;
      for (var U in P10)
        if (P10.hasOwnProperty(U))
          for (var I = P10[U], X = 0, H = I.dw.length; X < H; X++)
            V.w[te] = I.dw[X], te++;
      return V;
    }, x = function(P10, z10, U, I) {
      var V = new c(P10, z10);
      return S(V, U, I), V;
    }, S = function(P10, z10, U) {
      for (var I = 0, V = P10.w.length; I < V; I++)
        P10.w[I] = a(z10, U);
    }, O = function(P10, z10) {
      for (var U = 0, I = P10.dw.length; U < I; U++)
        P10.dw[U] = z10;
    }, _ = function(P10) {
      typeof P10 > "u" && (P10 = true), this.needs_backprop = P10, this.backprop = [];
    };
    _.prototype = {
      backward: function() {
        for (var P10 = this.backprop.length - 1; P10 >= 0; P10--)
          this.backprop[P10]();
      },
      rowPluck: function(P10, z10) {
        e(z10 >= 0 && z10 < P10.n);
        for (var U = P10.d, I = new c(U, 1), V = 0, te = U; V < te; V++)
          I.w[V] = P10.w[U * z10 + V];
        if (this.needs_backprop) {
          var X = function() {
            for (var H = 0, $ = U; H < $; H++)
              P10.dw[U * z10 + H] += I.dw[H];
          };
          this.backprop.push(X);
        }
        return I;
      },
      tanh: function(P10) {
        for (var z10 = new c(P10.n, P10.d), U = P10.w.length, I = 0; I < U; I++)
          z10.w[I] = Math.tanh(P10.w[I]);
        if (this.needs_backprop) {
          var V = function() {
            for (var te = 0; te < U; te++) {
              var X = z10.w[te];
              P10.dw[te] += (1 - X * X) * z10.dw[te];
            }
          };
          this.backprop.push(V);
        }
        return z10;
      },
      sigmoid: function(P10) {
        for (var z10 = new c(P10.n, P10.d), U = P10.w.length, I = 0; I < U; I++)
          z10.w[I] = G(P10.w[I]);
        if (this.needs_backprop) {
          var V = function() {
            for (var te = 0; te < U; te++) {
              var X = z10.w[te];
              P10.dw[te] += X * (1 - X) * z10.dw[te];
            }
          };
          this.backprop.push(V);
        }
        return z10;
      },
      relu: function(P10) {
        for (var z10 = new c(P10.n, P10.d), U = P10.w.length, I = 0; I < U; I++)
          z10.w[I] = Math.max(0, P10.w[I]);
        if (this.needs_backprop) {
          var V = function() {
            for (var te = 0; te < U; te++)
              P10.dw[te] += P10.w[te] > 0 ? z10.dw[te] : 0;
          };
          this.backprop.push(V);
        }
        return z10;
      },
      mul: function(P10, z10) {
        e(P10.d === z10.n, "matmul dimensions misaligned");
        for (var U = P10.n, I = z10.d, V = new c(U, I), te = 0; te < P10.n; te++)
          for (var X = 0; X < z10.d; X++) {
            for (var H = 0, $ = 0; $ < P10.d; $++)
              H += P10.w[P10.d * te + $] * z10.w[z10.d * $ + X];
            V.w[I * te + X] = H;
          }
        if (this.needs_backprop) {
          var se = function() {
            for (var he = 0; he < P10.n; he++)
              for (var pe = 0; pe < z10.d; pe++)
                for (var me = 0; me < P10.d; me++) {
                  var B = V.dw[I * he + pe];
                  P10.dw[P10.d * he + me] += z10.w[z10.d * me + pe] * B, z10.dw[z10.d * me + pe] += P10.w[P10.d * he + me] * B;
                }
          };
          this.backprop.push(se);
        }
        return V;
      },
      add: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var U = new c(P10.n, P10.d), I = 0, V = P10.w.length; I < V; I++)
          U.w[I] = P10.w[I] + z10.w[I];
        if (this.needs_backprop) {
          var te = function() {
            for (var X = 0, H = P10.w.length; X < H; X++)
              P10.dw[X] += U.dw[X], z10.dw[X] += U.dw[X];
          };
          this.backprop.push(te);
        }
        return U;
      },
      dot: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var U = new c(1, 1), I = 0, V = 0, te = P10.w.length; V < te; V++)
          I += P10.w[V] * z10.w[V];
        if (U.w[0] = I, this.needs_backprop) {
          var X = function() {
            for (var H = 0, $ = P10.w.length; H < $; H++)
              P10.dw[H] += z10.w[H] * U.dw[0], z10.dw[H] += P10.w[H] * U.dw[0];
          };
          this.backprop.push(X);
        }
        return U;
      },
      eltmul: function(P10, z10) {
        e(P10.w.length === z10.w.length);
        for (var U = new c(P10.n, P10.d), I = 0, V = P10.w.length; I < V; I++)
          U.w[I] = P10.w[I] * z10.w[I];
        if (this.needs_backprop) {
          var te = function() {
            for (var X = 0, H = P10.w.length; X < H; X++)
              P10.dw[X] += z10.w[X] * U.dw[X], z10.dw[X] += P10.w[X] * U.dw[X];
          };
          this.backprop.push(te);
        }
        return U;
      }
    };
    var L = function(P10) {
      for (var z10 = new c(P10.n, P10.d), U = -999999, I = 0, V = P10.w.length; I < V; I++)
        P10.w[I] > U && (U = P10.w[I]);
      for (var te = 0, I = 0, V = P10.w.length; I < V; I++)
        z10.w[I] = Math.exp(P10.w[I] - U), te += z10.w[I];
      for (var I = 0, V = P10.w.length; I < V; I++)
        z10.w[I] /= te;
      return z10;
    }, N = function() {
      this.decay_rate = 0.999, this.smooth_eps = 1e-8, this.step_cache = {};
    };
    N.prototype = {
      step: function(P10, z10, U, I) {
        var V = {}, te = 0, X = 0;
        for (var H in P10)
          if (P10.hasOwnProperty(H)) {
            var $ = P10[H];
            H in this.step_cache || (this.step_cache[H] = new c($.n, $.d));
            for (var se = this.step_cache[H], he = 0, pe = $.w.length; he < pe; he++) {
              var me = $.dw[he];
              se.w[he] = se.w[he] * this.decay_rate + (1 - this.decay_rate) * me * me, me > I && (me = I, te++), me < -I && (me = -I, te++), X++, $.w[he] += -z10 * me / Math.sqrt(se.w[he] + this.smooth_eps) - U * $.w[he], $.dw[he] = 0;
            }
          }
        return V.ratio_clipped = te * 1 / X, V;
      }
    };
    var j = function(P10, z10, U) {
      for (var I = {}, V = 0; V < z10.length; V++) {
        var te = V === 0 ? P10 : z10[V - 1], X = z10[V];
        I["Wix" + V] = new x(X, te, 0, 0.08), I["Wih" + V] = new x(X, X, 0, 0.08), I["bi" + V] = new c(X, 1), I["Wfx" + V] = new x(X, te, 0, 0.08), I["Wfh" + V] = new x(X, X, 0, 0.08), I["bf" + V] = new c(X, 1), I["Wox" + V] = new x(X, te, 0, 0.08), I["Woh" + V] = new x(X, X, 0, 0.08), I["bo" + V] = new c(X, 1), I["Wcx" + V] = new x(X, te, 0, 0.08), I["Wch" + V] = new x(X, X, 0, 0.08), I["bc" + V] = new c(X, 1);
      }
      return I.Whd = new x(U, X, 0, 0.08), I.bd = new c(U, 1), I;
    }, W = function(P10, z10, U, I, V) {
      if (V == null || typeof V.h > "u")
        for (var te = [], X = [], H = 0; H < U.length; H++)
          te.push(new wt.Mat(U[H], 1)), X.push(new wt.Mat(U[H], 1));
      else
        var te = V.h, X = V.c;
      for (var $ = [], se = [], H = 0; H < U.length; H++) {
        var he = H === 0 ? I : $[H - 1], pe = te[H], me = X[H], B = P10.mul(z10["Wix" + H], he), q = P10.mul(z10["Wih" + H], pe), Z = P10.sigmoid(P10.add(P10.add(B, q), z10["bi" + H])), oe = P10.mul(z10["Wfx" + H], he), de = P10.mul(z10["Wfh" + H], pe), R = P10.sigmoid(P10.add(P10.add(oe, de), z10["bf" + H])), k = P10.mul(z10["Wox" + H], he), re = P10.mul(z10["Woh" + H], pe), ne = P10.sigmoid(P10.add(P10.add(k, re), z10["bo" + H])), Ae = P10.mul(z10["Wcx" + H], he), C = P10.mul(z10["Wch" + H], pe), v = P10.tanh(P10.add(P10.add(Ae, C), z10["bc" + H])), w = P10.eltmul(R, me), D = P10.eltmul(Z, v), J = P10.add(w, D), ae = P10.eltmul(ne, P10.tanh(J));
        $.push(ae), se.push(J);
      }
      var ue = P10.add(P10.mul(z10.Whd, $[$.length - 1]), z10.bd);
      return { h: $, c: se, o: ue };
    }, G = function(P10) {
      return 1 / (1 + Math.exp(-P10));
    }, ee = function(P10) {
      for (var z10 = P10[0], U = 0, I = 1, V = P10.length; I < V; I++) {
        var te = P10[I];
        te > z10 && (U = I, z10 = te);
      }
      return U;
    }, fe = function(P10) {
      for (var z10 = o(0, 1), U = 0, I = 0; ; ) {
        if (U += P10[I], U > z10)
          return I;
        I++;
      }
      return P10.length - 1;
    };
    t10.assert = e, t10.zeros = l, t10.maxi = ee, t10.samplei = fe, t10.randi = s, t10.randn = a, t10.softmax = L, t10.Mat = c, t10.RandMat = x, t10.forwardLSTM = W, t10.initLSTM = j, t10.updateMat = d, t10.updateNet = h, t10.copyMat = u, t10.copyNet = f, t10.netToJSON = g, t10.netFromJSON = p, t10.netZeroGrads = y, t10.netFlattenGrads = b, t10.Solver = N, t10.Graph = _;
  })(wt);
  var l1 = {};
  (function(t10) {
    var e = function(u, f, d) {
      return typeof u > "u" ? d : typeof u[f] < "u" ? u[f] : d;
    }, r = wt.zeros, n = wt.assert, i = wt.randi;
    wt.randf;
    var o = function(u, f) {
      for (var d = 0, h = u.length; d < h; d++)
        u[d] = f;
    }, s = function(u) {
      for (var f = Math.random(), d = 0, h = 0, g = u.length; h < g; h++)
        if (d += u[h], d >= f)
          return h;
      n(false, "wtf");
    }, a = function(u, f) {
      this.V = null, this.P = null, this.env = u, this.gamma = e(f, "gamma", 0.75), this.reset();
    };
    a.prototype = {
      reset: function() {
        this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.V = r(this.ns), this.P = r(this.ns * this.na);
        for (var u = 0; u < this.ns; u++)
          for (var f = this.env.allowedActions(u), d = 0, h = f.length; d < h; d++)
            this.P[f[d] * this.ns + u] = 1 / f.length;
      },
      act: function(u) {
        for (var f = this.env.allowedActions(u), d = [], h = 0, g = f.length; h < g; h++) {
          var p = f[h], y = this.P[p * this.ns + u];
          d.push(y);
        }
        var b = s(d);
        return f[b];
      },
      learn: function() {
        self.evaluatePolicy(), self.updatePolicy();
      },
      evaluatePolicy: function() {
        for (var u = r(this.ns), f = 0; f < this.ns; f++) {
          for (var d = 0, h = this.env.allowedActions(f), g = 0, p = h.length; g < p; g++) {
            var y = h[g], b = this.P[y * this.ns + f];
            if (b !== 0) {
              var x = this.env.nextStateDistribution(f, y), S = this.env.reward(f, y, x);
              d += b * (S + this.gamma * this.V[x]);
            }
          }
          u[f] = d;
        }
        this.V = u;
      },
      updatePolicy: function() {
        for (var u = 0; u < this.ns; u++) {
          for (var f = this.env.allowedActions(u), d, h, g = [], p = 0, y = f.length; p < y; p++) {
            var b = f[p], x = this.env.nextStateDistribution(u, b), S = this.env.reward(u, b, x), O = S + this.gamma * this.V[x];
            g.push(O), p === 0 || O > d ? (d = O, h = 1) : O === d && (h += 1);
          }
          for (var p = 0, y = f.length; p < y; p++) {
            var b = f[p];
            this.P[b * this.ns + u] = g[p] === d ? 1 / h : 0;
          }
        }
      }
    };
    var l = function(u, f) {
      this.update = e(f, "update", "qlearn"), this.gamma = e(f, "gamma", 0.75), this.epsilon = e(f, "epsilon", 0.1), this.alpha = e(f, "alpha", 0.01), this.smooth_policy_update = e(f, "smooth_policy_update", false), this.beta = e(f, "beta", 0.01), this.lambda = e(f, "lambda", 0), this.replacing_traces = e(f, "replacing_traces", true), this.q_init_val = e(f, "q_init_val", 0), this.planN = e(f, "planN", 0), this.Q = null, this.P = null, this.e = null, this.env_model_s = null, this.env_model_r = null, this.env = u, this.reset();
    };
    l.prototype = {
      reset: function() {
        this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.Q = r(this.ns * this.na), this.q_init_val !== 0 && o(this.Q, this.q_init_val), this.P = r(this.ns * this.na), this.e = r(this.ns * this.na), this.env_model_s = r(this.ns * this.na), o(this.env_model_s, -1), this.env_model_r = r(this.ns * this.na), this.sa_seen = [], this.pq = r(this.ns * this.na);
        for (var u = 0; u < this.ns; u++)
          for (var f = this.env.allowedActions(u), d = 0, h = f.length; d < h; d++)
            this.P[f[d] * this.ns + u] = 1 / f.length;
        this.r0 = null, this.s0 = null, this.s1 = null, this.a0 = null, this.a1 = null;
      },
      resetEpisode: function() {
      },
      act: function(u) {
        for (var f = this.env.allowedActions(u), d = [], h = 0, g = f.length; h < g; h++)
          d.push(this.P[f[h] * this.ns + u]);
        if (Math.random() < this.epsilon) {
          var p = f[i(0, f.length)];
          this.explored = true;
        } else {
          var p = f[s(d)];
          this.explored = false;
        }
        return this.s0 = this.s1, this.a0 = this.a1, this.s1 = u, this.a1 = p, p;
      },
      learn: function(u) {
        this.r0 != null && (this.learnFromTuple(this.s0, this.a0, this.r0, this.s1, this.a1, this.lambda), this.planN > 0 && (this.updateModel(this.s0, this.a0, this.r0, this.s1), this.plan())), this.r0 = u;
      },
      updateModel: function(u, f, d, h) {
        var g = f * this.ns + u;
        this.env_model_s[g] === -1 && this.sa_seen.push(f * this.ns + u), this.env_model_s[g] = h, this.env_model_r[g] = d;
      },
      plan: function() {
        for (var u = [], f = 0, d = this.sa_seen.length; f < d; f++) {
          var h = this.sa_seen[f], g = this.pq[h];
          g > 1e-5 && u.push({ sa: h, p: g });
        }
        u.sort(function(j, W) {
          return j.p < W.p ? 1 : -1;
        });
        for (var p = Math.min(this.planN, u.length), y = 0; y < p; y++) {
          var b = u[y].sa;
          this.pq[b] = 0;
          var x = b % this.ns, S = Math.floor(b / this.ns), O = this.env_model_r[b], _ = this.env_model_s[b], L = -1;
          if (this.update === "sarsa")
            var N = this.env.allowedActions(_), L = N[i(0, N.length)];
          this.learnFromTuple(x, S, O, _, L, 0);
        }
      },
      learnFromTuple: function(u, f, d, h, g, p) {
        var y = f * this.ns + u;
        if (this.update === "qlearn") {
          for (var b = this.env.allowedActions(h), x = 0, S = 0, O = b.length; S < O; S++) {
            var _ = b[S] * this.ns + h, L = this.Q[_];
            (S === 0 || L > x) && (x = L);
          }
          var N = d + this.gamma * x;
        } else if (this.update === "sarsa")
          var j = g * this.ns + h, N = d + this.gamma * this.Q[j];
        if (p > 0) {
          this.replacing_traces ? this.e[y] = 1 : this.e[y] += 1;
          for (var W = p * this.gamma, G = r(this.ns), ee = 0; ee < this.ns; ee++)
            for (var b = this.env.allowedActions(ee), S = 0; S < b.length; S++) {
              var fe = b[S], P10 = fe * this.ns + ee, z10 = this.e[P10], U = this.alpha * z10 * (N - this.Q[P10]);
              this.Q[P10] += U, this.updatePriority(ee, fe, U), this.e[P10] *= W;
              var I = Math.abs(U);
              I > G[ee] && (G[ee] = I);
            }
          for (var ee = 0; ee < this.ns; ee++)
            G[ee] > 1e-5 && this.updatePolicy(ee);
          this.explored && this.update === "qlearn" && (this.e = r(this.ns * this.na));
        } else {
          var U = this.alpha * (N - this.Q[y]);
          this.Q[y] += U, this.updatePriority(u, f, U), this.updatePolicy(u);
        }
      },
      updatePriority: function(u, f, d) {
        if (d = Math.abs(d), !(d < 1e-5) && this.planN !== 0)
          for (var h = 0; h < this.ns; h++)
            for (var g = 0; g < this.na; g++) {
              var p = g * this.ns + h;
              this.env_model_s[p] === u && (this.pq[p] += d);
            }
      },
      updatePolicy: function(u) {
        for (var f = this.env.allowedActions(u), d, h, g = [], p = 0, y = f.length; p < y; p++) {
          var b = f[p], x = this.Q[b * this.ns + u];
          g.push(x), p === 0 || x > d ? (d = x, h = 1) : x === d && (h += 1);
        }
        for (var S = 0, p = 0, y = f.length; p < y; p++) {
          var b = f[p], O = g[p] === d ? 1 / h : 0, _ = b * this.ns + u;
          this.smooth_policy_update ? (this.P[_] += this.beta * (O - this.P[_]), S += this.P[_]) : this.P[_] = O;
        }
        if (this.smooth_policy_update)
          for (var p = 0, y = f.length; p < y; p++) {
            var b = f[p];
            this.P[b * this.ns + u] /= S;
          }
      }
    };
    var c = function(u, f) {
      this.gamma = e(f, "gamma", 0.75), this.epsilon = e(f, "epsilon", 0.1), this.alpha = e(f, "alpha", 0.01), this.experience_add_every = e(f, "experience_add_every", 25), this.experience_size = e(f, "experience_size", 5e3), this.learning_steps_per_iteration = e(f, "learning_steps_per_iteration", 10), this.tderror_clamp = e(f, "tderror_clamp", 1), this.num_hidden_units = e(f, "num_hidden_units", 100), this.env = u, this.reset();
    };
    c.prototype = {
      reset: function() {
        this.nh = this.num_hidden_units, this.ns = this.env.getNumStates(), this.na = this.env.getMaxNumActions(), this.net = {}, this.net.W1 = new wt.RandMat(this.nh, this.ns, 0, 0.01), this.net.b1 = new wt.Mat(this.nh, 1, 0, 0.01), this.net.W2 = new wt.RandMat(this.na, this.nh, 0, 0.01), this.net.b2 = new wt.Mat(this.na, 1, 0, 0.01), this.exp = [], this.expi = 0, this.t = 0, this.r0 = null, this.s0 = null, this.s1 = null, this.a0 = null, this.a1 = null, this.tderror = 0;
      },
      toJSON: function() {
        var u = {};
        return u.nh = this.nh, u.ns = this.ns, u.na = this.na, u.net = wt.netToJSON(this.net), u;
      },
      fromJSON: function(u) {
        this.nh = u.nh, this.ns = u.ns, this.na = u.na, this.net = wt.netFromJSON(u.net);
      },
      forwardQ: function(u, f, d) {
        var h = new wt.Graph(d), g = h.add(h.mul(u.W1, f), u.b1), p = h.tanh(g), y = h.add(h.mul(u.W2, p), u.b2);
        return this.lastG = h, y;
      },
      act: function(u) {
        var f = new wt.Mat(this.ns, 1);
        if (f.setFrom(u), Math.random() < this.epsilon)
          var d = i(0, this.na);
        else
          var h = this.forwardQ(this.net, f, false), d = wt.maxi(h.w);
        return this.s0 = this.s1, this.a0 = this.a1, this.s1 = f, this.a1 = d, d;
      },
      learn: function(u) {
        if (this.r0 != null && this.alpha > 0) {
          var f = this.learnFromTuple(this.s0, this.a0, this.r0, this.s1, this.a1);
          this.tderror = f, this.t % this.experience_add_every === 0 && (this.exp[this.expi] = [this.s0, this.a0, this.r0, this.s1, this.a1], this.expi += 1, this.expi > this.experience_size && (this.expi = 0)), this.t += 1;
          for (var d = 0; d < this.learning_steps_per_iteration; d++) {
            var h = i(0, this.exp.length), g = this.exp[h];
            this.learnFromTuple(g[0], g[1], g[2], g[3], g[4]);
          }
        }
        this.r0 = u;
      },
      learnFromTuple: function(u, f, d, h, g) {
        var p = this.forwardQ(this.net, h, false), y = d + this.gamma * p.w[wt.maxi(p.w)], b = this.forwardQ(this.net, u, true), x = b.w[f] - y, S = this.tderror_clamp;
        return Math.abs(x) > S && (x > S && (x = S), x < -S && (x = -S)), b.dw[f] = x, this.lastG.backward(), wt.updateNet(this.net, this.alpha), x;
      }
    }, t10.DPAgent = a, t10.TDAgent = l, t10.DQNAgent = c;
  })(l1);
  /*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   */
  function Jo(t10) {
    return t10 + 0.5 | 0;
  }
  const tn = (t10, e, r) => Math.max(Math.min(t10, r), e);
  function io(t10) {
    return tn(Jo(t10 * 2.55), 0, 255);
  }
  function un(t10) {
    return tn(Jo(t10 * 255), 0, 255);
  }
  function Nr(t10) {
    return tn(Jo(t10 / 2.55) / 100, 0, 1);
  }
  function bd(t10) {
    return tn(Jo(t10 * 100), 0, 100);
  }
  const $t = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Rc = [..."0123456789ABCDEF"], C3 = (t10) => Rc[t10 & 15], T3 = (t10) => Rc[(t10 & 240) >> 4] + Rc[t10 & 15], ms = (t10) => (t10 & 240) >> 4 === (t10 & 15), O3 = (t10) => ms(t10.r) && ms(t10.g) && ms(t10.b) && ms(t10.a);
  function I3(t10) {
    var e = t10.length, r;
    return t10[0] === "#" && (e === 4 || e === 5 ? r = {
      r: 255 & $t[t10[1]] * 17,
      g: 255 & $t[t10[2]] * 17,
      b: 255 & $t[t10[3]] * 17,
      a: e === 5 ? $t[t10[4]] * 17 : 255
    } : (e === 7 || e === 9) && (r = {
      r: $t[t10[1]] << 4 | $t[t10[2]],
      g: $t[t10[3]] << 4 | $t[t10[4]],
      b: $t[t10[5]] << 4 | $t[t10[6]],
      a: e === 9 ? $t[t10[7]] << 4 | $t[t10[8]] : 255
    })), r;
  }
  const P3 = (t10, e) => t10 < 255 ? e(t10) : "";
  function R3(t10) {
    var e = O3(t10) ? C3 : T3;
    return t10 ? "#" + e(t10.r) + e(t10.g) + e(t10.b) + P3(t10.a, e) : void 0;
  }
  const D3 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function c1(t10, e, r) {
    const n = e * Math.min(r, 1 - r), i = (o, s = (o + t10 / 30) % 12) => r - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
    return [i(0), i(8), i(4)];
  }
  function M3(t10, e, r) {
    const n = (i, o = (i + t10 / 60) % 6) => r - r * e * Math.max(Math.min(o, 4 - o, 1), 0);
    return [n(5), n(3), n(1)];
  }
  function N3(t10, e, r) {
    const n = c1(t10, 1, 0.5);
    let i;
    for (e + r > 1 && (i = 1 / (e + r), e *= i, r *= i), i = 0; i < 3; i++)
      n[i] *= 1 - e - r, n[i] += e;
    return n;
  }
  function L3(t10, e, r, n, i) {
    return t10 === i ? (e - r) / n + (e < r ? 6 : 0) : e === i ? (r - t10) / n + 2 : (t10 - e) / n + 4;
  }
  function Nu(t10) {
    const r = t10.r / 255, n = t10.g / 255, i = t10.b / 255, o = Math.max(r, n, i), s = Math.min(r, n, i), a = (o + s) / 2;
    let l, c, u;
    return o !== s && (u = o - s, c = a > 0.5 ? u / (2 - o - s) : u / (o + s), l = L3(r, n, i, u, o), l = l * 60 + 0.5), [l | 0, c || 0, a];
  }
  function Lu(t10, e, r, n) {
    return (Array.isArray(e) ? t10(e[0], e[1], e[2]) : t10(e, r, n)).map(un);
  }
  function Bu(t10, e, r) {
    return Lu(c1, t10, e, r);
  }
  function B3(t10, e, r) {
    return Lu(N3, t10, e, r);
  }
  function F3(t10, e, r) {
    return Lu(M3, t10, e, r);
  }
  function u1(t10) {
    return (t10 % 360 + 360) % 360;
  }
  function j3(t10) {
    const e = D3.exec(t10);
    let r = 255, n;
    if (!e)
      return;
    e[5] !== n && (r = e[6] ? io(+e[5]) : un(+e[5]));
    const i = u1(+e[2]), o = +e[3] / 100, s = +e[4] / 100;
    return e[1] === "hwb" ? n = B3(i, o, s) : e[1] === "hsv" ? n = F3(i, o, s) : n = Bu(i, o, s), {
      r: n[0],
      g: n[1],
      b: n[2],
      a: r
    };
  }
  function W3(t10, e) {
    var r = Nu(t10);
    r[0] = u1(r[0] + e), r = Bu(r), t10.r = r[0], t10.g = r[1], t10.b = r[2];
  }
  function U3(t10) {
    if (!t10)
      return;
    const e = Nu(t10), r = e[0], n = bd(e[1]), i = bd(e[2]);
    return t10.a < 255 ? `hsla(${r}, ${n}%, ${i}%, ${Nr(t10.a)})` : `hsl(${r}, ${n}%, ${i}%)`;
  }
  const vd = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  }, Ad = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function z3() {
    const t10 = {}, e = Object.keys(Ad), r = Object.keys(vd);
    let n, i, o, s, a;
    for (n = 0; n < e.length; n++) {
      for (s = a = e[n], i = 0; i < r.length; i++)
        o = r[i], a = a.replace(o, vd[o]);
      o = parseInt(Ad[s], 16), t10[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];
    }
    return t10;
  }
  let ys;
  function V3(t10) {
    ys || (ys = z3(), ys.transparent = [0, 0, 0, 0]);
    const e = ys[t10.toLowerCase()];
    return e && {
      r: e[0],
      g: e[1],
      b: e[2],
      a: e.length === 4 ? e[3] : 255
    };
  }
  const q3 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function H3(t10) {
    const e = q3.exec(t10);
    let r = 255, n, i, o;
    if (e) {
      if (e[7] !== n) {
        const s = +e[7];
        r = e[8] ? io(s) : tn(s * 255, 0, 255);
      }
      return n = +e[1], i = +e[3], o = +e[5], n = 255 & (e[2] ? io(n) : tn(n, 0, 255)), i = 255 & (e[4] ? io(i) : tn(i, 0, 255)), o = 255 & (e[6] ? io(o) : tn(o, 0, 255)), {
        r: n,
        g: i,
        b: o,
        a: r
      };
    }
  }
  function Y3(t10) {
    return t10 && (t10.a < 255 ? `rgba(${t10.r}, ${t10.g}, ${t10.b}, ${Nr(t10.a)})` : `rgb(${t10.r}, ${t10.g}, ${t10.b})`);
  }
  const Vl = (t10) => t10 <= 31308e-7 ? t10 * 12.92 : Math.pow(t10, 1 / 2.4) * 1.055 - 0.055, ei = (t10) => t10 <= 0.04045 ? t10 / 12.92 : Math.pow((t10 + 0.055) / 1.055, 2.4);
  function K3(t10, e, r) {
    const n = ei(Nr(t10.r)), i = ei(Nr(t10.g)), o = ei(Nr(t10.b));
    return {
      r: un(Vl(n + r * (ei(Nr(e.r)) - n))),
      g: un(Vl(i + r * (ei(Nr(e.g)) - i))),
      b: un(Vl(o + r * (ei(Nr(e.b)) - o))),
      a: t10.a + r * (e.a - t10.a)
    };
  }
  function bs(t10, e, r) {
    if (t10) {
      let n = Nu(t10);
      n[e] = Math.max(0, Math.min(n[e] + n[e] * r, e === 0 ? 360 : 1)), n = Bu(n), t10.r = n[0], t10.g = n[1], t10.b = n[2];
    }
  }
  function f1(t10, e) {
    return t10 && Object.assign(e || {}, t10);
  }
  function wd(t10) {
    var e = { r: 0, g: 0, b: 0, a: 255 };
    return Array.isArray(t10) ? t10.length >= 3 && (e = { r: t10[0], g: t10[1], b: t10[2], a: 255 }, t10.length > 3 && (e.a = un(t10[3]))) : (e = f1(t10, { r: 0, g: 0, b: 0, a: 1 }), e.a = un(e.a)), e;
  }
  function X3(t10) {
    return t10.charAt(0) === "r" ? H3(t10) : j3(t10);
  }
  class To {
    constructor(e) {
      if (e instanceof To)
        return e;
      const r = typeof e;
      let n;
      r === "object" ? n = wd(e) : r === "string" && (n = I3(e) || V3(e) || X3(e)), this._rgb = n, this._valid = !!n;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var e = f1(this._rgb);
      return e && (e.a = Nr(e.a)), e;
    }
    set rgb(e) {
      this._rgb = wd(e);
    }
    rgbString() {
      return this._valid ? Y3(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? R3(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? U3(this._rgb) : void 0;
    }
    mix(e, r) {
      if (e) {
        const n = this.rgb, i = e.rgb;
        let o;
        const s = r === o ? 0.5 : r, a = 2 * s - 1, l = n.a - i.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
        o = 1 - c, n.r = 255 & c * n.r + o * i.r + 0.5, n.g = 255 & c * n.g + o * i.g + 0.5, n.b = 255 & c * n.b + o * i.b + 0.5, n.a = s * n.a + (1 - s) * i.a, this.rgb = n;
      }
      return this;
    }
    interpolate(e, r) {
      return e && (this._rgb = K3(this._rgb, e._rgb, r)), this;
    }
    clone() {
      return new To(this.rgb);
    }
    alpha(e) {
      return this._rgb.a = un(e), this;
    }
    clearer(e) {
      const r = this._rgb;
      return r.a *= 1 - e, this;
    }
    greyscale() {
      const e = this._rgb, r = Jo(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
      return e.r = e.g = e.b = r, this;
    }
    opaquer(e) {
      const r = this._rgb;
      return r.a *= 1 + e, this;
    }
    negate() {
      const e = this._rgb;
      return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
    }
    lighten(e) {
      return bs(this._rgb, 2, e), this;
    }
    darken(e) {
      return bs(this._rgb, 2, -e), this;
    }
    saturate(e) {
      return bs(this._rgb, 1, e), this;
    }
    desaturate(e) {
      return bs(this._rgb, 1, -e), this;
    }
    rotate(e) {
      return W3(this._rgb, e), this;
    }
  }
  /*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   */
  function Pr() {
  }
  const J3 = /* @__PURE__ */ (() => {
    let t10 = 0;
    return () => t10++;
  })();
  function We(t10) {
    return t10 === null || typeof t10 > "u";
  }
  function it(t10) {
    if (Array.isArray && Array.isArray(t10))
      return true;
    const e = Object.prototype.toString.call(t10);
    return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
  }
  function Le(t10) {
    return t10 !== null && Object.prototype.toString.call(t10) === "[object Object]";
  }
  function pt(t10) {
    return (typeof t10 == "number" || t10 instanceof Number) && isFinite(+t10);
  }
  function Ht(t10, e) {
    return pt(t10) ? t10 : e;
  }
  function Oe(t10, e) {
    return typeof t10 > "u" ? e : t10;
  }
  const Q3 = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 : +t10 / e, d1 = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 * e : +t10;
  function nt(t10, e, r) {
    if (t10 && typeof t10.call == "function")
      return t10.apply(r, e);
  }
  function $e(t10, e, r, n) {
    let i, o, s;
    if (it(t10))
      if (o = t10.length, n)
        ;
      else
        for (i = 0; i < o; i++)
          e.call(r, t10[i], i);
    else if (Le(t10))
      for (s = Object.keys(t10), o = s.length, i = 0; i < o; i++)
        e.call(r, t10[s[i]], s[i]);
  }
  function ga(t10, e) {
    let r, n, i, o;
    if (!t10 || !e || t10.length !== e.length)
      return false;
    for (r = 0, n = t10.length; r < n; ++r)
      if (i = t10[r], o = e[r], i.datasetIndex !== o.datasetIndex || i.index !== o.index)
        return false;
    return true;
  }
  function ma(t10) {
    if (it(t10))
      return t10.map(ma);
    if (Le(t10)) {
      const e = /* @__PURE__ */ Object.create(null), r = Object.keys(t10), n = r.length;
      let i = 0;
      for (; i < n; ++i)
        e[r[i]] = ma(t10[r[i]]);
      return e;
    }
    return t10;
  }
  function h1(t10) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(t10) === -1;
  }
  function G3(t10, e, r, n) {
    if (!h1(t10))
      return;
    const i = e[t10], o = r[t10];
    Le(i) && Le(o) ? Oo(i, o, n) : e[t10] = ma(o);
  }
  function Oo(t10, e, r) {
    const n = it(e) ? e : [
      e
    ], i = n.length;
    if (!Le(t10))
      return t10;
    r = r || {};
    const o = r.merger || G3;
    let s;
    for (let a = 0; a < i; ++a) {
      if (s = n[a], !Le(s))
        continue;
      const l = Object.keys(s);
      for (let c = 0, u = l.length; c < u; ++c)
        o(l[c], t10, s, r);
    }
    return t10;
  }
  function mo(t10, e) {
    return Oo(t10, e, {
      merger: Z3
    });
  }
  function Z3(t10, e, r) {
    if (!h1(t10))
      return;
    const n = e[t10], i = r[t10];
    Le(n) && Le(i) ? mo(n, i) : Object.prototype.hasOwnProperty.call(e, t10) || (e[t10] = ma(i));
  }
  const xd = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (t10) => t10,
    // default resolvers
    x: (t10) => t10.x,
    y: (t10) => t10.y
  };
  function $3(t10) {
    const e = t10.split("."), r = [];
    let n = "";
    for (const i of e)
      n += i, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (r.push(n), n = "");
    return r;
  }
  function e2(t10) {
    const e = $3(t10);
    return (r) => {
      for (const n of e) {
        if (n === "")
          break;
        r = r && r[n];
      }
      return r;
    };
  }
  function pn(t10, e) {
    return (xd[e] || (xd[e] = e2(e)))(t10);
  }
  function Fu(t10) {
    return t10.charAt(0).toUpperCase() + t10.slice(1);
  }
  const Io = (t10) => typeof t10 < "u", gn = (t10) => typeof t10 == "function", _d = (t10, e) => {
    if (t10.size !== e.size)
      return false;
    for (const r of t10)
      if (!e.has(r))
        return false;
    return true;
  };
  function t2(t10) {
    return t10.type === "mouseup" || t10.type === "click" || t10.type === "contextmenu";
  }
  const st = Math.PI, ot = 2 * st, r2 = ot + st, ya = Number.POSITIVE_INFINITY, n2 = st / 180, mt = st / 2, En = st / 4, Sd = st * 2 / 3, rn = Math.log10, Cr = Math.sign;
  function yo(t10, e, r) {
    return Math.abs(t10 - e) < r;
  }
  function Ed(t10) {
    const e = Math.round(t10);
    t10 = yo(t10, e, t10 / 1e3) ? e : t10;
    const r = Math.pow(10, Math.floor(rn(t10))), n = t10 / r;
    return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * r;
  }
  function i2(t10) {
    const e = [], r = Math.sqrt(t10);
    let n;
    for (n = 1; n < r; n++)
      t10 % n === 0 && (e.push(n), e.push(t10 / n));
    return r === (r | 0) && e.push(r), e.sort((i, o) => i - o).pop(), e;
  }
  function Ei(t10) {
    return !isNaN(parseFloat(t10)) && isFinite(t10);
  }
  function o2(t10, e) {
    const r = Math.round(t10);
    return r - e <= t10 && r + e >= t10;
  }
  function p1(t10, e, r) {
    let n, i, o;
    for (n = 0, i = t10.length; n < i; n++)
      o = t10[n][r], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));
  }
  function gr(t10) {
    return t10 * (st / 180);
  }
  function ju(t10) {
    return t10 * (180 / st);
  }
  function kd(t10) {
    if (!pt(t10))
      return;
    let e = 1, r = 0;
    for (; Math.round(t10 * e) / e !== t10; )
      e *= 10, r++;
    return r;
  }
  function g1(t10, e) {
    const r = e.x - t10.x, n = e.y - t10.y, i = Math.sqrt(r * r + n * n);
    let o = Math.atan2(n, r);
    return o < -0.5 * st && (o += ot), {
      angle: o,
      distance: i
    };
  }
  function Dc(t10, e) {
    return Math.sqrt(Math.pow(e.x - t10.x, 2) + Math.pow(e.y - t10.y, 2));
  }
  function s2(t10, e) {
    return (t10 - e + r2) % ot - st;
  }
  function Yt(t10) {
    return (t10 % ot + ot) % ot;
  }
  function Po(t10, e, r, n) {
    const i = Yt(t10), o = Yt(e), s = Yt(r), a = Yt(o - i), l = Yt(s - i), c = Yt(i - o), u = Yt(i - s);
    return i === o || i === s || n && o === s || a > l && c < u;
  }
  function St(t10, e, r) {
    return Math.max(e, Math.min(r, t10));
  }
  function a2(t10) {
    return St(t10, -32768, 32767);
  }
  function Wr(t10, e, r, n = 1e-6) {
    return t10 >= Math.min(e, r) - n && t10 <= Math.max(e, r) + n;
  }
  function Wu(t10, e, r) {
    r = r || ((s) => t10[s] < e);
    let n = t10.length - 1, i = 0, o;
    for (; n - i > 1; )
      o = i + n >> 1, r(o) ? i = o : n = o;
    return {
      lo: i,
      hi: n
    };
  }
  const Ur = (t10, e, r, n) => Wu(t10, r, n ? (i) => {
    const o = t10[i][e];
    return o < r || o === r && t10[i + 1][e] === r;
  } : (i) => t10[i][e] < r), l2 = (t10, e, r) => Wu(t10, r, (n) => t10[n][e] >= r);
  function c2(t10, e, r) {
    let n = 0, i = t10.length;
    for (; n < i && t10[n] < e; )
      n++;
    for (; i > n && t10[i - 1] > r; )
      i--;
    return n > 0 || i < t10.length ? t10.slice(n, i) : t10;
  }
  const m1 = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function u2(t10, e) {
    if (t10._chartjs) {
      t10._chartjs.listeners.push(e);
      return;
    }
    Object.defineProperty(t10, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          e
        ]
      }
    }), m1.forEach((r) => {
      const n = "_onData" + Fu(r), i = t10[r];
      Object.defineProperty(t10, r, {
        configurable: true,
        enumerable: false,
        value(...o) {
          const s = i.apply(this, o);
          return t10._chartjs.listeners.forEach((a) => {
            typeof a[n] == "function" && a[n](...o);
          }), s;
        }
      });
    });
  }
  function Cd(t10, e) {
    const r = t10._chartjs;
    if (!r)
      return;
    const n = r.listeners, i = n.indexOf(e);
    i !== -1 && n.splice(i, 1), !(n.length > 0) && (m1.forEach((o) => {
      delete t10[o];
    }), delete t10._chartjs);
  }
  function y1(t10) {
    const e = new Set(t10);
    return e.size === t10.length ? t10 : Array.from(e);
  }
  const b1 = function() {
    return typeof window > "u" ? function(t10) {
      return t10();
    } : window.requestAnimationFrame;
  }();
  function v1(t10, e) {
    let r = [], n = false;
    return function(...i) {
      r = i, n || (n = true, b1.call(window, () => {
        n = false, t10.apply(e, r);
      }));
    };
  }
  function f2(t10, e) {
    let r;
    return function(...n) {
      return e ? (clearTimeout(r), r = setTimeout(t10, e, n)) : t10.apply(this, n), e;
    };
  }
  const Uu = (t10) => t10 === "start" ? "left" : t10 === "end" ? "right" : "center", It = (t10, e, r) => t10 === "start" ? e : t10 === "end" ? r : (e + r) / 2, d2 = (t10, e, r, n) => t10 === (n ? "left" : "right") ? r : t10 === "center" ? (e + r) / 2 : e;
  function A1(t10, e, r) {
    const n = e.length;
    let i = 0, o = n;
    if (t10._sorted) {
      const { iScale: s, _parsed: a } = t10, l = s.axis, { min: c, max: u, minDefined: f, maxDefined: d } = s.getUserBounds();
      f && (i = St(Math.min(
        // @ts-expect-error Need to type _parsed
        Ur(a, l, c).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        r ? n : Ur(e, l, s.getPixelForValue(c)).lo
      ), 0, n - 1)), d ? o = St(Math.max(
        // @ts-expect-error Need to type _parsed
        Ur(a, s.axis, u, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        r ? 0 : Ur(e, l, s.getPixelForValue(u), true).hi + 1
      ), i, n) - i : o = n - i;
    }
    return {
      start: i,
      count: o
    };
  }
  function w1(t10) {
    const { xScale: e, yScale: r, _scaleRanges: n } = t10, i = {
      xmin: e.min,
      xmax: e.max,
      ymin: r.min,
      ymax: r.max
    };
    if (!n)
      return t10._scaleRanges = i, true;
    const o = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== r.min || n.ymax !== r.max;
    return Object.assign(n, i), o;
  }
  const vs = (t10) => t10 === 0 || t10 === 1, Td = (t10, e, r) => -(Math.pow(2, 10 * (t10 -= 1)) * Math.sin((t10 - e) * ot / r)), Od = (t10, e, r) => Math.pow(2, -10 * t10) * Math.sin((t10 - e) * ot / r) + 1, bo = {
    linear: (t10) => t10,
    easeInQuad: (t10) => t10 * t10,
    easeOutQuad: (t10) => -t10 * (t10 - 2),
    easeInOutQuad: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 : -0.5 * (--t10 * (t10 - 2) - 1),
    easeInCubic: (t10) => t10 * t10 * t10,
    easeOutCubic: (t10) => (t10 -= 1) * t10 * t10 + 1,
    easeInOutCubic: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 + 2),
    easeInQuart: (t10) => t10 * t10 * t10 * t10,
    easeOutQuart: (t10) => -((t10 -= 1) * t10 * t10 * t10 - 1),
    easeInOutQuart: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 : -0.5 * ((t10 -= 2) * t10 * t10 * t10 - 2),
    easeInQuint: (t10) => t10 * t10 * t10 * t10 * t10,
    easeOutQuint: (t10) => (t10 -= 1) * t10 * t10 * t10 * t10 + 1,
    easeInOutQuint: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 * t10 * t10 + 2),
    easeInSine: (t10) => -Math.cos(t10 * mt) + 1,
    easeOutSine: (t10) => Math.sin(t10 * mt),
    easeInOutSine: (t10) => -0.5 * (Math.cos(st * t10) - 1),
    easeInExpo: (t10) => t10 === 0 ? 0 : Math.pow(2, 10 * (t10 - 1)),
    easeOutExpo: (t10) => t10 === 1 ? 1 : -Math.pow(2, -10 * t10) + 1,
    easeInOutExpo: (t10) => vs(t10) ? t10 : t10 < 0.5 ? 0.5 * Math.pow(2, 10 * (t10 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t10 * 2 - 1)) + 2),
    easeInCirc: (t10) => t10 >= 1 ? t10 : -(Math.sqrt(1 - t10 * t10) - 1),
    easeOutCirc: (t10) => Math.sqrt(1 - (t10 -= 1) * t10),
    easeInOutCirc: (t10) => (t10 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t10 * t10) - 1) : 0.5 * (Math.sqrt(1 - (t10 -= 2) * t10) + 1),
    easeInElastic: (t10) => vs(t10) ? t10 : Td(t10, 0.075, 0.3),
    easeOutElastic: (t10) => vs(t10) ? t10 : Od(t10, 0.075, 0.3),
    easeInOutElastic(t10) {
      return vs(t10) ? t10 : t10 < 0.5 ? 0.5 * Td(t10 * 2, 0.1125, 0.45) : 0.5 + 0.5 * Od(t10 * 2 - 1, 0.1125, 0.45);
    },
    easeInBack(t10) {
      return t10 * t10 * ((1.70158 + 1) * t10 - 1.70158);
    },
    easeOutBack(t10) {
      return (t10 -= 1) * t10 * ((1.70158 + 1) * t10 + 1.70158) + 1;
    },
    easeInOutBack(t10) {
      let e = 1.70158;
      return (t10 /= 0.5) < 1 ? 0.5 * (t10 * t10 * (((e *= 1.525) + 1) * t10 - e)) : 0.5 * ((t10 -= 2) * t10 * (((e *= 1.525) + 1) * t10 + e) + 2);
    },
    easeInBounce: (t10) => 1 - bo.easeOutBounce(1 - t10),
    easeOutBounce(t10) {
      return t10 < 1 / 2.75 ? 7.5625 * t10 * t10 : t10 < 2 / 2.75 ? 7.5625 * (t10 -= 1.5 / 2.75) * t10 + 0.75 : t10 < 2.5 / 2.75 ? 7.5625 * (t10 -= 2.25 / 2.75) * t10 + 0.9375 : 7.5625 * (t10 -= 2.625 / 2.75) * t10 + 0.984375;
    },
    easeInOutBounce: (t10) => t10 < 0.5 ? bo.easeInBounce(t10 * 2) * 0.5 : bo.easeOutBounce(t10 * 2 - 1) * 0.5 + 0.5
  };
  function zu(t10) {
    if (t10 && typeof t10 == "object") {
      const e = t10.toString();
      return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
    }
    return false;
  }
  function Id(t10) {
    return zu(t10) ? t10 : new To(t10);
  }
  function ql(t10) {
    return zu(t10) ? t10 : new To(t10).saturate(0.5).darken(0.1).hexString();
  }
  const h2 = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ], p2 = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function g2(t10) {
    t10.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    }), t10.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
    }), t10.set("animations", {
      colors: {
        type: "color",
        properties: p2
      },
      numbers: {
        type: "number",
        properties: h2
      }
    }), t10.describe("animations", {
      _fallback: "animation"
    }), t10.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (e) => e | 0
          }
        }
      }
    });
  }
  function m2(t10) {
    t10.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  const Pd = /* @__PURE__ */ new Map();
  function y2(t10, e) {
    e = e || {};
    const r = t10 + JSON.stringify(e);
    let n = Pd.get(r);
    return n || (n = new Intl.NumberFormat(t10, e), Pd.set(r, n)), n;
  }
  function Qo(t10, e, r) {
    return y2(e, r).format(t10);
  }
  const x1 = {
    values(t10) {
      return it(t10) ? t10 : "" + t10;
    },
    numeric(t10, e, r) {
      if (t10 === 0)
        return "0";
      const n = this.chart.options.locale;
      let i, o = t10;
      if (r.length > 1) {
        const c = Math.max(Math.abs(r[0].value), Math.abs(r[r.length - 1].value));
        (c < 1e-4 || c > 1e15) && (i = "scientific"), o = b2(t10, r);
      }
      const s = rn(Math.abs(o)), a = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), l = {
        notation: i,
        minimumFractionDigits: a,
        maximumFractionDigits: a
      };
      return Object.assign(l, this.options.ticks.format), Qo(t10, n, l);
    },
    logarithmic(t10, e, r) {
      if (t10 === 0)
        return "0";
      const n = r[e].significand || t10 / Math.pow(10, Math.floor(rn(t10)));
      return [
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(n) || e > 0.8 * r.length ? x1.numeric.call(this, t10, e, r) : "";
    }
  };
  function b2(t10, e) {
    let r = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
    return Math.abs(r) >= 1 && t10 !== Math.floor(t10) && (r = t10 - Math.floor(t10)), r;
  }
  var Ya = {
    formatters: x1
  };
  function v2(t10) {
    t10.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (e, r) => r.lineWidth,
        tickColor: (e, r) => r.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ya.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    }), t10.route("scale.ticks", "color", "", "color"), t10.route("scale.grid", "color", "", "borderColor"), t10.route("scale.border", "color", "", "borderColor"), t10.route("scale.title", "color", "", "color"), t10.describe("scale", {
      _fallback: false,
      _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
      _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
    }), t10.describe("scales", {
      _fallback: "scale"
    }), t10.describe("scale.ticks", {
      _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
      _indexable: (e) => e !== "backdropPadding"
    });
  }
  const Yn = /* @__PURE__ */ Object.create(null), Mc = /* @__PURE__ */ Object.create(null);
  function vo(t10, e) {
    if (!e)
      return t10;
    const r = e.split(".");
    for (let n = 0, i = r.length; n < i; ++n) {
      const o = r[n];
      t10 = t10[o] || (t10[o] = /* @__PURE__ */ Object.create(null));
    }
    return t10;
  }
  function Hl(t10, e, r) {
    return typeof e == "string" ? Oo(vo(t10, e), r) : Oo(vo(t10, ""), e);
  }
  class A2 {
    constructor(e, r) {
      this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ], this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      }, this.hover = {}, this.hoverBackgroundColor = (n, i) => ql(i.backgroundColor), this.hoverBorderColor = (n, i) => ql(i.borderColor), this.hoverColor = (n, i) => ql(i.color), this.indexAxis = "x", this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(e), this.apply(r);
    }
    set(e, r) {
      return Hl(this, e, r);
    }
    get(e) {
      return vo(this, e);
    }
    describe(e, r) {
      return Hl(Mc, e, r);
    }
    override(e, r) {
      return Hl(Yn, e, r);
    }
    route(e, r, n, i) {
      const o = vo(this, e), s = vo(this, n), a = "_" + r;
      Object.defineProperties(o, {
        [a]: {
          value: o[r],
          writable: true
        },
        [r]: {
          enumerable: true,
          get() {
            const l = this[a], c = s[i];
            return Le(l) ? Object.assign({}, c, l) : Oe(l, c);
          },
          set(l) {
            this[a] = l;
          }
        }
      });
    }
    apply(e) {
      e.forEach((r) => r(this));
    }
  }
  var gt = /* @__PURE__ */ new A2({
    _scriptable: (t10) => !t10.startsWith("on"),
    _indexable: (t10) => t10 !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    g2,
    m2,
    v2
  ]);
  function w2(t10) {
    return !t10 || We(t10.size) || We(t10.family) ? null : (t10.style ? t10.style + " " : "") + (t10.weight ? t10.weight + " " : "") + t10.size + "px " + t10.family;
  }
  function ba(t10, e, r, n, i) {
    let o = e[i];
    return o || (o = e[i] = t10.measureText(i).width, r.push(i)), o > n && (n = o), n;
  }
  function x2(t10, e, r, n) {
    n = n || {};
    let i = n.data = n.data || {}, o = n.garbageCollect = n.garbageCollect || [];
    n.font !== e && (i = n.data = {}, o = n.garbageCollect = [], n.font = e), t10.save(), t10.font = e;
    let s = 0;
    const a = r.length;
    let l, c, u, f, d;
    for (l = 0; l < a; l++)
      if (f = r[l], f != null && !it(f))
        s = ba(t10, i, o, s, f);
      else if (it(f))
        for (c = 0, u = f.length; c < u; c++)
          d = f[c], d != null && !it(d) && (s = ba(t10, i, o, s, d));
    t10.restore();
    const h = o.length / 2;
    if (h > r.length) {
      for (l = 0; l < h; l++)
        delete i[o[l]];
      o.splice(0, h);
    }
    return s;
  }
  function kn(t10, e, r) {
    const n = t10.currentDevicePixelRatio, i = r !== 0 ? Math.max(r / 2, 0.5) : 0;
    return Math.round((e - i) * n) / n + i;
  }
  function Rd(t10, e) {
    e = e || t10.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t10.width, t10.height), e.restore();
  }
  function Nc(t10, e, r, n) {
    _1(t10, e, r, n, null);
  }
  function _1(t10, e, r, n, i) {
    let o, s, a, l, c, u, f, d;
    const h = e.pointStyle, g = e.rotation, p = e.radius;
    let y = (g || 0) * n2;
    if (h && typeof h == "object" && (o = h.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
      t10.save(), t10.translate(r, n), t10.rotate(y), t10.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t10.restore();
      return;
    }
    if (!(isNaN(p) || p <= 0)) {
      switch (t10.beginPath(), h) {
        default:
          i ? t10.ellipse(r, n, i / 2, p, 0, 0, ot) : t10.arc(r, n, p, 0, ot), t10.closePath();
          break;
        case "triangle":
          u = i ? i / 2 : p, t10.moveTo(r + Math.sin(y) * u, n - Math.cos(y) * p), y += Sd, t10.lineTo(r + Math.sin(y) * u, n - Math.cos(y) * p), y += Sd, t10.lineTo(r + Math.sin(y) * u, n - Math.cos(y) * p), t10.closePath();
          break;
        case "rectRounded":
          c = p * 0.516, l = p - c, s = Math.cos(y + En) * l, f = Math.cos(y + En) * (i ? i / 2 - c : l), a = Math.sin(y + En) * l, d = Math.sin(y + En) * (i ? i / 2 - c : l), t10.arc(r - f, n - a, c, y - st, y - mt), t10.arc(r + d, n - s, c, y - mt, y), t10.arc(r + f, n + a, c, y, y + mt), t10.arc(r - d, n + s, c, y + mt, y + st), t10.closePath();
          break;
        case "rect":
          if (!g) {
            l = Math.SQRT1_2 * p, u = i ? i / 2 : l, t10.rect(r - u, n - l, 2 * u, 2 * l);
            break;
          }
          y += En;
        case "rectRot":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + d, n - s), t10.lineTo(r + f, n + a), t10.lineTo(r - d, n + s), t10.closePath();
          break;
        case "crossRot":
          y += En;
        case "cross":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s);
          break;
        case "star":
          f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s), y += En, f = Math.cos(y) * (i ? i / 2 : p), s = Math.cos(y) * p, a = Math.sin(y) * p, d = Math.sin(y) * (i ? i / 2 : p), t10.moveTo(r - f, n - a), t10.lineTo(r + f, n + a), t10.moveTo(r + d, n - s), t10.lineTo(r - d, n + s);
          break;
        case "line":
          s = i ? i / 2 : Math.cos(y) * p, a = Math.sin(y) * p, t10.moveTo(r - s, n - a), t10.lineTo(r + s, n + a);
          break;
        case "dash":
          t10.moveTo(r, n), t10.lineTo(r + Math.cos(y) * (i ? i / 2 : p), n + Math.sin(y) * p);
          break;
        case false:
          t10.closePath();
          break;
      }
      t10.fill(), e.borderWidth > 0 && t10.stroke();
    }
  }
  function zr(t10, e, r) {
    return r = r || 0.5, !e || t10 && t10.x > e.left - r && t10.x < e.right + r && t10.y > e.top - r && t10.y < e.bottom + r;
  }
  function Ka(t10, e) {
    t10.save(), t10.beginPath(), t10.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t10.clip();
  }
  function Xa(t10) {
    t10.restore();
  }
  function _2(t10, e, r, n, i) {
    if (!e)
      return t10.lineTo(r.x, r.y);
    if (i === "middle") {
      const o = (e.x + r.x) / 2;
      t10.lineTo(o, e.y), t10.lineTo(o, r.y);
    } else
      i === "after" != !!n ? t10.lineTo(e.x, r.y) : t10.lineTo(r.x, e.y);
    t10.lineTo(r.x, r.y);
  }
  function S2(t10, e, r, n) {
    if (!e)
      return t10.lineTo(r.x, r.y);
    t10.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? r.cp2x : r.cp1x, n ? r.cp2y : r.cp1y, r.x, r.y);
  }
  function E2(t10, e) {
    e.translation && t10.translate(e.translation[0], e.translation[1]), We(e.rotation) || t10.rotate(e.rotation), e.color && (t10.fillStyle = e.color), e.textAlign && (t10.textAlign = e.textAlign), e.textBaseline && (t10.textBaseline = e.textBaseline);
  }
  function k2(t10, e, r, n, i) {
    if (i.strikethrough || i.underline) {
      const o = t10.measureText(n), s = e - o.actualBoundingBoxLeft, a = e + o.actualBoundingBoxRight, l = r - o.actualBoundingBoxAscent, c = r + o.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c;
      t10.strokeStyle = t10.fillStyle, t10.beginPath(), t10.lineWidth = i.decorationWidth || 2, t10.moveTo(s, u), t10.lineTo(a, u), t10.stroke();
    }
  }
  function C2(t10, e) {
    const r = t10.fillStyle;
    t10.fillStyle = e.color, t10.fillRect(e.left, e.top, e.width, e.height), t10.fillStyle = r;
  }
  function Kn(t10, e, r, n, i, o = {}) {
    const s = it(e) ? e : [
      e
    ], a = o.strokeWidth > 0 && o.strokeColor !== "";
    let l, c;
    for (t10.save(), t10.font = i.string, E2(t10, o), l = 0; l < s.length; ++l)
      c = s[l], o.backdrop && C2(t10, o.backdrop), a && (o.strokeColor && (t10.strokeStyle = o.strokeColor), We(o.strokeWidth) || (t10.lineWidth = o.strokeWidth), t10.strokeText(c, r, n, o.maxWidth)), t10.fillText(c, r, n, o.maxWidth), k2(t10, r, n, c, o), n += Number(i.lineHeight);
    t10.restore();
  }
  function Ro(t10, e) {
    const { x: r, y: n, w: i, h: o, radius: s } = e;
    t10.arc(r + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * st, st, true), t10.lineTo(r, n + o - s.bottomLeft), t10.arc(r + s.bottomLeft, n + o - s.bottomLeft, s.bottomLeft, st, mt, true), t10.lineTo(r + i - s.bottomRight, n + o), t10.arc(r + i - s.bottomRight, n + o - s.bottomRight, s.bottomRight, mt, 0, true), t10.lineTo(r + i, n + s.topRight), t10.arc(r + i - s.topRight, n + s.topRight, s.topRight, 0, -mt, true), t10.lineTo(r + s.topLeft, n);
  }
  const T2 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, O2 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function I2(t10, e) {
    const r = ("" + t10).match(T2);
    if (!r || r[1] === "normal")
      return e * 1.2;
    switch (t10 = +r[2], r[3]) {
      case "px":
        return t10;
      case "%":
        t10 /= 100;
        break;
    }
    return e * t10;
  }
  const P2 = (t10) => +t10 || 0;
  function Vu(t10, e) {
    const r = {}, n = Le(e), i = n ? Object.keys(e) : e, o = Le(t10) ? n ? (s) => Oe(t10[s], t10[e[s]]) : (s) => t10[s] : () => t10;
    for (const s of i)
      r[s] = P2(o(s));
    return r;
  }
  function S1(t10) {
    return Vu(t10, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function Fn(t10) {
    return Vu(t10, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function Mt(t10) {
    const e = S1(t10);
    return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
  }
  function vt(t10, e) {
    t10 = t10 || {}, e = e || gt.font;
    let r = Oe(t10.size, e.size);
    typeof r == "string" && (r = parseInt(r, 10));
    let n = Oe(t10.style, e.style);
    n && !("" + n).match(O2) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
    const i = {
      family: Oe(t10.family, e.family),
      lineHeight: I2(Oe(t10.lineHeight, e.lineHeight), r),
      size: r,
      style: n,
      weight: Oe(t10.weight, e.weight),
      string: ""
    };
    return i.string = w2(i), i;
  }
  function oo(t10, e, r, n) {
    let o, s, a;
    for (o = 0, s = t10.length; o < s; ++o)
      if (a = t10[o], a !== void 0 && a !== void 0)
        return a;
  }
  function R2(t10, e, r) {
    const { min: n, max: i } = t10, o = d1(e, (i - n) / 2), s = (a, l) => r && a === 0 ? 0 : a + l;
    return {
      min: s(n, -Math.abs(o)),
      max: s(i, o)
    };
  }
  function vn(t10, e) {
    return Object.assign(Object.create(t10), e);
  }
  function qu(t10, e = [
    ""
  ], r, n, i = () => t10[0]) {
    const o = r || t10;
    typeof n > "u" && (n = T1("_fallback", t10));
    const s = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: t10,
      _rootScopes: o,
      _fallback: n,
      _getTarget: i,
      override: (a) => qu([
        a,
        ...t10
      ], e, o, n)
    };
    return new Proxy(s, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(a, l) {
        return delete a[l], delete a._keys, delete t10[0][l], true;
      },
      /**
      * A trap for getting property values.
      */
      get(a, l) {
        return k1(a, l, () => W2(l, e, t10, a));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(a, l) {
        return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(t10[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(a, l) {
        return Md(a).includes(l);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(a) {
        return Md(a);
      },
      /**
      * A trap for setting property values.
      */
      set(a, l, c) {
        const u = a._storage || (a._storage = i());
        return a[l] = u[l] = c, delete a._keys, true;
      }
    });
  }
  function ki(t10, e, r, n) {
    const i = {
      _cacheable: false,
      _proxy: t10,
      _context: e,
      _subProxy: r,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: E1(t10, n),
      setContext: (o) => ki(t10, o, r, n),
      override: (o) => ki(t10.override(o), e, r, n)
    };
    return new Proxy(i, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(o, s) {
        return delete o[s], delete t10[s], true;
      },
      /**
      * A trap for getting property values.
      */
      get(o, s, a) {
        return k1(o, s, () => M2(o, s, a));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(o, s) {
        return o._descriptors.allKeys ? Reflect.has(t10, s) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(t10, s);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(t10);
      },
      /**
      * A trap for the in operator.
      */
      has(o, s) {
        return Reflect.has(t10, s);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(t10);
      },
      /**
      * A trap for setting property values.
      */
      set(o, s, a) {
        return t10[s] = a, delete o[s], true;
      }
    });
  }
  function E1(t10, e = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable: r = e.scriptable, _indexable: n = e.indexable, _allKeys: i = e.allKeys } = t10;
    return {
      allKeys: i,
      scriptable: r,
      indexable: n,
      isScriptable: gn(r) ? r : () => r,
      isIndexable: gn(n) ? n : () => n
    };
  }
  const D2 = (t10, e) => t10 ? t10 + Fu(e) : e, Hu = (t10, e) => Le(e) && t10 !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
  function k1(t10, e, r) {
    if (Object.prototype.hasOwnProperty.call(t10, e))
      return t10[e];
    const n = r();
    return t10[e] = n, n;
  }
  function M2(t10, e, r) {
    const { _proxy: n, _context: i, _subProxy: o, _descriptors: s } = t10;
    let a = n[e];
    return gn(a) && s.isScriptable(e) && (a = N2(e, a, t10, r)), it(a) && a.length && (a = L2(e, a, t10, s.isIndexable)), Hu(e, a) && (a = ki(a, i, o && o[e], s)), a;
  }
  function N2(t10, e, r, n) {
    const { _proxy: i, _context: o, _subProxy: s, _stack: a } = r;
    if (a.has(t10))
      throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t10);
    a.add(t10);
    let l = e(o, s || n);
    return a.delete(t10), Hu(t10, l) && (l = Yu(i._scopes, i, t10, l)), l;
  }
  function L2(t10, e, r, n) {
    const { _proxy: i, _context: o, _subProxy: s, _descriptors: a } = r;
    if (typeof o.index < "u" && n(t10))
      return e[o.index % e.length];
    if (Le(e[0])) {
      const l = e, c = i._scopes.filter((u) => u !== l);
      e = [];
      for (const u of l) {
        const f = Yu(c, i, t10, u);
        e.push(ki(f, o, s && s[t10], a));
      }
    }
    return e;
  }
  function C1(t10, e, r) {
    return gn(t10) ? t10(e, r) : t10;
  }
  const B2 = (t10, e) => t10 === true ? e : typeof t10 == "string" ? pn(e, t10) : void 0;
  function F2(t10, e, r, n, i) {
    for (const o of e) {
      const s = B2(r, o);
      if (s) {
        t10.add(s);
        const a = C1(s._fallback, r, i);
        if (typeof a < "u" && a !== r && a !== n)
          return a;
      } else if (s === false && typeof n < "u" && r !== n)
        return null;
    }
    return false;
  }
  function Yu(t10, e, r, n) {
    const i = e._rootScopes, o = C1(e._fallback, r, n), s = [
      ...t10,
      ...i
    ], a = /* @__PURE__ */ new Set();
    a.add(n);
    let l = Dd(a, s, r, o || r, n);
    return l === null || typeof o < "u" && o !== r && (l = Dd(a, s, o, l, n), l === null) ? false : qu(Array.from(a), [
      ""
    ], i, o, () => j2(e, r, n));
  }
  function Dd(t10, e, r, n, i) {
    for (; r; )
      r = F2(t10, e, r, n, i);
    return r;
  }
  function j2(t10, e, r) {
    const n = t10._getTarget();
    e in n || (n[e] = {});
    const i = n[e];
    return it(i) && Le(r) ? r : i || {};
  }
  function W2(t10, e, r, n) {
    let i;
    for (const o of e)
      if (i = T1(D2(o, t10), r), typeof i < "u")
        return Hu(t10, i) ? Yu(r, n, t10, i) : i;
  }
  function T1(t10, e) {
    for (const r of e) {
      if (!r)
        continue;
      const n = r[t10];
      if (typeof n < "u")
        return n;
    }
  }
  function Md(t10) {
    let e = t10._keys;
    return e || (e = t10._keys = U2(t10._scopes)), e;
  }
  function U2(t10) {
    const e = /* @__PURE__ */ new Set();
    for (const r of t10)
      for (const n of Object.keys(r).filter((i) => !i.startsWith("_")))
        e.add(n);
    return Array.from(e);
  }
  function O1(t10, e, r, n) {
    const { iScale: i } = t10, { key: o = "r" } = this._parsing, s = new Array(n);
    let a, l, c, u;
    for (a = 0, l = n; a < l; ++a)
      c = a + r, u = e[c], s[a] = {
        r: i.parse(pn(u, o), c)
      };
    return s;
  }
  const z2 = Number.EPSILON || 1e-14, Ci = (t10, e) => e < t10.length && !t10[e].skip && t10[e], I1 = (t10) => t10 === "x" ? "y" : "x";
  function V2(t10, e, r, n) {
    const i = t10.skip ? e : t10, o = e, s = r.skip ? e : r, a = Dc(o, i), l = Dc(s, o);
    let c = a / (a + l), u = l / (a + l);
    c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
    const f = n * c, d = n * u;
    return {
      previous: {
        x: o.x - f * (s.x - i.x),
        y: o.y - f * (s.y - i.y)
      },
      next: {
        x: o.x + d * (s.x - i.x),
        y: o.y + d * (s.y - i.y)
      }
    };
  }
  function q2(t10, e, r) {
    const n = t10.length;
    let i, o, s, a, l, c = Ci(t10, 0);
    for (let u = 0; u < n - 1; ++u)
      if (l = c, c = Ci(t10, u + 1), !(!l || !c)) {
        if (yo(e[u], 0, z2)) {
          r[u] = r[u + 1] = 0;
          continue;
        }
        i = r[u] / e[u], o = r[u + 1] / e[u], a = Math.pow(i, 2) + Math.pow(o, 2), !(a <= 9) && (s = 3 / Math.sqrt(a), r[u] = i * s * e[u], r[u + 1] = o * s * e[u]);
      }
  }
  function H2(t10, e, r = "x") {
    const n = I1(r), i = t10.length;
    let o, s, a, l = Ci(t10, 0);
    for (let c = 0; c < i; ++c) {
      if (s = a, a = l, l = Ci(t10, c + 1), !a)
        continue;
      const u = a[r], f = a[n];
      s && (o = (u - s[r]) / 3, a[`cp1${r}`] = u - o, a[`cp1${n}`] = f - o * e[c]), l && (o = (l[r] - u) / 3, a[`cp2${r}`] = u + o, a[`cp2${n}`] = f + o * e[c]);
    }
  }
  function Y2(t10, e = "x") {
    const r = I1(e), n = t10.length, i = Array(n).fill(0), o = Array(n);
    let s, a, l, c = Ci(t10, 0);
    for (s = 0; s < n; ++s)
      if (a = l, l = c, c = Ci(t10, s + 1), !!l) {
        if (c) {
          const u = c[e] - l[e];
          i[s] = u !== 0 ? (c[r] - l[r]) / u : 0;
        }
        o[s] = a ? c ? Cr(i[s - 1]) !== Cr(i[s]) ? 0 : (i[s - 1] + i[s]) / 2 : i[s - 1] : i[s];
      }
    q2(t10, i, o), H2(t10, o, e);
  }
  function As(t10, e, r) {
    return Math.max(Math.min(t10, r), e);
  }
  function K2(t10, e) {
    let r, n, i, o, s, a = zr(t10[0], e);
    for (r = 0, n = t10.length; r < n; ++r)
      s = o, o = a, a = r < n - 1 && zr(t10[r + 1], e), o && (i = t10[r], s && (i.cp1x = As(i.cp1x, e.left, e.right), i.cp1y = As(i.cp1y, e.top, e.bottom)), a && (i.cp2x = As(i.cp2x, e.left, e.right), i.cp2y = As(i.cp2y, e.top, e.bottom)));
  }
  function X2(t10, e, r, n, i) {
    let o, s, a, l;
    if (e.spanGaps && (t10 = t10.filter((c) => !c.skip)), e.cubicInterpolationMode === "monotone")
      Y2(t10, i);
    else {
      let c = n ? t10[t10.length - 1] : t10[0];
      for (o = 0, s = t10.length; o < s; ++o)
        a = t10[o], l = V2(c, a, t10[Math.min(o + 1, s - (n ? 0 : 1)) % s], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
    }
    e.capBezierPoints && K2(t10, r);
  }
  function P1() {
    return typeof window < "u" && typeof document < "u";
  }
  function Ku(t10) {
    let e = t10.parentNode;
    return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
  }
  function va(t10, e, r) {
    let n;
    return typeof t10 == "string" ? (n = parseInt(t10, 10), t10.indexOf("%") !== -1 && (n = n / 100 * e.parentNode[r])) : n = t10, n;
  }
  const Ja = (t10) => t10.ownerDocument.defaultView.getComputedStyle(t10, null);
  function J2(t10, e) {
    return Ja(t10).getPropertyValue(e);
  }
  const Q2 = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function jn(t10, e, r) {
    const n = {};
    r = r ? "-" + r : "";
    for (let i = 0; i < 4; i++) {
      const o = Q2[i];
      n[o] = parseFloat(t10[e + "-" + o + r]) || 0;
    }
    return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
  }
  const G2 = (t10, e, r) => (t10 > 0 || e > 0) && (!r || !r.shadowRoot);
  function Z2(t10, e) {
    const r = t10.touches, n = r && r.length ? r[0] : t10, { offsetX: i, offsetY: o } = n;
    let s = false, a, l;
    if (G2(i, o, t10.target))
      a = i, l = o;
    else {
      const c = e.getBoundingClientRect();
      a = n.clientX - c.left, l = n.clientY - c.top, s = true;
    }
    return {
      x: a,
      y: l,
      box: s
    };
  }
  function Pn(t10, e) {
    if ("native" in t10)
      return t10;
    const { canvas: r, currentDevicePixelRatio: n } = e, i = Ja(r), o = i.boxSizing === "border-box", s = jn(i, "padding"), a = jn(i, "border", "width"), { x: l, y: c, box: u } = Z2(t10, r), f = s.left + (u && a.left), d = s.top + (u && a.top);
    let { width: h, height: g } = e;
    return o && (h -= s.width + a.width, g -= s.height + a.height), {
      x: Math.round((l - f) / h * r.width / n),
      y: Math.round((c - d) / g * r.height / n)
    };
  }
  function $2(t10, e, r) {
    let n, i;
    if (e === void 0 || r === void 0) {
      const o = Ku(t10);
      if (!o)
        e = t10.clientWidth, r = t10.clientHeight;
      else {
        const s = o.getBoundingClientRect(), a = Ja(o), l = jn(a, "border", "width"), c = jn(a, "padding");
        e = s.width - c.width - l.width, r = s.height - c.height - l.height, n = va(a.maxWidth, o, "clientWidth"), i = va(a.maxHeight, o, "clientHeight");
      }
    }
    return {
      width: e,
      height: r,
      maxWidth: n || ya,
      maxHeight: i || ya
    };
  }
  const ws = (t10) => Math.round(t10 * 10) / 10;
  function ev(t10, e, r, n) {
    const i = Ja(t10), o = jn(i, "margin"), s = va(i.maxWidth, t10, "clientWidth") || ya, a = va(i.maxHeight, t10, "clientHeight") || ya, l = $2(t10, e, r);
    let { width: c, height: u } = l;
    if (i.boxSizing === "content-box") {
      const d = jn(i, "border", "width"), h = jn(i, "padding");
      c -= h.width + d.width, u -= h.height + d.height;
    }
    return c = Math.max(0, c - o.width), u = Math.max(0, n ? c / n : u - o.height), c = ws(Math.min(c, s, l.maxWidth)), u = ws(Math.min(u, a, l.maxHeight)), c && !u && (u = ws(c / 2)), (e !== void 0 || r !== void 0) && n && l.height && u > l.height && (u = l.height, c = ws(Math.floor(u * n))), {
      width: c,
      height: u
    };
  }
  function Nd(t10, e, r) {
    const n = e || 1, i = Math.floor(t10.height * n), o = Math.floor(t10.width * n);
    t10.height = Math.floor(t10.height), t10.width = Math.floor(t10.width);
    const s = t10.canvas;
    return s.style && (r || !s.style.height && !s.style.width) && (s.style.height = `${t10.height}px`, s.style.width = `${t10.width}px`), t10.currentDevicePixelRatio !== n || s.height !== i || s.width !== o ? (t10.currentDevicePixelRatio = n, s.height = i, s.width = o, t10.ctx.setTransform(n, 0, 0, n, 0, 0), true) : false;
  }
  const tv = function() {
    let t10 = false;
    try {
      const e = {
        get passive() {
          return t10 = true, false;
        }
      };
      window.addEventListener("test", null, e), window.removeEventListener("test", null, e);
    } catch {
    }
    return t10;
  }();
  function Ld(t10, e) {
    const r = J2(t10, e), n = r && r.match(/^(\d+)(\.\d+)?px$/);
    return n ? +n[1] : void 0;
  }
  function Rn(t10, e, r, n) {
    return {
      x: t10.x + r * (e.x - t10.x),
      y: t10.y + r * (e.y - t10.y)
    };
  }
  function rv(t10, e, r, n) {
    return {
      x: t10.x + r * (e.x - t10.x),
      y: n === "middle" ? r < 0.5 ? t10.y : e.y : n === "after" ? r < 1 ? t10.y : e.y : r > 0 ? e.y : t10.y
    };
  }
  function nv(t10, e, r, n) {
    const i = {
      x: t10.cp2x,
      y: t10.cp2y
    }, o = {
      x: e.cp1x,
      y: e.cp1y
    }, s = Rn(t10, i, r), a = Rn(i, o, r), l = Rn(o, e, r), c = Rn(s, a, r), u = Rn(a, l, r);
    return Rn(c, u, r);
  }
  const iv = function(t10, e) {
    return {
      x(r) {
        return t10 + t10 + e - r;
      },
      setWidth(r) {
        e = r;
      },
      textAlign(r) {
        return r === "center" ? r : r === "right" ? "left" : "right";
      },
      xPlus(r, n) {
        return r - n;
      },
      leftForLtr(r, n) {
        return r - n;
      }
    };
  }, ov = function() {
    return {
      x(t10) {
        return t10;
      },
      setWidth(t10) {
      },
      textAlign(t10) {
        return t10;
      },
      xPlus(t10, e) {
        return t10 + e;
      },
      leftForLtr(t10, e) {
        return t10;
      }
    };
  };
  function bi(t10, e, r) {
    return t10 ? iv(e, r) : ov();
  }
  function R1(t10, e) {
    let r, n;
    (e === "ltr" || e === "rtl") && (r = t10.canvas.style, n = [
      r.getPropertyValue("direction"),
      r.getPropertyPriority("direction")
    ], r.setProperty("direction", e, "important"), t10.prevTextDirection = n);
  }
  function D1(t10, e) {
    e !== void 0 && (delete t10.prevTextDirection, t10.canvas.style.setProperty("direction", e[0], e[1]));
  }
  function M1(t10) {
    return t10 === "angle" ? {
      between: Po,
      compare: s2,
      normalize: Yt
    } : {
      between: Wr,
      compare: (e, r) => e - r,
      normalize: (e) => e
    };
  }
  function Bd({ start: t10, end: e, count: r, loop: n, style: i }) {
    return {
      start: t10 % r,
      end: e % r,
      loop: n && (e - t10 + 1) % r === 0,
      style: i
    };
  }
  function sv(t10, e, r) {
    const { property: n, start: i, end: o } = r, { between: s, normalize: a } = M1(n), l = e.length;
    let { start: c, end: u, loop: f } = t10, d, h;
    if (f) {
      for (c += l, u += l, d = 0, h = l; d < h && s(a(e[c % l][n]), i, o); ++d)
        c--, u--;
      c %= l, u %= l;
    }
    return u < c && (u += l), {
      start: c,
      end: u,
      loop: f,
      style: t10.style
    };
  }
  function N1(t10, e, r) {
    if (!r)
      return [
        t10
      ];
    const { property: n, start: i, end: o } = r, s = e.length, { compare: a, between: l, normalize: c } = M1(n), { start: u, end: f, loop: d, style: h } = sv(t10, e, r), g = [];
    let p = false, y = null, b, x, S;
    const O = () => l(i, S, b) && a(i, S) !== 0, _ = () => a(o, b) === 0 || l(o, S, b), L = () => p || O(), N = () => !p || _();
    for (let j = u, W = u; j <= f; ++j)
      x = e[j % s], !x.skip && (b = c(x[n]), b !== S && (p = l(b, i, o), y === null && L() && (y = a(b, i) === 0 ? j : W), y !== null && N() && (g.push(Bd({
        start: y,
        end: j,
        loop: d,
        count: s,
        style: h
      })), y = null), W = j, S = b));
    return y !== null && g.push(Bd({
      start: y,
      end: f,
      loop: d,
      count: s,
      style: h
    })), g;
  }
  function L1(t10, e) {
    const r = [], n = t10.segments;
    for (let i = 0; i < n.length; i++) {
      const o = N1(n[i], t10.points, e);
      o.length && r.push(...o);
    }
    return r;
  }
  function av(t10, e, r, n) {
    let i = 0, o = e - 1;
    if (r && !n)
      for (; i < e && !t10[i].skip; )
        i++;
    for (; i < e && t10[i].skip; )
      i++;
    for (i %= e, r && (o += i); o > i && t10[o % e].skip; )
      o--;
    return o %= e, {
      start: i,
      end: o
    };
  }
  function lv(t10, e, r, n) {
    const i = t10.length, o = [];
    let s = e, a = t10[e], l;
    for (l = e + 1; l <= r; ++l) {
      const c = t10[l % i];
      c.skip || c.stop ? a.skip || (n = false, o.push({
        start: e % i,
        end: (l - 1) % i,
        loop: n
      }), e = s = c.stop ? l : null) : (s = l, a.skip && (e = l)), a = c;
    }
    return s !== null && o.push({
      start: e % i,
      end: s % i,
      loop: n
    }), o;
  }
  function cv(t10, e) {
    const r = t10.points, n = t10.options.spanGaps, i = r.length;
    if (!i)
      return [];
    const o = !!t10._loop, { start: s, end: a } = av(r, i, o, n);
    if (n === true)
      return Fd(t10, [
        {
          start: s,
          end: a,
          loop: o
        }
      ], r, e);
    const l = a < s ? a + i : a, c = !!t10._fullLoop && s === 0 && a === i - 1;
    return Fd(t10, lv(r, s, l, c), r, e);
  }
  function Fd(t10, e, r, n) {
    return !n || !n.setContext || !r ? e : uv(t10, e, r, n);
  }
  function uv(t10, e, r, n) {
    const i = t10._chart.getContext(), o = jd(t10.options), { _datasetIndex: s, options: { spanGaps: a } } = t10, l = r.length, c = [];
    let u = o, f = e[0].start, d = f;
    function h(g, p, y, b) {
      const x = a ? -1 : 1;
      if (g !== p) {
        for (g += l; r[g % l].skip; )
          g -= x;
        for (; r[p % l].skip; )
          p += x;
        g % l !== p % l && (c.push({
          start: g % l,
          end: p % l,
          loop: y,
          style: b
        }), u = b, f = p % l);
      }
    }
    for (const g of e) {
      f = a ? f : g.start;
      let p = r[f % l], y;
      for (d = f + 1; d <= g.end; d++) {
        const b = r[d % l];
        y = jd(n.setContext(vn(i, {
          type: "segment",
          p0: p,
          p1: b,
          p0DataIndex: (d - 1) % l,
          p1DataIndex: d % l,
          datasetIndex: s
        }))), fv(y, u) && h(f, d - 1, g.loop, u), p = b, u = y;
      }
      f < d - 1 && h(f, d - 1, g.loop, u);
    }
    return c;
  }
  function jd(t10) {
    return {
      backgroundColor: t10.backgroundColor,
      borderCapStyle: t10.borderCapStyle,
      borderDash: t10.borderDash,
      borderDashOffset: t10.borderDashOffset,
      borderJoinStyle: t10.borderJoinStyle,
      borderWidth: t10.borderWidth,
      borderColor: t10.borderColor
    };
  }
  function fv(t10, e) {
    if (!e)
      return false;
    const r = [], n = function(i, o) {
      return zu(o) ? (r.includes(o) || r.push(o), r.indexOf(o)) : o;
    };
    return JSON.stringify(t10, n) !== JSON.stringify(e, n);
  }
  /*!
   * Chart.js v4.4.0
   * https://www.chartjs.org
   * (c) 2023 Chart.js Contributors
   * Released under the MIT License
   */
  class dv {
    constructor() {
      this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
    }
    _notify(e, r, n, i) {
      const o = r.listeners[i], s = r.duration;
      o.forEach((a) => a({
        chart: e,
        initial: r.initial,
        numSteps: s,
        currentStep: Math.min(n - r.start, s)
      }));
    }
    _refresh() {
      this._request || (this._running = true, this._request = b1.call(window, () => {
        this._update(), this._request = null, this._running && this._refresh();
      }));
    }
    _update(e = Date.now()) {
      let r = 0;
      this._charts.forEach((n, i) => {
        if (!n.running || !n.items.length)
          return;
        const o = n.items;
        let s = o.length - 1, a = false, l;
        for (; s >= 0; --s)
          l = o[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(e), a = true) : (o[s] = o[o.length - 1], o.pop());
        a && (i.draw(), this._notify(i, n, e, "progress")), o.length || (n.running = false, this._notify(i, n, e, "complete"), n.initial = false), r += o.length;
      }), this._lastDate = e, r === 0 && (this._running = false);
    }
    _getAnims(e) {
      const r = this._charts;
      let n = r.get(e);
      return n || (n = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      }, r.set(e, n)), n;
    }
    listen(e, r, n) {
      this._getAnims(e).listeners[r].push(n);
    }
    add(e, r) {
      !r || !r.length || this._getAnims(e).items.push(...r);
    }
    has(e) {
      return this._getAnims(e).items.length > 0;
    }
    start(e) {
      const r = this._charts.get(e);
      r && (r.running = true, r.start = Date.now(), r.duration = r.items.reduce((n, i) => Math.max(n, i._duration), 0), this._refresh());
    }
    running(e) {
      if (!this._running)
        return false;
      const r = this._charts.get(e);
      return !(!r || !r.running || !r.items.length);
    }
    stop(e) {
      const r = this._charts.get(e);
      if (!r || !r.items.length)
        return;
      const n = r.items;
      let i = n.length - 1;
      for (; i >= 0; --i)
        n[i].cancel();
      r.items = [], this._notify(e, r, Date.now(), "complete");
    }
    remove(e) {
      return this._charts.delete(e);
    }
  }
  var Dr = /* @__PURE__ */ new dv();
  const Wd = "transparent", hv = {
    boolean(t10, e, r) {
      return r > 0.5 ? e : t10;
    },
    color(t10, e, r) {
      const n = Id(t10 || Wd), i = n.valid && Id(e || Wd);
      return i && i.valid ? i.mix(n, r).hexString() : e;
    },
    number(t10, e, r) {
      return t10 + (e - t10) * r;
    }
  };
  class pv {
    constructor(e, r, n, i) {
      const o = r[n];
      i = oo([
        e.to,
        i,
        o,
        e.from
      ]);
      const s = oo([
        e.from,
        o,
        i
      ]);
      this._active = true, this._fn = e.fn || hv[e.type || typeof s], this._easing = bo[e.easing] || bo.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = r, this._prop = n, this._from = s, this._to = i, this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(e, r, n) {
      if (this._active) {
        this._notify(false);
        const i = this._target[this._prop], o = n - this._start, s = this._duration - o;
        this._start = n, this._duration = Math.floor(Math.max(s, e.duration)), this._total += o, this._loop = !!e.loop, this._to = oo([
          e.to,
          r,
          i,
          e.from
        ]), this._from = oo([
          e.from,
          i,
          r
        ]);
      }
    }
    cancel() {
      this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
    }
    tick(e) {
      const r = e - this._start, n = this._duration, i = this._prop, o = this._from, s = this._loop, a = this._to;
      let l;
      if (this._active = o !== a && (s || r < n), !this._active) {
        this._target[i] = a, this._notify(true);
        return;
      }
      if (r < 0) {
        this._target[i] = o;
        return;
      }
      l = r / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(o, a, l);
    }
    wait() {
      const e = this._promises || (this._promises = []);
      return new Promise((r, n) => {
        e.push({
          res: r,
          rej: n
        });
      });
    }
    _notify(e) {
      const r = e ? "res" : "rej", n = this._promises || [];
      for (let i = 0; i < n.length; i++)
        n[i][r]();
    }
  }
  class B1 {
    constructor(e, r) {
      this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(r);
    }
    configure(e) {
      if (!Le(e))
        return;
      const r = Object.keys(gt.animation), n = this._properties;
      Object.getOwnPropertyNames(e).forEach((i) => {
        const o = e[i];
        if (!Le(o))
          return;
        const s = {};
        for (const a of r)
          s[a] = o[a];
        (it(o.properties) && o.properties || [
          i
        ]).forEach((a) => {
          (a === i || !n.has(a)) && n.set(a, s);
        });
      });
    }
    _animateOptions(e, r) {
      const n = r.options, i = mv(e, n);
      if (!i)
        return [];
      const o = this._createAnimations(i, n);
      return n.$shared && gv(e.options.$animations, n).then(() => {
        e.options = n;
      }, () => {
      }), o;
    }
    _createAnimations(e, r) {
      const n = this._properties, i = [], o = e.$animations || (e.$animations = {}), s = Object.keys(r), a = Date.now();
      let l;
      for (l = s.length - 1; l >= 0; --l) {
        const c = s[l];
        if (c.charAt(0) === "$")
          continue;
        if (c === "options") {
          i.push(...this._animateOptions(e, r));
          continue;
        }
        const u = r[c];
        let f = o[c];
        const d = n.get(c);
        if (f)
          if (d && f.active()) {
            f.update(d, u, a);
            continue;
          } else
            f.cancel();
        if (!d || !d.duration) {
          e[c] = u;
          continue;
        }
        o[c] = f = new pv(d, e, c, u), i.push(f);
      }
      return i;
    }
    update(e, r) {
      if (this._properties.size === 0) {
        Object.assign(e, r);
        return;
      }
      const n = this._createAnimations(e, r);
      if (n.length)
        return Dr.add(this._chart, n), true;
    }
  }
  function gv(t10, e) {
    const r = [], n = Object.keys(e);
    for (let i = 0; i < n.length; i++) {
      const o = t10[n[i]];
      o && o.active() && r.push(o.wait());
    }
    return Promise.all(r);
  }
  function mv(t10, e) {
    if (!e)
      return;
    let r = t10.options;
    if (!r) {
      t10.options = e;
      return;
    }
    return r.$shared && (t10.options = r = Object.assign({}, r, {
      $shared: false,
      $animations: {}
    })), r;
  }
  function Ud(t10, e) {
    const r = t10 && t10.options || {}, n = r.reverse, i = r.min === void 0 ? e : 0, o = r.max === void 0 ? e : 0;
    return {
      start: n ? o : i,
      end: n ? i : o
    };
  }
  function yv(t10, e, r) {
    if (r === false)
      return false;
    const n = Ud(t10, r), i = Ud(e, r);
    return {
      top: i.end,
      right: n.end,
      bottom: i.start,
      left: n.start
    };
  }
  function bv(t10) {
    let e, r, n, i;
    return Le(t10) ? (e = t10.top, r = t10.right, n = t10.bottom, i = t10.left) : e = r = n = i = t10, {
      top: e,
      right: r,
      bottom: n,
      left: i,
      disabled: t10 === false
    };
  }
  function F1(t10, e) {
    const r = [], n = t10._getSortedDatasetMetas(e);
    let i, o;
    for (i = 0, o = n.length; i < o; ++i)
      r.push(n[i].index);
    return r;
  }
  function zd(t10, e, r, n = {}) {
    const i = t10.keys, o = n.mode === "single";
    let s, a, l, c;
    if (e !== null) {
      for (s = 0, a = i.length; s < a; ++s) {
        if (l = +i[s], l === r) {
          if (n.all)
            continue;
          break;
        }
        c = t10.values[l], pt(c) && (o || e === 0 || Cr(e) === Cr(c)) && (e += c);
      }
      return e;
    }
  }
  function vv(t10) {
    const e = Object.keys(t10), r = new Array(e.length);
    let n, i, o;
    for (n = 0, i = e.length; n < i; ++n)
      o = e[n], r[n] = {
        x: o,
        y: t10[o]
      };
    return r;
  }
  function Vd(t10, e) {
    const r = t10 && t10.options.stacked;
    return r || r === void 0 && e.stack !== void 0;
  }
  function Av(t10, e, r) {
    return `${t10.id}.${e.id}.${r.stack || r.type}`;
  }
  function wv(t10) {
    const { min: e, max: r, minDefined: n, maxDefined: i } = t10.getUserBounds();
    return {
      min: n ? e : Number.NEGATIVE_INFINITY,
      max: i ? r : Number.POSITIVE_INFINITY
    };
  }
  function xv(t10, e, r) {
    const n = t10[e] || (t10[e] = {});
    return n[r] || (n[r] = {});
  }
  function qd(t10, e, r, n) {
    for (const i of e.getMatchingVisibleMetas(n).reverse()) {
      const o = t10[i.index];
      if (r && o > 0 || !r && o < 0)
        return i.index;
    }
    return null;
  }
  function Hd(t10, e) {
    const { chart: r, _cachedMeta: n } = t10, i = r._stacks || (r._stacks = {}), { iScale: o, vScale: s, index: a } = n, l = o.axis, c = s.axis, u = Av(o, s, n), f = e.length;
    let d;
    for (let h = 0; h < f; ++h) {
      const g = e[h], { [l]: p, [c]: y } = g, b = g._stacks || (g._stacks = {});
      d = b[c] = xv(i, u, p), d[a] = y, d._top = qd(d, s, true, n.type), d._bottom = qd(d, s, false, n.type);
      const x = d._visualValues || (d._visualValues = {});
      x[a] = y;
    }
  }
  function Yl(t10, e) {
    const r = t10.scales;
    return Object.keys(r).filter((n) => r[n].axis === e).shift();
  }
  function _v(t10, e) {
    return vn(t10, {
      active: false,
      dataset: void 0,
      datasetIndex: e,
      index: e,
      mode: "default",
      type: "dataset"
    });
  }
  function Sv(t10, e, r) {
    return vn(t10, {
      active: false,
      dataIndex: e,
      parsed: void 0,
      raw: void 0,
      element: r,
      index: e,
      mode: "default",
      type: "data"
    });
  }
  function Hi(t10, e) {
    const r = t10.controller.index, n = t10.vScale && t10.vScale.axis;
    if (n) {
      e = e || t10._parsed;
      for (const i of e) {
        const o = i._stacks;
        if (!o || o[n] === void 0 || o[n][r] === void 0)
          return;
        delete o[n][r], o[n]._visualValues !== void 0 && o[n]._visualValues[r] !== void 0 && delete o[n]._visualValues[r];
      }
    }
  }
  const Kl = (t10) => t10 === "reset" || t10 === "none", Yd = (t10, e) => e ? t10 : Object.assign({}, t10), Ev = (t10, e, r) => t10 && !e.hidden && e._stacked && {
    keys: F1(r, true),
    values: null
  };
  class mr {
    constructor(e, r) {
      this.chart = e, this._ctx = e.ctx, this.index = r, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
    }
    initialize() {
      const e = this._cachedMeta;
      this.configure(), this.linkScales(), e._stacked = Vd(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
    updateIndex(e) {
      this.index !== e && Hi(this._cachedMeta), this.index = e;
    }
    linkScales() {
      const e = this.chart, r = this._cachedMeta, n = this.getDataset(), i = (f, d, h, g) => f === "x" ? d : f === "r" ? g : h, o = r.xAxisID = Oe(n.xAxisID, Yl(e, "x")), s = r.yAxisID = Oe(n.yAxisID, Yl(e, "y")), a = r.rAxisID = Oe(n.rAxisID, Yl(e, "r")), l = r.indexAxis, c = r.iAxisID = i(l, o, s, a), u = r.vAxisID = i(l, s, o, a);
      r.xScale = this.getScaleForId(o), r.yScale = this.getScaleForId(s), r.rScale = this.getScaleForId(a), r.iScale = this.getScaleForId(c), r.vScale = this.getScaleForId(u);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(e) {
      return this.chart.scales[e];
    }
    _getOtherScale(e) {
      const r = this._cachedMeta;
      return e === r.iScale ? r.vScale : r.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const e = this._cachedMeta;
      this._data && Cd(this._data, this), e._stacked && Hi(e);
    }
    _dataCheck() {
      const e = this.getDataset(), r = e.data || (e.data = []), n = this._data;
      if (Le(r))
        this._data = vv(r);
      else if (n !== r) {
        if (n) {
          Cd(n, this);
          const i = this._cachedMeta;
          Hi(i), i._parsed = [];
        }
        r && Object.isExtensible(r) && u2(r, this), this._syncList = [], this._data = r;
      }
    }
    addElements() {
      const e = this._cachedMeta;
      this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
    }
    buildOrUpdateElements(e) {
      const r = this._cachedMeta, n = this.getDataset();
      let i = false;
      this._dataCheck();
      const o = r._stacked;
      r._stacked = Vd(r.vScale, r), r.stack !== n.stack && (i = true, Hi(r), r.stack = n.stack), this._resyncElements(e), (i || o !== r._stacked) && Hd(this, r._parsed);
    }
    configure() {
      const e = this.chart.config, r = e.datasetScopeKeys(this._type), n = e.getOptionScopes(this.getDataset(), r, true);
      this.options = e.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
    }
    parse(e, r) {
      const { _cachedMeta: n, _data: i } = this, { iScale: o, _stacked: s } = n, a = o.axis;
      let l = e === 0 && r === i.length ? true : n._sorted, c = e > 0 && n._parsed[e - 1], u, f, d;
      if (this._parsing === false)
        n._parsed = i, n._sorted = true, d = i;
      else {
        it(i[e]) ? d = this.parseArrayData(n, i, e, r) : Le(i[e]) ? d = this.parseObjectData(n, i, e, r) : d = this.parsePrimitiveData(n, i, e, r);
        const h = () => f[a] === null || c && f[a] < c[a];
        for (u = 0; u < r; ++u)
          n._parsed[u + e] = f = d[u], l && (h() && (l = false), c = f);
        n._sorted = l;
      }
      s && Hd(this, d);
    }
    parsePrimitiveData(e, r, n, i) {
      const { iScale: o, vScale: s } = e, a = o.axis, l = s.axis, c = o.getLabels(), u = o === s, f = new Array(i);
      let d, h, g;
      for (d = 0, h = i; d < h; ++d)
        g = d + n, f[d] = {
          [a]: u || o.parse(c[g], g),
          [l]: s.parse(r[g], g)
        };
      return f;
    }
    parseArrayData(e, r, n, i) {
      const { xScale: o, yScale: s } = e, a = new Array(i);
      let l, c, u, f;
      for (l = 0, c = i; l < c; ++l)
        u = l + n, f = r[u], a[l] = {
          x: o.parse(f[0], u),
          y: s.parse(f[1], u)
        };
      return a;
    }
    parseObjectData(e, r, n, i) {
      const { xScale: o, yScale: s } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i);
      let u, f, d, h;
      for (u = 0, f = i; u < f; ++u)
        d = u + n, h = r[d], c[u] = {
          x: o.parse(pn(h, a), d),
          y: s.parse(pn(h, l), d)
        };
      return c;
    }
    getParsed(e) {
      return this._cachedMeta._parsed[e];
    }
    getDataElement(e) {
      return this._cachedMeta.data[e];
    }
    applyStack(e, r, n) {
      const i = this.chart, o = this._cachedMeta, s = r[e.axis], a = {
        keys: F1(i, true),
        values: r._stacks[e.axis]._visualValues
      };
      return zd(a, s, o.index, {
        mode: n
      });
    }
    updateRangeFromParsed(e, r, n, i) {
      const o = n[r.axis];
      let s = o === null ? NaN : o;
      const a = i && n._stacks[r.axis];
      i && a && (i.values = a, s = zd(i, o, this._cachedMeta.index)), e.min = Math.min(e.min, s), e.max = Math.max(e.max, s);
    }
    getMinMax(e, r) {
      const n = this._cachedMeta, i = n._parsed, o = n._sorted && e === n.iScale, s = i.length, a = this._getOtherScale(e), l = Ev(r, n, this.chart), c = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      }, { min: u, max: f } = wv(a);
      let d, h;
      function g() {
        h = i[d];
        const p = h[a.axis];
        return !pt(h[e.axis]) || u > p || f < p;
      }
      for (d = 0; d < s && !(!g() && (this.updateRangeFromParsed(c, e, h, l), o)); ++d)
        ;
      if (o) {
        for (d = s - 1; d >= 0; --d)
          if (!g()) {
            this.updateRangeFromParsed(c, e, h, l);
            break;
          }
      }
      return c;
    }
    getAllParsedValues(e) {
      const r = this._cachedMeta._parsed, n = [];
      let i, o, s;
      for (i = 0, o = r.length; i < o; ++i)
        s = r[i][e.axis], pt(s) && n.push(s);
      return n;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = r.iScale, i = r.vScale, o = this.getParsed(e);
      return {
        label: n ? "" + n.getLabelForValue(o[n.axis]) : "",
        value: i ? "" + i.getLabelForValue(o[i.axis]) : ""
      };
    }
    _update(e) {
      const r = this._cachedMeta;
      this.update(e || "default"), r._clip = bv(Oe(this.options.clip, yv(r.xScale, r.yScale, this.getMaxOverflow())));
    }
    update(e) {
    }
    draw() {
      const e = this._ctx, r = this.chart, n = this._cachedMeta, i = n.data || [], o = r.chartArea, s = [], a = this._drawStart || 0, l = this._drawCount || i.length - a, c = this.options.drawActiveElementsOnTop;
      let u;
      for (n.dataset && n.dataset.draw(e, o, a, l), u = a; u < a + l; ++u) {
        const f = i[u];
        f.hidden || (f.active && c ? s.push(f) : f.draw(e, o));
      }
      for (u = 0; u < s.length; ++u)
        s[u].draw(e, o);
    }
    getStyle(e, r) {
      const n = r ? "active" : "default";
      return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(e || 0, n);
    }
    getContext(e, r, n) {
      const i = this.getDataset();
      let o;
      if (e >= 0 && e < this._cachedMeta.data.length) {
        const s = this._cachedMeta.data[e];
        o = s.$context || (s.$context = Sv(this.getContext(), e, s)), o.parsed = this.getParsed(e), o.raw = i.data[e], o.index = o.dataIndex = e;
      } else
        o = this.$context || (this.$context = _v(this.chart.getContext(), this.index)), o.dataset = i, o.index = o.datasetIndex = this.index;
      return o.active = !!r, o.mode = n, o;
    }
    resolveDatasetElementOptions(e) {
      return this._resolveElementOptions(this.datasetElementType.id, e);
    }
    resolveDataElementOptions(e, r) {
      return this._resolveElementOptions(this.dataElementType.id, r, e);
    }
    _resolveElementOptions(e, r = "default", n) {
      const i = r === "active", o = this._cachedDataOpts, s = e + "-" + r, a = o[s], l = this.enableOptionSharing && Io(n);
      if (a)
        return Yd(a, l);
      const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), f = i ? [
        `${e}Hover`,
        "hover",
        e,
        ""
      ] : [
        e,
        ""
      ], d = c.getOptionScopes(this.getDataset(), u), h = Object.keys(gt.elements[e]), g = () => this.getContext(n, i, r), p = c.resolveNamedOptions(d, h, g, f);
      return p.$shared && (p.$shared = l, o[s] = Object.freeze(Yd(p, l))), p;
    }
    _resolveAnimations(e, r, n) {
      const i = this.chart, o = this._cachedDataOpts, s = `animation-${r}`, a = o[s];
      if (a)
        return a;
      let l;
      if (i.options.animation !== false) {
        const u = this.chart.config, f = u.datasetAnimationScopeKeys(this._type, r), d = u.getOptionScopes(this.getDataset(), f);
        l = u.createResolver(d, this.getContext(e, n, r));
      }
      const c = new B1(i, l && l.animations);
      return l && l._cacheable && (o[s] = Object.freeze(c)), c;
    }
    getSharedOptions(e) {
      if (e.$shared)
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
    }
    includeOptions(e, r) {
      return !r || Kl(e) || this.chart._animationsDisabled;
    }
    _getSharedOptions(e, r) {
      const n = this.resolveDataElementOptions(e, r), i = this._sharedOptions, o = this.getSharedOptions(n), s = this.includeOptions(r, o) || o !== i;
      return this.updateSharedOptions(o, r, n), {
        sharedOptions: o,
        includeOptions: s
      };
    }
    updateElement(e, r, n, i) {
      Kl(i) ? Object.assign(e, n) : this._resolveAnimations(r, i).update(e, n);
    }
    updateSharedOptions(e, r, n) {
      e && !Kl(r) && this._resolveAnimations(void 0, r).update(e, n);
    }
    _setStyle(e, r, n, i) {
      e.active = i;
      const o = this.getStyle(r, i);
      this._resolveAnimations(r, n, i).update(e, {
        options: !i && this.getSharedOptions(o) || o
      });
    }
    removeHoverStyle(e, r, n) {
      this._setStyle(e, n, "active", false);
    }
    setHoverStyle(e, r, n) {
      this._setStyle(e, n, "active", true);
    }
    _removeDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", false);
    }
    _setDatasetHoverStyle() {
      const e = this._cachedMeta.dataset;
      e && this._setStyle(e, void 0, "active", true);
    }
    _resyncElements(e) {
      const r = this._data, n = this._cachedMeta.data;
      for (const [a, l, c] of this._syncList)
        this[a](l, c);
      this._syncList = [];
      const i = n.length, o = r.length, s = Math.min(o, i);
      s && this.parse(0, s), o > i ? this._insertElements(i, o - i, e) : o < i && this._removeElements(o, i - o);
    }
    _insertElements(e, r, n = true) {
      const i = this._cachedMeta, o = i.data, s = e + r;
      let a;
      const l = (c) => {
        for (c.length += r, a = c.length - 1; a >= s; a--)
          c[a] = c[a - r];
      };
      for (l(o), a = e; a < s; ++a)
        o[a] = new this.dataElementType();
      this._parsing && l(i._parsed), this.parse(e, r), n && this.updateElements(o, e, r, "reset");
    }
    updateElements(e, r, n, i) {
    }
    _removeElements(e, r) {
      const n = this._cachedMeta;
      if (this._parsing) {
        const i = n._parsed.splice(e, r);
        n._stacked && Hi(n, i);
      }
      n.data.splice(e, r);
    }
    _sync(e) {
      if (this._parsing)
        this._syncList.push(e);
      else {
        const [r, n, i] = e;
        this[r](n, i);
      }
      this.chart._dataChanges.push([
        this.index,
        ...e
      ]);
    }
    _onDataPush() {
      const e = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - e,
        e
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(e, r) {
      r && this._sync([
        "_removeElements",
        e,
        r
      ]);
      const n = arguments.length - 2;
      n && this._sync([
        "_insertElements",
        e,
        n
      ]);
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  }
  ye(mr, "defaults", {}), ye(mr, "datasetElementType", null), ye(mr, "dataElementType", null);
  function kv(t10, e) {
    if (!t10._cache.$bar) {
      const r = t10.getMatchingVisibleMetas(e);
      let n = [];
      for (let i = 0, o = r.length; i < o; i++)
        n = n.concat(r[i].controller.getAllParsedValues(t10));
      t10._cache.$bar = y1(n.sort((i, o) => i - o));
    }
    return t10._cache.$bar;
  }
  function Cv(t10) {
    const e = t10.iScale, r = kv(e, t10.type);
    let n = e._length, i, o, s, a;
    const l = () => {
      s === 32767 || s === -32768 || (Io(a) && (n = Math.min(n, Math.abs(s - a) || n)), a = s);
    };
    for (i = 0, o = r.length; i < o; ++i)
      s = e.getPixelForValue(r[i]), l();
    for (a = void 0, i = 0, o = e.ticks.length; i < o; ++i)
      s = e.getPixelForTick(i), l();
    return n;
  }
  function Tv(t10, e, r, n) {
    const i = r.barThickness;
    let o, s;
    return We(i) ? (o = e.min * r.categoryPercentage, s = r.barPercentage) : (o = i * n, s = 1), {
      chunk: o / n,
      ratio: s,
      start: e.pixels[t10] - o / 2
    };
  }
  function Ov(t10, e, r, n) {
    const i = e.pixels, o = i[t10];
    let s = t10 > 0 ? i[t10 - 1] : null, a = t10 < i.length - 1 ? i[t10 + 1] : null;
    const l = r.categoryPercentage;
    s === null && (s = o - (a === null ? e.end - e.start : a - o)), a === null && (a = o + o - s);
    const c = o - (o - Math.min(s, a)) / 2 * l;
    return {
      chunk: Math.abs(a - s) / 2 * l / n,
      ratio: r.barPercentage,
      start: c
    };
  }
  function Iv(t10, e, r, n) {
    const i = r.parse(t10[0], n), o = r.parse(t10[1], n), s = Math.min(i, o), a = Math.max(i, o);
    let l = s, c = a;
    Math.abs(s) > Math.abs(a) && (l = a, c = s), e[r.axis] = c, e._custom = {
      barStart: l,
      barEnd: c,
      start: i,
      end: o,
      min: s,
      max: a
    };
  }
  function j1(t10, e, r, n) {
    return it(t10) ? Iv(t10, e, r, n) : e[r.axis] = r.parse(t10, n), e;
  }
  function Kd(t10, e, r, n) {
    const i = t10.iScale, o = t10.vScale, s = i.getLabels(), a = i === o, l = [];
    let c, u, f, d;
    for (c = r, u = r + n; c < u; ++c)
      d = e[c], f = {}, f[i.axis] = a || i.parse(s[c], c), l.push(j1(d, f, o, c));
    return l;
  }
  function Xl(t10) {
    return t10 && t10.barStart !== void 0 && t10.barEnd !== void 0;
  }
  function Pv(t10, e, r) {
    return t10 !== 0 ? Cr(t10) : (e.isHorizontal() ? 1 : -1) * (e.min >= r ? 1 : -1);
  }
  function Rv(t10) {
    let e, r, n, i, o;
    return t10.horizontal ? (e = t10.base > t10.x, r = "left", n = "right") : (e = t10.base < t10.y, r = "bottom", n = "top"), e ? (i = "end", o = "start") : (i = "start", o = "end"), {
      start: r,
      end: n,
      reverse: e,
      top: i,
      bottom: o
    };
  }
  function Dv(t10, e, r, n) {
    let i = e.borderSkipped;
    const o = {};
    if (!i) {
      t10.borderSkipped = o;
      return;
    }
    if (i === true) {
      t10.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start: s, end: a, reverse: l, top: c, bottom: u } = Rv(t10);
    i === "middle" && r && (t10.enableBorderRadius = true, (r._top || 0) === n ? i = c : (r._bottom || 0) === n ? i = u : (o[Xd(u, s, a, l)] = true, i = c)), o[Xd(i, s, a, l)] = true, t10.borderSkipped = o;
  }
  function Xd(t10, e, r, n) {
    return n ? (t10 = Mv(t10, e, r), t10 = Jd(t10, r, e)) : t10 = Jd(t10, e, r), t10;
  }
  function Mv(t10, e, r) {
    return t10 === e ? r : t10 === r ? e : t10;
  }
  function Jd(t10, e, r) {
    return t10 === "start" ? e : t10 === "end" ? r : t10;
  }
  function Nv(t10, { inflateAmount: e }, r) {
    t10.inflateAmount = e === "auto" ? r === 1 ? 0.33 : 0 : e;
  }
  class zs extends mr {
    parsePrimitiveData(e, r, n, i) {
      return Kd(e, r, n, i);
    }
    parseArrayData(e, r, n, i) {
      return Kd(e, r, n, i);
    }
    parseObjectData(e, r, n, i) {
      const { iScale: o, vScale: s } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? a : l, u = s.axis === "x" ? a : l, f = [];
      let d, h, g, p;
      for (d = n, h = n + i; d < h; ++d)
        p = r[d], g = {}, g[o.axis] = o.parse(pn(p, c), d), f.push(j1(pn(p, u), g, s, d));
      return f;
    }
    updateRangeFromParsed(e, r, n, i) {
      super.updateRangeFromParsed(e, r, n, i);
      const o = n._custom;
      o && r === this._cachedMeta.vScale && (e.min = Math.min(e.min, o.min), e.max = Math.max(e.max, o.max));
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, { iScale: n, vScale: i } = r, o = this.getParsed(e), s = o._custom, a = Xl(s) ? "[" + s.start + ", " + s.end + "]" : "" + i.getLabelForValue(o[i.axis]);
      return {
        label: "" + n.getLabelForValue(o[n.axis]),
        value: a
      };
    }
    initialize() {
      this.enableOptionSharing = true, super.initialize();
      const e = this._cachedMeta;
      e.stack = this.getDataset().stack;
    }
    update(e) {
      const r = this._cachedMeta;
      this.updateElements(r.data, 0, r.data.length, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { index: s, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: f, includeOptions: d } = this._getSharedOptions(r, i);
      for (let h = r; h < r + n; h++) {
        const g = this.getParsed(h), p = o || We(g[a.axis]) ? {
          base: l,
          head: l
        } : this._calculateBarValuePixels(h), y = this._calculateBarIndexPixels(h, u), b = (g._stacks || {})[a.axis], x = {
          horizontal: c,
          base: p.base,
          enableBorderRadius: !b || Xl(g._custom) || s === b._top || s === b._bottom,
          x: c ? p.head : y.center,
          y: c ? y.center : p.head,
          height: c ? y.size : Math.abs(p.size),
          width: c ? Math.abs(p.size) : y.size
        };
        d && (x.options = f || this.resolveDataElementOptions(h, e[h].active ? "active" : i));
        const S = x.options || e[h].options;
        Dv(x, S, b, s), Nv(x, S, u.ratio), this.updateElement(e[h], h, x, i);
      }
    }
    _getStacks(e, r) {
      const { iScale: n } = this._cachedMeta, i = n.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), o = n.options.stacked, s = [], a = (l) => {
        const c = l.controller.getParsed(r), u = c && c[l.vScale.axis];
        if (We(u) || isNaN(u))
          return true;
      };
      for (const l of i)
        if (!(r !== void 0 && a(l)) && ((o === false || s.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && s.push(l.stack), l.index === e))
          break;
      return s.length || s.push(void 0), s;
    }
    _getStackCount(e) {
      return this._getStacks(void 0, e).length;
    }
    _getStackIndex(e, r, n) {
      const i = this._getStacks(e, n), o = r !== void 0 ? i.indexOf(r) : -1;
      return o === -1 ? i.length - 1 : o;
    }
    _getRuler() {
      const e = this.options, r = this._cachedMeta, n = r.iScale, i = [];
      let o, s;
      for (o = 0, s = r.data.length; o < s; ++o)
        i.push(n.getPixelForValue(this.getParsed(o)[n.axis], o));
      const a = e.barThickness;
      return {
        min: a || Cv(r),
        pixels: i,
        start: n._startPixel,
        end: n._endPixel,
        stackCount: this._getStackCount(),
        scale: n,
        grouped: e.grouped,
        ratio: a ? 1 : e.categoryPercentage * e.barPercentage
      };
    }
    _calculateBarValuePixels(e) {
      const { _cachedMeta: { vScale: r, _stacked: n, index: i }, options: { base: o, minBarLength: s } } = this, a = o || 0, l = this.getParsed(e), c = l._custom, u = Xl(c);
      let f = l[r.axis], d = 0, h = n ? this.applyStack(r, l, n) : f, g, p;
      h !== f && (d = h - f, h = f), u && (f = c.barStart, h = c.barEnd - c.barStart, f !== 0 && Cr(f) !== Cr(c.barEnd) && (d = 0), d += f);
      const y = !We(o) && !u ? o : d;
      let b = r.getPixelForValue(y);
      if (this.chart.getDataVisibility(e) ? g = r.getPixelForValue(d + h) : g = b, p = g - b, Math.abs(p) < s) {
        p = Pv(p, r, a) * s, f === a && (b -= p / 2);
        const x = r.getPixelForDecimal(0), S = r.getPixelForDecimal(1), O = Math.min(x, S), _ = Math.max(x, S);
        b = Math.max(Math.min(b, _), O), g = b + p, n && !u && (l._stacks[r.axis]._visualValues[i] = r.getValueForPixel(g) - r.getValueForPixel(b));
      }
      if (b === r.getPixelForValue(a)) {
        const x = Cr(p) * r.getLineWidthForValue(a) / 2;
        b += x, p -= x;
      }
      return {
        size: p,
        base: b,
        head: g,
        center: g + p / 2
      };
    }
    _calculateBarIndexPixels(e, r) {
      const n = r.scale, i = this.options, o = i.skipNull, s = Oe(i.maxBarThickness, 1 / 0);
      let a, l;
      if (r.grouped) {
        const c = o ? this._getStackCount(e) : r.stackCount, u = i.barThickness === "flex" ? Ov(e, r, i, c) : Tv(e, r, i, c), f = this._getStackIndex(this.index, this._cachedMeta.stack, o ? e : void 0);
        a = u.start + u.chunk * f + u.chunk / 2, l = Math.min(s, u.chunk * u.ratio);
      } else
        a = n.getPixelForValue(this.getParsed(e)[n.axis], e), l = Math.min(s, r.min * r.ratio);
      return {
        base: a - l / 2,
        head: a + l / 2,
        center: a,
        size: l
      };
    }
    draw() {
      const e = this._cachedMeta, r = e.vScale, n = e.data, i = n.length;
      let o = 0;
      for (; o < i; ++o)
        this.getParsed(o)[r.axis] !== null && n[o].draw(this._ctx);
    }
  }
  ye(zs, "id", "bar"), ye(zs, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  }), ye(zs, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  class Vs extends mr {
    initialize() {
      this.enableOptionSharing = true, super.initialize();
    }
    parsePrimitiveData(e, r, n, i) {
      const o = super.parsePrimitiveData(e, r, n, i);
      for (let s = 0; s < o.length; s++)
        o[s]._custom = this.resolveDataElementOptions(s + n).radius;
      return o;
    }
    parseArrayData(e, r, n, i) {
      const o = super.parseArrayData(e, r, n, i);
      for (let s = 0; s < o.length; s++) {
        const a = r[n + s];
        o[s]._custom = Oe(a[2], this.resolveDataElementOptions(s + n).radius);
      }
      return o;
    }
    parseObjectData(e, r, n, i) {
      const o = super.parseObjectData(e, r, n, i);
      for (let s = 0; s < o.length; s++) {
        const a = r[n + s];
        o[s]._custom = Oe(a && a.r && +a.r, this.resolveDataElementOptions(s + n).radius);
      }
      return o;
    }
    getMaxOverflow() {
      const e = this._cachedMeta.data;
      let r = 0;
      for (let n = e.length - 1; n >= 0; --n)
        r = Math.max(r, e[n].size(this.resolveDataElementOptions(n)) / 2);
      return r > 0 && r;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart.data.labels || [], { xScale: i, yScale: o } = r, s = this.getParsed(e), a = i.getLabelForValue(s.x), l = o.getLabelForValue(s.y), c = s._custom;
      return {
        label: n[e] || "",
        value: "(" + a + ", " + l + (c ? ", " + c : "") + ")"
      };
    }
    update(e) {
      const r = this._cachedMeta.data;
      this.updateElements(r, 0, r.length, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(r, i), u = s.axis, f = a.axis;
      for (let d = r; d < r + n; d++) {
        const h = e[d], g = !o && this.getParsed(d), p = {}, y = p[u] = o ? s.getPixelForDecimal(0.5) : s.getPixelForValue(g[u]), b = p[f] = o ? a.getBasePixel() : a.getPixelForValue(g[f]);
        p.skip = isNaN(y) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(d, h.active ? "active" : i), o && (p.options.radius = 0)), this.updateElement(h, d, p, i);
      }
    }
    resolveDataElementOptions(e, r) {
      const n = this.getParsed(e);
      let i = super.resolveDataElementOptions(e, r);
      i.$shared && (i = Object.assign({}, i, {
        $shared: false
      }));
      const o = i.radius;
      return r !== "active" && (i.radius = 0), i.radius += Oe(n && n._custom, o), i;
    }
  }
  ye(Vs, "id", "bubble"), ye(Vs, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  }), ye(Vs, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function Lv(t10, e, r) {
    let n = 1, i = 1, o = 0, s = 0;
    if (e < ot) {
      const a = t10, l = a + e, c = Math.cos(a), u = Math.sin(a), f = Math.cos(l), d = Math.sin(l), h = (S, O, _) => Po(S, a, l, true) ? 1 : Math.max(O, O * r, _, _ * r), g = (S, O, _) => Po(S, a, l, true) ? -1 : Math.min(O, O * r, _, _ * r), p = h(0, c, f), y = h(mt, u, d), b = g(st, c, f), x = g(st + mt, u, d);
      n = (p - b) / 2, i = (y - x) / 2, o = -(p + b) / 2, s = -(y + x) / 2;
    }
    return {
      ratioX: n,
      ratioY: i,
      offsetX: o,
      offsetY: s
    };
  }
  class Bn extends mr {
    constructor(e, r) {
      super(e, r), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(e, r) {
      const n = this.getDataset().data, i = this._cachedMeta;
      if (this._parsing === false)
        i._parsed = n;
      else {
        let o = (l) => +n[l];
        if (Le(n[e])) {
          const { key: l = "value" } = this._parsing;
          o = (c) => +pn(n[c], l);
        }
        let s, a;
        for (s = e, a = e + r; s < a; ++s)
          i._parsed[s] = o(s);
      }
    }
    _getRotation() {
      return gr(this.options.rotation - 90);
    }
    _getCircumference() {
      return gr(this.options.circumference);
    }
    _getRotationExtents() {
      let e = ot, r = -ot;
      for (let n = 0; n < this.chart.data.datasets.length; ++n)
        if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
          const i = this.chart.getDatasetMeta(n).controller, o = i._getRotation(), s = i._getCircumference();
          e = Math.min(e, o), r = Math.max(r, o + s);
        }
      return {
        rotation: e,
        circumference: r - e
      };
    }
    update(e) {
      const r = this.chart, { chartArea: n } = r, i = this._cachedMeta, o = i.data, s = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(Q3(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: f } = this._getRotationExtents(), { ratioX: d, ratioY: h, offsetX: g, offsetY: p } = Lv(f, u, l), y = (n.width - s) / d, b = (n.height - s) / h, x = Math.max(Math.min(y, b) / 2, 0), S = d1(this.options.radius, x), O = Math.max(S * l, 0), _ = (S - O) / this._getVisibleDatasetWeightTotal();
      this.offsetX = g * S, this.offsetY = p * S, i.total = this.calculateTotal(), this.outerRadius = S - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, e);
    }
    _circumference(e, r) {
      const n = this.options, i = this._cachedMeta, o = this._getCircumference();
      return r && n.animation.animateRotate || !this.chart.getDataVisibility(e) || i._parsed[e] === null || i.data[e].hidden ? 0 : this.calculateCircumference(i._parsed[e] * o / ot);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", s = this.chart, a = s.chartArea, c = s.options.animation, u = (a.left + a.right) / 2, f = (a.top + a.bottom) / 2, d = o && c.animateScale, h = d ? 0 : this.innerRadius, g = d ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: y } = this._getSharedOptions(r, i);
      let b = this._getRotation(), x;
      for (x = 0; x < r; ++x)
        b += this._circumference(x, o);
      for (x = r; x < r + n; ++x) {
        const S = this._circumference(x, o), O = e[x], _ = {
          x: u + this.offsetX,
          y: f + this.offsetY,
          startAngle: b,
          endAngle: b + S,
          circumference: S,
          outerRadius: g,
          innerRadius: h
        };
        y && (_.options = p || this.resolveDataElementOptions(x, O.active ? "active" : i)), b += S, this.updateElement(O, x, _, i);
      }
    }
    calculateTotal() {
      const e = this._cachedMeta, r = e.data;
      let n = 0, i;
      for (i = 0; i < r.length; i++) {
        const o = e._parsed[i];
        o !== null && !isNaN(o) && this.chart.getDataVisibility(i) && !r[i].hidden && (n += Math.abs(o));
      }
      return n;
    }
    calculateCircumference(e) {
      const r = this._cachedMeta.total;
      return r > 0 && !isNaN(e) ? ot * (Math.abs(e) / r) : 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart, i = n.data.labels || [], o = Qo(r._parsed[e], n.options.locale);
      return {
        label: i[e] || "",
        value: o
      };
    }
    getMaxBorderWidth(e) {
      let r = 0;
      const n = this.chart;
      let i, o, s, a, l;
      if (!e) {
        for (i = 0, o = n.data.datasets.length; i < o; ++i)
          if (n.isDatasetVisible(i)) {
            s = n.getDatasetMeta(i), e = s.data, a = s.controller;
            break;
          }
      }
      if (!e)
        return 0;
      for (i = 0, o = e.length; i < o; ++i)
        l = a.resolveDataElementOptions(i), l.borderAlign !== "inner" && (r = Math.max(r, l.borderWidth || 0, l.hoverBorderWidth || 0));
      return r;
    }
    getMaxOffset(e) {
      let r = 0;
      for (let n = 0, i = e.length; n < i; ++n) {
        const o = this.resolveDataElementOptions(n);
        r = Math.max(r, o.offset || 0, o.hoverOffset || 0);
      }
      return r;
    }
    _getRingWeightOffset(e) {
      let r = 0;
      for (let n = 0; n < e; ++n)
        this.chart.isDatasetVisible(n) && (r += this._getRingWeight(n));
      return r;
    }
    _getRingWeight(e) {
      return Math.max(Oe(this.chart.data.datasets[e].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  }
  ye(Bn, "id", "doughnut"), ye(Bn, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  }), ye(Bn, "descriptors", {
    _scriptable: (e) => e !== "spacing",
    _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
  }), ye(Bn, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const r = e.data;
            if (r.labels.length && r.datasets.length) {
              const { labels: { pointStyle: n, color: i } } = e.legend.options;
              return r.labels.map((o, s) => {
                const l = e.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: n,
                  hidden: !e.getDataVisibility(s),
                  index: s
                };
              });
            }
            return [];
          }
        },
        onClick(e, r, n) {
          n.chart.toggleDataVisibility(r.index), n.chart.update();
        }
      }
    }
  });
  class qs extends mr {
    initialize() {
      this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
    }
    update(e) {
      const r = this._cachedMeta, { dataset: n, data: i = [], _dataset: o } = r, s = this.chart._animationsDisabled;
      let { start: a, count: l } = A1(r, i, s);
      this._drawStart = a, this._drawCount = l, w1(r) && (a = 0, l = i.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;
      const c = this.resolveDatasetElementOptions(e);
      this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(n, void 0, {
        animated: !s,
        options: c
      }, e), this.updateElements(i, a, l, e);
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: f } = this._getSharedOptions(r, i), d = s.axis, h = a.axis, { spanGaps: g, segment: p } = this.options, y = Ei(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || i === "none", x = r + n, S = e.length;
      let O = r > 0 && this.getParsed(r - 1);
      for (let _ = 0; _ < S; ++_) {
        const L = e[_], N = b ? L : {};
        if (_ < r || _ >= x) {
          N.skip = true;
          continue;
        }
        const j = this.getParsed(_), W = We(j[h]), G = N[d] = s.getPixelForValue(j[d], _), ee = N[h] = o || W ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, j, l) : j[h], _);
        N.skip = isNaN(G) || isNaN(ee) || W, N.stop = _ > 0 && Math.abs(j[d] - O[d]) > y, p && (N.parsed = j, N.raw = c.data[_]), f && (N.options = u || this.resolveDataElementOptions(_, L.active ? "active" : i)), b || this.updateElement(L, _, N, i), O = j;
      }
    }
    getMaxOverflow() {
      const e = this._cachedMeta, r = e.dataset, n = r.options && r.options.borderWidth || 0, i = e.data || [];
      if (!i.length)
        return n;
      const o = i[0].size(this.resolveDataElementOptions(0)), s = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1));
      return Math.max(n, o, s) / 2;
    }
    draw() {
      const e = this._cachedMeta;
      e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
    }
  }
  ye(qs, "id", "line"), ye(qs, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  }), ye(qs, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  class Ao extends mr {
    constructor(e, r) {
      super(e, r), this.innerRadius = void 0, this.outerRadius = void 0;
    }
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart, i = n.data.labels || [], o = Qo(r._parsed[e].r, n.options.locale);
      return {
        label: i[e] || "",
        value: o
      };
    }
    parseObjectData(e, r, n, i) {
      return O1.bind(this)(e, r, n, i);
    }
    update(e) {
      const r = this._cachedMeta.data;
      this._updateRadius(), this.updateElements(r, 0, r.length, e);
    }
    getMinMax() {
      const e = this._cachedMeta, r = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      return e.data.forEach((n, i) => {
        const o = this.getParsed(i).r;
        !isNaN(o) && this.chart.getDataVisibility(i) && (o < r.min && (r.min = o), o > r.max && (r.max = o));
      }), r;
    }
    _updateRadius() {
      const e = this.chart, r = e.chartArea, n = e.options, i = Math.min(r.right - r.left, r.bottom - r.top), o = Math.max(i / 2, 0), s = Math.max(n.cutoutPercentage ? o / 100 * n.cutoutPercentage : 1, 0), a = (o - s) / e.getVisibleDatasetCount();
      this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", s = this.chart, l = s.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, f = c.yCenter, d = c.getIndexAngle(0) - 0.5 * st;
      let h = d, g;
      const p = 360 / this.countVisibleElements();
      for (g = 0; g < r; ++g)
        h += this._computeAngle(g, i, p);
      for (g = r; g < r + n; g++) {
        const y = e[g];
        let b = h, x = h + this._computeAngle(g, i, p), S = s.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
        h = x, o && (l.animateScale && (S = 0), l.animateRotate && (b = x = d));
        const O = {
          x: u,
          y: f,
          innerRadius: 0,
          outerRadius: S,
          startAngle: b,
          endAngle: x,
          options: this.resolveDataElementOptions(g, y.active ? "active" : i)
        };
        this.updateElement(y, g, O, i);
      }
    }
    countVisibleElements() {
      const e = this._cachedMeta;
      let r = 0;
      return e.data.forEach((n, i) => {
        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && r++;
      }), r;
    }
    _computeAngle(e, r, n) {
      return this.chart.getDataVisibility(e) ? gr(this.resolveDataElementOptions(e, r).angle || n) : 0;
    }
  }
  ye(Ao, "id", "polarArea"), ye(Ao, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  }), ye(Ao, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(e) {
            const r = e.data;
            if (r.labels.length && r.datasets.length) {
              const { labels: { pointStyle: n, color: i } } = e.legend.options;
              return r.labels.map((o, s) => {
                const l = e.getDatasetMeta(0).controller.getStyle(s);
                return {
                  text: o,
                  fillStyle: l.backgroundColor,
                  strokeStyle: l.borderColor,
                  fontColor: i,
                  lineWidth: l.borderWidth,
                  pointStyle: n,
                  hidden: !e.getDataVisibility(s),
                  index: s
                };
              });
            }
            return [];
          }
        },
        onClick(e, r, n) {
          n.chart.toggleDataVisibility(r.index), n.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  class Lc extends Bn {
  }
  ye(Lc, "id", "pie"), ye(Lc, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  class Hs extends mr {
    getLabelAndValue(e) {
      const r = this._cachedMeta.vScale, n = this.getParsed(e);
      return {
        label: r.getLabels()[e],
        value: "" + r.getLabelForValue(n[r.axis])
      };
    }
    parseObjectData(e, r, n, i) {
      return O1.bind(this)(e, r, n, i);
    }
    update(e) {
      const r = this._cachedMeta, n = r.dataset, i = r.data || [], o = r.iScale.getLabels();
      if (n.points = i, e !== "resize") {
        const s = this.resolveDatasetElementOptions(e);
        this.options.showLine || (s.borderWidth = 0);
        const a = {
          _loop: true,
          _fullLoop: o.length === i.length,
          options: s
        };
        this.updateElement(n, void 0, a, e);
      }
      this.updateElements(i, 0, i.length, e);
    }
    updateElements(e, r, n, i) {
      const o = this._cachedMeta.rScale, s = i === "reset";
      for (let a = r; a < r + n; a++) {
        const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : i), u = o.getPointPositionForValue(a, this.getParsed(a).r), f = s ? o.xCenter : u.x, d = s ? o.yCenter : u.y, h = {
          x: f,
          y: d,
          angle: u.angle,
          skip: isNaN(f) || isNaN(d),
          options: c
        };
        this.updateElement(l, a, h, i);
      }
    }
  }
  ye(Hs, "id", "radar"), ye(Hs, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  }), ye(Hs, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  class Ys extends mr {
    getLabelAndValue(e) {
      const r = this._cachedMeta, n = this.chart.data.labels || [], { xScale: i, yScale: o } = r, s = this.getParsed(e), a = i.getLabelForValue(s.x), l = o.getLabelForValue(s.y);
      return {
        label: n[e] || "",
        value: "(" + a + ", " + l + ")"
      };
    }
    update(e) {
      const r = this._cachedMeta, { data: n = [] } = r, i = this.chart._animationsDisabled;
      let { start: o, count: s } = A1(r, n, i);
      if (this._drawStart = o, this._drawCount = s, w1(r) && (o = 0, s = n.length), this.options.showLine) {
        this.datasetElementType || this.addElements();
        const { dataset: a, _dataset: l } = r;
        a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = n;
        const c = this.resolveDatasetElementOptions(e);
        c.segment = this.options.segment, this.updateElement(a, void 0, {
          animated: !i,
          options: c
        }, e);
      } else
        this.datasetElementType && (delete r.dataset, this.datasetElementType = false);
      this.updateElements(n, o, s, e);
    }
    addElements() {
      const { showLine: e } = this.options;
      !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
    }
    updateElements(e, r, n, i) {
      const o = i === "reset", { iScale: s, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(r, i), f = this.getSharedOptions(u), d = this.includeOptions(i, f), h = s.axis, g = a.axis, { spanGaps: p, segment: y } = this.options, b = Ei(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || i === "none";
      let S = r > 0 && this.getParsed(r - 1);
      for (let O = r; O < r + n; ++O) {
        const _ = e[O], L = this.getParsed(O), N = x ? _ : {}, j = We(L[g]), W = N[h] = s.getPixelForValue(L[h], O), G = N[g] = o || j ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, L, l) : L[g], O);
        N.skip = isNaN(W) || isNaN(G) || j, N.stop = O > 0 && Math.abs(L[h] - S[h]) > b, y && (N.parsed = L, N.raw = c.data[O]), d && (N.options = f || this.resolveDataElementOptions(O, _.active ? "active" : i)), x || this.updateElement(_, O, N, i), S = L;
      }
      this.updateSharedOptions(f, i, u);
    }
    getMaxOverflow() {
      const e = this._cachedMeta, r = e.data || [];
      if (!this.options.showLine) {
        let a = 0;
        for (let l = r.length - 1; l >= 0; --l)
          a = Math.max(a, r[l].size(this.resolveDataElementOptions(l)) / 2);
        return a > 0 && a;
      }
      const n = e.dataset, i = n.options && n.options.borderWidth || 0;
      if (!r.length)
        return i;
      const o = r[0].size(this.resolveDataElementOptions(0)), s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
      return Math.max(i, o, s) / 2;
    }
  }
  ye(Ys, "id", "scatter"), ye(Ys, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  }), ye(Ys, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var Bv = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController: zs,
    BubbleController: Vs,
    DoughnutController: Bn,
    LineController: qs,
    PieController: Lc,
    PolarAreaController: Ao,
    RadarController: Hs,
    ScatterController: Ys
  });
  function Cn() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  class Xu {
    constructor(e) {
      ye(this, "options");
      this.options = e || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(e) {
      Object.assign(Xu.prototype, e);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return Cn();
    }
    parse() {
      return Cn();
    }
    format() {
      return Cn();
    }
    add() {
      return Cn();
    }
    diff() {
      return Cn();
    }
    startOf() {
      return Cn();
    }
    endOf() {
      return Cn();
    }
  }
  var Fv = {
    _date: Xu
  };
  function jv(t10, e, r, n) {
    const { controller: i, data: o, _sorted: s } = t10, a = i._cachedMeta.iScale;
    if (a && e === a.axis && e !== "r" && s && o.length) {
      const l = a._reversePixels ? l2 : Ur;
      if (n) {
        if (i._sharedOptions) {
          const c = o[0], u = typeof c.getRange == "function" && c.getRange(e);
          if (u) {
            const f = l(o, e, r - u), d = l(o, e, r + u);
            return {
              lo: f.lo,
              hi: d.hi
            };
          }
        }
      } else
        return l(o, e, r);
    }
    return {
      lo: 0,
      hi: o.length - 1
    };
  }
  function Go(t10, e, r, n, i) {
    const o = t10.getSortedVisibleDatasetMetas(), s = r[e];
    for (let a = 0, l = o.length; a < l; ++a) {
      const { index: c, data: u } = o[a], { lo: f, hi: d } = jv(o[a], e, s, i);
      for (let h = f; h <= d; ++h) {
        const g = u[h];
        g.skip || n(g, c, h);
      }
    }
  }
  function Wv(t10) {
    const e = t10.indexOf("x") !== -1, r = t10.indexOf("y") !== -1;
    return function(n, i) {
      const o = e ? Math.abs(n.x - i.x) : 0, s = r ? Math.abs(n.y - i.y) : 0;
      return Math.sqrt(Math.pow(o, 2) + Math.pow(s, 2));
    };
  }
  function Jl(t10, e, r, n, i) {
    const o = [];
    return !i && !t10.isPointInArea(e) || Go(t10, r, e, function(a, l, c) {
      !i && !zr(a, t10.chartArea, 0) || a.inRange(e.x, e.y, n) && o.push({
        element: a,
        datasetIndex: l,
        index: c
      });
    }, true), o;
  }
  function Uv(t10, e, r, n) {
    let i = [];
    function o(s, a, l) {
      const { startAngle: c, endAngle: u } = s.getProps([
        "startAngle",
        "endAngle"
      ], n), { angle: f } = g1(s, {
        x: e.x,
        y: e.y
      });
      Po(f, c, u) && i.push({
        element: s,
        datasetIndex: a,
        index: l
      });
    }
    return Go(t10, r, e, o), i;
  }
  function zv(t10, e, r, n, i, o) {
    let s = [];
    const a = Wv(r);
    let l = Number.POSITIVE_INFINITY;
    function c(u, f, d) {
      const h = u.inRange(e.x, e.y, i);
      if (n && !h)
        return;
      const g = u.getCenterPoint(i);
      if (!(!!o || t10.isPointInArea(g)) && !h)
        return;
      const y = a(e, g);
      y < l ? (s = [
        {
          element: u,
          datasetIndex: f,
          index: d
        }
      ], l = y) : y === l && s.push({
        element: u,
        datasetIndex: f,
        index: d
      });
    }
    return Go(t10, r, e, c), s;
  }
  function Ql(t10, e, r, n, i, o) {
    return !o && !t10.isPointInArea(e) ? [] : r === "r" && !n ? Uv(t10, e, r, i) : zv(t10, e, r, n, i, o);
  }
  function Qd(t10, e, r, n, i) {
    const o = [], s = r === "x" ? "inXRange" : "inYRange";
    let a = false;
    return Go(t10, r, e, (l, c, u) => {
      l[s](e[r], i) && (o.push({
        element: l,
        datasetIndex: c,
        index: u
      }), a = a || l.inRange(e.x, e.y, i));
    }), n && !a ? [] : o;
  }
  var Vv = {
    evaluateInteractionItems: Go,
    modes: {
      index(t10, e, r, n) {
        const i = Pn(e, t10), o = r.axis || "x", s = r.includeInvisible || false, a = r.intersect ? Jl(t10, i, o, n, s) : Ql(t10, i, o, false, n, s), l = [];
        return a.length ? (t10.getSortedVisibleDatasetMetas().forEach((c) => {
          const u = a[0].index, f = c.data[u];
          f && !f.skip && l.push({
            element: f,
            datasetIndex: c.index,
            index: u
          });
        }), l) : [];
      },
      dataset(t10, e, r, n) {
        const i = Pn(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        let a = r.intersect ? Jl(t10, i, o, n, s) : Ql(t10, i, o, false, n, s);
        if (a.length > 0) {
          const l = a[0].datasetIndex, c = t10.getDatasetMeta(l).data;
          a = [];
          for (let u = 0; u < c.length; ++u)
            a.push({
              element: c[u],
              datasetIndex: l,
              index: u
            });
        }
        return a;
      },
      point(t10, e, r, n) {
        const i = Pn(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        return Jl(t10, i, o, n, s);
      },
      nearest(t10, e, r, n) {
        const i = Pn(e, t10), o = r.axis || "xy", s = r.includeInvisible || false;
        return Ql(t10, i, o, r.intersect, n, s);
      },
      x(t10, e, r, n) {
        const i = Pn(e, t10);
        return Qd(t10, i, "x", r.intersect, n);
      },
      y(t10, e, r, n) {
        const i = Pn(e, t10);
        return Qd(t10, i, "y", r.intersect, n);
      }
    }
  };
  const W1 = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function Yi(t10, e) {
    return t10.filter((r) => r.pos === e);
  }
  function Gd(t10, e) {
    return t10.filter((r) => W1.indexOf(r.pos) === -1 && r.box.axis === e);
  }
  function Ki(t10, e) {
    return t10.sort((r, n) => {
      const i = e ? n : r, o = e ? r : n;
      return i.weight === o.weight ? i.index - o.index : i.weight - o.weight;
    });
  }
  function qv(t10) {
    const e = [];
    let r, n, i, o, s, a;
    for (r = 0, n = (t10 || []).length; r < n; ++r)
      i = t10[r], { position: o, options: { stack: s, stackWeight: a = 1 } } = i, e.push({
        index: r,
        box: i,
        pos: o,
        horizontal: i.isHorizontal(),
        weight: i.weight,
        stack: s && o + s,
        stackWeight: a
      });
    return e;
  }
  function Hv(t10) {
    const e = {};
    for (const r of t10) {
      const { stack: n, pos: i, stackWeight: o } = r;
      if (!n || !W1.includes(i))
        continue;
      const s = e[n] || (e[n] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      s.count++, s.weight += o;
    }
    return e;
  }
  function Yv(t10, e) {
    const r = Hv(t10), { vBoxMaxWidth: n, hBoxMaxHeight: i } = e;
    let o, s, a;
    for (o = 0, s = t10.length; o < s; ++o) {
      a = t10[o];
      const { fullSize: l } = a.box, c = r[a.stack], u = c && a.stackWeight / c.weight;
      a.horizontal ? (a.width = u ? u * n : l && e.availableWidth, a.height = i) : (a.width = n, a.height = u ? u * i : l && e.availableHeight);
    }
    return r;
  }
  function Kv(t10) {
    const e = qv(t10), r = Ki(e.filter((c) => c.box.fullSize), true), n = Ki(Yi(e, "left"), true), i = Ki(Yi(e, "right")), o = Ki(Yi(e, "top"), true), s = Ki(Yi(e, "bottom")), a = Gd(e, "x"), l = Gd(e, "y");
    return {
      fullSize: r,
      leftAndTop: n.concat(o),
      rightAndBottom: i.concat(l).concat(s).concat(a),
      chartArea: Yi(e, "chartArea"),
      vertical: n.concat(i).concat(l),
      horizontal: o.concat(s).concat(a)
    };
  }
  function Zd(t10, e, r, n) {
    return Math.max(t10[r], e[r]) + Math.max(t10[n], e[n]);
  }
  function U1(t10, e) {
    t10.top = Math.max(t10.top, e.top), t10.left = Math.max(t10.left, e.left), t10.bottom = Math.max(t10.bottom, e.bottom), t10.right = Math.max(t10.right, e.right);
  }
  function Xv(t10, e, r, n) {
    const { pos: i, box: o } = r, s = t10.maxPadding;
    if (!Le(i)) {
      r.size && (t10[i] -= r.size);
      const f = n[r.stack] || {
        size: 0,
        count: 1
      };
      f.size = Math.max(f.size, r.horizontal ? o.height : o.width), r.size = f.size / f.count, t10[i] += r.size;
    }
    o.getPadding && U1(s, o.getPadding());
    const a = Math.max(0, e.outerWidth - Zd(s, t10, "left", "right")), l = Math.max(0, e.outerHeight - Zd(s, t10, "top", "bottom")), c = a !== t10.w, u = l !== t10.h;
    return t10.w = a, t10.h = l, r.horizontal ? {
      same: c,
      other: u
    } : {
      same: u,
      other: c
    };
  }
  function Jv(t10) {
    const e = t10.maxPadding;
    function r(n) {
      const i = Math.max(e[n] - t10[n], 0);
      return t10[n] += i, i;
    }
    t10.y += r("top"), t10.x += r("left"), r("right"), r("bottom");
  }
  function Qv(t10, e) {
    const r = e.maxPadding;
    function n(i) {
      const o = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      return i.forEach((s) => {
        o[s] = Math.max(e[s], r[s]);
      }), o;
    }
    return n(t10 ? [
      "left",
      "right"
    ] : [
      "top",
      "bottom"
    ]);
  }
  function so(t10, e, r, n) {
    const i = [];
    let o, s, a, l, c, u;
    for (o = 0, s = t10.length, c = 0; o < s; ++o) {
      a = t10[o], l = a.box, l.update(a.width || e.w, a.height || e.h, Qv(a.horizontal, e));
      const { same: f, other: d } = Xv(e, r, a, n);
      c |= f && i.length, u = u || d, l.fullSize || i.push(a);
    }
    return c && so(i, e, r, n) || u;
  }
  function xs(t10, e, r, n, i) {
    t10.top = r, t10.left = e, t10.right = e + n, t10.bottom = r + i, t10.width = n, t10.height = i;
  }
  function $d(t10, e, r, n) {
    const i = r.padding;
    let { x: o, y: s } = e;
    for (const a of t10) {
      const l = a.box, c = n[a.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      }, u = a.stackWeight / c.weight || 1;
      if (a.horizontal) {
        const f = e.w * u, d = c.size || l.height;
        Io(c.start) && (s = c.start), l.fullSize ? xs(l, i.left, s, r.outerWidth - i.right - i.left, d) : xs(l, e.left + c.placed, s, f, d), c.start = s, c.placed += f, s = l.bottom;
      } else {
        const f = e.h * u, d = c.size || l.width;
        Io(c.start) && (o = c.start), l.fullSize ? xs(l, o, i.top, d, r.outerHeight - i.bottom - i.top) : xs(l, o, e.top + c.placed, d, f), c.start = o, c.placed += f, o = l.right;
      }
    }
    e.x = o, e.y = s;
  }
  var Rt = {
    addBox(t10, e) {
      t10.boxes || (t10.boxes = []), e.fullSize = e.fullSize || false, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
        return [
          {
            z: 0,
            draw(r) {
              e.draw(r);
            }
          }
        ];
      }, t10.boxes.push(e);
    },
    removeBox(t10, e) {
      const r = t10.boxes ? t10.boxes.indexOf(e) : -1;
      r !== -1 && t10.boxes.splice(r, 1);
    },
    configure(t10, e, r) {
      e.fullSize = r.fullSize, e.position = r.position, e.weight = r.weight;
    },
    update(t10, e, r, n) {
      if (!t10)
        return;
      const i = Mt(t10.options.layout.padding), o = Math.max(e - i.width, 0), s = Math.max(r - i.height, 0), a = Kv(t10.boxes), l = a.vertical, c = a.horizontal;
      $e(t10.boxes, (p) => {
        typeof p.beforeLayout == "function" && p.beforeLayout();
      });
      const u = l.reduce((p, y) => y.box.options && y.box.options.display === false ? p : p + 1, 0) || 1, f = Object.freeze({
        outerWidth: e,
        outerHeight: r,
        padding: i,
        availableWidth: o,
        availableHeight: s,
        vBoxMaxWidth: o / 2 / u,
        hBoxMaxHeight: s / 2
      }), d = Object.assign({}, i);
      U1(d, Mt(n));
      const h = Object.assign({
        maxPadding: d,
        w: o,
        h: s,
        x: i.left,
        y: i.top
      }, i), g = Yv(l.concat(c), f);
      so(a.fullSize, h, f, g), so(l, h, f, g), so(c, h, f, g) && so(l, h, f, g), Jv(h), $d(a.leftAndTop, h, f, g), h.x += h.w, h.y += h.h, $d(a.rightAndBottom, h, f, g), t10.chartArea = {
        left: h.left,
        top: h.top,
        right: h.left + h.w,
        bottom: h.top + h.h,
        height: h.h,
        width: h.w
      }, $e(a.chartArea, (p) => {
        const y = p.box;
        Object.assign(y, t10.chartArea), y.update(h.w, h.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  class z1 {
    acquireContext(e, r) {
    }
    releaseContext(e) {
      return false;
    }
    addEventListener(e, r, n) {
    }
    removeEventListener(e, r, n) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(e, r, n, i) {
      return r = Math.max(0, r || e.width), n = n || e.height, {
        width: r,
        height: Math.max(0, i ? Math.floor(r / i) : n)
      };
    }
    isAttached(e) {
      return true;
    }
    updateConfig(e) {
    }
  }
  class Gv extends z1 {
    acquireContext(e) {
      return e && e.getContext && e.getContext("2d") || null;
    }
    updateConfig(e) {
      e.options.animation = false;
    }
  }
  const Ks = "$chartjs", Zv = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  }, eh = (t10) => t10 === null || t10 === "";
  function $v(t10, e) {
    const r = t10.style, n = t10.getAttribute("height"), i = t10.getAttribute("width");
    if (t10[Ks] = {
      initial: {
        height: n,
        width: i,
        style: {
          display: r.display,
          height: r.height,
          width: r.width
        }
      }
    }, r.display = r.display || "block", r.boxSizing = r.boxSizing || "border-box", eh(i)) {
      const o = Ld(t10, "width");
      o !== void 0 && (t10.width = o);
    }
    if (eh(n))
      if (t10.style.height === "")
        t10.height = t10.width / (e || 2);
      else {
        const o = Ld(t10, "height");
        o !== void 0 && (t10.height = o);
      }
    return t10;
  }
  const V1 = tv ? {
    passive: true
  } : false;
  function e6(t10, e, r) {
    t10.addEventListener(e, r, V1);
  }
  function t6(t10, e, r) {
    t10.canvas.removeEventListener(e, r, V1);
  }
  function r6(t10, e) {
    const r = Zv[t10.type] || t10.type, { x: n, y: i } = Pn(t10, e);
    return {
      type: r,
      chart: e,
      native: t10,
      x: n !== void 0 ? n : null,
      y: i !== void 0 ? i : null
    };
  }
  function Aa(t10, e) {
    for (const r of t10)
      if (r === e || r.contains(e))
        return true;
  }
  function n6(t10, e, r) {
    const n = t10.canvas, i = new MutationObserver((o) => {
      let s = false;
      for (const a of o)
        s = s || Aa(a.addedNodes, n), s = s && !Aa(a.removedNodes, n);
      s && r();
    });
    return i.observe(document, {
      childList: true,
      subtree: true
    }), i;
  }
  function i6(t10, e, r) {
    const n = t10.canvas, i = new MutationObserver((o) => {
      let s = false;
      for (const a of o)
        s = s || Aa(a.removedNodes, n), s = s && !Aa(a.addedNodes, n);
      s && r();
    });
    return i.observe(document, {
      childList: true,
      subtree: true
    }), i;
  }
  const Do = /* @__PURE__ */ new Map();
  let th = 0;
  function q1() {
    const t10 = window.devicePixelRatio;
    t10 !== th && (th = t10, Do.forEach((e, r) => {
      r.currentDevicePixelRatio !== t10 && e();
    }));
  }
  function o6(t10, e) {
    Do.size || window.addEventListener("resize", q1), Do.set(t10, e);
  }
  function s6(t10) {
    Do.delete(t10), Do.size || window.removeEventListener("resize", q1);
  }
  function a6(t10, e, r) {
    const n = t10.canvas, i = n && Ku(n);
    if (!i)
      return;
    const o = v1((a, l) => {
      const c = i.clientWidth;
      r(a, l), c < i.clientWidth && r();
    }, window), s = new ResizeObserver((a) => {
      const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
      c === 0 && u === 0 || o(c, u);
    });
    return s.observe(i), o6(t10, o), s;
  }
  function Gl(t10, e, r) {
    r && r.disconnect(), e === "resize" && s6(t10);
  }
  function l6(t10, e, r) {
    const n = t10.canvas, i = v1((o) => {
      t10.ctx !== null && r(r6(o, t10));
    }, t10);
    return e6(n, e, i), i;
  }
  class c6 extends z1 {
    acquireContext(e, r) {
      const n = e && e.getContext && e.getContext("2d");
      return n && n.canvas === e ? ($v(e, r), n) : null;
    }
    releaseContext(e) {
      const r = e.canvas;
      if (!r[Ks])
        return false;
      const n = r[Ks].initial;
      [
        "height",
        "width"
      ].forEach((o) => {
        const s = n[o];
        We(s) ? r.removeAttribute(o) : r.setAttribute(o, s);
      });
      const i = n.style || {};
      return Object.keys(i).forEach((o) => {
        r.style[o] = i[o];
      }), r.width = r.width, delete r[Ks], true;
    }
    addEventListener(e, r, n) {
      this.removeEventListener(e, r);
      const i = e.$proxies || (e.$proxies = {}), s = {
        attach: n6,
        detach: i6,
        resize: a6
      }[r] || l6;
      i[r] = s(e, r, n);
    }
    removeEventListener(e, r) {
      const n = e.$proxies || (e.$proxies = {}), i = n[r];
      if (!i)
        return;
      ({
        attach: Gl,
        detach: Gl,
        resize: Gl
      }[r] || t6)(e, r, i), n[r] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(e, r, n, i) {
      return ev(e, r, n, i);
    }
    isAttached(e) {
      const r = Ku(e);
      return !!(r && r.isConnected);
    }
  }
  function u6(t10) {
    return !P1() || typeof OffscreenCanvas < "u" && t10 instanceof OffscreenCanvas ? Gv : c6;
  }
  var js;
  let Jr = (js = class {
    constructor() {
      ye(this, "x");
      ye(this, "y");
      ye(this, "active", false);
      ye(this, "options");
      ye(this, "$animations");
    }
    tooltipPosition(e) {
      const { x: r, y: n } = this.getProps([
        "x",
        "y"
      ], e);
      return {
        x: r,
        y: n
      };
    }
    hasValue() {
      return Ei(this.x) && Ei(this.y);
    }
    getProps(e, r) {
      const n = this.$animations;
      if (!r || !n)
        return this;
      const i = {};
      return e.forEach((o) => {
        i[o] = n[o] && n[o].active() ? n[o]._to : this[o];
      }), i;
    }
  }, ye(js, "defaults", {}), ye(js, "defaultRoutes"), js);
  function f6(t10, e) {
    const r = t10.options.ticks, n = d6(t10), i = Math.min(r.maxTicksLimit || n, n), o = r.major.enabled ? p6(e) : [], s = o.length, a = o[0], l = o[s - 1], c = [];
    if (s > i)
      return g6(e, c, o, s / i), c;
    const u = h6(o, e, i);
    if (s > 0) {
      let f, d;
      const h = s > 1 ? Math.round((l - a) / (s - 1)) : null;
      for (_s(e, c, u, We(h) ? 0 : a - h, a), f = 0, d = s - 1; f < d; f++)
        _s(e, c, u, o[f], o[f + 1]);
      return _s(e, c, u, l, We(h) ? e.length : l + h), c;
    }
    return _s(e, c, u), c;
  }
  function d6(t10) {
    const e = t10.options.offset, r = t10._tickSize(), n = t10._length / r + (e ? 0 : 1), i = t10._maxLength / r;
    return Math.floor(Math.min(n, i));
  }
  function h6(t10, e, r) {
    const n = m6(t10), i = e.length / r;
    if (!n)
      return Math.max(i, 1);
    const o = i2(n);
    for (let s = 0, a = o.length - 1; s < a; s++) {
      const l = o[s];
      if (l > i)
        return l;
    }
    return Math.max(i, 1);
  }
  function p6(t10) {
    const e = [];
    let r, n;
    for (r = 0, n = t10.length; r < n; r++)
      t10[r].major && e.push(r);
    return e;
  }
  function g6(t10, e, r, n) {
    let i = 0, o = r[0], s;
    for (n = Math.ceil(n), s = 0; s < t10.length; s++)
      s === o && (e.push(t10[s]), i++, o = r[i * n]);
  }
  function _s(t10, e, r, n, i) {
    const o = Oe(n, 0), s = Math.min(Oe(i, t10.length), t10.length);
    let a = 0, l, c, u;
    for (r = Math.ceil(r), i && (l = i - n, r = l / Math.floor(l / r)), u = o; u < 0; )
      a++, u = Math.round(o + a * r);
    for (c = Math.max(o, 0); c < s; c++)
      c === u && (e.push(t10[c]), a++, u = Math.round(o + a * r));
  }
  function m6(t10) {
    const e = t10.length;
    let r, n;
    if (e < 2)
      return false;
    for (n = t10[0], r = 1; r < e; ++r)
      if (t10[r] - t10[r - 1] !== n)
        return false;
    return n;
  }
  const y6 = (t10) => t10 === "left" ? "right" : t10 === "right" ? "left" : t10, rh = (t10, e, r) => e === "top" || e === "left" ? t10[e] + r : t10[e] - r, nh = (t10, e) => Math.min(e || t10, t10);
  function ih(t10, e) {
    const r = [], n = t10.length / e, i = t10.length;
    let o = 0;
    for (; o < i; o += n)
      r.push(t10[Math.floor(o)]);
    return r;
  }
  function b6(t10, e, r) {
    const n = t10.ticks.length, i = Math.min(e, n - 1), o = t10._startPixel, s = t10._endPixel, a = 1e-6;
    let l = t10.getPixelForTick(i), c;
    if (!(r && (n === 1 ? c = Math.max(l - o, s - l) : e === 0 ? c = (t10.getPixelForTick(1) - l) / 2 : c = (l - t10.getPixelForTick(i - 1)) / 2, l += i < e ? c : -c, l < o - a || l > s + a)))
      return l;
  }
  function v6(t10, e) {
    $e(t10, (r) => {
      const n = r.gc, i = n.length / 2;
      let o;
      if (i > e) {
        for (o = 0; o < i; ++o)
          delete r.data[n[o]];
        n.splice(0, i);
      }
    });
  }
  function Xi(t10) {
    return t10.drawTicks ? t10.tickLength : 0;
  }
  function oh(t10, e) {
    if (!t10.display)
      return 0;
    const r = vt(t10.font, e), n = Mt(t10.padding);
    return (it(t10.text) ? t10.text.length : 1) * r.lineHeight + n.height;
  }
  function A6(t10, e) {
    return vn(t10, {
      scale: e,
      type: "scale"
    });
  }
  function w6(t10, e, r) {
    return vn(t10, {
      tick: r,
      index: e,
      type: "tick"
    });
  }
  function x6(t10, e, r) {
    let n = Uu(t10);
    return (r && e !== "right" || !r && e === "right") && (n = y6(n)), n;
  }
  function _6(t10, e, r, n) {
    const { top: i, left: o, bottom: s, right: a, chart: l } = t10, { chartArea: c, scales: u } = l;
    let f = 0, d, h, g;
    const p = s - i, y = a - o;
    if (t10.isHorizontal()) {
      if (h = It(n, o, a), Le(r)) {
        const b = Object.keys(r)[0], x = r[b];
        g = u[b].getPixelForValue(x) + p - e;
      } else
        r === "center" ? g = (c.bottom + c.top) / 2 + p - e : g = rh(t10, r, e);
      d = a - o;
    } else {
      if (Le(r)) {
        const b = Object.keys(r)[0], x = r[b];
        h = u[b].getPixelForValue(x) - y + e;
      } else
        r === "center" ? h = (c.left + c.right) / 2 - y + e : h = rh(t10, r, e);
      g = It(n, s, i), f = r === "left" ? -mt : mt;
    }
    return {
      titleX: h,
      titleY: g,
      maxWidth: d,
      rotation: f
    };
  }
  class Zn extends Jr {
    constructor(e) {
      super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
    }
    init(e) {
      this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
    }
    parse(e, r) {
      return e;
    }
    getUserBounds() {
      let { _userMin: e, _userMax: r, _suggestedMin: n, _suggestedMax: i } = this;
      return e = Ht(e, Number.POSITIVE_INFINITY), r = Ht(r, Number.NEGATIVE_INFINITY), n = Ht(n, Number.POSITIVE_INFINITY), i = Ht(i, Number.NEGATIVE_INFINITY), {
        min: Ht(e, n),
        max: Ht(r, i),
        minDefined: pt(e),
        maxDefined: pt(r)
      };
    }
    getMinMax(e) {
      let { min: r, max: n, minDefined: i, maxDefined: o } = this.getUserBounds(), s;
      if (i && o)
        return {
          min: r,
          max: n
        };
      const a = this.getMatchingVisibleMetas();
      for (let l = 0, c = a.length; l < c; ++l)
        s = a[l].controller.getMinMax(this, e), i || (r = Math.min(r, s.min)), o || (n = Math.max(n, s.max));
      return r = o && r > n ? n : r, n = i && r > n ? r : n, {
        min: Ht(r, Ht(n, r)),
        max: Ht(n, Ht(r, n))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const e = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
    }
    getLabelItems(e = this.chart.chartArea) {
      return this._labelItems || (this._labelItems = this._computeLabelItems(e));
    }
    beforeLayout() {
      this._cache = {}, this._dataLimitsCached = false;
    }
    beforeUpdate() {
      nt(this.options.beforeUpdate, [
        this
      ]);
    }
    update(e, r, n) {
      const { beginAtZero: i, grace: o, ticks: s } = this.options, a = s.sampleSize;
      this.beforeUpdate(), this.maxWidth = e, this.maxHeight = r, this._margins = n = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = R2(this, o, i), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
      const l = a < this.ticks.length;
      this._convertTicksToLabels(l ? ih(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = f6(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
    }
    configure() {
      let e = this.options.reverse, r, n;
      this.isHorizontal() ? (r = this.left, n = this.right) : (r = this.top, n = this.bottom, e = !e), this._startPixel = r, this._endPixel = n, this._reversePixels = e, this._length = n - r, this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      nt(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      nt(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
    }
    afterSetDimensions() {
      nt(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(e) {
      this.chart.notifyPlugins(e, this.getContext()), nt(this.options[e], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      nt(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(e) {
      const r = this.options.ticks;
      let n, i, o;
      for (n = 0, i = e.length; n < i; n++)
        o = e[n], o.label = nt(r.callback, [
          o.value,
          n,
          e
        ], this);
    }
    afterTickToLabelConversion() {
      nt(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      nt(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const e = this.options, r = e.ticks, n = nh(this.ticks.length, e.ticks.maxTicksLimit), i = r.minRotation || 0, o = r.maxRotation;
      let s = i, a, l, c;
      if (!this._isVisible() || !r.display || i >= o || n <= 1 || !this.isHorizontal()) {
        this.labelRotation = i;
        return;
      }
      const u = this._getLabelSizes(), f = u.widest.width, d = u.highest.height, h = St(this.chart.width - f, 0, this.maxWidth);
      a = e.offset ? this.maxWidth / n : h / (n - 1), f + 6 > a && (a = h / (n - (e.offset ? 0.5 : 1)), l = this.maxHeight - Xi(e.grid) - r.padding - oh(e.title, this.chart.options.font), c = Math.sqrt(f * f + d * d), s = ju(Math.min(Math.asin(St((u.highest.height + 6) / a, -1, 1)), Math.asin(St(l / c, -1, 1)) - Math.asin(St(d / c, -1, 1)))), s = Math.max(i, Math.min(o, s))), this.labelRotation = s;
    }
    afterCalculateLabelRotation() {
      nt(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      nt(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const e = {
        width: 0,
        height: 0
      }, { chart: r, options: { ticks: n, title: i, grid: o } } = this, s = this._isVisible(), a = this.isHorizontal();
      if (s) {
        const l = oh(i, r.options.font);
        if (a ? (e.width = this.maxWidth, e.height = Xi(o) + l) : (e.height = this.maxHeight, e.width = Xi(o) + l), n.display && this.ticks.length) {
          const { first: c, last: u, widest: f, highest: d } = this._getLabelSizes(), h = n.padding * 2, g = gr(this.labelRotation), p = Math.cos(g), y = Math.sin(g);
          if (a) {
            const b = n.mirror ? 0 : y * f.width + p * d.height;
            e.height = Math.min(this.maxHeight, e.height + b + h);
          } else {
            const b = n.mirror ? 0 : p * f.width + y * d.height;
            e.width = Math.min(this.maxWidth, e.width + b + h);
          }
          this._calculatePadding(c, u, y, p);
        }
      }
      this._handleMargins(), a ? (this.width = this._length = r.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = r.height - this._margins.top - this._margins.bottom);
    }
    _calculatePadding(e, r, n, i) {
      const { ticks: { align: o, padding: s }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const u = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1);
        let d = 0, h = 0;
        l ? c ? (d = i * e.width, h = n * r.height) : (d = n * e.height, h = i * r.width) : o === "start" ? h = r.width : o === "end" ? d = e.width : o !== "inner" && (d = e.width / 2, h = r.width / 2), this.paddingLeft = Math.max((d - u + s) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - f + s) * this.width / (this.width - f), 0);
      } else {
        let u = r.height / 2, f = e.height / 2;
        o === "start" ? (u = 0, f = e.height) : o === "end" && (u = r.height, f = 0), this.paddingTop = u + s, this.paddingBottom = f + s;
      }
    }
    _handleMargins() {
      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
    }
    afterFit() {
      nt(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis: e, position: r } = this.options;
      return r === "top" || r === "bottom" || e === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(e) {
      this.beforeTickToLabelConversion(), this.generateTickLabels(e);
      let r, n;
      for (r = 0, n = e.length; r < n; r++)
        We(e[r].label) && (e.splice(r, 1), n--, r--);
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let e = this._labelSizes;
      if (!e) {
        const r = this.options.ticks.sampleSize;
        let n = this.ticks;
        r < n.length && (n = ih(n, r)), this._labelSizes = e = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
      }
      return e;
    }
    _computeLabelSizes(e, r, n) {
      const { ctx: i, _longestTextCache: o } = this, s = [], a = [], l = Math.floor(r / nh(r, n));
      let c = 0, u = 0, f, d, h, g, p, y, b, x, S, O, _;
      for (f = 0; f < r; f += l) {
        if (g = e[f].label, p = this._resolveTickFontOptions(f), i.font = y = p.string, b = o[y] = o[y] || {
          data: {},
          gc: []
        }, x = p.lineHeight, S = O = 0, !We(g) && !it(g))
          S = ba(i, b.data, b.gc, S, g), O = x;
        else if (it(g))
          for (d = 0, h = g.length; d < h; ++d)
            _ = g[d], !We(_) && !it(_) && (S = ba(i, b.data, b.gc, S, _), O += x);
        s.push(S), a.push(O), c = Math.max(S, c), u = Math.max(O, u);
      }
      v6(o, r);
      const L = s.indexOf(c), N = a.indexOf(u), j = (W) => ({
        width: s[W] || 0,
        height: a[W] || 0
      });
      return {
        first: j(0),
        last: j(r - 1),
        widest: j(L),
        highest: j(N),
        widths: s,
        heights: a
      };
    }
    getLabelForValue(e) {
      return e;
    }
    getPixelForValue(e, r) {
      return NaN;
    }
    getValueForPixel(e) {
    }
    getPixelForTick(e) {
      const r = this.ticks;
      return e < 0 || e > r.length - 1 ? null : this.getPixelForValue(r[e].value);
    }
    getPixelForDecimal(e) {
      this._reversePixels && (e = 1 - e);
      const r = this._startPixel + e * this._length;
      return a2(this._alignToPixels ? kn(this.chart, r, 0) : r);
    }
    getDecimalForPixel(e) {
      const r = (e - this._startPixel) / this._length;
      return this._reversePixels ? 1 - r : r;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: e, max: r } = this;
      return e < 0 && r < 0 ? r : e > 0 && r > 0 ? e : 0;
    }
    getContext(e) {
      const r = this.ticks || [];
      if (e >= 0 && e < r.length) {
        const n = r[e];
        return n.$context || (n.$context = w6(this.getContext(), e, n));
      }
      return this.$context || (this.$context = A6(this.chart.getContext(), this));
    }
    _tickSize() {
      const e = this.options.ticks, r = gr(this.labelRotation), n = Math.abs(Math.cos(r)), i = Math.abs(Math.sin(r)), o = this._getLabelSizes(), s = e.autoSkipPadding || 0, a = o ? o.widest.width + s : 0, l = o ? o.highest.height + s : 0;
      return this.isHorizontal() ? l * n > a * i ? a / n : l / i : l * i < a * n ? l / n : a / i;
    }
    _isVisible() {
      const e = this.options.display;
      return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(e) {
      const r = this.axis, n = this.chart, i = this.options, { grid: o, position: s, border: a } = i, l = o.offset, c = this.isHorizontal(), f = this.ticks.length + (l ? 1 : 0), d = Xi(o), h = [], g = a.setContext(this.getContext()), p = g.display ? g.width : 0, y = p / 2, b = function(I) {
        return kn(n, I, p);
      };
      let x, S, O, _, L, N, j, W, G, ee, fe, P10;
      if (s === "top")
        x = b(this.bottom), N = this.bottom - d, W = x - y, ee = b(e.top) + y, P10 = e.bottom;
      else if (s === "bottom")
        x = b(this.top), ee = e.top, P10 = b(e.bottom) - y, N = x + y, W = this.top + d;
      else if (s === "left")
        x = b(this.right), L = this.right - d, j = x - y, G = b(e.left) + y, fe = e.right;
      else if (s === "right")
        x = b(this.left), G = e.left, fe = b(e.right) - y, L = x + y, j = this.left + d;
      else if (r === "x") {
        if (s === "center")
          x = b((e.top + e.bottom) / 2 + 0.5);
        else if (Le(s)) {
          const I = Object.keys(s)[0], V = s[I];
          x = b(this.chart.scales[I].getPixelForValue(V));
        }
        ee = e.top, P10 = e.bottom, N = x + y, W = N + d;
      } else if (r === "y") {
        if (s === "center")
          x = b((e.left + e.right) / 2);
        else if (Le(s)) {
          const I = Object.keys(s)[0], V = s[I];
          x = b(this.chart.scales[I].getPixelForValue(V));
        }
        L = x - y, j = L - d, G = e.left, fe = e.right;
      }
      const z10 = Oe(i.ticks.maxTicksLimit, f), U = Math.max(1, Math.ceil(f / z10));
      for (S = 0; S < f; S += U) {
        const I = this.getContext(S), V = o.setContext(I), te = a.setContext(I), X = V.lineWidth, H = V.color, $ = te.dash || [], se = te.dashOffset, he = V.tickWidth, pe = V.tickColor, me = V.tickBorderDash || [], B = V.tickBorderDashOffset;
        O = b6(this, S, l), O !== void 0 && (_ = kn(n, O, X), c ? L = j = G = fe = _ : N = W = ee = P10 = _, h.push({
          tx1: L,
          ty1: N,
          tx2: j,
          ty2: W,
          x1: G,
          y1: ee,
          x2: fe,
          y2: P10,
          width: X,
          color: H,
          borderDash: $,
          borderDashOffset: se,
          tickWidth: he,
          tickColor: pe,
          tickBorderDash: me,
          tickBorderDashOffset: B
        }));
      }
      return this._ticksLength = f, this._borderValue = x, h;
    }
    _computeLabelItems(e) {
      const r = this.axis, n = this.options, { position: i, ticks: o } = n, s = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: f } = o, d = Xi(n.grid), h = d + u, g = f ? -u : h, p = -gr(this.labelRotation), y = [];
      let b, x, S, O, _, L, N, j, W, G, ee, fe, P10 = "middle";
      if (i === "top")
        L = this.bottom - g, N = this._getXAxisLabelAlignment();
      else if (i === "bottom")
        L = this.top + g, N = this._getXAxisLabelAlignment();
      else if (i === "left") {
        const U = this._getYAxisLabelAlignment(d);
        N = U.textAlign, _ = U.x;
      } else if (i === "right") {
        const U = this._getYAxisLabelAlignment(d);
        N = U.textAlign, _ = U.x;
      } else if (r === "x") {
        if (i === "center")
          L = (e.top + e.bottom) / 2 + h;
        else if (Le(i)) {
          const U = Object.keys(i)[0], I = i[U];
          L = this.chart.scales[U].getPixelForValue(I) + h;
        }
        N = this._getXAxisLabelAlignment();
      } else if (r === "y") {
        if (i === "center")
          _ = (e.left + e.right) / 2 - h;
        else if (Le(i)) {
          const U = Object.keys(i)[0], I = i[U];
          _ = this.chart.scales[U].getPixelForValue(I);
        }
        N = this._getYAxisLabelAlignment(d).textAlign;
      }
      r === "y" && (l === "start" ? P10 = "top" : l === "end" && (P10 = "bottom"));
      const z10 = this._getLabelSizes();
      for (b = 0, x = a.length; b < x; ++b) {
        S = a[b], O = S.label;
        const U = o.setContext(this.getContext(b));
        j = this.getPixelForTick(b) + o.labelOffset, W = this._resolveTickFontOptions(b), G = W.lineHeight, ee = it(O) ? O.length : 1;
        const I = ee / 2, V = U.color, te = U.textStrokeColor, X = U.textStrokeWidth;
        let H = N;
        s ? (_ = j, N === "inner" && (b === x - 1 ? H = this.options.reverse ? "left" : "right" : b === 0 ? H = this.options.reverse ? "right" : "left" : H = "center"), i === "top" ? c === "near" || p !== 0 ? fe = -ee * G + G / 2 : c === "center" ? fe = -z10.highest.height / 2 - I * G + G : fe = -z10.highest.height + G / 2 : c === "near" || p !== 0 ? fe = G / 2 : c === "center" ? fe = z10.highest.height / 2 - I * G : fe = z10.highest.height - ee * G, f && (fe *= -1), p !== 0 && !U.showLabelBackdrop && (_ += G / 2 * Math.sin(p))) : (L = j, fe = (1 - ee) * G / 2);
        let $;
        if (U.showLabelBackdrop) {
          const se = Mt(U.backdropPadding), he = z10.heights[b], pe = z10.widths[b];
          let me = fe - se.top, B = 0 - se.left;
          switch (P10) {
            case "middle":
              me -= he / 2;
              break;
            case "bottom":
              me -= he;
              break;
          }
          switch (N) {
            case "center":
              B -= pe / 2;
              break;
            case "right":
              B -= pe;
              break;
          }
          $ = {
            left: B,
            top: me,
            width: pe + se.width,
            height: he + se.height,
            color: U.backdropColor
          };
        }
        y.push({
          label: O,
          font: W,
          textOffset: fe,
          options: {
            rotation: p,
            color: V,
            strokeColor: te,
            strokeWidth: X,
            textAlign: H,
            textBaseline: P10,
            translation: [
              _,
              L
            ],
            backdrop: $
          }
        });
      }
      return y;
    }
    _getXAxisLabelAlignment() {
      const { position: e, ticks: r } = this.options;
      if (-gr(this.labelRotation))
        return e === "top" ? "left" : "right";
      let i = "center";
      return r.align === "start" ? i = "left" : r.align === "end" ? i = "right" : r.align === "inner" && (i = "inner"), i;
    }
    _getYAxisLabelAlignment(e) {
      const { position: r, ticks: { crossAlign: n, mirror: i, padding: o } } = this.options, s = this._getLabelSizes(), a = e + o, l = s.widest.width;
      let c, u;
      return r === "left" ? i ? (u = this.right + o, n === "near" ? c = "left" : n === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, n === "near" ? c = "right" : n === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : r === "right" ? i ? (u = this.left + o, n === "near" ? c = "right" : n === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, n === "near" ? c = "left" : n === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
        textAlign: c,
        x: u
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror)
        return;
      const e = this.chart, r = this.options.position;
      if (r === "left" || r === "right")
        return {
          top: 0,
          left: this.left,
          bottom: e.height,
          right: this.right
        };
      if (r === "top" || r === "bottom")
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: e.width
        };
    }
    drawBackground() {
      const { ctx: e, options: { backgroundColor: r }, left: n, top: i, width: o, height: s } = this;
      r && (e.save(), e.fillStyle = r, e.fillRect(n, i, o, s), e.restore());
    }
    getLineWidthForValue(e) {
      const r = this.options.grid;
      if (!this._isVisible() || !r.display)
        return 0;
      const i = this.ticks.findIndex((o) => o.value === e);
      return i >= 0 ? r.setContext(this.getContext(i)).lineWidth : 0;
    }
    drawGrid(e) {
      const r = this.options.grid, n = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
      let o, s;
      const a = (l, c, u) => {
        !u.width || !u.color || (n.save(), n.lineWidth = u.width, n.strokeStyle = u.color, n.setLineDash(u.borderDash || []), n.lineDashOffset = u.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(c.x, c.y), n.stroke(), n.restore());
      };
      if (r.display)
        for (o = 0, s = i.length; o < s; ++o) {
          const l = i[o];
          r.drawOnChartArea && a({
            x: l.x1,
            y: l.y1
          }, {
            x: l.x2,
            y: l.y2
          }, l), r.drawTicks && a({
            x: l.tx1,
            y: l.ty1
          }, {
            x: l.tx2,
            y: l.ty2
          }, {
            color: l.tickColor,
            width: l.tickWidth,
            borderDash: l.tickBorderDash,
            borderDashOffset: l.tickBorderDashOffset
          });
        }
    }
    drawBorder() {
      const { chart: e, ctx: r, options: { border: n, grid: i } } = this, o = n.setContext(this.getContext()), s = n.display ? o.width : 0;
      if (!s)
        return;
      const a = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
      let c, u, f, d;
      this.isHorizontal() ? (c = kn(e, this.left, s) - s / 2, u = kn(e, this.right, a) + a / 2, f = d = l) : (f = kn(e, this.top, s) - s / 2, d = kn(e, this.bottom, a) + a / 2, c = u = l), r.save(), r.lineWidth = o.width, r.strokeStyle = o.color, r.beginPath(), r.moveTo(c, f), r.lineTo(u, d), r.stroke(), r.restore();
    }
    drawLabels(e) {
      if (!this.options.ticks.display)
        return;
      const n = this.ctx, i = this._computeLabelArea();
      i && Ka(n, i);
      const o = this.getLabelItems(e);
      for (const s of o) {
        const a = s.options, l = s.font, c = s.label, u = s.textOffset;
        Kn(n, c, 0, u, l, a);
      }
      i && Xa(n);
    }
    drawTitle() {
      const { ctx: e, options: { position: r, title: n, reverse: i } } = this;
      if (!n.display)
        return;
      const o = vt(n.font), s = Mt(n.padding), a = n.align;
      let l = o.lineHeight / 2;
      r === "bottom" || r === "center" || Le(r) ? (l += s.bottom, it(n.text) && (l += o.lineHeight * (n.text.length - 1))) : l += s.top;
      const { titleX: c, titleY: u, maxWidth: f, rotation: d } = _6(this, l, r, a);
      Kn(e, n.text, 0, 0, o, {
        color: n.color,
        maxWidth: f,
        rotation: d,
        textAlign: x6(a, r, i),
        textBaseline: "middle",
        translation: [
          c,
          u
        ]
      });
    }
    draw(e) {
      this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
    }
    _layers() {
      const e = this.options, r = e.ticks && e.ticks.z || 0, n = Oe(e.grid && e.grid.z, -1), i = Oe(e.border && e.border.z, 0);
      return !this._isVisible() || this.draw !== Zn.prototype.draw ? [
        {
          z: r,
          draw: (o) => {
            this.draw(o);
          }
        }
      ] : [
        {
          z: n,
          draw: (o) => {
            this.drawBackground(), this.drawGrid(o), this.drawTitle();
          }
        },
        {
          z: i,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: r,
          draw: (o) => {
            this.drawLabels(o);
          }
        }
      ];
    }
    getMatchingVisibleMetas(e) {
      const r = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", i = [];
      let o, s;
      for (o = 0, s = r.length; o < s; ++o) {
        const a = r[o];
        a[n] === this.id && (!e || a.type === e) && i.push(a);
      }
      return i;
    }
    _resolveTickFontOptions(e) {
      const r = this.options.ticks.setContext(this.getContext(e));
      return vt(r.font);
    }
    _maxDigits() {
      const e = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / e;
    }
  }
  class Ss {
    constructor(e, r, n) {
      this.type = e, this.scope = r, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(e) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
    }
    register(e) {
      const r = Object.getPrototypeOf(e);
      let n;
      k6(r) && (n = this.register(r));
      const i = this.items, o = e.id, s = this.scope + "." + o;
      if (!o)
        throw new Error("class does not have id: " + e);
      return o in i || (i[o] = e, S6(e, s, n), this.override && gt.override(e.id, e.overrides)), s;
    }
    get(e) {
      return this.items[e];
    }
    unregister(e) {
      const r = this.items, n = e.id, i = this.scope;
      n in r && delete r[n], i && n in gt[i] && (delete gt[i][n], this.override && delete Yn[n]);
    }
  }
  function S6(t10, e, r) {
    const n = Oo(/* @__PURE__ */ Object.create(null), [
      r ? gt.get(r) : {},
      gt.get(e),
      t10.defaults
    ]);
    gt.set(e, n), t10.defaultRoutes && E6(e, t10.defaultRoutes), t10.descriptors && gt.describe(e, t10.descriptors);
  }
  function E6(t10, e) {
    Object.keys(e).forEach((r) => {
      const n = r.split("."), i = n.pop(), o = [
        t10
      ].concat(n).join("."), s = e[r].split("."), a = s.pop(), l = s.join(".");
      gt.route(o, i, l, a);
    });
  }
  function k6(t10) {
    return "id" in t10 && "defaults" in t10;
  }
  class C6 {
    constructor() {
      this.controllers = new Ss(mr, "datasets", true), this.elements = new Ss(Jr, "elements"), this.plugins = new Ss(Object, "plugins"), this.scales = new Ss(Zn, "scales"), this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...e) {
      this._each("register", e);
    }
    remove(...e) {
      this._each("unregister", e);
    }
    addControllers(...e) {
      this._each("register", e, this.controllers);
    }
    addElements(...e) {
      this._each("register", e, this.elements);
    }
    addPlugins(...e) {
      this._each("register", e, this.plugins);
    }
    addScales(...e) {
      this._each("register", e, this.scales);
    }
    getController(e) {
      return this._get(e, this.controllers, "controller");
    }
    getElement(e) {
      return this._get(e, this.elements, "element");
    }
    getPlugin(e) {
      return this._get(e, this.plugins, "plugin");
    }
    getScale(e) {
      return this._get(e, this.scales, "scale");
    }
    removeControllers(...e) {
      this._each("unregister", e, this.controllers);
    }
    removeElements(...e) {
      this._each("unregister", e, this.elements);
    }
    removePlugins(...e) {
      this._each("unregister", e, this.plugins);
    }
    removeScales(...e) {
      this._each("unregister", e, this.scales);
    }
    _each(e, r, n) {
      [
        ...r
      ].forEach((i) => {
        const o = n || this._getRegistryForType(i);
        n || o.isForType(i) || o === this.plugins && i.id ? this._exec(e, o, i) : $e(i, (s) => {
          const a = n || this._getRegistryForType(s);
          this._exec(e, a, s);
        });
      });
    }
    _exec(e, r, n) {
      const i = Fu(e);
      nt(n["before" + i], [], n), r[e](n), nt(n["after" + i], [], n);
    }
    _getRegistryForType(e) {
      for (let r = 0; r < this._typedRegistries.length; r++) {
        const n = this._typedRegistries[r];
        if (n.isForType(e))
          return n;
      }
      return this.plugins;
    }
    _get(e, r, n) {
      const i = r.get(e);
      if (i === void 0)
        throw new Error('"' + e + '" is not a registered ' + n + ".");
      return i;
    }
  }
  var Ar = /* @__PURE__ */ new C6();
  class T6 {
    constructor() {
      this._init = [];
    }
    notify(e, r, n, i) {
      r === "beforeInit" && (this._init = this._createDescriptors(e, true), this._notify(this._init, e, "install"));
      const o = i ? this._descriptors(e).filter(i) : this._descriptors(e), s = this._notify(o, e, r, n);
      return r === "afterDestroy" && (this._notify(o, e, "stop"), this._notify(this._init, e, "uninstall")), s;
    }
    _notify(e, r, n, i) {
      i = i || {};
      for (const o of e) {
        const s = o.plugin, a = s[n], l = [
          r,
          i,
          o.options
        ];
        if (nt(a, l, s) === false && i.cancelable)
          return false;
      }
      return true;
    }
    invalidate() {
      We(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
    }
    _descriptors(e) {
      if (this._cache)
        return this._cache;
      const r = this._cache = this._createDescriptors(e);
      return this._notifyStateChanges(e), r;
    }
    _createDescriptors(e, r) {
      const n = e && e.config, i = Oe(n.options && n.options.plugins, {}), o = O6(n);
      return i === false && !r ? [] : P6(e, o, i, r);
    }
    _notifyStateChanges(e) {
      const r = this._oldCache || [], n = this._cache, i = (o, s) => o.filter((a) => !s.some((l) => a.plugin.id === l.plugin.id));
      this._notify(i(r, n), e, "stop"), this._notify(i(n, r), e, "start");
    }
  }
  function O6(t10) {
    const e = {}, r = [], n = Object.keys(Ar.plugins.items);
    for (let o = 0; o < n.length; o++)
      r.push(Ar.getPlugin(n[o]));
    const i = t10.plugins || [];
    for (let o = 0; o < i.length; o++) {
      const s = i[o];
      r.indexOf(s) === -1 && (r.push(s), e[s.id] = true);
    }
    return {
      plugins: r,
      localIds: e
    };
  }
  function I6(t10, e) {
    return !e && t10 === false ? null : t10 === true ? {} : t10;
  }
  function P6(t10, { plugins: e, localIds: r }, n, i) {
    const o = [], s = t10.getContext();
    for (const a of e) {
      const l = a.id, c = I6(n[l], i);
      c !== null && o.push({
        plugin: a,
        options: R6(t10.config, {
          plugin: a,
          local: r[l]
        }, c, s)
      });
    }
    return o;
  }
  function R6(t10, { plugin: e, local: r }, n, i) {
    const o = t10.pluginScopeKeys(e), s = t10.getOptionScopes(n, o);
    return r && e.defaults && s.push(e.defaults), t10.createResolver(s, i, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function Bc(t10, e) {
    const r = gt.datasets[t10] || {};
    return ((e.datasets || {})[t10] || {}).indexAxis || e.indexAxis || r.indexAxis || "x";
  }
  function D6(t10, e) {
    let r = t10;
    return t10 === "_index_" ? r = e : t10 === "_value_" && (r = e === "x" ? "y" : "x"), r;
  }
  function M6(t10, e) {
    return t10 === e ? "_index_" : "_value_";
  }
  function sh(t10) {
    if (t10 === "x" || t10 === "y" || t10 === "r")
      return t10;
  }
  function N6(t10) {
    if (t10 === "top" || t10 === "bottom")
      return "x";
    if (t10 === "left" || t10 === "right")
      return "y";
  }
  function Fc(t10, ...e) {
    if (sh(t10))
      return t10;
    for (const r of e) {
      const n = r.axis || N6(r.position) || t10.length > 1 && sh(t10[0].toLowerCase());
      if (n)
        return n;
    }
    throw new Error(`Cannot determine type of '${t10}' axis. Please provide 'axis' or 'position' option.`);
  }
  function ah(t10, e, r) {
    if (r[e + "AxisID"] === t10)
      return {
        axis: e
      };
  }
  function L6(t10, e) {
    if (e.data && e.data.datasets) {
      const r = e.data.datasets.filter((n) => n.xAxisID === t10 || n.yAxisID === t10);
      if (r.length)
        return ah(t10, "x", r[0]) || ah(t10, "y", r[0]);
    }
    return {};
  }
  function B6(t10, e) {
    const r = Yn[t10.type] || {
      scales: {}
    }, n = e.scales || {}, i = Bc(t10.type, e), o = /* @__PURE__ */ Object.create(null);
    return Object.keys(n).forEach((s) => {
      const a = n[s];
      if (!Le(a))
        return console.error(`Invalid scale configuration for scale: ${s}`);
      if (a._proxy)
        return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
      const l = Fc(s, a, L6(s, t10), gt.scales[a.type]), c = M6(l, i), u = r.scales || {};
      o[s] = mo(/* @__PURE__ */ Object.create(null), [
        {
          axis: l
        },
        a,
        u[l],
        u[c]
      ]);
    }), t10.data.datasets.forEach((s) => {
      const a = s.type || t10.type, l = s.indexAxis || Bc(a, e), u = (Yn[a] || {}).scales || {};
      Object.keys(u).forEach((f) => {
        const d = D6(f, l), h = s[d + "AxisID"] || d;
        o[h] = o[h] || /* @__PURE__ */ Object.create(null), mo(o[h], [
          {
            axis: d
          },
          n[h],
          u[f]
        ]);
      });
    }), Object.keys(o).forEach((s) => {
      const a = o[s];
      mo(a, [
        gt.scales[a.type],
        gt.scale
      ]);
    }), o;
  }
  function H1(t10) {
    const e = t10.options || (t10.options = {});
    e.plugins = Oe(e.plugins, {}), e.scales = B6(t10, e);
  }
  function Y1(t10) {
    return t10 = t10 || {}, t10.datasets = t10.datasets || [], t10.labels = t10.labels || [], t10;
  }
  function F6(t10) {
    return t10 = t10 || {}, t10.data = Y1(t10.data), H1(t10), t10;
  }
  const lh = /* @__PURE__ */ new Map(), K1 = /* @__PURE__ */ new Set();
  function Es(t10, e) {
    let r = lh.get(t10);
    return r || (r = e(), lh.set(t10, r), K1.add(r)), r;
  }
  const Ji = (t10, e, r) => {
    const n = pn(e, r);
    n !== void 0 && t10.add(n);
  };
  class j6 {
    constructor(e) {
      this._config = F6(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(e) {
      this._config.type = e;
    }
    get data() {
      return this._config.data;
    }
    set data(e) {
      this._config.data = Y1(e);
    }
    get options() {
      return this._config.options;
    }
    set options(e) {
      this._config.options = e;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const e = this._config;
      this.clearCache(), H1(e);
    }
    clearCache() {
      this._scopeCache.clear(), this._resolverCache.clear();
    }
    datasetScopeKeys(e) {
      return Es(e, () => [
        [
          `datasets.${e}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(e, r) {
      return Es(`${e}.transition.${r}`, () => [
        [
          `datasets.${e}.transitions.${r}`,
          `transitions.${r}`
        ],
        [
          `datasets.${e}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(e, r) {
      return Es(`${e}-${r}`, () => [
        [
          `datasets.${e}.elements.${r}`,
          `datasets.${e}`,
          `elements.${r}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(e) {
      const r = e.id, n = this.type;
      return Es(`${n}-plugin-${r}`, () => [
        [
          `plugins.${r}`,
          ...e.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(e, r) {
      const n = this._scopeCache;
      let i = n.get(e);
      return (!i || r) && (i = /* @__PURE__ */ new Map(), n.set(e, i)), i;
    }
    getOptionScopes(e, r, n) {
      const { options: i, type: o } = this, s = this._cachedScopes(e, n), a = s.get(r);
      if (a)
        return a;
      const l = /* @__PURE__ */ new Set();
      r.forEach((u) => {
        e && (l.add(e), u.forEach((f) => Ji(l, e, f))), u.forEach((f) => Ji(l, i, f)), u.forEach((f) => Ji(l, Yn[o] || {}, f)), u.forEach((f) => Ji(l, gt, f)), u.forEach((f) => Ji(l, Mc, f));
      });
      const c = Array.from(l);
      return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), K1.has(r) && s.set(r, c), c;
    }
    chartOptionScopes() {
      const { options: e, type: r } = this;
      return [
        e,
        Yn[r] || {},
        gt.datasets[r] || {},
        {
          type: r
        },
        gt,
        Mc
      ];
    }
    resolveNamedOptions(e, r, n, i = [
      ""
    ]) {
      const o = {
        $shared: true
      }, { resolver: s, subPrefixes: a } = ch(this._resolverCache, e, i);
      let l = s;
      if (U6(s, r)) {
        o.$shared = false, n = gn(n) ? n() : n;
        const c = this.createResolver(e, n, a);
        l = ki(s, n, c);
      }
      for (const c of r)
        o[c] = l[c];
      return o;
    }
    createResolver(e, r, n = [
      ""
    ], i) {
      const { resolver: o } = ch(this._resolverCache, e, n);
      return Le(r) ? ki(o, r, void 0, i) : o;
    }
  }
  function ch(t10, e, r) {
    let n = t10.get(e);
    n || (n = /* @__PURE__ */ new Map(), t10.set(e, n));
    const i = r.join();
    let o = n.get(i);
    return o || (o = {
      resolver: qu(e, r),
      subPrefixes: r.filter((a) => !a.toLowerCase().includes("hover"))
    }, n.set(i, o)), o;
  }
  const W6 = (t10) => Le(t10) && Object.getOwnPropertyNames(t10).reduce((e, r) => e || gn(t10[r]), false);
  function U6(t10, e) {
    const { isScriptable: r, isIndexable: n } = E1(t10);
    for (const i of e) {
      const o = r(i), s = n(i), a = (s || o) && t10[i];
      if (o && (gn(a) || W6(a)) || s && it(a))
        return true;
    }
    return false;
  }
  var z6 = "4.4.0";
  const V6 = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function uh(t10, e) {
    return t10 === "top" || t10 === "bottom" || V6.indexOf(t10) === -1 && e === "x";
  }
  function fh(t10, e) {
    return function(r, n) {
      return r[t10] === n[t10] ? r[e] - n[e] : r[t10] - n[t10];
    };
  }
  function dh(t10) {
    const e = t10.chart, r = e.options.animation;
    e.notifyPlugins("afterRender"), nt(r && r.onComplete, [
      t10
    ], e);
  }
  function q6(t10) {
    const e = t10.chart, r = e.options.animation;
    nt(r && r.onProgress, [
      t10
    ], e);
  }
  function X1(t10) {
    return P1() && typeof t10 == "string" ? t10 = document.getElementById(t10) : t10 && t10.length && (t10 = t10[0]), t10 && t10.canvas && (t10 = t10.canvas), t10;
  }
  const Xs = {}, hh = (t10) => {
    const e = X1(t10);
    return Object.values(Xs).filter((r) => r.canvas === e).pop();
  };
  function H6(t10, e, r) {
    const n = Object.keys(t10);
    for (const i of n) {
      const o = +i;
      if (o >= e) {
        const s = t10[i];
        delete t10[i], (r > 0 || o > e) && (t10[o + r] = s);
      }
    }
  }
  function Y6(t10, e, r, n) {
    return !r || t10.type === "mouseout" ? null : n ? e : t10;
  }
  function ks(t10, e, r) {
    return t10.options.clip ? t10[r] : e[r];
  }
  function K6(t10, e) {
    const { xScale: r, yScale: n } = t10;
    return r && n ? {
      left: ks(r, e, "left"),
      right: ks(r, e, "right"),
      top: ks(n, e, "top"),
      bottom: ks(n, e, "bottom")
    } : e;
  }
  class Lr {
    static register(...e) {
      Ar.add(...e), ph();
    }
    static unregister(...e) {
      Ar.remove(...e), ph();
    }
    constructor(e, r) {
      const n = this.config = new j6(r), i = X1(e), o = hh(i);
      if (o)
        throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
      const s = n.createResolver(n.chartOptionScopes(), this.getContext());
      this.platform = new (n.platform || u6(i))(), this.platform.updateConfig(n);
      const a = this.platform.acquireContext(i, s.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
      if (this.id = J3(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new T6(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = f2((f) => this.update(f), s.resizeDelay || 0), this._dataChanges = [], Xs[this.id] = this, !a || !l) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      Dr.listen(this, "complete", dh), Dr.listen(this, "progress", q6), this._initialize(), this.attached && this.update();
    }
    get aspectRatio() {
      const { options: { aspectRatio: e, maintainAspectRatio: r }, width: n, height: i, _aspectRatio: o } = this;
      return We(e) ? r && o ? o : i ? n / i : null : e;
    }
    get data() {
      return this.config.data;
    }
    set data(e) {
      this.config.data = e;
    }
    get options() {
      return this._options;
    }
    set options(e) {
      this.config.options = e;
    }
    get registry() {
      return Ar;
    }
    _initialize() {
      return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Nd(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
    }
    clear() {
      return Rd(this.canvas, this.ctx), this;
    }
    stop() {
      return Dr.stop(this), this;
    }
    resize(e, r) {
      Dr.running(this) ? this._resizeBeforeDraw = {
        width: e,
        height: r
      } : this._resize(e, r);
    }
    _resize(e, r) {
      const n = this.options, i = this.canvas, o = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(i, e, r, o), a = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
      this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, Nd(this, a, true) && (this.notifyPlugins("resize", {
        size: s
      }), nt(n.onResize, [
        this,
        s
      ], this), this.attached && this._doResize(l) && this.render());
    }
    ensureScalesHaveIDs() {
      const r = this.options.scales || {};
      $e(r, (n, i) => {
        n.id = i;
      });
    }
    buildOrUpdateScales() {
      const e = this.options, r = e.scales, n = this.scales, i = Object.keys(n).reduce((s, a) => (s[a] = false, s), {});
      let o = [];
      r && (o = o.concat(Object.keys(r).map((s) => {
        const a = r[s], l = Fc(s, a), c = l === "r", u = l === "x";
        return {
          options: a,
          dposition: c ? "chartArea" : u ? "bottom" : "left",
          dtype: c ? "radialLinear" : u ? "category" : "linear"
        };
      }))), $e(o, (s) => {
        const a = s.options, l = a.id, c = Fc(l, a), u = Oe(a.type, s.dtype);
        (a.position === void 0 || uh(a.position, c) !== uh(s.dposition)) && (a.position = s.dposition), i[l] = true;
        let f = null;
        if (l in n && n[l].type === u)
          f = n[l];
        else {
          const d = Ar.getScale(u);
          f = new d({
            id: l,
            type: u,
            ctx: this.ctx,
            chart: this
          }), n[f.id] = f;
        }
        f.init(a, e);
      }), $e(i, (s, a) => {
        s || delete n[a];
      }), $e(n, (s) => {
        Rt.configure(this, s, s.options), Rt.addBox(this, s);
      });
    }
    _updateMetasets() {
      const e = this._metasets, r = this.data.datasets.length, n = e.length;
      if (e.sort((i, o) => i.index - o.index), n > r) {
        for (let i = r; i < n; ++i)
          this._destroyDatasetMeta(i);
        e.splice(r, n - r);
      }
      this._sortedMetasets = e.slice(0).sort(fh("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: e, data: { datasets: r } } = this;
      e.length > r.length && delete this._stacks, e.forEach((n, i) => {
        r.filter((o) => o === n._dataset).length === 0 && this._destroyDatasetMeta(i);
      });
    }
    buildOrUpdateControllers() {
      const e = [], r = this.data.datasets;
      let n, i;
      for (this._removeUnreferencedMetasets(), n = 0, i = r.length; n < i; n++) {
        const o = r[n];
        let s = this.getDatasetMeta(n);
        const a = o.type || this.config.type;
        if (s.type && s.type !== a && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = a, s.indexAxis = o.indexAxis || Bc(a, this.options), s.order = o.order || 0, s.index = n, s.label = "" + o.label, s.visible = this.isDatasetVisible(n), s.controller)
          s.controller.updateIndex(n), s.controller.linkScales();
        else {
          const l = Ar.getController(a), { datasetElementType: c, dataElementType: u } = gt.datasets[a];
          Object.assign(l, {
            dataElementType: Ar.getElement(u),
            datasetElementType: c && Ar.getElement(c)
          }), s.controller = new l(this, n), e.push(s.controller);
        }
      }
      return this._updateMetasets(), e;
    }
    _resetElements() {
      $e(this.data.datasets, (e, r) => {
        this.getDatasetMeta(r).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements(), this.notifyPlugins("reset");
    }
    update(e) {
      const r = this.config;
      r.update();
      const n = this._options = r.createResolver(r.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !n.animation;
      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
        mode: e,
        cancelable: true
      }) === false)
        return;
      const o = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let s = 0;
      for (let c = 0, u = this.data.datasets.length; c < u; c++) {
        const { controller: f } = this.getDatasetMeta(c), d = !i && o.indexOf(f) === -1;
        f.buildOrUpdateElements(d), s = Math.max(+f.getMaxOverflow(), s);
      }
      s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), i || $e(o, (c) => {
        c.reset();
      }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
        mode: e
      }), this._layers.sort(fh("z", "_idx"));
      const { _active: a, _lastEvent: l } = this;
      l ? this._eventHandler(l, true) : a.length && this._updateHoverStyles(a, a, true), this.render();
    }
    _updateScales() {
      $e(this.scales, (e) => {
        Rt.removeBox(this, e);
      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const e = this.options, r = new Set(Object.keys(this._listeners)), n = new Set(e.events);
      (!_d(r, n) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
    }
    _updateHiddenIndices() {
      const { _hiddenIndices: e } = this, r = this._getUniformDataChanges() || [];
      for (const { method: n, start: i, count: o } of r) {
        const s = n === "_removeElements" ? -o : o;
        H6(e, i, s);
      }
    }
    _getUniformDataChanges() {
      const e = this._dataChanges;
      if (!e || !e.length)
        return;
      this._dataChanges = [];
      const r = this.data.datasets.length, n = (o) => new Set(e.filter((s) => s[0] === o).map((s, a) => a + "," + s.splice(1).join(","))), i = n(0);
      for (let o = 1; o < r; o++)
        if (!_d(i, n(o)))
          return;
      return Array.from(i).map((o) => o.split(",")).map((o) => ({
        method: o[1],
        start: +o[2],
        count: +o[3]
      }));
    }
    _updateLayout(e) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false)
        return;
      Rt.update(this, this.width, this.height, e);
      const r = this.chartArea, n = r.width <= 0 || r.height <= 0;
      this._layers = [], $e(this.boxes, (i) => {
        n && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers()));
      }, this), this._layers.forEach((i, o) => {
        i._idx = o;
      }), this.notifyPlugins("afterLayout");
    }
    _updateDatasets(e) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode: e,
        cancelable: true
      }) !== false) {
        for (let r = 0, n = this.data.datasets.length; r < n; ++r)
          this.getDatasetMeta(r).controller.configure();
        for (let r = 0, n = this.data.datasets.length; r < n; ++r)
          this._updateDataset(r, gn(e) ? e({
            datasetIndex: r
          }) : e);
        this.notifyPlugins("afterDatasetsUpdate", {
          mode: e
        });
      }
    }
    _updateDataset(e, r) {
      const n = this.getDatasetMeta(e), i = {
        meta: n,
        index: e,
        mode: r,
        cancelable: true
      };
      this.notifyPlugins("beforeDatasetUpdate", i) !== false && (n.controller._update(r), i.cancelable = false, this.notifyPlugins("afterDatasetUpdate", i));
    }
    render() {
      this.notifyPlugins("beforeRender", {
        cancelable: true
      }) !== false && (Dr.has(this) ? this.attached && !Dr.running(this) && Dr.start(this) : (this.draw(), dh({
        chart: this
      })));
    }
    draw() {
      let e;
      if (this._resizeBeforeDraw) {
        const { width: n, height: i } = this._resizeBeforeDraw;
        this._resize(n, i), this._resizeBeforeDraw = null;
      }
      if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false)
        return;
      const r = this._layers;
      for (e = 0; e < r.length && r[e].z <= 0; ++e)
        r[e].draw(this.chartArea);
      for (this._drawDatasets(); e < r.length; ++e)
        r[e].draw(this.chartArea);
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(e) {
      const r = this._sortedMetasets, n = [];
      let i, o;
      for (i = 0, o = r.length; i < o; ++i) {
        const s = r[i];
        (!e || s.visible) && n.push(s);
      }
      return n;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false)
        return;
      const e = this.getSortedVisibleDatasetMetas();
      for (let r = e.length - 1; r >= 0; --r)
        this._drawDataset(e[r]);
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(e) {
      const r = this.ctx, n = e._clip, i = !n.disabled, o = K6(e, this.chartArea), s = {
        meta: e,
        index: e.index,
        cancelable: true
      };
      this.notifyPlugins("beforeDatasetDraw", s) !== false && (i && Ka(r, {
        left: n.left === false ? 0 : o.left - n.left,
        right: n.right === false ? this.width : o.right + n.right,
        top: n.top === false ? 0 : o.top - n.top,
        bottom: n.bottom === false ? this.height : o.bottom + n.bottom
      }), e.controller.draw(), i && Xa(r), s.cancelable = false, this.notifyPlugins("afterDatasetDraw", s));
    }
    isPointInArea(e) {
      return zr(e, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, r, n, i) {
      const o = Vv.modes[r];
      return typeof o == "function" ? o(this, e, n, i) : [];
    }
    getDatasetMeta(e) {
      const r = this.data.datasets[e], n = this._metasets;
      let i = n.filter((o) => o && o._dataset === r).pop();
      return i || (i = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: r && r.order || 0,
        index: e,
        _dataset: r,
        _parsed: [],
        _sorted: false
      }, n.push(i)), i;
    }
    getContext() {
      return this.$context || (this.$context = vn(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(e) {
      const r = this.data.datasets[e];
      if (!r)
        return false;
      const n = this.getDatasetMeta(e);
      return typeof n.hidden == "boolean" ? !n.hidden : !r.hidden;
    }
    setDatasetVisibility(e, r) {
      const n = this.getDatasetMeta(e);
      n.hidden = !r;
    }
    toggleDataVisibility(e) {
      this._hiddenIndices[e] = !this._hiddenIndices[e];
    }
    getDataVisibility(e) {
      return !this._hiddenIndices[e];
    }
    _updateVisibility(e, r, n) {
      const i = n ? "show" : "hide", o = this.getDatasetMeta(e), s = o.controller._resolveAnimations(void 0, i);
      Io(r) ? (o.data[r].hidden = !n, this.update()) : (this.setDatasetVisibility(e, n), s.update(o, {
        visible: n
      }), this.update((a) => a.datasetIndex === e ? i : void 0));
    }
    hide(e, r) {
      this._updateVisibility(e, r, false);
    }
    show(e, r) {
      this._updateVisibility(e, r, true);
    }
    _destroyDatasetMeta(e) {
      const r = this._metasets[e];
      r && r.controller && r.controller._destroy(), delete this._metasets[e];
    }
    _stop() {
      let e, r;
      for (this.stop(), Dr.remove(this), e = 0, r = this.data.datasets.length; e < r; ++e)
        this._destroyDatasetMeta(e);
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas: e, ctx: r } = this;
      this._stop(), this.config.clearCache(), e && (this.unbindEvents(), Rd(e, r), this.platform.releaseContext(r), this.canvas = null, this.ctx = null), delete Xs[this.id], this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...e) {
      return this.canvas.toDataURL(...e);
    }
    bindEvents() {
      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
    }
    bindUserEvents() {
      const e = this._listeners, r = this.platform, n = (o, s) => {
        r.addEventListener(this, o, s), e[o] = s;
      }, i = (o, s, a) => {
        o.offsetX = s, o.offsetY = a, this._eventHandler(o);
      };
      $e(this.options.events, (o) => n(o, i));
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {});
      const e = this._responsiveListeners, r = this.platform, n = (l, c) => {
        r.addEventListener(this, l, c), e[l] = c;
      }, i = (l, c) => {
        e[l] && (r.removeEventListener(this, l, c), delete e[l]);
      }, o = (l, c) => {
        this.canvas && this.resize(l, c);
      };
      let s;
      const a = () => {
        i("attach", a), this.attached = true, this.resize(), n("resize", o), n("detach", s);
      };
      s = () => {
        this.attached = false, i("resize", o), this._stop(), this._resize(0, 0), n("attach", a);
      }, r.isAttached(this.canvas) ? a() : s();
    }
    unbindEvents() {
      $e(this._listeners, (e, r) => {
        this.platform.removeEventListener(this, r, e);
      }), this._listeners = {}, $e(this._responsiveListeners, (e, r) => {
        this.platform.removeEventListener(this, r, e);
      }), this._responsiveListeners = void 0;
    }
    updateHoverStyle(e, r, n) {
      const i = n ? "set" : "remove";
      let o, s, a, l;
      for (r === "dataset" && (o = this.getDatasetMeta(e[0].datasetIndex), o.controller["_" + i + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) {
        s = e[a];
        const c = s && this.getDatasetMeta(s.datasetIndex).controller;
        c && c[i + "HoverStyle"](s.element, s.datasetIndex, s.index);
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(e) {
      const r = this._active || [], n = e.map(({ datasetIndex: o, index: s }) => {
        const a = this.getDatasetMeta(o);
        if (!a)
          throw new Error("No dataset found at index " + o);
        return {
          datasetIndex: o,
          element: a.data[s],
          index: s
        };
      });
      !ga(n, r) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, r));
    }
    notifyPlugins(e, r, n) {
      return this._plugins.notify(this, e, r, n);
    }
    isPluginEnabled(e) {
      return this._plugins._cache.filter((r) => r.plugin.id === e).length === 1;
    }
    _updateHoverStyles(e, r, n) {
      const i = this.options.hover, o = (l, c) => l.filter((u) => !c.some((f) => u.datasetIndex === f.datasetIndex && u.index === f.index)), s = o(r, e), a = n ? e : o(e, r);
      s.length && this.updateHoverStyle(s, i.mode, false), a.length && i.mode && this.updateHoverStyle(a, i.mode, true);
    }
    _eventHandler(e, r) {
      const n = {
        event: e,
        replay: r,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      }, i = (s) => (s.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", n, i) === false)
        return;
      const o = this._handleEvent(e, r, n.inChartArea);
      return n.cancelable = false, this.notifyPlugins("afterEvent", n, i), (o || n.changed) && this.render(), this;
    }
    _handleEvent(e, r, n) {
      const { _active: i = [], options: o } = this, s = r, a = this._getActiveElements(e, i, n, s), l = t2(e), c = Y6(e, this._lastEvent, n, l);
      n && (this._lastEvent = null, nt(o.onHover, [
        e,
        a,
        this
      ], this), l && nt(o.onClick, [
        e,
        a,
        this
      ], this));
      const u = !ga(a, i);
      return (u || r) && (this._active = a, this._updateHoverStyles(a, i, r)), this._lastEvent = c, u;
    }
    _getActiveElements(e, r, n, i) {
      if (e.type === "mouseout")
        return [];
      if (!n)
        return r;
      const o = this.options.hover;
      return this.getElementsAtEventForMode(e, o.mode, o, i);
    }
  }
  ye(Lr, "defaults", gt), ye(Lr, "instances", Xs), ye(Lr, "overrides", Yn), ye(Lr, "registry", Ar), ye(Lr, "version", z6), ye(Lr, "getChart", hh);
  function ph() {
    return $e(Lr.instances, (t10) => t10._plugins.invalidate());
  }
  function X6(t10, e, r) {
    const { startAngle: n, pixelMargin: i, x: o, y: s, outerRadius: a, innerRadius: l } = e;
    let c = i / a;
    t10.beginPath(), t10.arc(o, s, a, n - c, r + c), l > i ? (c = i / l, t10.arc(o, s, l, r + c, n - c, true)) : t10.arc(o, s, i, r + mt, n - mt), t10.closePath(), t10.clip();
  }
  function J6(t10) {
    return Vu(t10, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function Q6(t10, e, r, n) {
    const i = J6(t10.options.borderRadius), o = (r - e) / 2, s = Math.min(o, n * e / 2), a = (l) => {
      const c = (r - Math.min(o, l)) * n / 2;
      return St(l, 0, Math.min(o, c));
    };
    return {
      outerStart: a(i.outerStart),
      outerEnd: a(i.outerEnd),
      innerStart: St(i.innerStart, 0, s),
      innerEnd: St(i.innerEnd, 0, s)
    };
  }
  function ti(t10, e, r, n) {
    return {
      x: r + t10 * Math.cos(e),
      y: n + t10 * Math.sin(e)
    };
  }
  function wa(t10, e, r, n, i, o) {
    const { x: s, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, f = Math.max(e.outerRadius + n + r - c, 0), d = u > 0 ? u + n + r + c : 0;
    let h = 0;
    const g = i - l;
    if (n) {
      const U = u > 0 ? u - n : 0, I = f > 0 ? f - n : 0, V = (U + I) / 2, te = V !== 0 ? g * V / (V + n) : g;
      h = (g - te) / 2;
    }
    const p = Math.max(1e-3, g * f - r / st) / f, y = (g - p) / 2, b = l + y + h, x = i - y - h, { outerStart: S, outerEnd: O, innerStart: _, innerEnd: L } = Q6(e, d, f, x - b), N = f - S, j = f - O, W = b + S / N, G = x - O / j, ee = d + _, fe = d + L, P10 = b + _ / ee, z10 = x - L / fe;
    if (t10.beginPath(), o) {
      const U = (W + G) / 2;
      if (t10.arc(s, a, f, W, U), t10.arc(s, a, f, U, G), O > 0) {
        const X = ti(j, G, s, a);
        t10.arc(X.x, X.y, O, G, x + mt);
      }
      const I = ti(fe, x, s, a);
      if (t10.lineTo(I.x, I.y), L > 0) {
        const X = ti(fe, z10, s, a);
        t10.arc(X.x, X.y, L, x + mt, z10 + Math.PI);
      }
      const V = (x - L / d + (b + _ / d)) / 2;
      if (t10.arc(s, a, d, x - L / d, V, true), t10.arc(s, a, d, V, b + _ / d, true), _ > 0) {
        const X = ti(ee, P10, s, a);
        t10.arc(X.x, X.y, _, P10 + Math.PI, b - mt);
      }
      const te = ti(N, b, s, a);
      if (t10.lineTo(te.x, te.y), S > 0) {
        const X = ti(N, W, s, a);
        t10.arc(X.x, X.y, S, b - mt, W);
      }
    } else {
      t10.moveTo(s, a);
      const U = Math.cos(W) * f + s, I = Math.sin(W) * f + a;
      t10.lineTo(U, I);
      const V = Math.cos(G) * f + s, te = Math.sin(G) * f + a;
      t10.lineTo(V, te);
    }
    t10.closePath();
  }
  function G6(t10, e, r, n, i) {
    const { fullCircles: o, startAngle: s, circumference: a } = e;
    let l = e.endAngle;
    if (o) {
      wa(t10, e, r, n, l, i);
      for (let c = 0; c < o; ++c)
        t10.fill();
      isNaN(a) || (l = s + (a % ot || ot));
    }
    return wa(t10, e, r, n, l, i), t10.fill(), l;
  }
  function Z6(t10, e, r, n, i) {
    const { fullCircles: o, startAngle: s, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u, borderDash: f, borderDashOffset: d } = l, h = l.borderAlign === "inner";
    if (!c)
      return;
    t10.setLineDash(f || []), t10.lineDashOffset = d, h ? (t10.lineWidth = c * 2, t10.lineJoin = u || "round") : (t10.lineWidth = c, t10.lineJoin = u || "bevel");
    let g = e.endAngle;
    if (o) {
      wa(t10, e, r, n, g, i);
      for (let p = 0; p < o; ++p)
        t10.stroke();
      isNaN(a) || (g = s + (a % ot || ot));
    }
    h && X6(t10, e, g), o || (wa(t10, e, r, n, g, i), t10.stroke());
  }
  class ao extends Jr {
    constructor(r) {
      super();
      ye(this, "circumference");
      ye(this, "endAngle");
      ye(this, "fullCircles");
      ye(this, "innerRadius");
      ye(this, "outerRadius");
      ye(this, "pixelMargin");
      ye(this, "startAngle");
      this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, r && Object.assign(this, r);
    }
    inRange(r, n, i) {
      const o = this.getProps([
        "x",
        "y"
      ], i), { angle: s, distance: a } = g1(o, {
        x: r,
        y: n
      }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: f, circumference: d } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], i), h = (this.options.spacing + this.options.borderWidth) / 2, p = Oe(d, c - l) >= ot || Po(s, l, c), y = Wr(a, u + h, f + h);
      return p && y;
    }
    getCenterPoint(r) {
      const { x: n, y: i, startAngle: o, endAngle: s, innerRadius: a, outerRadius: l } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], r), { offset: c, spacing: u } = this.options, f = (o + s) / 2, d = (a + l + u + c) / 2;
      return {
        x: n + Math.cos(f) * d,
        y: i + Math.sin(f) * d
      };
    }
    tooltipPosition(r) {
      return this.getCenterPoint(r);
    }
    draw(r) {
      const { options: n, circumference: i } = this, o = (n.offset || 0) / 4, s = (n.spacing || 0) / 2, a = n.circular;
      if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > ot ? Math.floor(i / ot) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0)
        return;
      r.save();
      const l = (this.startAngle + this.endAngle) / 2;
      r.translate(Math.cos(l) * o, Math.sin(l) * o);
      const c = 1 - Math.sin(Math.min(st, i || 0)), u = o * c;
      r.fillStyle = n.backgroundColor, r.strokeStyle = n.borderColor, G6(r, this, u, s, a), Z6(r, this, u, s, a), r.restore();
    }
  }
  ye(ao, "id", "arc"), ye(ao, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  }), ye(ao, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  }), ye(ao, "descriptors", {
    _scriptable: true,
    _indexable: (r) => r !== "borderDash"
  });
  function J1(t10, e, r = e) {
    t10.lineCap = Oe(r.borderCapStyle, e.borderCapStyle), t10.setLineDash(Oe(r.borderDash, e.borderDash)), t10.lineDashOffset = Oe(r.borderDashOffset, e.borderDashOffset), t10.lineJoin = Oe(r.borderJoinStyle, e.borderJoinStyle), t10.lineWidth = Oe(r.borderWidth, e.borderWidth), t10.strokeStyle = Oe(r.borderColor, e.borderColor);
  }
  function $6(t10, e, r) {
    t10.lineTo(r.x, r.y);
  }
  function eA(t10) {
    return t10.stepped ? _2 : t10.tension || t10.cubicInterpolationMode === "monotone" ? S2 : $6;
  }
  function Q1(t10, e, r = {}) {
    const n = t10.length, { start: i = 0, end: o = n - 1 } = r, { start: s, end: a } = e, l = Math.max(i, s), c = Math.min(o, a), u = i < s && o < s || i > a && o > a;
    return {
      count: n,
      start: l,
      loop: e.loop,
      ilen: c < l && !u ? n + c - l : c - l
    };
  }
  function tA(t10, e, r, n) {
    const { points: i, options: o } = e, { count: s, start: a, loop: l, ilen: c } = Q1(i, r, n), u = eA(o);
    let { move: f = true, reverse: d } = n || {}, h, g, p;
    for (h = 0; h <= c; ++h)
      g = i[(a + (d ? c - h : h)) % s], !g.skip && (f ? (t10.moveTo(g.x, g.y), f = false) : u(t10, p, g, d, o.stepped), p = g);
    return l && (g = i[(a + (d ? c : 0)) % s], u(t10, p, g, d, o.stepped)), !!l;
  }
  function rA(t10, e, r, n) {
    const i = e.points, { count: o, start: s, ilen: a } = Q1(i, r, n), { move: l = true, reverse: c } = n || {};
    let u = 0, f = 0, d, h, g, p, y, b;
    const x = (O) => (s + (c ? a - O : O)) % o, S = () => {
      p !== y && (t10.lineTo(u, y), t10.lineTo(u, p), t10.lineTo(u, b));
    };
    for (l && (h = i[x(0)], t10.moveTo(h.x, h.y)), d = 0; d <= a; ++d) {
      if (h = i[x(d)], h.skip)
        continue;
      const O = h.x, _ = h.y, L = O | 0;
      L === g ? (_ < p ? p = _ : _ > y && (y = _), u = (f * u + O) / ++f) : (S(), t10.lineTo(O, _), g = L, f = 0, p = y = _), b = _;
    }
    S();
  }
  function jc(t10) {
    const e = t10.options, r = e.borderDash && e.borderDash.length;
    return !t10._decimated && !t10._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !r ? rA : tA;
  }
  function nA(t10) {
    return t10.stepped ? rv : t10.tension || t10.cubicInterpolationMode === "monotone" ? nv : Rn;
  }
  function iA(t10, e, r, n) {
    let i = e._path;
    i || (i = e._path = new Path2D(), e.path(i, r, n) && i.closePath()), J1(t10, e.options), t10.stroke(i);
  }
  function oA(t10, e, r, n) {
    const { segments: i, options: o } = e, s = jc(e);
    for (const a of i)
      J1(t10, o, a.style), t10.beginPath(), s(t10, e, a, {
        start: r,
        end: r + n - 1
      }) && t10.closePath(), t10.stroke();
  }
  const sA = typeof Path2D == "function";
  function aA(t10, e, r, n) {
    sA && !e.options.segment ? iA(t10, e, r, n) : oA(t10, e, r, n);
  }
  class nn extends Jr {
    constructor(e) {
      super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, e && Object.assign(this, e);
    }
    updateControlPoints(e, r) {
      const n = this.options;
      if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
        const i = n.spanGaps ? this._loop : this._fullLoop;
        X2(this._points, n, e, i, r), this._pointsUpdated = true;
      }
    }
    set points(e) {
      this._points = e, delete this._segments, delete this._path, this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = cv(this, this.options.segment));
    }
    first() {
      const e = this.segments, r = this.points;
      return e.length && r[e[0].start];
    }
    last() {
      const e = this.segments, r = this.points, n = e.length;
      return n && r[e[n - 1].end];
    }
    interpolate(e, r) {
      const n = this.options, i = e[r], o = this.points, s = L1(this, {
        property: r,
        start: i,
        end: i
      });
      if (!s.length)
        return;
      const a = [], l = nA(n);
      let c, u;
      for (c = 0, u = s.length; c < u; ++c) {
        const { start: f, end: d } = s[c], h = o[f], g = o[d];
        if (h === g) {
          a.push(h);
          continue;
        }
        const p = Math.abs((i - h[r]) / (g[r] - h[r])), y = l(h, g, p, n.stepped);
        y[r] = e[r], a.push(y);
      }
      return a.length === 1 ? a[0] : a;
    }
    pathSegment(e, r, n) {
      return jc(this)(e, this, r, n);
    }
    path(e, r, n) {
      const i = this.segments, o = jc(this);
      let s = this._loop;
      r = r || 0, n = n || this.points.length - r;
      for (const a of i)
        s &= o(e, this, a, {
          start: r,
          end: r + n - 1
        });
      return !!s;
    }
    draw(e, r, n, i) {
      const o = this.options || {};
      (this.points || []).length && o.borderWidth && (e.save(), aA(e, this, n, i), e.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
    }
  }
  ye(nn, "id", "line"), ye(nn, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  }), ye(nn, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  }), ye(nn, "descriptors", {
    _scriptable: true,
    _indexable: (e) => e !== "borderDash" && e !== "fill"
  });
  function gh(t10, e, r, n) {
    const i = t10.options, { [r]: o } = t10.getProps([
      r
    ], n);
    return Math.abs(e - o) < i.radius + i.hitRadius;
  }
  class Js extends Jr {
    constructor(r) {
      super();
      ye(this, "parsed");
      ye(this, "skip");
      ye(this, "stop");
      this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, r && Object.assign(this, r);
    }
    inRange(r, n, i) {
      const o = this.options, { x: s, y: a } = this.getProps([
        "x",
        "y"
      ], i);
      return Math.pow(r - s, 2) + Math.pow(n - a, 2) < Math.pow(o.hitRadius + o.radius, 2);
    }
    inXRange(r, n) {
      return gh(this, r, "x", n);
    }
    inYRange(r, n) {
      return gh(this, r, "y", n);
    }
    getCenterPoint(r) {
      const { x: n, y: i } = this.getProps([
        "x",
        "y"
      ], r);
      return {
        x: n,
        y: i
      };
    }
    size(r) {
      r = r || this.options || {};
      let n = r.radius || 0;
      n = Math.max(n, n && r.hoverRadius || 0);
      const i = n && r.borderWidth || 0;
      return (n + i) * 2;
    }
    draw(r, n) {
      const i = this.options;
      this.skip || i.radius < 0.1 || !zr(this, n, this.size(i) / 2) || (r.strokeStyle = i.borderColor, r.lineWidth = i.borderWidth, r.fillStyle = i.backgroundColor, Nc(r, i, this.x, this.y));
    }
    getRange() {
      const r = this.options || {};
      return r.radius + r.hitRadius;
    }
  }
  ye(Js, "id", "point"), /**
  * @type {any}
  */
  ye(Js, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  }), /**
  * @type {any}
  */
  ye(Js, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function G1(t10, e) {
    const { x: r, y: n, base: i, width: o, height: s } = t10.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], e);
    let a, l, c, u, f;
    return t10.horizontal ? (f = s / 2, a = Math.min(r, i), l = Math.max(r, i), c = n - f, u = n + f) : (f = o / 2, a = r - f, l = r + f, c = Math.min(n, i), u = Math.max(n, i)), {
      left: a,
      top: c,
      right: l,
      bottom: u
    };
  }
  function on(t10, e, r, n) {
    return t10 ? 0 : St(e, r, n);
  }
  function lA(t10, e, r) {
    const n = t10.options.borderWidth, i = t10.borderSkipped, o = S1(n);
    return {
      t: on(i.top, o.top, 0, r),
      r: on(i.right, o.right, 0, e),
      b: on(i.bottom, o.bottom, 0, r),
      l: on(i.left, o.left, 0, e)
    };
  }
  function cA(t10, e, r) {
    const { enableBorderRadius: n } = t10.getProps([
      "enableBorderRadius"
    ]), i = t10.options.borderRadius, o = Fn(i), s = Math.min(e, r), a = t10.borderSkipped, l = n || Le(i);
    return {
      topLeft: on(!l || a.top || a.left, o.topLeft, 0, s),
      topRight: on(!l || a.top || a.right, o.topRight, 0, s),
      bottomLeft: on(!l || a.bottom || a.left, o.bottomLeft, 0, s),
      bottomRight: on(!l || a.bottom || a.right, o.bottomRight, 0, s)
    };
  }
  function uA(t10) {
    const e = G1(t10), r = e.right - e.left, n = e.bottom - e.top, i = lA(t10, r / 2, n / 2), o = cA(t10, r / 2, n / 2);
    return {
      outer: {
        x: e.left,
        y: e.top,
        w: r,
        h: n,
        radius: o
      },
      inner: {
        x: e.left + i.l,
        y: e.top + i.t,
        w: r - i.l - i.r,
        h: n - i.t - i.b,
        radius: {
          topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)),
          topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)),
          bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)),
          bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r))
        }
      }
    };
  }
  function Zl(t10, e, r, n) {
    const i = e === null, o = r === null, a = t10 && !(i && o) && G1(t10, n);
    return a && (i || Wr(e, a.left, a.right)) && (o || Wr(r, a.top, a.bottom));
  }
  function fA(t10) {
    return t10.topLeft || t10.topRight || t10.bottomLeft || t10.bottomRight;
  }
  function dA(t10, e) {
    t10.rect(e.x, e.y, e.w, e.h);
  }
  function $l(t10, e, r = {}) {
    const n = t10.x !== r.x ? -e : 0, i = t10.y !== r.y ? -e : 0, o = (t10.x + t10.w !== r.x + r.w ? e : 0) - n, s = (t10.y + t10.h !== r.y + r.h ? e : 0) - i;
    return {
      x: t10.x + n,
      y: t10.y + i,
      w: t10.w + o,
      h: t10.h + s,
      radius: t10.radius
    };
  }
  class Qs extends Jr {
    constructor(e) {
      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
    }
    draw(e) {
      const { inflateAmount: r, options: { borderColor: n, backgroundColor: i } } = this, { inner: o, outer: s } = uA(this), a = fA(s.radius) ? Ro : dA;
      e.save(), (s.w !== o.w || s.h !== o.h) && (e.beginPath(), a(e, $l(s, r, o)), e.clip(), a(e, $l(o, -r, s)), e.fillStyle = n, e.fill("evenodd")), e.beginPath(), a(e, $l(o, r)), e.fillStyle = i, e.fill(), e.restore();
    }
    inRange(e, r, n) {
      return Zl(this, e, r, n);
    }
    inXRange(e, r) {
      return Zl(this, e, null, r);
    }
    inYRange(e, r) {
      return Zl(this, null, e, r);
    }
    getCenterPoint(e) {
      const { x: r, y: n, base: i, horizontal: o } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], e);
      return {
        x: o ? (r + i) / 2 : r,
        y: o ? n : (n + i) / 2
      };
    }
    getRange(e) {
      return e === "x" ? this.width / 2 : this.height / 2;
    }
  }
  ye(Qs, "id", "bar"), ye(Qs, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  }), ye(Qs, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var hA = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement: ao,
    BarElement: Qs,
    LineElement: nn,
    PointElement: Js
  });
  const Wc = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ], mh = /* @__PURE__ */ Wc.map((t10) => t10.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function Z1(t10) {
    return Wc[t10 % Wc.length];
  }
  function $1(t10) {
    return mh[t10 % mh.length];
  }
  function pA(t10, e) {
    return t10.borderColor = Z1(e), t10.backgroundColor = $1(e), ++e;
  }
  function gA(t10, e) {
    return t10.backgroundColor = t10.data.map(() => Z1(e++)), e;
  }
  function mA(t10, e) {
    return t10.backgroundColor = t10.data.map(() => $1(e++)), e;
  }
  function yA(t10) {
    let e = 0;
    return (r, n) => {
      const i = t10.getDatasetMeta(n).controller;
      i instanceof Bn ? e = gA(r, e) : i instanceof Ao ? e = mA(r, e) : i && (e = pA(r, e));
    };
  }
  function yh(t10) {
    let e;
    for (e in t10)
      if (t10[e].borderColor || t10[e].backgroundColor)
        return true;
    return false;
  }
  function bA(t10) {
    return t10 && (t10.borderColor || t10.backgroundColor);
  }
  var vA = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(t10, e, r) {
      if (!r.enabled)
        return;
      const { data: { datasets: n }, options: i } = t10.config, { elements: o } = i;
      if (!r.forceOverride && (yh(n) || bA(i) || o && yh(o)))
        return;
      const s = yA(t10);
      n.forEach(s);
    }
  };
  function AA(t10, e, r, n, i) {
    const o = i.samples || n;
    if (o >= r)
      return t10.slice(e, e + r);
    const s = [], a = (r - 2) / (o - 2);
    let l = 0;
    const c = e + r - 1;
    let u = e, f, d, h, g, p;
    for (s[l++] = t10[u], f = 0; f < o - 2; f++) {
      let y = 0, b = 0, x;
      const S = Math.floor((f + 1) * a) + 1 + e, O = Math.min(Math.floor((f + 2) * a) + 1, r) + e, _ = O - S;
      for (x = S; x < O; x++)
        y += t10[x].x, b += t10[x].y;
      y /= _, b /= _;
      const L = Math.floor(f * a) + 1 + e, N = Math.min(Math.floor((f + 1) * a) + 1, r) + e, { x: j, y: W } = t10[u];
      for (h = g = -1, x = L; x < N; x++)
        g = 0.5 * Math.abs((j - y) * (t10[x].y - W) - (j - t10[x].x) * (b - W)), g > h && (h = g, d = t10[x], p = x);
      s[l++] = d, u = p;
    }
    return s[l++] = t10[c], s;
  }
  function wA(t10, e, r, n) {
    let i = 0, o = 0, s, a, l, c, u, f, d, h, g, p;
    const y = [], b = e + r - 1, x = t10[e].x, O = t10[b].x - x;
    for (s = e; s < e + r; ++s) {
      a = t10[s], l = (a.x - x) / O * n, c = a.y;
      const _ = l | 0;
      if (_ === u)
        c < g ? (g = c, f = s) : c > p && (p = c, d = s), i = (o * i + a.x) / ++o;
      else {
        const L = s - 1;
        if (!We(f) && !We(d)) {
          const N = Math.min(f, d), j = Math.max(f, d);
          N !== h && N !== L && y.push({
            ...t10[N],
            x: i
          }), j !== h && j !== L && y.push({
            ...t10[j],
            x: i
          });
        }
        s > 0 && L !== h && y.push(t10[L]), y.push(a), u = _, o = 0, g = p = c, f = d = h = s;
      }
    }
    return y;
  }
  function eg(t10) {
    if (t10._decimated) {
      const e = t10._data;
      delete t10._decimated, delete t10._data, Object.defineProperty(t10, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: e
      });
    }
  }
  function bh(t10) {
    t10.data.datasets.forEach((e) => {
      eg(e);
    });
  }
  function xA(t10, e) {
    const r = e.length;
    let n = 0, i;
    const { iScale: o } = t10, { min: s, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();
    return l && (n = St(Ur(e, o.axis, s).lo, 0, r - 1)), c ? i = St(Ur(e, o.axis, a).hi + 1, n, r) - n : i = r - n, {
      start: n,
      count: i
    };
  }
  var _A = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (t10, e, r) => {
      if (!r.enabled) {
        bh(t10);
        return;
      }
      const n = t10.width;
      t10.data.datasets.forEach((i, o) => {
        const { _data: s, indexAxis: a } = i, l = t10.getDatasetMeta(o), c = s || i.data;
        if (oo([
          a,
          t10.options.indexAxis
        ]) === "y" || !l.controller.supportsDecimation)
          return;
        const u = t10.scales[l.xAxisID];
        if (u.type !== "linear" && u.type !== "time" || t10.options.parsing)
          return;
        let { start: f, count: d } = xA(l, c);
        const h = r.threshold || 4 * n;
        if (d <= h) {
          eg(i);
          return;
        }
        We(s) && (i._data = c, delete i.data, Object.defineProperty(i, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(p) {
            this._data = p;
          }
        }));
        let g;
        switch (r.algorithm) {
          case "lttb":
            g = AA(c, f, d, n, r);
            break;
          case "min-max":
            g = wA(c, f, d, n);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${r.algorithm}'`);
        }
        i._decimated = g;
      });
    },
    destroy(t10) {
      bh(t10);
    }
  };
  function SA(t10, e, r) {
    const n = t10.segments, i = t10.points, o = e.points, s = [];
    for (const a of n) {
      let { start: l, end: c } = a;
      c = Ju(l, c, i);
      const u = Uc(r, i[l], i[c], a.loop);
      if (!e.segments) {
        s.push({
          source: a,
          target: u,
          start: i[l],
          end: i[c]
        });
        continue;
      }
      const f = L1(e, u);
      for (const d of f) {
        const h = Uc(r, o[d.start], o[d.end], d.loop), g = N1(a, i, h);
        for (const p of g)
          s.push({
            source: p,
            target: d,
            start: {
              [r]: vh(u, h, "start", Math.max)
            },
            end: {
              [r]: vh(u, h, "end", Math.min)
            }
          });
      }
    }
    return s;
  }
  function Uc(t10, e, r, n) {
    if (n)
      return;
    let i = e[t10], o = r[t10];
    return t10 === "angle" && (i = Yt(i), o = Yt(o)), {
      property: t10,
      start: i,
      end: o
    };
  }
  function EA(t10, e) {
    const { x: r = null, y: n = null } = t10 || {}, i = e.points, o = [];
    return e.segments.forEach(({ start: s, end: a }) => {
      a = Ju(s, a, i);
      const l = i[s], c = i[a];
      n !== null ? (o.push({
        x: l.x,
        y: n
      }), o.push({
        x: c.x,
        y: n
      })) : r !== null && (o.push({
        x: r,
        y: l.y
      }), o.push({
        x: r,
        y: c.y
      }));
    }), o;
  }
  function Ju(t10, e, r) {
    for (; e > t10; e--) {
      const n = r[e];
      if (!isNaN(n.x) && !isNaN(n.y))
        break;
    }
    return e;
  }
  function vh(t10, e, r, n) {
    return t10 && e ? n(t10[r], e[r]) : t10 ? t10[r] : e ? e[r] : 0;
  }
  function tg(t10, e) {
    let r = [], n = false;
    return it(t10) ? (n = true, r = t10) : r = EA(t10, e), r.length ? new nn({
      points: r,
      options: {
        tension: 0
      },
      _loop: n,
      _fullLoop: n
    }) : null;
  }
  function Ah(t10) {
    return t10 && t10.fill !== false;
  }
  function kA(t10, e, r) {
    let i = t10[e].fill;
    const o = [
      e
    ];
    let s;
    if (!r)
      return i;
    for (; i !== false && o.indexOf(i) === -1; ) {
      if (!pt(i))
        return i;
      if (s = t10[i], !s)
        return false;
      if (s.visible)
        return i;
      o.push(i), i = s.fill;
    }
    return false;
  }
  function CA(t10, e, r) {
    const n = PA(t10);
    if (Le(n))
      return isNaN(n.value) ? false : n;
    let i = parseFloat(n);
    return pt(i) && Math.floor(i) === i ? TA(n[0], e, i, r) : [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(n) >= 0 && n;
  }
  function TA(t10, e, r, n) {
    return (t10 === "-" || t10 === "+") && (r = e + r), r === e || r < 0 || r >= n ? false : r;
  }
  function OA(t10, e) {
    let r = null;
    return t10 === "start" ? r = e.bottom : t10 === "end" ? r = e.top : Le(t10) ? r = e.getPixelForValue(t10.value) : e.getBasePixel && (r = e.getBasePixel()), r;
  }
  function IA(t10, e, r) {
    let n;
    return t10 === "start" ? n = r : t10 === "end" ? n = e.options.reverse ? e.min : e.max : Le(t10) ? n = t10.value : n = e.getBaseValue(), n;
  }
  function PA(t10) {
    const e = t10.options, r = e.fill;
    let n = Oe(r && r.target, r);
    return n === void 0 && (n = !!e.backgroundColor), n === false || n === null ? false : n === true ? "origin" : n;
  }
  function RA(t10) {
    const { scale: e, index: r, line: n } = t10, i = [], o = n.segments, s = n.points, a = DA(e, r);
    a.push(tg({
      x: null,
      y: e.bottom
    }, n));
    for (let l = 0; l < o.length; l++) {
      const c = o[l];
      for (let u = c.start; u <= c.end; u++)
        MA(i, s[u], a);
    }
    return new nn({
      points: i,
      options: {}
    });
  }
  function DA(t10, e) {
    const r = [], n = t10.getMatchingVisibleMetas("line");
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      if (o.index === e)
        break;
      o.hidden || r.unshift(o.dataset);
    }
    return r;
  }
  function MA(t10, e, r) {
    const n = [];
    for (let i = 0; i < r.length; i++) {
      const o = r[i], { first: s, last: a, point: l } = NA(o, e, "x");
      if (!(!l || s && a)) {
        if (s)
          n.unshift(l);
        else if (t10.push(l), !a)
          break;
      }
    }
    t10.push(...n);
  }
  function NA(t10, e, r) {
    const n = t10.interpolate(e, r);
    if (!n)
      return {};
    const i = n[r], o = t10.segments, s = t10.points;
    let a = false, l = false;
    for (let c = 0; c < o.length; c++) {
      const u = o[c], f = s[u.start][r], d = s[u.end][r];
      if (Wr(i, f, d)) {
        a = i === f, l = i === d;
        break;
      }
    }
    return {
      first: a,
      last: l,
      point: n
    };
  }
  class rg {
    constructor(e) {
      this.x = e.x, this.y = e.y, this.radius = e.radius;
    }
    pathSegment(e, r, n) {
      const { x: i, y: o, radius: s } = this;
      return r = r || {
        start: 0,
        end: ot
      }, e.arc(i, o, s, r.end, r.start, true), !n.bounds;
    }
    interpolate(e) {
      const { x: r, y: n, radius: i } = this, o = e.angle;
      return {
        x: r + Math.cos(o) * i,
        y: n + Math.sin(o) * i,
        angle: o
      };
    }
  }
  function LA(t10) {
    const { chart: e, fill: r, line: n } = t10;
    if (pt(r))
      return BA(e, r);
    if (r === "stack")
      return RA(t10);
    if (r === "shape")
      return true;
    const i = FA(t10);
    return i instanceof rg ? i : tg(i, n);
  }
  function BA(t10, e) {
    const r = t10.getDatasetMeta(e);
    return r && t10.isDatasetVisible(e) ? r.dataset : null;
  }
  function FA(t10) {
    return (t10.scale || {}).getPointPositionForValue ? WA(t10) : jA(t10);
  }
  function jA(t10) {
    const { scale: e = {}, fill: r } = t10, n = OA(r, e);
    if (pt(n)) {
      const i = e.isHorizontal();
      return {
        x: i ? n : null,
        y: i ? null : n
      };
    }
    return null;
  }
  function WA(t10) {
    const { scale: e, fill: r } = t10, n = e.options, i = e.getLabels().length, o = n.reverse ? e.max : e.min, s = IA(r, e, o), a = [];
    if (n.grid.circular) {
      const l = e.getPointPositionForValue(0, o);
      return new rg({
        x: l.x,
        y: l.y,
        radius: e.getDistanceFromCenterForValue(s)
      });
    }
    for (let l = 0; l < i; ++l)
      a.push(e.getPointPositionForValue(l, s));
    return a;
  }
  function ec(t10, e, r) {
    const n = LA(e), { line: i, scale: o, axis: s } = e, a = i.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: f = c } = l || {};
    n && i.points.length && (Ka(t10, r), UA(t10, {
      line: i,
      target: n,
      above: u,
      below: f,
      area: r,
      scale: o,
      axis: s
    }), Xa(t10));
  }
  function UA(t10, e) {
    const { line: r, target: n, above: i, below: o, area: s, scale: a } = e, l = r._loop ? "angle" : e.axis;
    t10.save(), l === "x" && o !== i && (wh(t10, n, s.top), xh(t10, {
      line: r,
      target: n,
      color: i,
      scale: a,
      property: l
    }), t10.restore(), t10.save(), wh(t10, n, s.bottom)), xh(t10, {
      line: r,
      target: n,
      color: o,
      scale: a,
      property: l
    }), t10.restore();
  }
  function wh(t10, e, r) {
    const { segments: n, points: i } = e;
    let o = true, s = false;
    t10.beginPath();
    for (const a of n) {
      const { start: l, end: c } = a, u = i[l], f = i[Ju(l, c, i)];
      o ? (t10.moveTo(u.x, u.y), o = false) : (t10.lineTo(u.x, r), t10.lineTo(u.x, u.y)), s = !!e.pathSegment(t10, a, {
        move: s
      }), s ? t10.closePath() : t10.lineTo(f.x, r);
    }
    t10.lineTo(e.first().x, r), t10.closePath(), t10.clip();
  }
  function xh(t10, e) {
    const { line: r, target: n, property: i, color: o, scale: s } = e, a = SA(r, n, i);
    for (const { source: l, target: c, start: u, end: f } of a) {
      const { style: { backgroundColor: d = o } = {} } = l, h = n !== true;
      t10.save(), t10.fillStyle = d, zA(t10, s, h && Uc(i, u, f)), t10.beginPath();
      const g = !!r.pathSegment(t10, l);
      let p;
      if (h) {
        g ? t10.closePath() : _h(t10, n, f, i);
        const y = !!n.pathSegment(t10, c, {
          move: g,
          reverse: true
        });
        p = g && y, p || _h(t10, n, u, i);
      }
      t10.closePath(), t10.fill(p ? "evenodd" : "nonzero"), t10.restore();
    }
  }
  function zA(t10, e, r) {
    const { top: n, bottom: i } = e.chart.chartArea, { property: o, start: s, end: a } = r || {};
    o === "x" && (t10.beginPath(), t10.rect(s, n, a - s, i - n), t10.clip());
  }
  function _h(t10, e, r, n) {
    const i = e.interpolate(r, n);
    i && t10.lineTo(i.x, i.y);
  }
  var VA = {
    id: "filler",
    afterDatasetsUpdate(t10, e, r) {
      const n = (t10.data.datasets || []).length, i = [];
      let o, s, a, l;
      for (s = 0; s < n; ++s)
        o = t10.getDatasetMeta(s), a = o.dataset, l = null, a && a.options && a instanceof nn && (l = {
          visible: t10.isDatasetVisible(s),
          index: s,
          fill: CA(a, s, n),
          chart: t10,
          axis: o.controller.options.indexAxis,
          scale: o.vScale,
          line: a
        }), o.$filler = l, i.push(l);
      for (s = 0; s < n; ++s)
        l = i[s], !(!l || l.fill === false) && (l.fill = kA(i, s, r.propagate));
    },
    beforeDraw(t10, e, r) {
      const n = r.drawTime === "beforeDraw", i = t10.getSortedVisibleDatasetMetas(), o = t10.chartArea;
      for (let s = i.length - 1; s >= 0; --s) {
        const a = i[s].$filler;
        a && (a.line.updateControlPoints(o, a.axis), n && a.fill && ec(t10.ctx, a, o));
      }
    },
    beforeDatasetsDraw(t10, e, r) {
      if (r.drawTime !== "beforeDatasetsDraw")
        return;
      const n = t10.getSortedVisibleDatasetMetas();
      for (let i = n.length - 1; i >= 0; --i) {
        const o = n[i].$filler;
        Ah(o) && ec(t10.ctx, o, t10.chartArea);
      }
    },
    beforeDatasetDraw(t10, e, r) {
      const n = e.meta.$filler;
      !Ah(n) || r.drawTime !== "beforeDatasetDraw" || ec(t10.ctx, n, t10.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  const Sh = (t10, e) => {
    let { boxHeight: r = e, boxWidth: n = e } = t10;
    return t10.usePointStyle && (r = Math.min(r, e), n = t10.pointStyleWidth || Math.min(n, e)), {
      boxWidth: n,
      boxHeight: r,
      itemHeight: Math.max(e, r)
    };
  }, qA = (t10, e) => t10 !== null && e !== null && t10.datasetIndex === e.datasetIndex && t10.index === e.index;
  class Eh extends Jr {
    constructor(e) {
      super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
    }
    update(e, r, n) {
      this.maxWidth = e, this.maxHeight = r, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
    }
    setDimensions() {
      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
    }
    buildLabels() {
      const e = this.options.labels || {};
      let r = nt(e.generateLabels, [
        this.chart
      ], this) || [];
      e.filter && (r = r.filter((n) => e.filter(n, this.chart.data))), e.sort && (r = r.sort((n, i) => e.sort(n, i, this.chart.data))), this.options.reverse && r.reverse(), this.legendItems = r;
    }
    fit() {
      const { options: e, ctx: r } = this;
      if (!e.display) {
        this.width = this.height = 0;
        return;
      }
      const n = e.labels, i = vt(n.font), o = i.size, s = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Sh(n, o);
      let c, u;
      r.font = i.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(s, o, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(s, i, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
    }
    _fitRows(e, r, n, i) {
      const { ctx: o, maxWidth: s, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
        0
      ], u = i + a;
      let f = e;
      o.textAlign = "left", o.textBaseline = "middle";
      let d = -1, h = -u;
      return this.legendItems.forEach((g, p) => {
        const y = n + r / 2 + o.measureText(g.text).width;
        (p === 0 || c[c.length - 1] + y + 2 * a > s) && (f += u, c[c.length - (p > 0 ? 0 : 1)] = 0, h += u, d++), l[p] = {
          left: 0,
          top: h,
          row: d,
          width: y,
          height: i
        }, c[c.length - 1] += y + a;
      }), f;
    }
    _fitCols(e, r, n, i) {
      const { ctx: o, maxHeight: s, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = s - e;
      let f = a, d = 0, h = 0, g = 0, p = 0;
      return this.legendItems.forEach((y, b) => {
        const { itemWidth: x, itemHeight: S } = HA(n, r, o, y, i);
        b > 0 && h + S + 2 * a > u && (f += d + a, c.push({
          width: d,
          height: h
        }), g += d + a, p++, d = h = 0), l[b] = {
          left: g,
          top: h,
          col: p,
          width: x,
          height: S
        }, d = Math.max(d, x), h += S + a;
      }), f += d, c.push({
        width: d,
        height: h
      }), f;
    }
    adjustHitBoxes() {
      if (!this.options.display)
        return;
      const e = this._computeTitleHeight(), { legendHitBoxes: r, options: { align: n, labels: { padding: i }, rtl: o } } = this, s = bi(o, this.left, this.width);
      if (this.isHorizontal()) {
        let a = 0, l = It(n, this.left + i, this.right - this.lineWidths[a]);
        for (const c of r)
          a !== c.row && (a = c.row, l = It(n, this.left + i, this.right - this.lineWidths[a])), c.top += this.top + e + i, c.left = s.leftForLtr(s.x(l), c.width), l += c.width + i;
      } else {
        let a = 0, l = It(n, this.top + e + i, this.bottom - this.columnSizes[a].height);
        for (const c of r)
          c.col !== a && (a = c.col, l = It(n, this.top + e + i, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + i, c.left = s.leftForLtr(s.x(c.left), c.width), l += c.height + i;
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const e = this.ctx;
        Ka(e, this), this._draw(), Xa(e);
      }
    }
    _draw() {
      const { options: e, columnSizes: r, lineWidths: n, ctx: i } = this, { align: o, labels: s } = e, a = gt.color, l = bi(e.rtl, this.left, this.width), c = vt(s.font), { padding: u } = s, f = c.size, d = f / 2;
      let h;
      this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = 0.5, i.font = c.string;
      const { boxWidth: g, boxHeight: p, itemHeight: y } = Sh(s, f), b = function(L, N, j) {
        if (isNaN(g) || g <= 0 || isNaN(p) || p < 0)
          return;
        i.save();
        const W = Oe(j.lineWidth, 1);
        if (i.fillStyle = Oe(j.fillStyle, a), i.lineCap = Oe(j.lineCap, "butt"), i.lineDashOffset = Oe(j.lineDashOffset, 0), i.lineJoin = Oe(j.lineJoin, "miter"), i.lineWidth = W, i.strokeStyle = Oe(j.strokeStyle, a), i.setLineDash(Oe(j.lineDash, [])), s.usePointStyle) {
          const G = {
            radius: p * Math.SQRT2 / 2,
            pointStyle: j.pointStyle,
            rotation: j.rotation,
            borderWidth: W
          }, ee = l.xPlus(L, g / 2), fe = N + d;
          _1(i, G, ee, fe, s.pointStyleWidth && g);
        } else {
          const G = N + Math.max((f - p) / 2, 0), ee = l.leftForLtr(L, g), fe = Fn(j.borderRadius);
          i.beginPath(), Object.values(fe).some((P10) => P10 !== 0) ? Ro(i, {
            x: ee,
            y: G,
            w: g,
            h: p,
            radius: fe
          }) : i.rect(ee, G, g, p), i.fill(), W !== 0 && i.stroke();
        }
        i.restore();
      }, x = function(L, N, j) {
        Kn(i, j.text, L, N + y / 2, c, {
          strikethrough: j.hidden,
          textAlign: l.textAlign(j.textAlign)
        });
      }, S = this.isHorizontal(), O = this._computeTitleHeight();
      S ? h = {
        x: It(o, this.left + u, this.right - n[0]),
        y: this.top + u + O,
        line: 0
      } : h = {
        x: this.left + u,
        y: It(o, this.top + O + u, this.bottom - r[0].height),
        line: 0
      }, R1(this.ctx, e.textDirection);
      const _ = y + u;
      this.legendItems.forEach((L, N) => {
        i.strokeStyle = L.fontColor, i.fillStyle = L.fontColor;
        const j = i.measureText(L.text).width, W = l.textAlign(L.textAlign || (L.textAlign = s.textAlign)), G = g + d + j;
        let ee = h.x, fe = h.y;
        l.setWidth(this.width), S ? N > 0 && ee + G + u > this.right && (fe = h.y += _, h.line++, ee = h.x = It(o, this.left + u, this.right - n[h.line])) : N > 0 && fe + _ > this.bottom && (ee = h.x = ee + r[h.line].width + u, h.line++, fe = h.y = It(o, this.top + O + u, this.bottom - r[h.line].height));
        const P10 = l.x(ee);
        if (b(P10, fe, L), ee = d2(W, ee + g + d, S ? ee + G : this.right, e.rtl), x(l.x(ee), fe, L), S)
          h.x += G + u;
        else if (typeof L.text != "string") {
          const z10 = c.lineHeight;
          h.y += ng(L, z10) + u;
        } else
          h.y += _;
      }), D1(this.ctx, e.textDirection);
    }
    drawTitle() {
      const e = this.options, r = e.title, n = vt(r.font), i = Mt(r.padding);
      if (!r.display)
        return;
      const o = bi(e.rtl, this.left, this.width), s = this.ctx, a = r.position, l = n.size / 2, c = i.top + l;
      let u, f = this.left, d = this.width;
      if (this.isHorizontal())
        d = Math.max(...this.lineWidths), u = this.top + c, f = It(e.align, f, this.right - d);
      else {
        const g = this.columnSizes.reduce((p, y) => Math.max(p, y.height), 0);
        u = c + It(e.align, this.top, this.bottom - g - e.labels.padding - this._computeTitleHeight());
      }
      const h = It(a, f, f + d);
      s.textAlign = o.textAlign(Uu(a)), s.textBaseline = "middle", s.strokeStyle = r.color, s.fillStyle = r.color, s.font = n.string, Kn(s, r.text, h, u, n);
    }
    _computeTitleHeight() {
      const e = this.options.title, r = vt(e.font), n = Mt(e.padding);
      return e.display ? r.lineHeight + n.height : 0;
    }
    _getLegendItemAt(e, r) {
      let n, i, o;
      if (Wr(e, this.left, this.right) && Wr(r, this.top, this.bottom)) {
        for (o = this.legendHitBoxes, n = 0; n < o.length; ++n)
          if (i = o[n], Wr(e, i.left, i.left + i.width) && Wr(r, i.top, i.top + i.height))
            return this.legendItems[n];
      }
      return null;
    }
    handleEvent(e) {
      const r = this.options;
      if (!XA(e.type, r))
        return;
      const n = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const i = this._hoveredItem, o = qA(i, n);
        i && !o && nt(r.onLeave, [
          e,
          i,
          this
        ], this), this._hoveredItem = n, n && !o && nt(r.onHover, [
          e,
          n,
          this
        ], this);
      } else
        n && nt(r.onClick, [
          e,
          n,
          this
        ], this);
    }
  }
  function HA(t10, e, r, n, i) {
    const o = YA(n, t10, e, r), s = KA(i, n, e.lineHeight);
    return {
      itemWidth: o,
      itemHeight: s
    };
  }
  function YA(t10, e, r, n) {
    let i = t10.text;
    return i && typeof i != "string" && (i = i.reduce((o, s) => o.length > s.length ? o : s)), e + r.size / 2 + n.measureText(i).width;
  }
  function KA(t10, e, r) {
    let n = t10;
    return typeof e.text != "string" && (n = ng(e, r)), n;
  }
  function ng(t10, e) {
    const r = t10.text ? t10.text.length : 0;
    return e * r;
  }
  function XA(t10, e) {
    return !!((t10 === "mousemove" || t10 === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t10 === "click" || t10 === "mouseup"));
  }
  var JA = {
    id: "legend",
    _element: Eh,
    start(t10, e, r) {
      const n = t10.legend = new Eh({
        ctx: t10.ctx,
        options: r,
        chart: t10
      });
      Rt.configure(t10, n, r), Rt.addBox(t10, n);
    },
    stop(t10) {
      Rt.removeBox(t10, t10.legend), delete t10.legend;
    },
    beforeUpdate(t10, e, r) {
      const n = t10.legend;
      Rt.configure(t10, n, r), n.options = r;
    },
    afterUpdate(t10) {
      const e = t10.legend;
      e.buildLabels(), e.adjustHitBoxes();
    },
    afterEvent(t10, e) {
      e.replay || t10.legend.handleEvent(e.event);
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(t10, e, r) {
        const n = e.datasetIndex, i = r.chart;
        i.isDatasetVisible(n) ? (i.hide(n), e.hidden = true) : (i.show(n), e.hidden = false);
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (t10) => t10.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(t10) {
          const e = t10.data.datasets, { labels: { usePointStyle: r, pointStyle: n, textAlign: i, color: o, useBorderRadius: s, borderRadius: a } } = t10.legend.options;
          return t10._getSortedDatasetMetas().map((l) => {
            const c = l.controller.getStyle(r ? 0 : void 0), u = Mt(c.borderWidth);
            return {
              text: e[l.index].label,
              fillStyle: c.backgroundColor,
              fontColor: o,
              hidden: !l.visible,
              lineCap: c.borderCapStyle,
              lineDash: c.borderDash,
              lineDashOffset: c.borderDashOffset,
              lineJoin: c.borderJoinStyle,
              lineWidth: (u.width + u.height) / 4,
              strokeStyle: c.borderColor,
              pointStyle: n || c.pointStyle,
              rotation: c.rotation,
              textAlign: i || c.textAlign,
              borderRadius: s && (a || c.borderRadius),
              datasetIndex: l.index
            };
          }, this);
        }
      },
      title: {
        color: (t10) => t10.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (t10) => !t10.startsWith("on"),
      labels: {
        _scriptable: (t10) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(t10)
      }
    }
  };
  class Qu extends Jr {
    constructor(e) {
      super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
    }
    update(e, r) {
      const n = this.options;
      if (this.left = 0, this.top = 0, !n.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = e, this.height = this.bottom = r;
      const i = it(n.text) ? n.text.length : 1;
      this._padding = Mt(n.padding);
      const o = i * vt(n.font).lineHeight + this._padding.height;
      this.isHorizontal() ? this.height = o : this.width = o;
    }
    isHorizontal() {
      const e = this.options.position;
      return e === "top" || e === "bottom";
    }
    _drawArgs(e) {
      const { top: r, left: n, bottom: i, right: o, options: s } = this, a = s.align;
      let l = 0, c, u, f;
      return this.isHorizontal() ? (u = It(a, n, o), f = r + e, c = o - n) : (s.position === "left" ? (u = n + e, f = It(a, i, r), l = st * -0.5) : (u = o - e, f = It(a, r, i), l = st * 0.5), c = i - r), {
        titleX: u,
        titleY: f,
        maxWidth: c,
        rotation: l
      };
    }
    draw() {
      const e = this.ctx, r = this.options;
      if (!r.display)
        return;
      const n = vt(r.font), o = n.lineHeight / 2 + this._padding.top, { titleX: s, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);
      Kn(e, r.text, 0, 0, n, {
        color: r.color,
        maxWidth: l,
        rotation: c,
        textAlign: Uu(r.align),
        textBaseline: "middle",
        translation: [
          s,
          a
        ]
      });
    }
  }
  function QA(t10, e) {
    const r = new Qu({
      ctx: t10.ctx,
      options: e,
      chart: t10
    });
    Rt.configure(t10, r, e), Rt.addBox(t10, r), t10.titleBlock = r;
  }
  var GA = {
    id: "title",
    _element: Qu,
    start(t10, e, r) {
      QA(t10, r);
    },
    stop(t10) {
      const e = t10.titleBlock;
      Rt.removeBox(t10, e), delete t10.titleBlock;
    },
    beforeUpdate(t10, e, r) {
      const n = t10.titleBlock;
      Rt.configure(t10, n, r), n.options = r;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  const Cs = /* @__PURE__ */ new WeakMap();
  var ZA = {
    id: "subtitle",
    start(t10, e, r) {
      const n = new Qu({
        ctx: t10.ctx,
        options: r,
        chart: t10
      });
      Rt.configure(t10, n, r), Rt.addBox(t10, n), Cs.set(t10, n);
    },
    stop(t10) {
      Rt.removeBox(t10, Cs.get(t10)), Cs.delete(t10);
    },
    beforeUpdate(t10, e, r) {
      const n = Cs.get(t10);
      Rt.configure(t10, n, r), n.options = r;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  const lo = {
    average(t10) {
      if (!t10.length)
        return false;
      let e, r, n = 0, i = 0, o = 0;
      for (e = 0, r = t10.length; e < r; ++e) {
        const s = t10[e].element;
        if (s && s.hasValue()) {
          const a = s.tooltipPosition();
          n += a.x, i += a.y, ++o;
        }
      }
      return {
        x: n / o,
        y: i / o
      };
    },
    nearest(t10, e) {
      if (!t10.length)
        return false;
      let r = e.x, n = e.y, i = Number.POSITIVE_INFINITY, o, s, a;
      for (o = 0, s = t10.length; o < s; ++o) {
        const l = t10[o].element;
        if (l && l.hasValue()) {
          const c = l.getCenterPoint(), u = Dc(e, c);
          u < i && (i = u, a = l);
        }
      }
      if (a) {
        const l = a.tooltipPosition();
        r = l.x, n = l.y;
      }
      return {
        x: r,
        y: n
      };
    }
  };
  function vr(t10, e) {
    return e && (it(e) ? Array.prototype.push.apply(t10, e) : t10.push(e)), t10;
  }
  function Mr(t10) {
    return (typeof t10 == "string" || t10 instanceof String) && t10.indexOf(`
`) > -1 ? t10.split(`
`) : t10;
  }
  function $A(t10, e) {
    const { element: r, datasetIndex: n, index: i } = e, o = t10.getDatasetMeta(n).controller, { label: s, value: a } = o.getLabelAndValue(i);
    return {
      chart: t10,
      label: s,
      parsed: o.getParsed(i),
      raw: t10.data.datasets[n].data[i],
      formattedValue: a,
      dataset: o.getDataset(),
      dataIndex: i,
      datasetIndex: n,
      element: r
    };
  }
  function kh(t10, e) {
    const r = t10.chart.ctx, { body: n, footer: i, title: o } = t10, { boxWidth: s, boxHeight: a } = e, l = vt(e.bodyFont), c = vt(e.titleFont), u = vt(e.footerFont), f = o.length, d = i.length, h = n.length, g = Mt(e.padding);
    let p = g.height, y = 0, b = n.reduce((O, _) => O + _.before.length + _.lines.length + _.after.length, 0);
    if (b += t10.beforeBody.length + t10.afterBody.length, f && (p += f * c.lineHeight + (f - 1) * e.titleSpacing + e.titleMarginBottom), b) {
      const O = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
      p += h * O + (b - h) * l.lineHeight + (b - 1) * e.bodySpacing;
    }
    d && (p += e.footerMarginTop + d * u.lineHeight + (d - 1) * e.footerSpacing);
    let x = 0;
    const S = function(O) {
      y = Math.max(y, r.measureText(O).width + x);
    };
    return r.save(), r.font = c.string, $e(t10.title, S), r.font = l.string, $e(t10.beforeBody.concat(t10.afterBody), S), x = e.displayColors ? s + 2 + e.boxPadding : 0, $e(n, (O) => {
      $e(O.before, S), $e(O.lines, S), $e(O.after, S);
    }), x = 0, r.font = u.string, $e(t10.footer, S), r.restore(), y += g.width, {
      width: y,
      height: p
    };
  }
  function e5(t10, e) {
    const { y: r, height: n } = e;
    return r < n / 2 ? "top" : r > t10.height - n / 2 ? "bottom" : "center";
  }
  function t5(t10, e, r, n) {
    const { x: i, width: o } = n, s = r.caretSize + r.caretPadding;
    if (t10 === "left" && i + o + s > e.width || t10 === "right" && i - o - s < 0)
      return true;
  }
  function r5(t10, e, r, n) {
    const { x: i, width: o } = r, { width: s, chartArea: { left: a, right: l } } = t10;
    let c = "center";
    return n === "center" ? c = i <= (a + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= s - o / 2 && (c = "right"), t5(c, t10, e, r) && (c = "center"), c;
  }
  function Ch(t10, e, r) {
    const n = r.yAlign || e.yAlign || e5(t10, r);
    return {
      xAlign: r.xAlign || e.xAlign || r5(t10, e, r, n),
      yAlign: n
    };
  }
  function n5(t10, e) {
    let { x: r, width: n } = t10;
    return e === "right" ? r -= n : e === "center" && (r -= n / 2), r;
  }
  function i5(t10, e, r) {
    let { y: n, height: i } = t10;
    return e === "top" ? n += r : e === "bottom" ? n -= i + r : n -= i / 2, n;
  }
  function Th(t10, e, r, n) {
    const { caretSize: i, caretPadding: o, cornerRadius: s } = t10, { xAlign: a, yAlign: l } = r, c = i + o, { topLeft: u, topRight: f, bottomLeft: d, bottomRight: h } = Fn(s);
    let g = n5(e, a);
    const p = i5(e, l, c);
    return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(u, d) + i : a === "right" && (g += Math.max(f, h) + i), {
      x: St(g, 0, n.width - e.width),
      y: St(p, 0, n.height - e.height)
    };
  }
  function Ts(t10, e, r) {
    const n = Mt(r.padding);
    return e === "center" ? t10.x + t10.width / 2 : e === "right" ? t10.x + t10.width - n.right : t10.x + n.left;
  }
  function Oh(t10) {
    return vr([], Mr(t10));
  }
  function o5(t10, e, r) {
    return vn(t10, {
      tooltip: e,
      tooltipItems: r,
      type: "tooltip"
    });
  }
  function Ih(t10, e) {
    const r = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
    return r ? t10.override(r) : t10;
  }
  const ig = {
    beforeTitle: Pr,
    title(t10) {
      if (t10.length > 0) {
        const e = t10[0], r = e.chart.data.labels, n = r ? r.length : 0;
        if (this && this.options && this.options.mode === "dataset")
          return e.dataset.label || "";
        if (e.label)
          return e.label;
        if (n > 0 && e.dataIndex < n)
          return r[e.dataIndex];
      }
      return "";
    },
    afterTitle: Pr,
    beforeBody: Pr,
    beforeLabel: Pr,
    label(t10) {
      if (this && this.options && this.options.mode === "dataset")
        return t10.label + ": " + t10.formattedValue || t10.formattedValue;
      let e = t10.dataset.label || "";
      e && (e += ": ");
      const r = t10.formattedValue;
      return We(r) || (e += r), e;
    },
    labelColor(t10) {
      const r = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
      return {
        borderColor: r.borderColor,
        backgroundColor: r.backgroundColor,
        borderWidth: r.borderWidth,
        borderDash: r.borderDash,
        borderDashOffset: r.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(t10) {
      const r = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
      return {
        pointStyle: r.pointStyle,
        rotation: r.rotation
      };
    },
    afterLabel: Pr,
    afterBody: Pr,
    beforeFooter: Pr,
    footer: Pr,
    afterFooter: Pr
  };
  function Bt(t10, e, r, n) {
    const i = t10[e].call(r, n);
    return typeof i > "u" ? ig[e].call(r, n) : i;
  }
  var xc;
  let Ph = (xc = class extends Jr {
    constructor(e) {
      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
    }
    initialize(e) {
      this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
    }
    _resolveAnimations() {
      const e = this._cachedAnimations;
      if (e)
        return e;
      const r = this.chart, n = this.options.setContext(this.getContext()), i = n.enabled && r.options.animation && n.animations, o = new B1(this.chart, i);
      return i._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
    }
    getContext() {
      return this.$context || (this.$context = o5(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(e, r) {
      const { callbacks: n } = r, i = Bt(n, "beforeTitle", this, e), o = Bt(n, "title", this, e), s = Bt(n, "afterTitle", this, e);
      let a = [];
      return a = vr(a, Mr(i)), a = vr(a, Mr(o)), a = vr(a, Mr(s)), a;
    }
    getBeforeBody(e, r) {
      return Oh(Bt(r.callbacks, "beforeBody", this, e));
    }
    getBody(e, r) {
      const { callbacks: n } = r, i = [];
      return $e(e, (o) => {
        const s = {
          before: [],
          lines: [],
          after: []
        }, a = Ih(n, o);
        vr(s.before, Mr(Bt(a, "beforeLabel", this, o))), vr(s.lines, Bt(a, "label", this, o)), vr(s.after, Mr(Bt(a, "afterLabel", this, o))), i.push(s);
      }), i;
    }
    getAfterBody(e, r) {
      return Oh(Bt(r.callbacks, "afterBody", this, e));
    }
    getFooter(e, r) {
      const { callbacks: n } = r, i = Bt(n, "beforeFooter", this, e), o = Bt(n, "footer", this, e), s = Bt(n, "afterFooter", this, e);
      let a = [];
      return a = vr(a, Mr(i)), a = vr(a, Mr(o)), a = vr(a, Mr(s)), a;
    }
    _createItems(e) {
      const r = this._active, n = this.chart.data, i = [], o = [], s = [];
      let a = [], l, c;
      for (l = 0, c = r.length; l < c; ++l)
        a.push($A(this.chart, r[l]));
      return e.filter && (a = a.filter((u, f, d) => e.filter(u, f, d, n))), e.itemSort && (a = a.sort((u, f) => e.itemSort(u, f, n))), $e(a, (u) => {
        const f = Ih(e.callbacks, u);
        i.push(Bt(f, "labelColor", this, u)), o.push(Bt(f, "labelPointStyle", this, u)), s.push(Bt(f, "labelTextColor", this, u));
      }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = s, this.dataPoints = a, a;
    }
    update(e, r) {
      const n = this.options.setContext(this.getContext()), i = this._active;
      let o, s = [];
      if (!i.length)
        this.opacity !== 0 && (o = {
          opacity: 0
        });
      else {
        const a = lo[n.position].call(this, i, this._eventPosition);
        s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
        const l = this._size = kh(this, n), c = Object.assign({}, a, l), u = Ch(this.chart, n, c), f = Th(n, c, u, this.chart);
        this.xAlign = u.xAlign, this.yAlign = u.yAlign, o = {
          opacity: 1,
          x: f.x,
          y: f.y,
          width: l.width,
          height: l.height,
          caretX: a.x,
          caretY: a.y
        };
      }
      this._tooltipItems = s, this.$context = void 0, o && this._resolveAnimations().update(this, o), e && n.external && n.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay: r
      });
    }
    drawCaret(e, r, n, i) {
      const o = this.getCaretPosition(e, n, i);
      r.lineTo(o.x1, o.y1), r.lineTo(o.x2, o.y2), r.lineTo(o.x3, o.y3);
    }
    getCaretPosition(e, r, n) {
      const { xAlign: i, yAlign: o } = this, { caretSize: s, cornerRadius: a } = n, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: f } = Fn(a), { x: d, y: h } = e, { width: g, height: p } = r;
      let y, b, x, S, O, _;
      return o === "center" ? (O = h + p / 2, i === "left" ? (y = d, b = y - s, S = O + s, _ = O - s) : (y = d + g, b = y + s, S = O - s, _ = O + s), x = y) : (i === "left" ? b = d + Math.max(l, u) + s : i === "right" ? b = d + g - Math.max(c, f) - s : b = this.caretX, o === "top" ? (S = h, O = S - s, y = b - s, x = b + s) : (S = h + p, O = S + s, y = b + s, x = b - s), _ = S), {
        x1: y,
        x2: b,
        x3: x,
        y1: S,
        y2: O,
        y3: _
      };
    }
    drawTitle(e, r, n) {
      const i = this.title, o = i.length;
      let s, a, l;
      if (o) {
        const c = bi(n.rtl, this.x, this.width);
        for (e.x = Ts(this, n.titleAlign, n), r.textAlign = c.textAlign(n.titleAlign), r.textBaseline = "middle", s = vt(n.titleFont), a = n.titleSpacing, r.fillStyle = n.titleColor, r.font = s.string, l = 0; l < o; ++l)
          r.fillText(i[l], c.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + a, l + 1 === o && (e.y += n.titleMarginBottom - a);
      }
    }
    _drawColorBox(e, r, n, i, o) {
      const s = this.labelColors[n], a = this.labelPointStyles[n], { boxHeight: l, boxWidth: c } = o, u = vt(o.bodyFont), f = Ts(this, "left", o), d = i.x(f), h = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, g = r.y + h;
      if (o.usePointStyle) {
        const p = {
          radius: Math.min(c, l) / 2,
          pointStyle: a.pointStyle,
          rotation: a.rotation,
          borderWidth: 1
        }, y = i.leftForLtr(d, c) + c / 2, b = g + l / 2;
        e.strokeStyle = o.multiKeyBackground, e.fillStyle = o.multiKeyBackground, Nc(e, p, y, b), e.strokeStyle = s.borderColor, e.fillStyle = s.backgroundColor, Nc(e, p, y, b);
      } else {
        e.lineWidth = Le(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, e.strokeStyle = s.borderColor, e.setLineDash(s.borderDash || []), e.lineDashOffset = s.borderDashOffset || 0;
        const p = i.leftForLtr(d, c), y = i.leftForLtr(i.xPlus(d, 1), c - 2), b = Fn(s.borderRadius);
        Object.values(b).some((x) => x !== 0) ? (e.beginPath(), e.fillStyle = o.multiKeyBackground, Ro(e, {
          x: p,
          y: g,
          w: c,
          h: l,
          radius: b
        }), e.fill(), e.stroke(), e.fillStyle = s.backgroundColor, e.beginPath(), Ro(e, {
          x: y,
          y: g + 1,
          w: c - 2,
          h: l - 2,
          radius: b
        }), e.fill()) : (e.fillStyle = o.multiKeyBackground, e.fillRect(p, g, c, l), e.strokeRect(p, g, c, l), e.fillStyle = s.backgroundColor, e.fillRect(y, g + 1, c - 2, l - 2));
      }
      e.fillStyle = this.labelTextColors[n];
    }
    drawBody(e, r, n) {
      const { body: i } = this, { bodySpacing: o, bodyAlign: s, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = n, f = vt(n.bodyFont);
      let d = f.lineHeight, h = 0;
      const g = bi(n.rtl, this.x, this.width), p = function(j) {
        r.fillText(j, g.x(e.x + h), e.y + d / 2), e.y += d + o;
      }, y = g.textAlign(s);
      let b, x, S, O, _, L, N;
      for (r.textAlign = s, r.textBaseline = "middle", r.font = f.string, e.x = Ts(this, y, n), r.fillStyle = n.bodyColor, $e(this.beforeBody, p), h = a && y !== "right" ? s === "center" ? c / 2 + u : c + 2 + u : 0, O = 0, L = i.length; O < L; ++O) {
        for (b = i[O], x = this.labelTextColors[O], r.fillStyle = x, $e(b.before, p), S = b.lines, a && S.length && (this._drawColorBox(r, e, O, g, n), d = Math.max(f.lineHeight, l)), _ = 0, N = S.length; _ < N; ++_)
          p(S[_]), d = f.lineHeight;
        $e(b.after, p);
      }
      h = 0, d = f.lineHeight, $e(this.afterBody, p), e.y -= o;
    }
    drawFooter(e, r, n) {
      const i = this.footer, o = i.length;
      let s, a;
      if (o) {
        const l = bi(n.rtl, this.x, this.width);
        for (e.x = Ts(this, n.footerAlign, n), e.y += n.footerMarginTop, r.textAlign = l.textAlign(n.footerAlign), r.textBaseline = "middle", s = vt(n.footerFont), r.fillStyle = n.footerColor, r.font = s.string, a = 0; a < o; ++a)
          r.fillText(i[a], l.x(e.x), e.y + s.lineHeight / 2), e.y += s.lineHeight + n.footerSpacing;
      }
    }
    drawBackground(e, r, n, i) {
      const { xAlign: o, yAlign: s } = this, { x: a, y: l } = e, { width: c, height: u } = n, { topLeft: f, topRight: d, bottomLeft: h, bottomRight: g } = Fn(i.cornerRadius);
      r.fillStyle = i.backgroundColor, r.strokeStyle = i.borderColor, r.lineWidth = i.borderWidth, r.beginPath(), r.moveTo(a + f, l), s === "top" && this.drawCaret(e, r, n, i), r.lineTo(a + c - d, l), r.quadraticCurveTo(a + c, l, a + c, l + d), s === "center" && o === "right" && this.drawCaret(e, r, n, i), r.lineTo(a + c, l + u - g), r.quadraticCurveTo(a + c, l + u, a + c - g, l + u), s === "bottom" && this.drawCaret(e, r, n, i), r.lineTo(a + h, l + u), r.quadraticCurveTo(a, l + u, a, l + u - h), s === "center" && o === "left" && this.drawCaret(e, r, n, i), r.lineTo(a, l + f), r.quadraticCurveTo(a, l, a + f, l), r.closePath(), r.fill(), i.borderWidth > 0 && r.stroke();
    }
    _updateAnimationTarget(e) {
      const r = this.chart, n = this.$animations, i = n && n.x, o = n && n.y;
      if (i || o) {
        const s = lo[e.position].call(this, this._active, this._eventPosition);
        if (!s)
          return;
        const a = this._size = kh(this, e), l = Object.assign({}, s, this._size), c = Ch(r, e, l), u = Th(e, l, c, r);
        (i._to !== u.x || o._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, u));
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(e) {
      const r = this.options.setContext(this.getContext());
      let n = this.opacity;
      if (!n)
        return;
      this._updateAnimationTarget(r);
      const i = {
        width: this.width,
        height: this.height
      }, o = {
        x: this.x,
        y: this.y
      };
      n = Math.abs(n) < 1e-3 ? 0 : n;
      const s = Mt(r.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      r.enabled && a && (e.save(), e.globalAlpha = n, this.drawBackground(o, e, i, r), R1(e, r.textDirection), o.y += s.top, this.drawTitle(o, e, r), this.drawBody(o, e, r), this.drawFooter(o, e, r), D1(e, r.textDirection), e.restore());
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(e, r) {
      const n = this._active, i = e.map(({ datasetIndex: a, index: l }) => {
        const c = this.chart.getDatasetMeta(a);
        if (!c)
          throw new Error("Cannot find a dataset at index " + a);
        return {
          datasetIndex: a,
          element: c.data[l],
          index: l
        };
      }), o = !ga(n, i), s = this._positionChanged(i, r);
      (o || s) && (this._active = i, this._eventPosition = r, this._ignoreReplayEvents = true, this.update(true));
    }
    handleEvent(e, r, n = true) {
      if (r && this._ignoreReplayEvents)
        return false;
      this._ignoreReplayEvents = false;
      const i = this.options, o = this._active || [], s = this._getActiveElements(e, o, r, n), a = this._positionChanged(s, e), l = r || !ga(s, o) || a;
      return l && (this._active = s, (i.enabled || i.external) && (this._eventPosition = {
        x: e.x,
        y: e.y
      }, this.update(true, r))), l;
    }
    _getActiveElements(e, r, n, i) {
      const o = this.options;
      if (e.type === "mouseout")
        return [];
      if (!i)
        return r;
      const s = this.chart.getElementsAtEventForMode(e, o.mode, o, n);
      return o.reverse && s.reverse(), s;
    }
    _positionChanged(e, r) {
      const { caretX: n, caretY: i, options: o } = this, s = lo[o.position].call(this, e, r);
      return s !== false && (n !== s.x || i !== s.y);
    }
  }, ye(xc, "positioners", lo), xc);
  var s5 = {
    id: "tooltip",
    _element: Ph,
    positioners: lo,
    afterInit(t10, e, r) {
      r && (t10.tooltip = new Ph({
        chart: t10,
        options: r
      }));
    },
    beforeUpdate(t10, e, r) {
      t10.tooltip && t10.tooltip.initialize(r);
    },
    reset(t10, e, r) {
      t10.tooltip && t10.tooltip.initialize(r);
    },
    afterDraw(t10) {
      const e = t10.tooltip;
      if (e && e._willRender()) {
        const r = {
          tooltip: e
        };
        if (t10.notifyPlugins("beforeTooltipDraw", {
          ...r,
          cancelable: true
        }) === false)
          return;
        e.draw(t10.ctx), t10.notifyPlugins("afterTooltipDraw", r);
      }
    },
    afterEvent(t10, e) {
      if (t10.tooltip) {
        const r = e.replay;
        t10.tooltip.handleEvent(e.event, r, e.inChartArea) && (e.changed = true);
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (t10, e) => e.bodyFont.size,
      boxWidth: (t10, e) => e.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: ig
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (t10) => t10 !== "filter" && t10 !== "itemSort" && t10 !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  }, a5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: vA,
    Decimation: _A,
    Filler: VA,
    Legend: JA,
    SubTitle: ZA,
    Title: GA,
    Tooltip: s5
  });
  const l5 = (t10, e, r, n) => (typeof e == "string" ? (r = t10.push(e) - 1, n.unshift({
    index: r,
    label: e
  })) : isNaN(e) && (r = null), r);
  function c5(t10, e, r, n) {
    const i = t10.indexOf(e);
    if (i === -1)
      return l5(t10, e, r, n);
    const o = t10.lastIndexOf(e);
    return i !== o ? r : i;
  }
  const u5 = (t10, e) => t10 === null ? null : St(Math.round(t10), 0, e);
  function Rh(t10) {
    const e = this.getLabels();
    return t10 >= 0 && t10 < e.length ? e[t10] : t10;
  }
  class zc extends Zn {
    constructor(e) {
      super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
    }
    init(e) {
      const r = this._addedLabels;
      if (r.length) {
        const n = this.getLabels();
        for (const { index: i, label: o } of r)
          n[i] === o && n.splice(i, 1);
        this._addedLabels = [];
      }
      super.init(e);
    }
    parse(e, r) {
      if (We(e))
        return null;
      const n = this.getLabels();
      return r = isFinite(r) && n[r] === e ? r : c5(n, e, Oe(r, e), this._addedLabels), u5(r, n.length - 1);
    }
    determineDataLimits() {
      const { minDefined: e, maxDefined: r } = this.getUserBounds();
      let { min: n, max: i } = this.getMinMax(true);
      this.options.bounds === "ticks" && (e || (n = 0), r || (i = this.getLabels().length - 1)), this.min = n, this.max = i;
    }
    buildTicks() {
      const e = this.min, r = this.max, n = this.options.offset, i = [];
      let o = this.getLabels();
      o = e === 0 && r === o.length - 1 ? o : o.slice(e, r + 1), this._valueRange = Math.max(o.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
      for (let s = e; s <= r; s++)
        i.push({
          value: s
        });
      return i;
    }
    getLabelForValue(e) {
      return Rh.call(this, e);
    }
    configure() {
      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
    }
    getPixelForValue(e) {
      return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
    }
    getPixelForTick(e) {
      const r = this.ticks;
      return e < 0 || e > r.length - 1 ? null : this.getPixelForValue(r[e].value);
    }
    getValueForPixel(e) {
      return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  }
  ye(zc, "id", "category"), ye(zc, "defaults", {
    ticks: {
      callback: Rh
    }
  });
  function f5(t10, e) {
    const r = [], { bounds: i, step: o, min: s, max: a, precision: l, count: c, maxTicks: u, maxDigits: f, includeBounds: d } = t10, h = o || 1, g = u - 1, { min: p, max: y } = e, b = !We(s), x = !We(a), S = !We(c), O = (y - p) / (f + 1);
    let _ = Ed((y - p) / g / h) * h, L, N, j, W;
    if (_ < 1e-14 && !b && !x)
      return [
        {
          value: p
        },
        {
          value: y
        }
      ];
    W = Math.ceil(y / _) - Math.floor(p / _), W > g && (_ = Ed(W * _ / g / h) * h), We(l) || (L = Math.pow(10, l), _ = Math.ceil(_ * L) / L), i === "ticks" ? (N = Math.floor(p / _) * _, j = Math.ceil(y / _) * _) : (N = p, j = y), b && x && o && o2((a - s) / o, _ / 1e3) ? (W = Math.round(Math.min((a - s) / _, u)), _ = (a - s) / W, N = s, j = a) : S ? (N = b ? s : N, j = x ? a : j, W = c - 1, _ = (j - N) / W) : (W = (j - N) / _, yo(W, Math.round(W), _ / 1e3) ? W = Math.round(W) : W = Math.ceil(W));
    const G = Math.max(kd(_), kd(N));
    L = Math.pow(10, We(l) ? G : l), N = Math.round(N * L) / L, j = Math.round(j * L) / L;
    let ee = 0;
    for (b && (d && N !== s ? (r.push({
      value: s
    }), N < s && ee++, yo(Math.round((N + ee * _) * L) / L, s, Dh(s, O, t10)) && ee++) : N < s && ee++); ee < W; ++ee) {
      const fe = Math.round((N + ee * _) * L) / L;
      if (x && fe > a)
        break;
      r.push({
        value: fe
      });
    }
    return x && d && j !== a ? r.length && yo(r[r.length - 1].value, a, Dh(a, O, t10)) ? r[r.length - 1].value = a : r.push({
      value: a
    }) : (!x || j === a) && r.push({
      value: j
    }), r;
  }
  function Dh(t10, e, { horizontal: r, minRotation: n }) {
    const i = gr(n), o = (r ? Math.sin(i) : Math.cos(i)) || 1e-3, s = 0.75 * e * ("" + t10).length;
    return Math.min(e / o, s);
  }
  class xa extends Zn {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
    }
    parse(e, r) {
      return We(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
    }
    handleTickRangeOptions() {
      const { beginAtZero: e } = this.options, { minDefined: r, maxDefined: n } = this.getUserBounds();
      let { min: i, max: o } = this;
      const s = (l) => i = r ? i : l, a = (l) => o = n ? o : l;
      if (e) {
        const l = Cr(i), c = Cr(o);
        l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && s(0);
      }
      if (i === o) {
        let l = o === 0 ? 1 : Math.abs(o * 0.05);
        a(o + l), e || s(i - l);
      }
      this.min = i, this.max = o;
    }
    getTickLimit() {
      const e = this.options.ticks;
      let { maxTicksLimit: r, stepSize: n } = e, i;
      return n ? (i = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), r = r || 11), r && (i = Math.min(r, i)), i;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const e = this.options, r = e.ticks;
      let n = this.getTickLimit();
      n = Math.max(2, n);
      const i = {
        maxTicks: n,
        bounds: e.bounds,
        min: e.min,
        max: e.max,
        precision: r.precision,
        step: r.stepSize,
        count: r.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: r.minRotation || 0,
        includeBounds: r.includeBounds !== false
      }, o = this._range || this, s = f5(i, o);
      return e.bounds === "ticks" && p1(s, this, "value"), e.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
    }
    configure() {
      const e = this.ticks;
      let r = this.min, n = this.max;
      if (super.configure(), this.options.offset && e.length) {
        const i = (n - r) / Math.max(e.length - 1, 1) / 2;
        r -= i, n += i;
      }
      this._startValue = r, this._endValue = n, this._valueRange = n - r;
    }
    getLabelForValue(e) {
      return Qo(e, this.chart.options.locale, this.options.ticks.format);
    }
  }
  class Vc extends xa {
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(true);
      this.min = pt(e) ? e : 0, this.max = pt(r) ? r : 1, this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const e = this.isHorizontal(), r = e ? this.width : this.height, n = gr(this.options.ticks.minRotation), i = (e ? Math.sin(n) : Math.cos(n)) || 1e-3, o = this._resolveTickFontOptions(0);
      return Math.ceil(r / Math.min(40, o.lineHeight / i));
    }
    getPixelForValue(e) {
      return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
    }
    getValueForPixel(e) {
      return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
    }
  }
  ye(Vc, "id", "linear"), ye(Vc, "defaults", {
    ticks: {
      callback: Ya.formatters.numeric
    }
  });
  const Mo = (t10) => Math.floor(rn(t10)), Tn = (t10, e) => Math.pow(10, Mo(t10) + e);
  function Mh(t10) {
    return t10 / Math.pow(10, Mo(t10)) === 1;
  }
  function Nh(t10, e, r) {
    const n = Math.pow(10, r), i = Math.floor(t10 / n);
    return Math.ceil(e / n) - i;
  }
  function d5(t10, e) {
    const r = e - t10;
    let n = Mo(r);
    for (; Nh(t10, e, n) > 10; )
      n++;
    for (; Nh(t10, e, n) < 10; )
      n--;
    return Math.min(n, Mo(t10));
  }
  function h5(t10, { min: e, max: r }) {
    e = Ht(t10.min, e);
    const n = [], i = Mo(e);
    let o = d5(e, r), s = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
    const a = Math.pow(10, o), l = i > o ? Math.pow(10, i) : 0, c = Math.round((e - l) * s) / s, u = Math.floor((e - l) / a / 10) * a * 10;
    let f = Math.floor((c - u) / Math.pow(10, o)), d = Ht(t10.min, Math.round((l + u + f * Math.pow(10, o)) * s) / s);
    for (; d < r; )
      n.push({
        value: d,
        major: Mh(d),
        significand: f
      }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (o++, f = 2, s = o >= 0 ? 1 : s), d = Math.round((l + u + f * Math.pow(10, o)) * s) / s;
    const h = Ht(t10.max, d);
    return n.push({
      value: h,
      major: Mh(h),
      significand: f
    }), n;
  }
  class qc extends Zn {
    constructor(e) {
      super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
    }
    parse(e, r) {
      const n = xa.prototype.parse.apply(this, [
        e,
        r
      ]);
      if (n === 0) {
        this._zero = true;
        return;
      }
      return pt(n) && n > 0 ? n : null;
    }
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(true);
      this.min = pt(e) ? Math.max(0, e) : null, this.max = pt(r) ? Math.max(0, r) : null, this.options.beginAtZero && (this._zero = true), this._zero && this.min !== this._suggestedMin && !pt(this._userMin) && (this.min = e === Tn(this.min, 0) ? Tn(this.min, -1) : Tn(this.min, 0)), this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined: e, maxDefined: r } = this.getUserBounds();
      let n = this.min, i = this.max;
      const o = (a) => n = e ? n : a, s = (a) => i = r ? i : a;
      n === i && (n <= 0 ? (o(1), s(10)) : (o(Tn(n, -1)), s(Tn(i, 1)))), n <= 0 && o(Tn(i, -1)), i <= 0 && s(Tn(n, 1)), this.min = n, this.max = i;
    }
    buildTicks() {
      const e = this.options, r = {
        min: this._userMin,
        max: this._userMax
      }, n = h5(r, this);
      return e.bounds === "ticks" && p1(n, this, "value"), e.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;
    }
    getLabelForValue(e) {
      return e === void 0 ? "0" : Qo(e, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const e = this.min;
      super.configure(), this._startValue = rn(e), this._valueRange = rn(this.max) - rn(e);
    }
    getPixelForValue(e) {
      return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (rn(e) - this._startValue) / this._valueRange);
    }
    getValueForPixel(e) {
      const r = this.getDecimalForPixel(e);
      return Math.pow(10, this._startValue + r * this._valueRange);
    }
  }
  ye(qc, "id", "logarithmic"), ye(qc, "defaults", {
    ticks: {
      callback: Ya.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function Hc(t10) {
    const e = t10.ticks;
    if (e.display && t10.display) {
      const r = Mt(e.backdropPadding);
      return Oe(e.font && e.font.size, gt.font.size) + r.height;
    }
    return 0;
  }
  function p5(t10, e, r) {
    return r = it(r) ? r : [
      r
    ], {
      w: x2(t10, e.string, r),
      h: r.length * e.lineHeight
    };
  }
  function Lh(t10, e, r, n, i) {
    return t10 === n || t10 === i ? {
      start: e - r / 2,
      end: e + r / 2
    } : t10 < n || t10 > i ? {
      start: e - r,
      end: e
    } : {
      start: e,
      end: e + r
    };
  }
  function g5(t10) {
    const e = {
      l: t10.left + t10._padding.left,
      r: t10.right - t10._padding.right,
      t: t10.top + t10._padding.top,
      b: t10.bottom - t10._padding.bottom
    }, r = Object.assign({}, e), n = [], i = [], o = t10._pointLabels.length, s = t10.options.pointLabels, a = s.centerPointLabels ? st / o : 0;
    for (let l = 0; l < o; l++) {
      const c = s.setContext(t10.getPointLabelContext(l));
      i[l] = c.padding;
      const u = t10.getPointPosition(l, t10.drawingArea + i[l], a), f = vt(c.font), d = p5(t10.ctx, f, t10._pointLabels[l]);
      n[l] = d;
      const h = Yt(t10.getIndexAngle(l) + a), g = Math.round(ju(h)), p = Lh(g, u.x, d.w, 0, 180), y = Lh(g, u.y, d.h, 90, 270);
      m5(r, e, h, p, y);
    }
    t10.setCenterPoint(e.l - r.l, r.r - e.r, e.t - r.t, r.b - e.b), t10._pointLabelItems = v5(t10, n, i);
  }
  function m5(t10, e, r, n, i) {
    const o = Math.abs(Math.sin(r)), s = Math.abs(Math.cos(r));
    let a = 0, l = 0;
    n.start < e.l ? (a = (e.l - n.start) / o, t10.l = Math.min(t10.l, e.l - a)) : n.end > e.r && (a = (n.end - e.r) / o, t10.r = Math.max(t10.r, e.r + a)), i.start < e.t ? (l = (e.t - i.start) / s, t10.t = Math.min(t10.t, e.t - l)) : i.end > e.b && (l = (i.end - e.b) / s, t10.b = Math.max(t10.b, e.b + l));
  }
  function y5(t10, e, r) {
    const n = t10.drawingArea, { extra: i, additionalAngle: o, padding: s, size: a } = r, l = t10.getPointPosition(e, n + i + s, o), c = Math.round(ju(Yt(l.angle + mt))), u = x5(l.y, a.h, c), f = A5(c), d = w5(l.x, a.w, f);
    return {
      visible: true,
      x: l.x,
      y: u,
      textAlign: f,
      left: d,
      top: u,
      right: d + a.w,
      bottom: u + a.h
    };
  }
  function b5(t10, e) {
    if (!e)
      return true;
    const { left: r, top: n, right: i, bottom: o } = t10;
    return !(zr({
      x: r,
      y: n
    }, e) || zr({
      x: r,
      y: o
    }, e) || zr({
      x: i,
      y: n
    }, e) || zr({
      x: i,
      y: o
    }, e));
  }
  function v5(t10, e, r) {
    const n = [], i = t10._pointLabels.length, o = t10.options, { centerPointLabels: s, display: a } = o.pointLabels, l = {
      extra: Hc(o) / 2,
      additionalAngle: s ? st / i : 0
    };
    let c;
    for (let u = 0; u < i; u++) {
      l.padding = r[u], l.size = e[u];
      const f = y5(t10, u, l);
      n.push(f), a === "auto" && (f.visible = b5(f, c), f.visible && (c = f));
    }
    return n;
  }
  function A5(t10) {
    return t10 === 0 || t10 === 180 ? "center" : t10 < 180 ? "left" : "right";
  }
  function w5(t10, e, r) {
    return r === "right" ? t10 -= e : r === "center" && (t10 -= e / 2), t10;
  }
  function x5(t10, e, r) {
    return r === 90 || r === 270 ? t10 -= e / 2 : (r > 270 || r < 90) && (t10 -= e), t10;
  }
  function _5(t10, e, r) {
    const { left: n, top: i, right: o, bottom: s } = r, { backdropColor: a } = e;
    if (!We(a)) {
      const l = Fn(e.borderRadius), c = Mt(e.backdropPadding);
      t10.fillStyle = a;
      const u = n - c.left, f = i - c.top, d = o - n + c.width, h = s - i + c.height;
      Object.values(l).some((g) => g !== 0) ? (t10.beginPath(), Ro(t10, {
        x: u,
        y: f,
        w: d,
        h,
        radius: l
      }), t10.fill()) : t10.fillRect(u, f, d, h);
    }
  }
  function S5(t10, e) {
    const { ctx: r, options: { pointLabels: n } } = t10;
    for (let i = e - 1; i >= 0; i--) {
      const o = t10._pointLabelItems[i];
      if (!o.visible)
        continue;
      const s = n.setContext(t10.getPointLabelContext(i));
      _5(r, s, o);
      const a = vt(s.font), { x: l, y: c, textAlign: u } = o;
      Kn(r, t10._pointLabels[i], l, c + a.lineHeight / 2, a, {
        color: s.color,
        textAlign: u,
        textBaseline: "middle"
      });
    }
  }
  function og(t10, e, r, n) {
    const { ctx: i } = t10;
    if (r)
      i.arc(t10.xCenter, t10.yCenter, e, 0, ot);
    else {
      let o = t10.getPointPosition(0, e);
      i.moveTo(o.x, o.y);
      for (let s = 1; s < n; s++)
        o = t10.getPointPosition(s, e), i.lineTo(o.x, o.y);
    }
  }
  function E5(t10, e, r, n, i) {
    const o = t10.ctx, s = e.circular, { color: a, lineWidth: l } = e;
    !s && !n || !a || !l || r < 0 || (o.save(), o.strokeStyle = a, o.lineWidth = l, o.setLineDash(i.dash), o.lineDashOffset = i.dashOffset, o.beginPath(), og(t10, r, s, n), o.closePath(), o.stroke(), o.restore());
  }
  function k5(t10, e, r) {
    return vn(t10, {
      label: r,
      index: e,
      type: "pointLabel"
    });
  }
  class co extends xa {
    constructor(e) {
      super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
    }
    setDimensions() {
      const e = this._padding = Mt(Hc(this.options) / 2), r = this.width = this.maxWidth - e.width, n = this.height = this.maxHeight - e.height;
      this.xCenter = Math.floor(this.left + r / 2 + e.left), this.yCenter = Math.floor(this.top + n / 2 + e.top), this.drawingArea = Math.floor(Math.min(r, n) / 2);
    }
    determineDataLimits() {
      const { min: e, max: r } = this.getMinMax(false);
      this.min = pt(e) && !isNaN(e) ? e : 0, this.max = pt(r) && !isNaN(r) ? r : 0, this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / Hc(this.options));
    }
    generateTickLabels(e) {
      xa.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((r, n) => {
        const i = nt(this.options.pointLabels.callback, [
          r,
          n
        ], this);
        return i || i === 0 ? i : "";
      }).filter((r, n) => this.chart.getDataVisibility(n));
    }
    fit() {
      const e = this.options;
      e.display && e.pointLabels.display ? g5(this) : this.setCenterPoint(0, 0, 0, 0);
    }
    setCenterPoint(e, r, n, i) {
      this.xCenter += Math.floor((e - r) / 2), this.yCenter += Math.floor((n - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, r, n, i));
    }
    getIndexAngle(e) {
      const r = ot / (this._pointLabels.length || 1), n = this.options.startAngle || 0;
      return Yt(e * r + gr(n));
    }
    getDistanceFromCenterForValue(e) {
      if (We(e))
        return NaN;
      const r = this.drawingArea / (this.max - this.min);
      return this.options.reverse ? (this.max - e) * r : (e - this.min) * r;
    }
    getValueForDistanceFromCenter(e) {
      if (We(e))
        return NaN;
      const r = e / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - r : this.min + r;
    }
    getPointLabelContext(e) {
      const r = this._pointLabels || [];
      if (e >= 0 && e < r.length) {
        const n = r[e];
        return k5(this.getContext(), e, n);
      }
    }
    getPointPosition(e, r, n = 0) {
      const i = this.getIndexAngle(e) - mt + n;
      return {
        x: Math.cos(i) * r + this.xCenter,
        y: Math.sin(i) * r + this.yCenter,
        angle: i
      };
    }
    getPointPositionForValue(e, r) {
      return this.getPointPosition(e, this.getDistanceFromCenterForValue(r));
    }
    getBasePosition(e) {
      return this.getPointPositionForValue(e || 0, this.getBaseValue());
    }
    getPointLabelPosition(e) {
      const { left: r, top: n, right: i, bottom: o } = this._pointLabelItems[e];
      return {
        left: r,
        top: n,
        right: i,
        bottom: o
      };
    }
    drawBackground() {
      const { backgroundColor: e, grid: { circular: r } } = this.options;
      if (e) {
        const n = this.ctx;
        n.save(), n.beginPath(), og(this, this.getDistanceFromCenterForValue(this._endValue), r, this._pointLabels.length), n.closePath(), n.fillStyle = e, n.fill(), n.restore();
      }
    }
    drawGrid() {
      const e = this.ctx, r = this.options, { angleLines: n, grid: i, border: o } = r, s = this._pointLabels.length;
      let a, l, c;
      if (r.pointLabels.display && S5(this, s), i.display && this.ticks.forEach((u, f) => {
        if (f !== 0) {
          l = this.getDistanceFromCenterForValue(u.value);
          const d = this.getContext(f), h = i.setContext(d), g = o.setContext(d);
          E5(this, h, l, s, g);
        }
      }), n.display) {
        for (e.save(), a = s - 1; a >= 0; a--) {
          const u = n.setContext(this.getPointLabelContext(a)), { color: f, lineWidth: d } = u;
          !d || !f || (e.lineWidth = d, e.strokeStyle = f, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(r.ticks.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke());
        }
        e.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const e = this.ctx, r = this.options, n = r.ticks;
      if (!n.display)
        return;
      const i = this.getIndexAngle(0);
      let o, s;
      e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(i), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => {
        if (l === 0 && !r.reverse)
          return;
        const c = n.setContext(this.getContext(l)), u = vt(c.font);
        if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
          e.font = u.string, s = e.measureText(a.label).width, e.fillStyle = c.backdropColor;
          const f = Mt(c.backdropPadding);
          e.fillRect(-s / 2 - f.left, -o - u.size / 2 - f.top, s + f.width, u.size + f.height);
        }
        Kn(e, a.label, 0, -o, u, {
          color: c.color,
          strokeColor: c.textStrokeColor,
          strokeWidth: c.textStrokeWidth
        });
      }), e.restore();
    }
    drawTitle() {
    }
  }
  ye(co, "id", "radialLinear"), ye(co, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ya.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(e) {
        return e;
      },
      padding: 5,
      centerPointLabels: false
    }
  }), ye(co, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  }), ye(co, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  const Qa = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  }, jt = /* @__PURE__ */ Object.keys(Qa);
  function Bh(t10, e) {
    return t10 - e;
  }
  function Fh(t10, e) {
    if (We(e))
      return null;
    const r = t10._adapter, { parser: n, round: i, isoWeekday: o } = t10._parseOpts;
    let s = e;
    return typeof n == "function" && (s = n(s)), pt(s) || (s = typeof n == "string" ? r.parse(s, n) : r.parse(s)), s === null ? null : (i && (s = i === "week" && (Ei(o) || o === true) ? r.startOf(s, "isoWeek", o) : r.startOf(s, i)), +s);
  }
  function jh(t10, e, r, n) {
    const i = jt.length;
    for (let o = jt.indexOf(t10); o < i - 1; ++o) {
      const s = Qa[jt[o]], a = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
      if (s.common && Math.ceil((r - e) / (a * s.size)) <= n)
        return jt[o];
    }
    return jt[i - 1];
  }
  function C5(t10, e, r, n, i) {
    for (let o = jt.length - 1; o >= jt.indexOf(r); o--) {
      const s = jt[o];
      if (Qa[s].common && t10._adapter.diff(i, n, s) >= e - 1)
        return s;
    }
    return jt[r ? jt.indexOf(r) : 0];
  }
  function T5(t10) {
    for (let e = jt.indexOf(t10) + 1, r = jt.length; e < r; ++e)
      if (Qa[jt[e]].common)
        return jt[e];
  }
  function Wh(t10, e, r) {
    if (!r)
      t10[e] = true;
    else if (r.length) {
      const { lo: n, hi: i } = Wu(r, e), o = r[n] >= e ? r[n] : r[i];
      t10[o] = true;
    }
  }
  function O5(t10, e, r, n) {
    const i = t10._adapter, o = +i.startOf(e[0].value, n), s = e[e.length - 1].value;
    let a, l;
    for (a = o; a <= s; a = +i.add(a, 1, n))
      l = r[a], l >= 0 && (e[l].major = true);
    return e;
  }
  function Uh(t10, e, r) {
    const n = [], i = {}, o = e.length;
    let s, a;
    for (s = 0; s < o; ++s)
      a = e[s], i[a] = s, n.push({
        value: a,
        major: false
      });
    return o === 0 || !r ? n : O5(t10, n, i, r);
  }
  class No extends Zn {
    constructor(e) {
      super(e), this._cache = {
        data: [],
        labels: [],
        all: []
      }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
    }
    init(e, r = {}) {
      const n = e.time || (e.time = {}), i = this._adapter = new Fv._date(e.adapters.date);
      i.init(r), mo(n.displayFormats, i.formats()), this._parseOpts = {
        parser: n.parser,
        round: n.round,
        isoWeekday: n.isoWeekday
      }, super.init(e), this._normalized = r.normalized;
    }
    parse(e, r) {
      return e === void 0 ? null : Fh(this, e);
    }
    beforeLayout() {
      super.beforeLayout(), this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const e = this.options, r = this._adapter, n = e.time.unit || "day";
      let { min: i, max: o, minDefined: s, maxDefined: a } = this.getUserBounds();
      function l(c) {
        !s && !isNaN(c.min) && (i = Math.min(i, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));
      }
      (!s || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(false))), i = pt(i) && !isNaN(i) ? i : +r.startOf(Date.now(), n), o = pt(o) && !isNaN(o) ? o : +r.endOf(Date.now(), n) + 1, this.min = Math.min(i, o - 1), this.max = Math.max(i + 1, o);
    }
    _getLabelBounds() {
      const e = this.getLabelTimestamps();
      let r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
      return e.length && (r = e[0], n = e[e.length - 1]), {
        min: r,
        max: n
      };
    }
    buildTicks() {
      const e = this.options, r = e.time, n = e.ticks, i = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
      e.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]);
      const o = this.min, s = this.max, a = c2(i, o, s);
      return this._unit = r.unit || (n.autoSkip ? jh(r.minUnit, this.min, this.max, this._getLabelCapacity(o)) : C5(this, a.length, r.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : T5(this._unit), this.initOffsets(i), e.reverse && a.reverse(), Uh(this, a, this._majorUnit);
    }
    afterAutoSkip() {
      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
    }
    initOffsets(e = []) {
      let r = 0, n = 0, i, o;
      this.options.offset && e.length && (i = this.getDecimalForValue(e[0]), e.length === 1 ? r = 1 - i : r = (this.getDecimalForValue(e[1]) - i) / 2, o = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? n = o : n = (o - this.getDecimalForValue(e[e.length - 2])) / 2);
      const s = e.length < 3 ? 0.5 : 0.25;
      r = St(r, 0, s), n = St(n, 0, s), this._offsets = {
        start: r,
        end: n,
        factor: 1 / (r + 1 + n)
      };
    }
    _generate() {
      const e = this._adapter, r = this.min, n = this.max, i = this.options, o = i.time, s = o.unit || jh(o.minUnit, r, n, this._getLabelCapacity(r)), a = Oe(i.ticks.stepSize, 1), l = s === "week" ? o.isoWeekday : false, c = Ei(l) || l === true, u = {};
      let f = r, d, h;
      if (c && (f = +e.startOf(f, "isoWeek", l)), f = +e.startOf(f, c ? "day" : s), e.diff(n, r, s) > 1e5 * a)
        throw new Error(r + " and " + n + " are too far apart with stepSize of " + a + " " + s);
      const g = i.ticks.source === "data" && this.getDataTimestamps();
      for (d = f, h = 0; d < n; d = +e.add(d, a, s), h++)
        Wh(u, d, g);
      return (d === n || i.bounds === "ticks" || h === 1) && Wh(u, d, g), Object.keys(u).sort(Bh).map((p) => +p);
    }
    getLabelForValue(e) {
      const r = this._adapter, n = this.options.time;
      return n.tooltipFormat ? r.format(e, n.tooltipFormat) : r.format(e, n.displayFormats.datetime);
    }
    format(e, r) {
      const i = this.options.time.displayFormats, o = this._unit, s = r || i[o];
      return this._adapter.format(e, s);
    }
    _tickFormatFunction(e, r, n, i) {
      const o = this.options, s = o.ticks.callback;
      if (s)
        return nt(s, [
          e,
          r,
          n
        ], this);
      const a = o.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], f = c && a[c], d = n[r], h = c && f && d && d.major;
      return this._adapter.format(e, i || (h ? f : u));
    }
    generateTickLabels(e) {
      let r, n, i;
      for (r = 0, n = e.length; r < n; ++r)
        i = e[r], i.label = this._tickFormatFunction(i.value, r, e);
    }
    getDecimalForValue(e) {
      return e === null ? NaN : (e - this.min) / (this.max - this.min);
    }
    getPixelForValue(e) {
      const r = this._offsets, n = this.getDecimalForValue(e);
      return this.getPixelForDecimal((r.start + n) * r.factor);
    }
    getValueForPixel(e) {
      const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
      return this.min + n * (this.max - this.min);
    }
    _getLabelSize(e) {
      const r = this.options.ticks, n = this.ctx.measureText(e).width, i = gr(this.isHorizontal() ? r.maxRotation : r.minRotation), o = Math.cos(i), s = Math.sin(i), a = this._resolveTickFontOptions(0).size;
      return {
        w: n * o + a * s,
        h: n * s + a * o
      };
    }
    _getLabelCapacity(e) {
      const r = this.options.time, n = r.displayFormats, i = n[r.unit] || n.millisecond, o = this._tickFormatFunction(e, 0, Uh(this, [
        e
      ], this._majorUnit), i), s = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
      return a > 0 ? a : 1;
    }
    getDataTimestamps() {
      let e = this._cache.data || [], r, n;
      if (e.length)
        return e;
      const i = this.getMatchingVisibleMetas();
      if (this._normalized && i.length)
        return this._cache.data = i[0].controller.getAllParsedValues(this);
      for (r = 0, n = i.length; r < n; ++r)
        e = e.concat(i[r].controller.getAllParsedValues(this));
      return this._cache.data = this.normalize(e);
    }
    getLabelTimestamps() {
      const e = this._cache.labels || [];
      let r, n;
      if (e.length)
        return e;
      const i = this.getLabels();
      for (r = 0, n = i.length; r < n; ++r)
        e.push(Fh(this, i[r]));
      return this._cache.labels = this._normalized ? e : this.normalize(e);
    }
    normalize(e) {
      return y1(e.sort(Bh));
    }
  }
  ye(No, "id", "time"), ye(No, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function Os(t10, e, r) {
    let n = 0, i = t10.length - 1, o, s, a, l;
    r ? (e >= t10[n].pos && e <= t10[i].pos && ({ lo: n, hi: i } = Ur(t10, "pos", e)), { pos: o, time: a } = t10[n], { pos: s, time: l } = t10[i]) : (e >= t10[n].time && e <= t10[i].time && ({ lo: n, hi: i } = Ur(t10, "time", e)), { time: o, pos: a } = t10[n], { time: s, pos: l } = t10[i]);
    const c = s - o;
    return c ? a + (l - a) * (e - o) / c : a;
  }
  class Yc extends No {
    constructor(e) {
      super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
    }
    initOffsets() {
      const e = this._getTimestampsForTable(), r = this._table = this.buildLookupTable(e);
      this._minPos = Os(r, this.min), this._tableRange = Os(r, this.max) - this._minPos, super.initOffsets(e);
    }
    buildLookupTable(e) {
      const { min: r, max: n } = this, i = [], o = [];
      let s, a, l, c, u;
      for (s = 0, a = e.length; s < a; ++s)
        c = e[s], c >= r && c <= n && i.push(c);
      if (i.length < 2)
        return [
          {
            time: r,
            pos: 0
          },
          {
            time: n,
            pos: 1
          }
        ];
      for (s = 0, a = i.length; s < a; ++s)
        u = i[s + 1], l = i[s - 1], c = i[s], Math.round((u + l) / 2) !== c && o.push({
          time: c,
          pos: s / (a - 1)
        });
      return o;
    }
    _generate() {
      const e = this.min, r = this.max;
      let n = super.getDataTimestamps();
      return (!n.includes(e) || !n.length) && n.splice(0, 0, e), (!n.includes(r) || n.length === 1) && n.push(r), n.sort((i, o) => i - o);
    }
    _getTimestampsForTable() {
      let e = this._cache.all || [];
      if (e.length)
        return e;
      const r = this.getDataTimestamps(), n = this.getLabelTimestamps();
      return r.length && n.length ? e = this.normalize(r.concat(n)) : e = r.length ? r : n, e = this._cache.all = e, e;
    }
    getDecimalForValue(e) {
      return (Os(this._table, e) - this._minPos) / this._tableRange;
    }
    getValueForPixel(e) {
      const r = this._offsets, n = this.getDecimalForPixel(e) / r.factor - r.end;
      return Os(this._table, n * this._tableRange + this._minPos, true);
    }
  }
  ye(Yc, "id", "timeseries"), ye(Yc, "defaults", No.defaults);
  var I5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale: zc,
    LinearScale: Vc,
    LogarithmicScale: qc,
    RadialLinearScale: co,
    TimeScale: No,
    TimeSeriesScale: Yc
  });
  const P5 = [
    Bv,
    hA,
    a5,
    I5
  ];
  Lr.register(...P5);
  class R5 {
    constructor(e, r, n) {
      ye(this, "getConfiguration");
      this.myChart = void 0, this.getConfiguration = r, this.resetBot = n, this.startTime = e, this.elapsedTimeDiv = null;
    }
    createOverlay() {
      const e = document.createElement("div");
      e.style.display = "flex", e.style.position = "fixed", e.style.top = "0%", e.style.right = "0%", e.style.width = "450px", e.style.height = "150px", e.style.zIndex = "1000", e.style.backgroundColor = "rgba(0,0,0,0.7)";
      const r = document.createElement("div");
      r.id = "overlay", r.style.top = "0%", r.style.right = "0%", r.style.width = "75%", r.style.height = "150px", r.style.backgroundColor = "rgba(0,0,0,0.7)";
      const n = document.createElement("div");
      n.style.display = "flex", n.style.flexDirection = "column", n.style.width = "25%", n.style.height = "150px", n.style.justifyContent = "strech", n.style.alignItems = "strech", n.style.backgroundColor = "rgba(0,0,0,0.7)";
      const i = document.createElement("canvas");
      i.id = "overlayChart", i.width = "100%", i.height = "100%", this.elapsedTimeDiv = document.createElement("div"), this.elapsedTimeDiv.style.position = "absolute", this.elapsedTimeDiv.style.bottom = "5px", this.elapsedTimeDiv.style.left = "26%", this.elapsedTimeDiv.style.color = "gray", this.elapsedTimeDiv.style.fontSize = "12px", this.elapsedTimeDiv.innerText = "Elapsed Time: 0s";
      const o = document.createElement("button");
      o.innerText = "Reset", o.style.width = "100%", o.style.height = "50%", o.style.color = "gray", o.style.backgroundColor = "rgba(0,0,0,0.7)", n.appendChild(o), o.addEventListener("click", this.resetBot.bind(this));
      const s = document.createElement("button");
      return s.innerText = "Download", s.style.width = "100%", s.style.height = "50%", s.addEventListener("click", this.downloadConfiguration.bind(this)), s.style.backgroundColor = "rgba(0,0,0,0.7)", s.style.color = "gray", n.appendChild(s), e.appendChild(n), e.appendChild(r), r.appendChild(i), r.appendChild(this.elapsedTimeDiv), document.body.appendChild(e), { overlay: r, chartCanvas: i };
    }
    setConfigurationForBot(e) {
      this.getConfiguration = e, console.log("CONFIGURATION SET", this.getConfiguration());
    }
    downloadConfiguration() {
      console.log("DOWNLOADING CONF", this.getConfiguration());
      const e = this.getConfiguration();
      console.log("CONFIGURATIOn", e);
      const r = JSON.stringify(e, null, 2);
      console.log("jsonStr", r);
      const n = new Blob([r], { type: "application/json" }), i = URL.createObjectURL(n), o = document.createElement("a");
      o.href = i, o.download = "chartConfiguration.json", document.body.appendChild(o), o.click(), document.body.removeChild(o);
    }
    showOverlayChart() {
      const { overlay: e, chartCanvas: r } = this.createOverlay();
      setInterval(this.updateElapsedTime.bind(this), 1e3);
      const n = r.getContext("2d");
      this.myChart = new Lr(n, {
        type: "line",
        data: {
          labels: [],
          // Empty array, we will populate it dynamically
          datasets: [
            {
              label: "Average Rewards",
              data: [],
              // Empty array, we will populate it dynamically
              borderColor: "rgba(75, 192, 192, 1)",
              borderWidth: 0.6,
              fill: false,
              pointRadius: 0,
              // This will remove the points
              pointHitRadius: 0
              // This will remove the points
            },
            {
              label: "Individual Rewards",
              data: [],
              // Empty array for individual data points
              borderColor: "rgba(255, 24, 12, 1)",
              // borderWidth: 2,
              fill: true,
              pointRadius: 0.1,
              // Add points
              // pointHitRadius: 1,
              showLine: false,
              animation: {
                // Disable animation for this dataset
                duration: 0
              }
            }
          ]
        },
        options: {
          scales: {
            x: {
              type: "linear",
              // To handle numerical data on x-axis
              position: "bottom",
              title: {
                display: true,
                text: "Number of Iterations"
              }
            },
            y: {
              title: {
                display: true,
                text: "Total Reward"
              }
            }
          }
        }
      });
    }
    updateChart(e, r, n) {
      this.myChart.data.labels.push(e), this.myChart.data.datasets[0].data.push(n / e), r !== 0 && this.myChart.data.datasets[1].data.push(r), this.myChart.update();
    }
    reset() {
      this.startTime = (/* @__PURE__ */ new Date()).getTime(), this.myChart.data.labels = [], this.myChart.data.datasets[0].data = [], this.myChart.update();
    }
    updateElapsedTime() {
      const r = (/* @__PURE__ */ new Date()).getTime() - this.startTime, n = Math.floor(r / 1e3), i = Math.floor(n / 3600), o = Math.floor(n % 3600 / 60), s = n % 60, a = String(i).padStart(2, "0"), l = String(o).padStart(2, "0"), c = String(s).padStart(2, "0"), u = `${a}:${l}:${c}`;
      this.elapsedTimeDiv.innerText = `Elapsed Time: ${u}`;
    }
  }
  function zh(t10) {
    try {
      var e = window[t10], r = "__storage_test__";
      return e.setItem(r, r), e.removeItem(r), true;
    } catch {
      return false;
    }
  }
  class sg {
    constructor(e) {
      if (!e || !e.player)
        throw new Error(
          "botParams is undefined, did you forget to pass botParams to base Bot class like: super(params);"
        );
      this._player = e.player, this._player.setState("__bot", true), this._player.bot = this, this._id = void 0;
    }
    get id() {
      return this._player.id;
    }
    get player() {
      return this._player;
    }
    getProfile() {
      return this.player.getProfile();
    }
    getState(e) {
      return this.player.getState(e);
    }
    setState(e, r, n) {
      this.player.setState(e, r, n);
    }
    onQuit(e) {
      return this.player.onQuit(e);
    }
    kick() {
      return this.player.kick();
    }
  }
  class D5 extends sg {
    constructor(r) {
      super(r);
      ye(this, "agent");
      ye(this, "totalIteration", 0);
      ye(this, "totalReward", 0);
      ye(this, "numberOfStates", 0);
      ye(this, "numberOfActions", 0);
      ye(this, "showChart", false);
      ye(this, "overlayChart");
      ye(this, "startTime", (/* @__PURE__ */ new Date()).getTime());
      if (!r.numberOfActions)
        throw new Error("Please Define Number of Actions for DQN Bot");
      if (!r.numberOfStates)
        throw new Error("Please Define Number of States for DQN Bot");
      this.numberOfActions = r.numberOfActions, this.numberOfStates = r.numberOfStates;
      const n = {
        getNumStates: () => this.numberOfStates,
        getMaxNumActions: () => this.numberOfActions
      };
      this.agent = new l1.DQNAgent(n, r.specifications), (!r.hasOwnProperty("retrieveFromLocalStorage") || r.retrieveFromLocalStorage) && (window.addEventListener("beforeunload", () => {
        this.saveModelToLocalStorage();
      }), this.loadModelFromLocalStorage()), r.weights && r.weights.modelWeights && this.setWeights(r.weights), this.overlayChart = new R5(
        this.startTime,
        this.getDownloadableConfiguration.bind(this),
        this.resetBot.bind(this)
      );
    }
    resetBot() {
      this.agent.reset(), this.totalIteration = 0, this.totalReward = 0, this.startTime = (/* @__PURE__ */ new Date()).getTime(), this.overlayChart.reset();
    }
    act(r) {
      if (r.length !== this.numberOfStates)
        throw new Error(
          `State provided for action ${r.length} does not match the number of states ${this.numberOfStates} provided while initialization`
        );
      const n = this.getValidStates(r);
      return this.agent.act(n);
    }
    getValidStates(r) {
      const n = [];
      for (let i = 0; i < r.length; i++) {
        const o = r[i];
        if (typeof o == "boolean")
          n.push(o ? 1 : 0);
        else if (typeof o == "number" && !isNaN(o))
          n.push(o);
        else
          throw new Error(
            `Invalid element at index ${i}: ${o}. Bot only expects Number/Boolean`
          );
      }
      return n;
    }
    learn(r) {
      this.totalIteration += 1, this.totalReward += r, this.showChart && this.overlayChart.updateChart(
        this.totalIteration,
        r,
        this.totalReward
      ), this.agent.learn(r);
    }
    getCurrentModelStateAsJSON() {
      const r = this.agent.toJSON();
      return JSON.stringify(r);
    }
    setCurrentModelState(r) {
      const n = JSON.parse(r);
      this.agent.fromJSON(n);
    }
    saveModelToLocalStorage() {
      try {
        if (zh("localStorage")) {
          const r = this.getCurrentModelStateAsJSON();
          localStorage.setItem(
            this.numberOfStates + "_" + this.numberOfActions,
            r
          );
        }
      } catch (r) {
        console.error(r);
      }
    }
    loadModelFromLocalStorage() {
      try {
        if (zh("localStorage")) {
          const r = localStorage.getItem(
            this.numberOfStates + "_" + this.numberOfActions
          );
          r && this.setCurrentModelState(r);
        }
      } catch (r) {
        console.error(r);
      }
    }
    getDownloadableConfiguration() {
      return {
        numberOfActions: this.numberOfActions,
        numberOfStates: this.numberOfStates,
        modelWeights: this.getCurrentModelStateAsJSON(),
        type: "dqn",
        iterations: this.totalIteration,
        reward: this.totalReward,
        startTime: this.startTime
      };
    }
    setWeights(r) {
      if (!r)
        throw new Error("Weights not given");
      this.setCurrentModelState(r.modelWeights), this.totalIteration = r.iterations ? r.iterations : 0, this.totalReward = r.reward ? r.reward : 0, this.startTime = r.startTime ? r.startTime : (/* @__PURE__ */ new Date()).getTime();
    }
    displayChart() {
      this.overlayChart.showOverlayChart(), this.showChart = true;
    }
  }
  const tc = 20;
  class CE extends D5 {
    constructor(r) {
      var n = 0;
      let i = r.joystickOptions;
      i.type === "dpad" ? n += 4 : i.type === "angular" && (n += Math.floor(360 / tc)), i.buttons && (n += i.buttons.length), r.numberOfActions = n;
      super(r);
      ye(this, "joystick");
      this.joystick = i, this.numberOfActions = n;
    }
    getAction(r) {
      var n = this.act(r);
      let i = {};
      if (this.joystick.type === "dpad") {
        var o = void 0, s = void 0;
        n === 0 && (o = "left"), n === 1 && (o = "right"), n === 2 && (s = "up"), n === 3 && (s = "down"), o && (i.x = o), s && (i.y = s);
      }
      this.joystick.type === "angular" && (i = n * tc * (Math.PI / 180));
      var a = this.joystick.type === "dpad" ? 4 : Math.floor(360 / tc), l = {};
      const c = this.joystick.buttons;
      if (c.length > 0)
        for (let u = 0; u < c.length; u++)
          u === n - a ? l[c[u].id] = true : l[c[u].id] = false;
      return {
        joystickType: this.joystick.type,
        finalDirection: i,
        buttonSelection: l
      };
    }
    setDQNBotState(r) {
      var { joystickType: n, finalDirection: i, buttonSelection: o } = this.getAction(r);
      this.player.setState("ctr-joystick", false), n === "angular" && !isNaN(i) && (this.player.setState("ctr-angle", i), this.player.setState("ctr-joystick", true)), n === "dpad" && Object.keys(i).length !== 0 && (this.player.setState("ctr-dpad", i), this.player.setState("ctr-joystick", true));
      for (var s in o)
        this.player.setState("ctr-" + s, false), this.player.setState("ctr-" + s, o[s]);
    }
    setDQNBotReward(r) {
      this.learn(r);
    }
  }
  const Vh = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ];
  function M5() {
    return new Promise((t10, e) => {
      Ie().connection.once("sync", () => {
        setTimeout(() => {
          t10();
        }, 1e3);
      });
    });
  }
  let Qi = [], qh = false, hr, wr;
  async function N5() {
    var t10;
    if (!qh) {
      if (wr = Ie(), hr = (t10 = wr.sdkOptions) == null ? void 0 : t10.botOptions, !hr)
        throw new Error("Please Define Bot Options");
      if (!hr.botClass)
        throw new Error("Please Define Bot Instance");
      await M5(), qh = true, wr.on("joined", (e) => {
        !wr.isHost && e.isBot() && ag(e);
      });
    }
  }
  function ag(t10) {
    return hr.botParams = hr.botParams || {}, hr.botParams.player = t10, new hr.botClass(hr.botParams);
  }
  function L5(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  function B5(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Ha(qa(L5(10)));
  }
  async function F5() {
    if (!wr || !wr.isConnected)
      throw new Error("Create or join a room before adding bots");
    const t10 = wr.sdkOptions || {}, e = Object.keys(wr.getPlayers()).length;
    if (t10.maxPlayersPerRoom && e >= t10.maxPlayersPerRoom)
      throw new Error("Room's players limit has reached.");
    const r = wr.connection.addProxyPlayer();
    r.setState("profile", {
      name: "Bot " + (Qi.length + 1),
      photo: B5(t10.avatars),
      color: Vh[Qi.length % Vh.length]
    });
    let n = ag(r);
    if (!(n instanceof sg))
      throw wr.connection.removeProxyPlayer(r.id), new Error("Bot Class Should Be Instance of Bot");
    hr.trainingMode && n.displayChart();
    let i;
    return hr.botParams.joystickOptions ? i = new Pc(r, hr.botParams.joystickOptions) : i = new Pc(r), Qi.push({ player: r, joystick: i, bot: n }), r.on("quit", () => {
      const o = Qi.findIndex((s) => r.id == s.player.id);
      Qi.splice(o, 1);
    }), n;
  }
  const j5 = "playroomkit", W5 = "0.0.87", U5 = "https://joinplayroom.com", z5 = "./multiplayer.mjs", V5 = "./types.d.ts", q5 = "./bin/cli.js", H5 = [
    "multiplayer.umd.js",
    "multiplayer.full.umd.js",
    "multiplayer.mjs",
    "style.css",
    "types.d.ts",
    "bin"
  ], Y5 = {}, K5 = {
    react: ">=17.0.2 <= 18",
    "react-dom": ">=17.0.2 <= 18"
  }, X5 = {
    "@discord/embedded-app-sdk": ">=1.0.0"
  }, Gu = {
    name: j5,
    version: W5,
    homepage: U5,
    main: z5,
    types: V5,
    bin: q5,
    files: H5,
    dependencies: Y5,
    peerDependencies: K5,
    optionalDependencies: X5
  };
  async function TE(t10) {
    const e = ha(10);
    return await A3("_turns", {
      id: e,
      player: {
        id: Hn().id,
        profile: Hn().getProfile()
      },
      data: t10
    }), e;
  }
  async function OE() {
    return await a1("_turns") || [];
  }
  async function IE() {
    await v3("_turns", void 0);
  }
  async function PE() {
    const t10 = await a1("_turns"), e = (t10 == null ? void 0 : t10.filter((n) => {
      var o;
      return (typeof n.player == "string" ? n.player : (o = n.player) == null ? void 0 : o.id) === Hn().id;
    })) || [];
    return e[e.length - 1] || void 0;
  }
  const lg = `/*!
 * Bootstrap Grid Only (grid and responsive utilities extracted from Bootstrap 4.1.3)
 * GitHub: https://github.com/dmhendricks/bootstrap-grid-css
 * Bootstrap License: MIT (https://github.com/twbs/bootstrap/blob/v4-dev/LICENSE)
 * Credits: Twitter, Inc. & The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 */@-ms-viewport{width:device-width}html{-webkit-box-sizing:border-box;box-sizing:border-box;-ms-overflow-style:scrollbar}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}.bootstrap-wrapper .clearfix:after{display:block;clear:both;content:""}.bootstrap-wrapper .visible{visibility:visible!important}.bootstrap-wrapper .invisible{visibility:hidden!important}.bootstrap-wrapper .hidden-xs-up{display:none!important}@media (max-width: 575.98px){.bootstrap-wrapper .hidden-xs-down{display:none!important}}@media (min-width: 576px){.bootstrap-wrapper .hidden-sm-up{display:none!important}}@media (max-width: 767.98px){.bootstrap-wrapper .hidden-sm-down{display:none!important}}@media (min-width: 768px){.bootstrap-wrapper .hidden-md-up{display:none!important}}@media (max-width: 991.98px){.bootstrap-wrapper .hidden-md-down{display:none!important}}@media (min-width: 992px){.bootstrap-wrapper .hidden-lg-up{display:none!important}}@media (max-width: 1199.98px){.bootstrap-wrapper .hidden-lg-down{display:none!important}}@media (min-width: 1200px){.bootstrap-wrapper .hidden-xl-up{display:none!important}}.bootstrap-wrapper .hidden-xl-down,.bootstrap-wrapper .visible-print-block{display:none!important}@media print{.bootstrap-wrapper .visible-print-block{display:block!important}}.bootstrap-wrapper .visible-print-inline{display:none!important}@media print{.bootstrap-wrapper .visible-print-inline{display:inline!important}}.bootstrap-wrapper .visible-print-inline-block{display:none!important}@media print{.bootstrap-wrapper .visible-print-inline-block{display:inline-block!important}}@media print{.bootstrap-wrapper .hidden-print{display:none!important}}.bootstrap-wrapper .container{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width: 576px){.bootstrap-wrapper .container{max-width:540px}}@media (min-width: 768px){.bootstrap-wrapper .container{max-width:720px}}@media (min-width: 992px){.bootstrap-wrapper .container{max-width:960px}}@media (min-width: 1200px){.bootstrap-wrapper .container{max-width:1140px}}.bootstrap-wrapper .container-fluid{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.bootstrap-wrapper .row{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.bootstrap-wrapper .no-gutters{margin-right:0;margin-left:0}.bootstrap-wrapper .no-gutters>.col,.bootstrap-wrapper .no-gutters>[class*=col-]{padding-right:0;padding-left:0}.bootstrap-wrapper .col-1,.bootstrap-wrapper .col-2,.bootstrap-wrapper .col-3,.bootstrap-wrapper .col-4,.bootstrap-wrapper .col-5,.bootstrap-wrapper .col-6,.bootstrap-wrapper .col-7,.bootstrap-wrapper .col-8,.bootstrap-wrapper .col-9,.bootstrap-wrapper .col-10,.bootstrap-wrapper .col-11,.bootstrap-wrapper .col-12,.bootstrap-wrapper .col,.bootstrap-wrapper .col-auto,.bootstrap-wrapper .col-sm-1,.bootstrap-wrapper .col-sm-2,.bootstrap-wrapper .col-sm-3,.bootstrap-wrapper .col-sm-4,.bootstrap-wrapper .col-sm-5,.bootstrap-wrapper .col-sm-6,.bootstrap-wrapper .col-sm-7,.bootstrap-wrapper .col-sm-8,.bootstrap-wrapper .col-sm-9,.bootstrap-wrapper .col-sm-10,.bootstrap-wrapper .col-sm-11,.bootstrap-wrapper .col-sm-12,.bootstrap-wrapper .col-sm,.bootstrap-wrapper .col-sm-auto,.bootstrap-wrapper .col-md-1,.bootstrap-wrapper .col-md-2,.bootstrap-wrapper .col-md-3,.bootstrap-wrapper .col-md-4,.bootstrap-wrapper .col-md-5,.bootstrap-wrapper .col-md-6,.bootstrap-wrapper .col-md-7,.bootstrap-wrapper .col-md-8,.bootstrap-wrapper .col-md-9,.bootstrap-wrapper .col-md-10,.bootstrap-wrapper .col-md-11,.bootstrap-wrapper .col-md-12,.bootstrap-wrapper .col-md,.bootstrap-wrapper .col-md-auto,.bootstrap-wrapper .col-lg-1,.bootstrap-wrapper .col-lg-2,.bootstrap-wrapper .col-lg-3,.bootstrap-wrapper .col-lg-4,.bootstrap-wrapper .col-lg-5,.bootstrap-wrapper .col-lg-6,.bootstrap-wrapper .col-lg-7,.bootstrap-wrapper .col-lg-8,.bootstrap-wrapper .col-lg-9,.bootstrap-wrapper .col-lg-10,.bootstrap-wrapper .col-lg-11,.bootstrap-wrapper .col-lg-12,.bootstrap-wrapper .col-lg,.bootstrap-wrapper .col-lg-auto,.bootstrap-wrapper .col-xl-1,.bootstrap-wrapper .col-xl-2,.bootstrap-wrapper .col-xl-3,.bootstrap-wrapper .col-xl-4,.bootstrap-wrapper .col-xl-5,.bootstrap-wrapper .col-xl-6,.bootstrap-wrapper .col-xl-7,.bootstrap-wrapper .col-xl-8,.bootstrap-wrapper .col-xl-9,.bootstrap-wrapper .col-xl-10,.bootstrap-wrapper .col-xl-11,.bootstrap-wrapper .col-xl-12,.bootstrap-wrapper .col-xl,.bootstrap-wrapper .col-xl-auto{position:relative;width:100%;padding-right:15px;padding-left:15px}.bootstrap-wrapper .col{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-3{margin-left:25%}.bootstrap-wrapper .offset-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-6{margin-left:50%}.bootstrap-wrapper .offset-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-9{margin-left:75%}.bootstrap-wrapper .offset-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-11{margin-left:91.6666666667%}@media (min-width: 576px){.bootstrap-wrapper .col-sm{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-sm-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-sm-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-sm-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-sm-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-sm-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-sm-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-sm-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-sm-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-sm-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-sm-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-sm-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-sm-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-sm-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-sm-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-sm-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-sm-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-sm-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-sm-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-sm-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-sm-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-sm-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-sm-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-sm-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-sm-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-sm-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-sm-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-sm-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-sm-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-sm-0{margin-left:0}.bootstrap-wrapper .offset-sm-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-sm-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-sm-3{margin-left:25%}.bootstrap-wrapper .offset-sm-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-sm-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-sm-6{margin-left:50%}.bootstrap-wrapper .offset-sm-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-sm-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-sm-9{margin-left:75%}.bootstrap-wrapper .offset-sm-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-sm-11{margin-left:91.6666666667%}}@media (min-width: 768px){.bootstrap-wrapper .col-md{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-md-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-md-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-md-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-md-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-md-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-md-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-md-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-md-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-md-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-md-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-md-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-md-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-md-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-md-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-md-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-md-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-md-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-md-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-md-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-md-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-md-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-md-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-md-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-md-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-md-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-md-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-md-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-md-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-md-0{margin-left:0}.bootstrap-wrapper .offset-md-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-md-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-md-3{margin-left:25%}.bootstrap-wrapper .offset-md-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-md-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-md-6{margin-left:50%}.bootstrap-wrapper .offset-md-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-md-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-md-9{margin-left:75%}.bootstrap-wrapper .offset-md-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-md-11{margin-left:91.6666666667%}}@media (min-width: 992px){.bootstrap-wrapper .col-lg{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-lg-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-lg-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-lg-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-lg-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-lg-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-lg-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-lg-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-lg-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-lg-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-lg-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-lg-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-lg-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-lg-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-lg-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-lg-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-lg-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-lg-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-lg-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-lg-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-lg-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-lg-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-lg-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-lg-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-lg-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-lg-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-lg-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-lg-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-lg-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-lg-0{margin-left:0}.bootstrap-wrapper .offset-lg-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-lg-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-lg-3{margin-left:25%}.bootstrap-wrapper .offset-lg-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-lg-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-lg-6{margin-left:50%}.bootstrap-wrapper .offset-lg-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-lg-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-lg-9{margin-left:75%}.bootstrap-wrapper .offset-lg-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-lg-11{margin-left:91.6666666667%}}@media (min-width: 1200px){.bootstrap-wrapper .col-xl{-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;max-width:100%}.bootstrap-wrapper .col-xl-auto{-webkit-box-flex:0;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.bootstrap-wrapper .col-xl-1{-webkit-box-flex:0;-webkit-flex:0 0 8.3333333333%;-ms-flex:0 0 8.3333333333%;flex:0 0 8.3333333333%;max-width:8.3333333333%}.bootstrap-wrapper .col-xl-2{-webkit-box-flex:0;-webkit-flex:0 0 16.6666666667%;-ms-flex:0 0 16.6666666667%;flex:0 0 16.6666666667%;max-width:16.6666666667%}.bootstrap-wrapper .col-xl-3{-webkit-box-flex:0;-webkit-flex:0 0 25%;-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.bootstrap-wrapper .col-xl-4{-webkit-box-flex:0;-webkit-flex:0 0 33.3333333333%;-ms-flex:0 0 33.3333333333%;flex:0 0 33.3333333333%;max-width:33.3333333333%}.bootstrap-wrapper .col-xl-5{-webkit-box-flex:0;-webkit-flex:0 0 41.6666666667%;-ms-flex:0 0 41.6666666667%;flex:0 0 41.6666666667%;max-width:41.6666666667%}.bootstrap-wrapper .col-xl-6{-webkit-box-flex:0;-webkit-flex:0 0 50%;-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.bootstrap-wrapper .col-xl-7{-webkit-box-flex:0;-webkit-flex:0 0 58.3333333333%;-ms-flex:0 0 58.3333333333%;flex:0 0 58.3333333333%;max-width:58.3333333333%}.bootstrap-wrapper .col-xl-8{-webkit-box-flex:0;-webkit-flex:0 0 66.6666666667%;-ms-flex:0 0 66.6666666667%;flex:0 0 66.6666666667%;max-width:66.6666666667%}.bootstrap-wrapper .col-xl-9{-webkit-box-flex:0;-webkit-flex:0 0 75%;-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.bootstrap-wrapper .col-xl-10{-webkit-box-flex:0;-webkit-flex:0 0 83.3333333333%;-ms-flex:0 0 83.3333333333%;flex:0 0 83.3333333333%;max-width:83.3333333333%}.bootstrap-wrapper .col-xl-11{-webkit-box-flex:0;-webkit-flex:0 0 91.6666666667%;-ms-flex:0 0 91.6666666667%;flex:0 0 91.6666666667%;max-width:91.6666666667%}.bootstrap-wrapper .col-xl-12{-webkit-box-flex:0;-webkit-flex:0 0 100%;-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.bootstrap-wrapper .order-xl-first{-webkit-box-ordinal-group:0;-webkit-order:-1;-ms-flex-order:-1;order:-1}.bootstrap-wrapper .order-xl-last{-webkit-box-ordinal-group:14;-webkit-order:13;-ms-flex-order:13;order:13}.bootstrap-wrapper .order-xl-0{-webkit-box-ordinal-group:1;-webkit-order:0;-ms-flex-order:0;order:0}.bootstrap-wrapper .order-xl-1{-webkit-box-ordinal-group:2;-webkit-order:1;-ms-flex-order:1;order:1}.bootstrap-wrapper .order-xl-2{-webkit-box-ordinal-group:3;-webkit-order:2;-ms-flex-order:2;order:2}.bootstrap-wrapper .order-xl-3{-webkit-box-ordinal-group:4;-webkit-order:3;-ms-flex-order:3;order:3}.bootstrap-wrapper .order-xl-4{-webkit-box-ordinal-group:5;-webkit-order:4;-ms-flex-order:4;order:4}.bootstrap-wrapper .order-xl-5{-webkit-box-ordinal-group:6;-webkit-order:5;-ms-flex-order:5;order:5}.bootstrap-wrapper .order-xl-6{-webkit-box-ordinal-group:7;-webkit-order:6;-ms-flex-order:6;order:6}.bootstrap-wrapper .order-xl-7{-webkit-box-ordinal-group:8;-webkit-order:7;-ms-flex-order:7;order:7}.bootstrap-wrapper .order-xl-8{-webkit-box-ordinal-group:9;-webkit-order:8;-ms-flex-order:8;order:8}.bootstrap-wrapper .order-xl-9{-webkit-box-ordinal-group:10;-webkit-order:9;-ms-flex-order:9;order:9}.bootstrap-wrapper .order-xl-10{-webkit-box-ordinal-group:11;-webkit-order:10;-ms-flex-order:10;order:10}.bootstrap-wrapper .order-xl-11{-webkit-box-ordinal-group:12;-webkit-order:11;-ms-flex-order:11;order:11}.bootstrap-wrapper .order-xl-12{-webkit-box-ordinal-group:13;-webkit-order:12;-ms-flex-order:12;order:12}.bootstrap-wrapper .offset-xl-0{margin-left:0}.bootstrap-wrapper .offset-xl-1{margin-left:8.3333333333%}.bootstrap-wrapper .offset-xl-2{margin-left:16.6666666667%}.bootstrap-wrapper .offset-xl-3{margin-left:25%}.bootstrap-wrapper .offset-xl-4{margin-left:33.3333333333%}.bootstrap-wrapper .offset-xl-5{margin-left:41.6666666667%}.bootstrap-wrapper .offset-xl-6{margin-left:50%}.bootstrap-wrapper .offset-xl-7{margin-left:58.3333333333%}.bootstrap-wrapper .offset-xl-8{margin-left:66.6666666667%}.bootstrap-wrapper .offset-xl-9{margin-left:75%}.bootstrap-wrapper .offset-xl-10{margin-left:83.3333333333%}.bootstrap-wrapper .offset-xl-11{margin-left:91.6666666667%}}.bootstrap-wrapper .img-fluid{max-width:100%;height:auto}
`, cg = `:root{--bg-surface-base: #121316;--bg-surface-light2: #272729}.bootstrap-wrapper{font-family:Russo One,sans-serif}.modal-container{position:absolute;top:0;left:0;right:0;bottom:0;z-index:100}.modal-container.fullscreen #popup{background-image:linear-gradient(to bottom,var(--bg-surface-light2) 25%,var(--bg-surface-base) 75%)!important;border-radius:0;height:100vh;width:100vw;padding-top:1rem}.modal-container .popupcontent>span{font-size:1.3rem;margin-bottom:40px;display:block;text-align:center;padding:0px 6rem;max-width:50rem}.modal-container .popupcontent>span.error{color:#bf0000}.modal-container.fullscreen #overlay.show{opacity:1!important;border-radius:0}.modal-container .react-code-input input:first-child{border-color:#ffb0cc;color:#ffb0cc}.modal-container .react-code-input input:nth-child(2){border-color:#fff27a;color:#fff27a}.modal-container .react-code-input input:nth-child(3){border-color:#6bdcff;color:#6bdcff}.modal-container .react-code-input input:nth-child(4){border-color:#ff7f56;color:#ff7f56}.modal-container.fullscreen .popupcontent{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;row-gap:1rem}.full-room-container{background-image:linear-gradient(to bottom,var(--bg-surface-light2) 25%,var(--bg-surface-base) 75%);position:absolute;top:0;left:0;right:0;bottom:0;z-index:101}.button-bot{position:relative;top:60px;width:70px;min-width:70px;height:50px;border:none;border-radius:14px;border:2px solid #000;padding:0rem;font-size:1.5rem;font-weight:400;font-family:Russo One,sans-serif;background:#fff;background-color:#fff;cursor:pointer;color:#000;backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);box-shadow:0 7px #00000040}.button-black{cursor:pointer;font-weight:bolder;border:none;color:#000;min-width:80px;height:65px;font-size:1.2rem;background:#fff;backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:2px solid #000;box-shadow:0 7px #00000040;border-radius:20px}.button-black.disabled{color:#fff;background:transparent;border:1px solid #fff;cursor:not-allowed;width:100%}.button-black.btn-icon{background-repeat:no-repeat;background-position-y:center;background-position-x:1rem;background-size:1.75rem}.btn-invite{min-width:200px}.airplay-btn{margin-right:.5rem}.launch-btn{width:100%}.close-btn{width:100%;background:#000;cursor:pointer;font-weight:bolder;border:none;color:#fff;min-width:80px;height:60px;font-size:1rem;border-radius:14px}.close-btn.white{background:#fff;color:#000}.airplay-icon{width:30px;height:30px;object-fit:contain;margin-top:8px}.player-avatar-strip{display:flex}.player-avatar-strip:not(.mobile){margin-bottom:2.2rem;flex-wrap:wrap;row-gap:.5rem}.player-avatar-strip.mobile{overflow-x:auto;max-width:100%;padding-bottom:.4rem}.player-avatar-strip.mobile>div:first-child{margin-left:auto}.player-avatar-strip.mobile>div:last-child{margin-right:auto}.player-avatar-strip .player-score-container{display:flex;flex-direction:row;align-items:center;margin:0rem .3rem;border-radius:2rem;padding:.2rem;position:relative}.player-avatar-strip .player-score-container .player-remove{position:absolute;top:-.1rem;right:-1rem;width:1.5rem;height:1.5rem;border-radius:50%;color:#fff;display:flex;align-items:center;justify-content:center;font-size:1.2rem;cursor:pointer}.player-avatar-strip .player-score-container>span{color:#fff;font-family:Lilita One;font-style:normal;font-weight:400;font-size:2rem;margin:0rem 1rem}.player-avatar-strip .avatar-holder{background-color:#fffc;background-size:23px;background-position:center;background-repeat:no-repeat;width:3.5rem;height:3.5rem;border-radius:50%;margin:.1rem;border:.15rem solid transparent}.player-avatar-strip .avatar-holder.empty{background-color:#0003!important}.player-avatar-strip.mobile .avatar-holder{width:2.5rem;height:2.5rem}.player-avatar-strip.mobile .player-score-container>span{font-size:1.5rem;margin:0rem .7rem}.room-code-sticker{font-family:Russo One,sans-serif;position:absolute;top:calc(20px + env(safe-area-inset-top));right:0;background-color:#fff;color:#000;padding:1.45rem 1.513rem;border-radius:1.1rem;z-index:4;display:flex;flex-direction:column;align-items:center;margin:0rem 3rem;width:11.1rem;text-align:center}.room-code-sticker .qr-code{height:auto;margin:0 auto;width:100%}.room-code-sticker .room-code{margin-top:.62rem;font-size:.89rem;display:flex;flex-direction:column;align-items:center}.room-code-sticker .room-code b{font-size:1.5rem;margin:0;font-weight:400;display:block;white-space:nowrap}.room-code-sticker{width:15.8rem!important;border-radius:2.2rem!important}.room-code-sticker .room-code b{font-size:2.8rem!important;line-height:normal;font-weight:700}.room-code-sticker .room-code span{font-size:1.6rem!important;line-height:normal;display:none}.player-avatar-strip .player-score-container{padding:.1rem!important}.player-avatar-strip .avatar-holder{border-width:0px;width:3rem!important;height:3rem!important;position:relative}.player-avatar-strip .avatar-holder .badge-gamepad{display:block;background-color:#703eff;width:2rem;background-repeat:no-repeat;background-position:center;background-size:70%;border-radius:100%;position:absolute;height:1.7rem;top:1.7rem;right:-.7rem}@-webkit-keyframes playroom-anim-dash{0%{transform:translate(-100%)}to{transform:translate(100%)}}@keyframes playroom-anim-dash{0%{transform:translate(-100%)}to{transform:translate(100%)}}.bootstrap-wrapper .playroom .steps-container{display:flex;height:10px;width:100%;gap:14px}.bootstrap-wrapper .playroom .step-item{flex:1 1 0;width:0;background:#dfdfdf;border-radius:15px}.bootstrap-wrapper .playroom .step-item.active{background:#00bc8b}.bootstrap-wrapper .playroom .step-item.loading{position:relative;overflow:hidden;z-index:0}.bootstrap-wrapper .playroom .step-item.loading:before,.bootstrap-wrapper .playroom .step-item.loading:after,.bootstrap-wrapper .playroom .step-item.loading span{display:flex;position:absolute;transform:translate(-100%);height:100%;width:100%;border-radius:15px}.bootstrap-wrapper .playroom .step-item.loading span{-webkit-animation:playroom-anim-dash 1.618s infinite cubic-bezier(.4,0,1,1);animation:playroom-anim-dash 1.618s infinite cubic-bezier(.4,0,1,1);background-color:#00bc8b;z-index:2}.bootstrap-wrapper .playroom .step-item.loading span:before{content:"";display:inline-block;position:absolute;left:0;width:10px;height:10px;border-radius:50%;background-color:#dfdfdf}.bootstrap-wrapper .playroom .step-item.loading:before{content:"";-webkit-animation:playroom-anim-dash 1.618s infinite cubic-bezier(.2,0,1,1);animation:playroom-anim-dash 1.618s infinite cubic-bezier(.2,0,1,1);background-color:#9eddcc;z-index:1}.bootstrap-wrapper .playroom .step-item.loading:after{content:"";-webkit-animation:playroom-anim-dash 1.618s infinite linear;animation:playroom-anim-dash 1.618s infinite linear;background-color:#cbf4e9;z-index:0}
`, ug = `@import"https://fonts.googleapis.com/css2?family=Russo+One&display=swap";.platform{position:fixed;top:50%;max-width:500px;right:0;z-index:3;transform:translate(-50%,-50%);background-size:contain;width:90vw;left:50%;background-position:50% 55%;display:flex;flex-direction:column;align-items:center;justify-content:center}.back-dark-gradient{background:#5f33ff;background-repeat:no-repeat;background-attachment:fixed}.platform .avatar-container{width:100%;height:100%;display:block;background-size:contain;background-repeat:no-repeat;position:absolute;top:0}.full-avatar-container{width:80px;height:100px;display:block;background-size:contain;background-repeat:no-repeat;position:relative;z-index:2}.player-shadow{display:block;position:absolute;bottom:-45%;left:0;width:100%;height:100%;background-size:100%;background-repeat:no-repeat;background-position:center}.platform .avatar-photo{width:14rem;height:14rem;display:block;background-size:contain;background-repeat:no-repeat;position:relative;border-radius:50%;border:4px solid red;background-color:#0006;backdrop-filter:blur(20px)}.platform .avatar-photo.no-photo{background-size:25%;background-position:center}.platform .color-tray{z-index:3;display:block}.platform .color-tray .color{width:1.8rem;height:1.8rem;display:inline-block;border-radius:50%;margin:3.5px;vertical-align:middle}.platform .input-name{background:#fff;border:4px solid #fff;border-radius:1.8rem;padding:14px 0;font-size:1.2rem;margin:-30px 20px 20px;text-align:center;color:#000;font-weight:700;z-index:1;position:relative;width:14rem}.platform .profilecontainer{text-align:center;padding:40px 20px;background:linear-gradient(0deg,#18191b,#18191b),linear-gradient(0deg,#38393c,#38393c);border:1px solid #38393c;box-shadow:0 2px #ffffff40 inset;border-radius:20.75px;width:100%}.platform .party-hr{font-family:Russo One,sans-serif;font-weight:700;font-size:.85rem;display:flex;align-items:center;text-align:center;color:#fff;margin:2rem 0}.platform .party-hr:before,.platform .party-hr:after{content:"";flex:1;border-bottom:1px solid #38393c}.platform .party-hr:not(:empty):before{margin-right:1.25em}.platform .party-hr:not(:empty):after{margin-left:1.25em}.platform .input-name:focus{outline:none}.platform .color-tray .color.active{width:2.6rem;height:2.6rem}.platform #btn-launchjoin{margin-top:2rem}.button-crop{background-color:#fff;color:#000;width:auto;margin-top:20px}.platform .refresh-button{position:absolute;top:10px;right:10px;color:#000;cursor:pointer;background:#18191b;padding:10px;z-index:1;border-radius:50%;line-height:0;border:1px solid rgba(255,255,255,.3)}.room-code-sticker{width:16.8rem!important;margin:1.1rem 0px}.toast-container{animation:fadeIn .2s,slideIn .2s cubic-bezier(.4,-.05,0,1);transform:translate(-50%) scale(.9)}.sdk-version{margin-top:2rem;color:#fff;font-size:1rem}@keyframes slideIn{0%{transform:translate(-50%) translateY(400px) scale(.9);animation-timing-function:ease-out}to{transform:translate(-50%) translateY(0) scale(.9);animation-timing-function:ease-in}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.airplay-instruction-modal{position:absolute;top:0;left:0;bottom:0;right:0;z-index:101}.airplay-instruction-toast{max-width:500px;width:100%;position:absolute;bottom:.7rem;left:50%;transform:translate(-50%) scale(.9);display:flex;flex-direction:column;align-items:center;justify-content:center;border-radius:4.5rem}.airplay-instruction-container{font-family:Russo One,sans-serif;display:flex;flex-direction:column;align-items:center;margin:1rem 0rem;background:#fff;border:2px solid #000000;box-shadow:0 12px #00000040;border-radius:20px;width:95%;padding:1rem}.airplay-instruction-container .close-icon{background-color:#ff3666;height:4rem;width:4rem;transform:scale(.7);border-radius:50%;position:absolute;top:1.5rem;right:1rem;padding:1rem;cursor:pointer;text-align:center;flex-direction:column;align-items:center;justify-content:center}.airplay-instruction-container .airplay-icon{width:4rem;height:4rem;object-fit:contain}.airplay-instruction-container .airplay-instruction-title{font-weight:bolder;font-size:1.6rem;line-height:normal;margin:0rem;font-family:Open Sans,sans-serif}
`;
  function Dn(t10) {
    var e = Zu();
    return e[t10];
  }
  function Zu() {
    var t10 = window.location.hash;
    t10 && (t10 = t10.split("#")[1]);
    var e = t10.split("&"), r = {};
    return e.forEach(function(n, i) {
      n = n.split("="), n[0] !== "" && (r[n[0]] = n[1]);
    }), r;
  }
  function fg(t10) {
    var e = Object.keys(t10), r = Object.values(t10), n = [];
    e.forEach(function(o, s) {
      o !== "" && n.push(e[s] + "=" + r[s]);
    });
    var i = n.join("&");
    window.location.hash = i;
  }
  function Kc(t10, e) {
    var r = Zu();
    r[t10] = e, e === void 0 && delete r[t10], fg(r);
  }
  const Xc = {
    getUrlHashParameter: Dn,
    getUrlHashParameters: Zu,
    setUrlHashParameter: Kc,
    setUrlHashParameters: fg
  };
  function J5() {
    return Xc.getUrlHashParameter("preview") === "phone";
  }
  function Q5() {
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.NativeMethods)
      return true;
  }
  function G5() {
    return !!(Q5() || J5() || localStorage && xt.get("DEV"));
  }
  function Z5() {
    return !!(G5() || $5 || ew);
  }
  var $5 = typeof window < "u" && /(android)/i.test(navigator.userAgent), ew = function() {
    if (typeof window > "u")
      return false;
    var t10 = function() {
      var i = new Audio();
      return i.volume = 0.5, i.volume === 1;
    }, e = /iPhone|iPod/.test(navigator.userAgent), r = navigator.userAgent.includes("Macintosh"), n = navigator.maxTouchPoints >= 1;
    return e || r && (n || t10());
  }(), Jc = {}, tw = {
    get exports() {
      return Jc;
    },
    set exports(t10) {
      Jc = t10;
    }
  }, rc = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Hh;
  function rw() {
    if (Hh)
      return rc;
    Hh = 1;
    var t10 = K;
    function e(f, d) {
      return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : e, n = t10.useState, i = t10.useEffect, o = t10.useLayoutEffect, s = t10.useDebugValue;
    function a(f, d) {
      var h = d(), g = n({ inst: { value: h, getSnapshot: d } }), p = g[0].inst, y = g[1];
      return o(function() {
        p.value = h, p.getSnapshot = d, l(p) && y({ inst: p });
      }, [f, h, d]), i(function() {
        return l(p) && y({ inst: p }), f(function() {
          l(p) && y({ inst: p });
        });
      }, [f]), s(h), h;
    }
    function l(f) {
      var d = f.getSnapshot;
      f = f.value;
      try {
        var h = d();
        return !r(f, h);
      } catch {
        return true;
      }
    }
    function c(f, d) {
      return d();
    }
    var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
    return rc.useSyncExternalStore = t10.useSyncExternalStore !== void 0 ? t10.useSyncExternalStore : u, rc;
  }
  var nc = {};
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Yh;
  function nw() {
    return Yh || (Yh = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t10 = K, e = t10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function r(S) {
        {
          for (var O = arguments.length, _ = new Array(O > 1 ? O - 1 : 0), L = 1; L < O; L++)
            _[L - 1] = arguments[L];
          n("error", S, _);
        }
      }
      function n(S, O, _) {
        {
          var L = e.ReactDebugCurrentFrame, N = L.getStackAddendum();
          N !== "" && (O += "%s", _ = _.concat([N]));
          var j = _.map(function(W) {
            return String(W);
          });
          j.unshift("Warning: " + O), Function.prototype.apply.call(console[S], console, j);
        }
      }
      function i(S, O) {
        return S === O && (S !== 0 || 1 / S === 1 / O) || S !== S && O !== O;
      }
      var o = typeof Object.is == "function" ? Object.is : i, s = t10.useState, a = t10.useEffect, l = t10.useLayoutEffect, c = t10.useDebugValue, u = false, f = false;
      function d(S, O, _) {
        u || t10.startTransition !== void 0 && (u = true, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var L = O();
        if (!f) {
          var N = O();
          o(L, N) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), f = true);
        }
        var j = s({
          inst: {
            value: L,
            getSnapshot: O
          }
        }), W = j[0].inst, G = j[1];
        return l(function() {
          W.value = L, W.getSnapshot = O, h(W) && G({
            inst: W
          });
        }, [S, L, O]), a(function() {
          h(W) && G({
            inst: W
          });
          var ee = function() {
            h(W) && G({
              inst: W
            });
          };
          return S(ee);
        }, [S]), c(L), L;
      }
      function h(S) {
        var O = S.getSnapshot, _ = S.value;
        try {
          var L = O();
          return !o(_, L);
        } catch {
          return true;
        }
      }
      function g(S, O, _) {
        return O();
      }
      var p = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !p, b = y ? g : d, x = t10.useSyncExternalStore !== void 0 ? t10.useSyncExternalStore : b;
      nc.useSyncExternalStore = x, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }()), nc;
  }
  (function(t10) {
    define_process_env_default.NODE_ENV === "production" ? t10.exports = rw() : t10.exports = nw();
  })(tw);
  const sn = () => {
  }, Ft = (
    /*#__NOINLINE__*/
    sn()
  ), ic = Object, ze = (t10) => t10 === Ft, Vr = (t10) => typeof t10 == "function", mn = (t10, e) => ({
    ...t10,
    ...e
  }), iw = (t10) => Vr(t10.then), Is = /* @__PURE__ */ new WeakMap();
  let ow = 0;
  const Lo = (t10) => {
    const e = typeof t10, r = t10 && t10.constructor, n = r == Date;
    let i, o;
    if (ic(t10) === t10 && !n && r != RegExp) {
      if (i = Is.get(t10), i)
        return i;
      if (i = ++ow + "~", Is.set(t10, i), r == Array) {
        for (i = "@", o = 0; o < t10.length; o++)
          i += Lo(t10[o]) + ",";
        Is.set(t10, i);
      }
      if (r == ic) {
        i = "#";
        const s = ic.keys(t10).sort();
        for (; !ze(o = s.pop()); )
          ze(t10[o]) || (i += o + ":" + Lo(t10[o]) + ",");
        Is.set(t10, i);
      }
    } else
      i = n ? t10.toJSON() : e == "symbol" ? t10.toString() : e == "string" ? JSON.stringify(t10) : "" + t10;
    return i;
  }, Fr = /* @__PURE__ */ new WeakMap(), oc = {}, Ps = {}, $u = "undefined", Ga = typeof window != $u, Qc = typeof document != $u, sw = () => Ga && typeof window.requestAnimationFrame != $u, dg = (t10, e) => {
    const r = Fr.get(t10);
    return [
      // Getter
      () => !ze(e) && t10.get(e) || oc,
      // Setter
      (n) => {
        if (!ze(e)) {
          const i = t10.get(e);
          e in Ps || (Ps[e] = i), r[5](e, mn(i, n), i || oc);
        }
      },
      // Subscriber
      r[6],
      // Get server cache snapshot
      () => !ze(e) && e in Ps ? Ps[e] : !ze(e) && t10.get(e) || oc
    ];
  };
  let Gc = true;
  const aw = () => Gc, [Zc, $c] = Ga && window.addEventListener ? [
    window.addEventListener.bind(window),
    window.removeEventListener.bind(window)
  ] : [
    sn,
    sn
  ], lw = () => {
    const t10 = Qc && document.visibilityState;
    return ze(t10) || t10 !== "hidden";
  }, cw = (t10) => (Qc && document.addEventListener("visibilitychange", t10), Zc("focus", t10), () => {
    Qc && document.removeEventListener("visibilitychange", t10), $c("focus", t10);
  }), uw = (t10) => {
    const e = () => {
      Gc = true, t10();
    }, r = () => {
      Gc = false;
    };
    return Zc("online", e), Zc("offline", r), () => {
      $c("online", e), $c("offline", r);
    };
  }, fw = {
    isOnline: aw,
    isVisible: lw
  }, dw = {
    initFocus: cw,
    initReconnect: uw
  }, Kh = !K.useId, Bo = !Ga || "Deno" in window, hw = (t10) => sw() ? window.requestAnimationFrame(t10) : setTimeout(t10, 1), sc = Bo ? reactExports.useEffect : reactExports.useLayoutEffect, ac = typeof navigator < "u" && navigator.connection, Xh = !Bo && ac && ([
    "slow-2g",
    "2g"
  ].includes(ac.effectiveType) || ac.saveData), ef = (t10) => {
    if (Vr(t10))
      try {
        t10 = t10();
      } catch {
        t10 = "";
      }
    const e = t10;
    return t10 = typeof t10 == "string" ? t10 : (Array.isArray(t10) ? t10.length : t10) ? Lo(t10) : "", [
      t10,
      e
    ];
  };
  let pw = 0;
  const eu = () => ++pw, hg = 0, pg = 1, gg = 2, gw = 3;
  var Gi = {
    __proto__: null,
    ERROR_REVALIDATE_EVENT: gw,
    FOCUS_EVENT: hg,
    MUTATE_EVENT: gg,
    RECONNECT_EVENT: pg
  };
  async function mg(...t10) {
    const [e, r, n, i] = t10, o = mn({
      populateCache: true,
      throwOnError: true
    }, typeof i == "boolean" ? {
      revalidate: i
    } : i || {});
    let s = o.populateCache;
    const a = o.rollbackOnError;
    let l = o.optimisticData;
    const c = o.revalidate !== false, u = (h) => typeof a == "function" ? a(h) : a !== false, f = o.throwOnError;
    if (Vr(r)) {
      const h = r, g = [], p = e.keys();
      for (const y of p)
        !/^\$(inf|sub)\$/.test(y) && h(e.get(y)._k) && g.push(y);
      return Promise.all(g.map(d));
    }
    return d(r);
    async function d(h) {
      const [g] = ef(h);
      if (!g)
        return;
      const [p, y] = dg(e, g), [b, x, S, O] = Fr.get(e), _ = () => {
        const z10 = b[g];
        return c && (delete S[g], delete O[g], z10 && z10[0]) ? z10[0](gg).then(() => p().data) : p().data;
      };
      if (t10.length < 3)
        return _();
      let L = n, N;
      const j = eu();
      x[g] = [
        j,
        0
      ];
      const W = !ze(l), G = p(), ee = G.data, fe = G._c, P10 = ze(fe) ? ee : fe;
      if (W && (l = Vr(l) ? l(P10, ee) : l, y({
        data: l,
        _c: P10
      })), Vr(L))
        try {
          L = L(P10);
        } catch (z10) {
          N = z10;
        }
      if (L && iw(L))
        if (L = await L.catch((z10) => {
          N = z10;
        }), j !== x[g][0]) {
          if (N)
            throw N;
          return L;
        } else
          N && W && u(N) && (s = true, y({
            data: P10,
            _c: Ft
          }));
      if (s && !N)
        if (Vr(s)) {
          const z10 = s(L, P10);
          y({
            data: z10,
            error: Ft,
            _c: Ft
          });
        } else
          y({
            data: L,
            error: Ft,
            _c: Ft
          });
      if (x[g][1] = eu(), Promise.resolve(_()).then(() => {
        y({
          _c: Ft
        });
      }), N) {
        if (f)
          throw N;
        return;
      }
      return L;
    }
  }
  const Jh = (t10, e) => {
    for (const r in t10)
      t10[r][0] && t10[r][0](e);
  }, mw = (t10, e) => {
    if (!Fr.has(t10)) {
      const r = mn(dw, e), n = {}, i = mg.bind(Ft, t10);
      let o = sn;
      const s = {}, a = (u, f) => {
        const d = s[u] || [];
        return s[u] = d, d.push(f), () => d.splice(d.indexOf(f), 1);
      }, l = (u, f, d) => {
        t10.set(u, f);
        const h = s[u];
        if (h)
          for (const g of h)
            g(f, d);
      }, c = () => {
        if (!Fr.has(t10) && (Fr.set(t10, [
          n,
          {},
          {},
          {},
          i,
          l,
          a
        ]), !Bo)) {
          const u = r.initFocus(setTimeout.bind(Ft, Jh.bind(Ft, n, hg))), f = r.initReconnect(setTimeout.bind(Ft, Jh.bind(Ft, n, pg)));
          o = () => {
            u && u(), f && f(), Fr.delete(t10);
          };
        }
      };
      return c(), [
        t10,
        i,
        c,
        o
      ];
    }
    return [
      t10,
      Fr.get(t10)[4]
    ];
  }, yw = (t10, e, r, n, i) => {
    const o = r.errorRetryCount, s = i.retryCount, a = ~~((Math.random() + 0.5) * (1 << (s < 8 ? s : 8))) * r.errorRetryInterval;
    !ze(o) && s > o || setTimeout(n, a, i);
  }, bw = (t10, e) => Lo(t10) == Lo(e), [yg, vw] = mw(/* @__PURE__ */ new Map()), Aw = mn(
    {
      // events
      onLoadingSlow: sn,
      onSuccess: sn,
      onError: sn,
      onErrorRetry: yw,
      onDiscarded: sn,
      // switches
      revalidateOnFocus: true,
      revalidateOnReconnect: true,
      revalidateIfStale: true,
      shouldRetryOnError: true,
      // timeouts
      errorRetryInterval: Xh ? 1e4 : 5e3,
      focusThrottleInterval: 5 * 1e3,
      dedupingInterval: 2 * 1e3,
      loadingTimeout: Xh ? 5e3 : 3e3,
      // providers
      compare: bw,
      isPaused: () => false,
      cache: yg,
      mutate: vw,
      fallback: {}
    },
    // use web preset by default
    fw
  ), ww = (t10, e) => {
    const r = mn(t10, e);
    if (e) {
      const { use: n, fallback: i } = t10, { use: o, fallback: s } = e;
      n && o && (r.use = n.concat(o)), i && s && (r.fallback = mn(i, s));
    }
    return r;
  }, xw = reactExports.createContext({}), _w = "$inf$", bg = Ga && window.__SWR_DEVTOOLS_USE__, Sw = bg ? window.__SWR_DEVTOOLS_USE__ : [], Ew = () => {
    bg && (window.__SWR_DEVTOOLS_REACT__ = K);
  }, kw = (t10) => Vr(t10[1]) ? [
    t10[0],
    t10[1],
    t10[2] || {}
  ] : [
    t10[0],
    null,
    (t10[1] === null ? t10[2] : t10[1]) || {}
  ], Cw = () => mn(Aw, reactExports.useContext(xw)), Tw = (t10) => (e, r, n) => t10(e, r && ((...o) => {
    const [s] = ef(e), [, , , a] = Fr.get(yg);
    if (s.startsWith(_w))
      return r(...o);
    const l = a[s];
    return ze(l) ? r(...o) : (delete a[s], l);
  }), n), Ow = Sw.concat(Tw), Iw = (t10) => function(...r) {
    const n = Cw(), [i, o, s] = kw(r), a = ww(n, s);
    let l = t10;
    const { use: c } = a, u = (c || []).concat(Ow);
    for (let f = u.length; f--; )
      l = u[f](l);
    return l(i, o || a.fetcher || null, a);
  }, Pw = (t10, e, r) => {
    const n = e[t10] || (e[t10] = []);
    return n.push(r), () => {
      const i = n.indexOf(r);
      i >= 0 && (n[i] = n[n.length - 1], n.pop());
    };
  };
  Ew();
  const Qh = K.use || ((t10) => {
    if (t10.status === "pending")
      throw t10;
    if (t10.status === "fulfilled")
      return t10.value;
    throw t10.status === "rejected" ? t10.reason : (t10.status = "pending", t10.then((e) => {
      t10.status = "fulfilled", t10.value = e;
    }, (e) => {
      t10.status = "rejected", t10.reason = e;
    }), t10);
  }), lc = {
    dedupe: true
  }, Rw = (t10, e, r) => {
    const { cache: n, compare: i, suspense: o, fallbackData: s, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: f, keepPreviousData: d } = r, [h, g, p, y] = Fr.get(n), [b, x] = ef(t10), S = reactExports.useRef(false), O = reactExports.useRef(false), _ = reactExports.useRef(b), L = reactExports.useRef(e), N = reactExports.useRef(r), j = () => N.current, W = () => j().isVisible() && j().isOnline(), [G, ee, fe, P10] = dg(n, b), z10 = reactExports.useRef({}).current, U = ze(s) ? r.fallback[b] : s, I = (k, re) => {
      for (const ne in z10) {
        const Ae = ne;
        if (Ae === "data") {
          if (!i(k[Ae], re[Ae]) && (!ze(k[Ae]) || !i(me, re[Ae])))
            return false;
        } else if (re[Ae] !== k[Ae])
          return false;
      }
      return true;
    }, V = reactExports.useMemo(() => {
      const k = (() => !b || !e ? false : ze(a) ? j().isPaused() || o ? false : ze(l) ? true : l : a)(), re = (D) => {
        const J = mn(D);
        return delete J._k, k ? {
          isValidating: true,
          isLoading: true,
          ...J
        } : J;
      }, ne = G(), Ae = P10(), C = re(ne), v = ne === Ae ? C : re(Ae);
      let w = C;
      return [
        () => {
          const D = re(G());
          return I(D, w) ? (w.data = D.data, w.isLoading = D.isLoading, w.isValidating = D.isValidating, w.error = D.error, w) : (w = D, D);
        },
        () => v
      ];
    }, [
      n,
      b
    ]), te = Jc.useSyncExternalStore(reactExports.useCallback(
      (k) => fe(b, (re, ne) => {
        I(ne, re) || k();
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        n,
        b
      ]
    ), V[0], V[1]), X = !S.current, H = h[b] && h[b].length > 0, $ = te.data, se = ze($) ? U : $, he = te.error, pe = reactExports.useRef(se), me = d ? ze($) ? pe.current : $ : se, B = (() => H && !ze(he) ? false : X && !ze(a) ? a : j().isPaused() ? false : o ? ze(se) ? false : l : ze(se) || l)(), q = !!(b && e && X && B), Z = ze(te.isValidating) ? q : te.isValidating, oe = ze(te.isLoading) ? q : te.isLoading, de = reactExports.useCallback(
      async (k) => {
        const re = L.current;
        if (!b || !re || O.current || j().isPaused())
          return false;
        let ne, Ae, C = true;
        const v = k || {}, w = !p[b] || !v.dedupe, D = () => Kh ? !O.current && b === _.current && S.current : b === _.current, J = {
          isValidating: false,
          isLoading: false
        }, ae = () => {
          ee(J);
        }, ue = () => {
          const _e = p[b];
          _e && _e[1] === Ae && delete p[b];
        }, Se = {
          isValidating: true
        };
        ze(G().data) && (Se.isLoading = true);
        try {
          if (w && (ee(Se), r.loadingTimeout && ze(G().data) && setTimeout(() => {
            C && D() && j().onLoadingSlow(b, r);
          }, r.loadingTimeout), p[b] = [
            re(x),
            eu()
          ]), [ne, Ae] = p[b], ne = await ne, w && setTimeout(ue, r.dedupingInterval), !p[b] || p[b][1] !== Ae)
            return w && D() && j().onDiscarded(b), false;
          J.error = Ft;
          const _e = g[b];
          if (!ze(_e) && // case 1
          (Ae <= _e[0] || // case 2
          Ae <= _e[1] || // case 3
          _e[1] === 0))
            return ae(), w && D() && j().onDiscarded(b), false;
          const we = G().data;
          J.data = i(we, ne) ? we : ne, w && D() && j().onSuccess(ne, b, r);
        } catch (_e) {
          ue();
          const we = j(), { shouldRetryOnError: Ne } = we;
          we.isPaused() || (J.error = _e, w && D() && (we.onError(_e, b, we), (Ne === true || Vr(Ne) && Ne(_e)) && W() && we.onErrorRetry(_e, b, we, (E) => {
            const m = h[b];
            m && m[0] && m[0](Gi.ERROR_REVALIDATE_EVENT, E);
          }, {
            retryCount: (v.retryCount || 0) + 1,
            dedupe: true
          })));
        }
        return C = false, ae(), true;
      },
      // `setState` is immutable, and `eventsCallback`, `fnArg`, and
      // `keyValidating` are depending on `key`, so we can exclude them from
      // the deps array.
      //
      // FIXME:
      // `fn` and `config` might be changed during the lifecycle,
      // but they might be changed every render like this.
      // `useSWR('key', () => fetch('/api/'), { suspense: true })`
      // So we omit the values from the deps array
      // even though it might cause unexpected behaviors.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        b,
        n
      ]
    ), R = reactExports.useCallback(
      // Use callback to make sure `keyRef.current` returns latest result every time
      (...k) => mg(n, _.current, ...k),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    if (sc(() => {
      L.current = e, N.current = r, ze($) || (pe.current = $);
    }), sc(() => {
      if (!b)
        return;
      const k = de.bind(Ft, lc);
      let re = 0;
      const Ae = Pw(b, h, (C, v = {}) => {
        if (C == Gi.FOCUS_EVENT) {
          const w = Date.now();
          j().revalidateOnFocus && w > re && W() && (re = w + j().focusThrottleInterval, k());
        } else if (C == Gi.RECONNECT_EVENT)
          j().revalidateOnReconnect && W() && k();
        else {
          if (C == Gi.MUTATE_EVENT)
            return de();
          if (C == Gi.ERROR_REVALIDATE_EVENT)
            return de(v);
        }
      });
      return O.current = false, _.current = b, S.current = true, ee({
        _k: x
      }), B && (ze(se) || Bo ? k() : hw(k)), () => {
        O.current = true, Ae();
      };
    }, [
      b
    ]), sc(() => {
      let k;
      function re() {
        const Ae = Vr(c) ? c(G().data) : c;
        Ae && k !== -1 && (k = setTimeout(ne, Ae));
      }
      function ne() {
        !G().error && (u || j().isVisible()) && (f || j().isOnline()) ? de(lc).then(re) : re();
      }
      return re(), () => {
        k && (clearTimeout(k), k = -1);
      };
    }, [
      c,
      u,
      f,
      b
    ]), reactExports.useDebugValue(me), o && ze(se) && b) {
      if (!Kh && Bo)
        throw new Error("Fallback data is required when using suspense in SSR.");
      L.current = e, N.current = r, O.current = false;
      const k = y[b];
      if (!ze(k)) {
        const re = R(k);
        Qh(re);
      }
      if (ze(he)) {
        const re = de(lc);
        ze(me) || (re.status = "fulfilled", re.value = true), Qh(re);
      } else
        throw he;
    }
    return {
      mutate: R,
      get data() {
        return z10.data = true, me;
      },
      get error() {
        return z10.error = true, he;
      },
      get isValidating() {
        return z10.isValidating = true, Z;
      },
      get isLoading() {
        return z10.isLoading = true, oe;
      }
    };
  }, Dw = Iw(Rw);
  function Li({
    middle: t10,
    center: e,
    bottom: r,
    right: n,
    visible: i,
    children: o,
    flag: s,
    style: a,
    containerClassName: l
  }) {
    return i ? /* @__PURE__ */ K.createElement(
      "div",
      {
        style: a,
        className: [
          "toast-container",
          r ? "bottom" : "",
          n ? "right" : "",
          s ? " with-flag" : "",
          l || ""
        ].join(" ")
      },
      o
    ) : null;
  }
  var F = {}, Gh = {
    get exports() {
      return F;
    },
    set exports(t10) {
      F = t10;
    }
  }, _a = {}, Mw = {
    get exports() {
      return _a;
    },
    set exports(t10) {
      _a = t10;
    }
  }, Ye = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Zh;
  function Nw() {
    if (Zh)
      return Ye;
    Zh = 1;
    var t10 = typeof Symbol == "function" && Symbol.for, e = t10 ? Symbol.for("react.element") : 60103, r = t10 ? Symbol.for("react.portal") : 60106, n = t10 ? Symbol.for("react.fragment") : 60107, i = t10 ? Symbol.for("react.strict_mode") : 60108, o = t10 ? Symbol.for("react.profiler") : 60114, s = t10 ? Symbol.for("react.provider") : 60109, a = t10 ? Symbol.for("react.context") : 60110, l = t10 ? Symbol.for("react.async_mode") : 60111, c = t10 ? Symbol.for("react.concurrent_mode") : 60111, u = t10 ? Symbol.for("react.forward_ref") : 60112, f = t10 ? Symbol.for("react.suspense") : 60113, d = t10 ? Symbol.for("react.suspense_list") : 60120, h = t10 ? Symbol.for("react.memo") : 60115, g = t10 ? Symbol.for("react.lazy") : 60116, p = t10 ? Symbol.for("react.block") : 60121, y = t10 ? Symbol.for("react.fundamental") : 60117, b = t10 ? Symbol.for("react.responder") : 60118, x = t10 ? Symbol.for("react.scope") : 60119;
    function S(_) {
      if (typeof _ == "object" && _ !== null) {
        var L = _.$$typeof;
        switch (L) {
          case e:
            switch (_ = _.type, _) {
              case l:
              case c:
              case n:
              case o:
              case i:
              case f:
                return _;
              default:
                switch (_ = _ && _.$$typeof, _) {
                  case a:
                  case u:
                  case g:
                  case h:
                  case s:
                    return _;
                  default:
                    return L;
                }
            }
          case r:
            return L;
        }
      }
    }
    function O(_) {
      return S(_) === c;
    }
    return Ye.AsyncMode = l, Ye.ConcurrentMode = c, Ye.ContextConsumer = a, Ye.ContextProvider = s, Ye.Element = e, Ye.ForwardRef = u, Ye.Fragment = n, Ye.Lazy = g, Ye.Memo = h, Ye.Portal = r, Ye.Profiler = o, Ye.StrictMode = i, Ye.Suspense = f, Ye.isAsyncMode = function(_) {
      return O(_) || S(_) === l;
    }, Ye.isConcurrentMode = O, Ye.isContextConsumer = function(_) {
      return S(_) === a;
    }, Ye.isContextProvider = function(_) {
      return S(_) === s;
    }, Ye.isElement = function(_) {
      return typeof _ == "object" && _ !== null && _.$$typeof === e;
    }, Ye.isForwardRef = function(_) {
      return S(_) === u;
    }, Ye.isFragment = function(_) {
      return S(_) === n;
    }, Ye.isLazy = function(_) {
      return S(_) === g;
    }, Ye.isMemo = function(_) {
      return S(_) === h;
    }, Ye.isPortal = function(_) {
      return S(_) === r;
    }, Ye.isProfiler = function(_) {
      return S(_) === o;
    }, Ye.isStrictMode = function(_) {
      return S(_) === i;
    }, Ye.isSuspense = function(_) {
      return S(_) === f;
    }, Ye.isValidElementType = function(_) {
      return typeof _ == "string" || typeof _ == "function" || _ === n || _ === c || _ === o || _ === i || _ === f || _ === d || typeof _ == "object" && _ !== null && (_.$$typeof === g || _.$$typeof === h || _.$$typeof === s || _.$$typeof === a || _.$$typeof === u || _.$$typeof === y || _.$$typeof === b || _.$$typeof === x || _.$$typeof === p);
    }, Ye.typeOf = S, Ye;
  }
  var Ke = {};
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var $h;
  function Lw() {
    return $h || ($h = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      var t10 = typeof Symbol == "function" && Symbol.for, e = t10 ? Symbol.for("react.element") : 60103, r = t10 ? Symbol.for("react.portal") : 60106, n = t10 ? Symbol.for("react.fragment") : 60107, i = t10 ? Symbol.for("react.strict_mode") : 60108, o = t10 ? Symbol.for("react.profiler") : 60114, s = t10 ? Symbol.for("react.provider") : 60109, a = t10 ? Symbol.for("react.context") : 60110, l = t10 ? Symbol.for("react.async_mode") : 60111, c = t10 ? Symbol.for("react.concurrent_mode") : 60111, u = t10 ? Symbol.for("react.forward_ref") : 60112, f = t10 ? Symbol.for("react.suspense") : 60113, d = t10 ? Symbol.for("react.suspense_list") : 60120, h = t10 ? Symbol.for("react.memo") : 60115, g = t10 ? Symbol.for("react.lazy") : 60116, p = t10 ? Symbol.for("react.block") : 60121, y = t10 ? Symbol.for("react.fundamental") : 60117, b = t10 ? Symbol.for("react.responder") : 60118, x = t10 ? Symbol.for("react.scope") : 60119;
      function S(k) {
        return typeof k == "string" || typeof k == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        k === n || k === c || k === o || k === i || k === f || k === d || typeof k == "object" && k !== null && (k.$$typeof === g || k.$$typeof === h || k.$$typeof === s || k.$$typeof === a || k.$$typeof === u || k.$$typeof === y || k.$$typeof === b || k.$$typeof === x || k.$$typeof === p);
      }
      function O(k) {
        if (typeof k == "object" && k !== null) {
          var re = k.$$typeof;
          switch (re) {
            case e:
              var ne = k.type;
              switch (ne) {
                case l:
                case c:
                case n:
                case o:
                case i:
                case f:
                  return ne;
                default:
                  var Ae = ne && ne.$$typeof;
                  switch (Ae) {
                    case a:
                    case u:
                    case g:
                    case h:
                    case s:
                      return Ae;
                    default:
                      return re;
                  }
              }
            case r:
              return re;
          }
        }
      }
      var _ = l, L = c, N = a, j = s, W = e, G = u, ee = n, fe = g, P10 = h, z10 = r, U = o, I = i, V = f, te = false;
      function X(k) {
        return te || (te = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), H(k) || O(k) === l;
      }
      function H(k) {
        return O(k) === c;
      }
      function $(k) {
        return O(k) === a;
      }
      function se(k) {
        return O(k) === s;
      }
      function he(k) {
        return typeof k == "object" && k !== null && k.$$typeof === e;
      }
      function pe(k) {
        return O(k) === u;
      }
      function me(k) {
        return O(k) === n;
      }
      function B(k) {
        return O(k) === g;
      }
      function q(k) {
        return O(k) === h;
      }
      function Z(k) {
        return O(k) === r;
      }
      function oe(k) {
        return O(k) === o;
      }
      function de(k) {
        return O(k) === i;
      }
      function R(k) {
        return O(k) === f;
      }
      Ke.AsyncMode = _, Ke.ConcurrentMode = L, Ke.ContextConsumer = N, Ke.ContextProvider = j, Ke.Element = W, Ke.ForwardRef = G, Ke.Fragment = ee, Ke.Lazy = fe, Ke.Memo = P10, Ke.Portal = z10, Ke.Profiler = U, Ke.StrictMode = I, Ke.Suspense = V, Ke.isAsyncMode = X, Ke.isConcurrentMode = H, Ke.isContextConsumer = $, Ke.isContextProvider = se, Ke.isElement = he, Ke.isForwardRef = pe, Ke.isFragment = me, Ke.isLazy = B, Ke.isMemo = q, Ke.isPortal = Z, Ke.isProfiler = oe, Ke.isStrictMode = de, Ke.isSuspense = R, Ke.isValidElementType = S, Ke.typeOf = O;
    }()), Ke;
  }
  var ep;
  function vg() {
    return ep || (ep = 1, function(t10) {
      define_process_env_default.NODE_ENV === "production" ? t10.exports = Nw() : t10.exports = Lw();
    }(Mw)), _a;
  }
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var cc, tp;
  function tf() {
    if (tp)
      return cc;
    tp = 1;
    var t10 = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
    function n(o) {
      if (o == null)
        throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(o);
    }
    function i() {
      try {
        if (!Object.assign)
          return false;
        var o = new String("abc");
        if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
          return false;
        for (var s = {}, a = 0; a < 10; a++)
          s["_" + String.fromCharCode(a)] = a;
        var l = Object.getOwnPropertyNames(s).map(function(u) {
          return s[u];
        });
        if (l.join("") !== "0123456789")
          return false;
        var c = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(u) {
          c[u] = u;
        }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
      } catch {
        return false;
      }
    }
    return cc = i() ? Object.assign : function(o, s) {
      for (var a, l = n(o), c, u = 1; u < arguments.length; u++) {
        a = Object(arguments[u]);
        for (var f in a)
          e.call(a, f) && (l[f] = a[f]);
        if (t10) {
          c = t10(a);
          for (var d = 0; d < c.length; d++)
            r.call(a, c[d]) && (l[c[d]] = a[c[d]]);
        }
      }
      return l;
    }, cc;
  }
  var uc, rp;
  function rf() {
    if (rp)
      return uc;
    rp = 1;
    var t10 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return uc = t10, uc;
  }
  var fc, np;
  function Ag() {
    return np || (np = 1, fc = Function.call.bind(Object.prototype.hasOwnProperty)), fc;
  }
  var dc, ip;
  function Bw() {
    if (ip)
      return dc;
    ip = 1;
    var t10 = function() {
    };
    if (define_process_env_default.NODE_ENV !== "production") {
      var e = rf(), r = {}, n = Ag();
      t10 = function(o) {
        var s = "Warning: " + o;
        typeof console < "u" && console.error(s);
        try {
          throw new Error(s);
        } catch {
        }
      };
    }
    function i(o, s, a, l, c) {
      if (define_process_env_default.NODE_ENV !== "production") {
        for (var u in o)
          if (n(o, u)) {
            var f;
            try {
              if (typeof o[u] != "function") {
                var d = Error(
                  (l || "React class") + ": " + a + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                throw d.name = "Invariant Violation", d;
              }
              f = o[u](s, u, l, a, null, e);
            } catch (g) {
              f = g;
            }
            if (f && !(f instanceof Error) && t10(
              (l || "React class") + ": type specification of " + a + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            ), f instanceof Error && !(f.message in r)) {
              r[f.message] = true;
              var h = c ? c() : "";
              t10(
                "Failed " + a + " type: " + f.message + (h ?? "")
              );
            }
          }
      }
    }
    return i.resetWarningCache = function() {
      define_process_env_default.NODE_ENV !== "production" && (r = {});
    }, dc = i, dc;
  }
  var hc, op;
  function Fw() {
    if (op)
      return hc;
    op = 1;
    var t10 = vg(), e = tf(), r = rf(), n = Ag(), i = Bw(), o = function() {
    };
    define_process_env_default.NODE_ENV !== "production" && (o = function(a) {
      var l = "Warning: " + a;
      typeof console < "u" && console.error(l);
      try {
        throw new Error(l);
      } catch {
      }
    });
    function s() {
      return null;
    }
    return hc = function(a, l) {
      var c = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
      function f(H) {
        var $ = H && (c && H[c] || H[u]);
        if (typeof $ == "function")
          return $;
      }
      var d = "<<anonymous>>", h = {
        array: b("array"),
        bigint: b("bigint"),
        bool: b("boolean"),
        func: b("function"),
        number: b("number"),
        object: b("object"),
        string: b("string"),
        symbol: b("symbol"),
        any: x(),
        arrayOf: S,
        element: O(),
        elementType: _(),
        instanceOf: L,
        node: G(),
        objectOf: j,
        oneOf: N,
        oneOfType: W,
        shape: fe,
        exact: P10
      };
      function g(H, $) {
        return H === $ ? H !== 0 || 1 / H === 1 / $ : H !== H && $ !== $;
      }
      function p(H, $) {
        this.message = H, this.data = $ && typeof $ == "object" ? $ : {}, this.stack = "";
      }
      p.prototype = Error.prototype;
      function y(H) {
        if (define_process_env_default.NODE_ENV !== "production")
          var $ = {}, se = 0;
        function he(me, B, q, Z, oe, de, R) {
          if (Z = Z || d, de = de || q, R !== r) {
            if (l) {
              var k = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              throw k.name = "Invariant Violation", k;
            } else if (define_process_env_default.NODE_ENV !== "production" && typeof console < "u") {
              var re = Z + ":" + q;
              !$[re] && // Avoid spamming the console because they are often not actionable except for lib authors
              se < 3 && (o(
                "You are manually calling a React.PropTypes validation function for the `" + de + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              ), $[re] = true, se++);
            }
          }
          return B[q] == null ? me ? B[q] === null ? new p("The " + oe + " `" + de + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new p("The " + oe + " `" + de + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : H(B, q, Z, oe, de);
        }
        var pe = he.bind(null, false);
        return pe.isRequired = he.bind(null, true), pe;
      }
      function b(H) {
        function $(se, he, pe, me, B, q) {
          var Z = se[he], oe = I(Z);
          if (oe !== H) {
            var de = V(Z);
            return new p(
              "Invalid " + me + " `" + B + "` of type " + ("`" + de + "` supplied to `" + pe + "`, expected ") + ("`" + H + "`."),
              { expectedType: H }
            );
          }
          return null;
        }
        return y($);
      }
      function x() {
        return y(s);
      }
      function S(H) {
        function $(se, he, pe, me, B) {
          if (typeof H != "function")
            return new p("Property `" + B + "` of component `" + pe + "` has invalid PropType notation inside arrayOf.");
          var q = se[he];
          if (!Array.isArray(q)) {
            var Z = I(q);
            return new p("Invalid " + me + " `" + B + "` of type " + ("`" + Z + "` supplied to `" + pe + "`, expected an array."));
          }
          for (var oe = 0; oe < q.length; oe++) {
            var de = H(q, oe, pe, me, B + "[" + oe + "]", r);
            if (de instanceof Error)
              return de;
          }
          return null;
        }
        return y($);
      }
      function O() {
        function H($, se, he, pe, me) {
          var B = $[se];
          if (!a(B)) {
            var q = I(B);
            return new p("Invalid " + pe + " `" + me + "` of type " + ("`" + q + "` supplied to `" + he + "`, expected a single ReactElement."));
          }
          return null;
        }
        return y(H);
      }
      function _() {
        function H($, se, he, pe, me) {
          var B = $[se];
          if (!t10.isValidElementType(B)) {
            var q = I(B);
            return new p("Invalid " + pe + " `" + me + "` of type " + ("`" + q + "` supplied to `" + he + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return y(H);
      }
      function L(H) {
        function $(se, he, pe, me, B) {
          if (!(se[he] instanceof H)) {
            var q = H.name || d, Z = X(se[he]);
            return new p("Invalid " + me + " `" + B + "` of type " + ("`" + Z + "` supplied to `" + pe + "`, expected ") + ("instance of `" + q + "`."));
          }
          return null;
        }
        return y($);
      }
      function N(H) {
        if (!Array.isArray(H))
          return define_process_env_default.NODE_ENV !== "production" && (arguments.length > 1 ? o(
            "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
          ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
        function $(se, he, pe, me, B) {
          for (var q = se[he], Z = 0; Z < H.length; Z++)
            if (g(q, H[Z]))
              return null;
          var oe = JSON.stringify(H, function(R, k) {
            var re = V(k);
            return re === "symbol" ? String(k) : k;
          });
          return new p("Invalid " + me + " `" + B + "` of value `" + String(q) + "` " + ("supplied to `" + pe + "`, expected one of " + oe + "."));
        }
        return y($);
      }
      function j(H) {
        function $(se, he, pe, me, B) {
          if (typeof H != "function")
            return new p("Property `" + B + "` of component `" + pe + "` has invalid PropType notation inside objectOf.");
          var q = se[he], Z = I(q);
          if (Z !== "object")
            return new p("Invalid " + me + " `" + B + "` of type " + ("`" + Z + "` supplied to `" + pe + "`, expected an object."));
          for (var oe in q)
            if (n(q, oe)) {
              var de = H(q, oe, pe, me, B + "." + oe, r);
              if (de instanceof Error)
                return de;
            }
          return null;
        }
        return y($);
      }
      function W(H) {
        if (!Array.isArray(H))
          return define_process_env_default.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
        for (var $ = 0; $ < H.length; $++) {
          var se = H[$];
          if (typeof se != "function")
            return o(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(se) + " at index " + $ + "."
            ), s;
        }
        function he(pe, me, B, q, Z) {
          for (var oe = [], de = 0; de < H.length; de++) {
            var R = H[de], k = R(pe, me, B, q, Z, r);
            if (k == null)
              return null;
            k.data && n(k.data, "expectedType") && oe.push(k.data.expectedType);
          }
          var re = oe.length > 0 ? ", expected one of type [" + oe.join(", ") + "]" : "";
          return new p("Invalid " + q + " `" + Z + "` supplied to " + ("`" + B + "`" + re + "."));
        }
        return y(he);
      }
      function G() {
        function H($, se, he, pe, me) {
          return z10($[se]) ? null : new p("Invalid " + pe + " `" + me + "` supplied to " + ("`" + he + "`, expected a ReactNode."));
        }
        return y(H);
      }
      function ee(H, $, se, he, pe) {
        return new p(
          (H || "React class") + ": " + $ + " type `" + se + "." + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + pe + "`."
        );
      }
      function fe(H) {
        function $(se, he, pe, me, B) {
          var q = se[he], Z = I(q);
          if (Z !== "object")
            return new p("Invalid " + me + " `" + B + "` of type `" + Z + "` " + ("supplied to `" + pe + "`, expected `object`."));
          for (var oe in H) {
            var de = H[oe];
            if (typeof de != "function")
              return ee(pe, me, B, oe, V(de));
            var R = de(q, oe, pe, me, B + "." + oe, r);
            if (R)
              return R;
          }
          return null;
        }
        return y($);
      }
      function P10(H) {
        function $(se, he, pe, me, B) {
          var q = se[he], Z = I(q);
          if (Z !== "object")
            return new p("Invalid " + me + " `" + B + "` of type `" + Z + "` " + ("supplied to `" + pe + "`, expected `object`."));
          var oe = e({}, se[he], H);
          for (var de in oe) {
            var R = H[de];
            if (n(H, de) && typeof R != "function")
              return ee(pe, me, B, de, V(R));
            if (!R)
              return new p(
                "Invalid " + me + " `" + B + "` key `" + de + "` supplied to `" + pe + "`.\nBad object: " + JSON.stringify(se[he], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(H), null, "  ")
              );
            var k = R(q, de, pe, me, B + "." + de, r);
            if (k)
              return k;
          }
          return null;
        }
        return y($);
      }
      function z10(H) {
        switch (typeof H) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !H;
          case "object":
            if (Array.isArray(H))
              return H.every(z10);
            if (H === null || a(H))
              return true;
            var $ = f(H);
            if ($) {
              var se = $.call(H), he;
              if ($ !== H.entries) {
                for (; !(he = se.next()).done; )
                  if (!z10(he.value))
                    return false;
              } else
                for (; !(he = se.next()).done; ) {
                  var pe = he.value;
                  if (pe && !z10(pe[1]))
                    return false;
                }
            } else
              return false;
            return true;
          default:
            return false;
        }
      }
      function U(H, $) {
        return H === "symbol" ? true : $ ? $["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && $ instanceof Symbol : false;
      }
      function I(H) {
        var $ = typeof H;
        return Array.isArray(H) ? "array" : H instanceof RegExp ? "object" : U($, H) ? "symbol" : $;
      }
      function V(H) {
        if (typeof H > "u" || H === null)
          return "" + H;
        var $ = I(H);
        if ($ === "object") {
          if (H instanceof Date)
            return "date";
          if (H instanceof RegExp)
            return "regexp";
        }
        return $;
      }
      function te(H) {
        var $ = V(H);
        switch ($) {
          case "array":
          case "object":
            return "an " + $;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + $;
          default:
            return $;
        }
      }
      function X(H) {
        return !H.constructor || !H.constructor.name ? d : H.constructor.name;
      }
      return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
    }, hc;
  }
  var pc, sp;
  function jw() {
    if (sp)
      return pc;
    sp = 1;
    var t10 = rf();
    function e() {
    }
    function r() {
    }
    return r.resetWarningCache = e, pc = function() {
      function n(s, a, l, c, u, f) {
        if (f !== t10) {
          var d = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw d.name = "Invariant Violation", d;
        }
      }
      n.isRequired = n;
      function i() {
        return n;
      }
      var o = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: i,
        element: n,
        elementType: n,
        instanceOf: i,
        node: n,
        objectOf: i,
        oneOf: i,
        oneOfType: i,
        shape: i,
        exact: i,
        checkPropTypes: r,
        resetWarningCache: e
      };
      return o.PropTypes = o, o;
    }, pc;
  }
  if (define_process_env_default.NODE_ENV !== "production") {
    var Ww = vg(), Uw = true;
    Gh.exports = Fw()(Ww.isElement, Uw);
  } else
    Gh.exports = jw()();
  var zw = !!(typeof window < "u" && window.document && window.document.createElement), Vw = /* @__PURE__ */ function() {
    function t10(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
      }
    }
    return function(e, r, n) {
      return r && t10(e.prototype, r), n && t10(e, n), e;
    };
  }();
  function qw(t10, e) {
    if (!(t10 instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function Hw(t10, e) {
    if (!t10)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t10;
  }
  function Yw(t10, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t10.prototype = Object.create(e && e.prototype, { constructor: { value: t10, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t10, e) : t10.__proto__ = e);
  }
  var wg = function(t10) {
    Yw(e, t10);
    function e() {
      return qw(this, e), Hw(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
    }
    return Vw(e, [{
      key: "componentWillUnmount",
      value: function() {
        this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null;
      }
    }, {
      key: "render",
      value: function() {
        return zw ? (!this.props.node && !this.defaultNode && (this.defaultNode = document.createElement("div"), document.body.appendChild(this.defaultNode)), Wt.createPortal(this.props.children, this.props.node || this.defaultNode)) : null;
      }
    }]), e;
  }(K.Component);
  wg.propTypes = {
    children: F.node.isRequired,
    node: F.any
  };
  const Kw = wg;
  var Xw = /* @__PURE__ */ function() {
    function t10(e, r) {
      for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
      }
    }
    return function(e, r, n) {
      return r && t10(e.prototype, r), n && t10(e, n), e;
    };
  }();
  function Jw(t10, e) {
    if (!(t10 instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function Qw(t10, e) {
    if (!t10)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t10;
  }
  function Gw(t10, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t10.prototype = Object.create(e && e.prototype, { constructor: { value: t10, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t10, e) : t10.__proto__ = e);
  }
  var xg = function(t10) {
    Gw(e, t10);
    function e() {
      return Jw(this, e), Qw(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
    }
    return Xw(e, [{
      key: "componentDidMount",
      value: function() {
        this.renderPortal();
      }
    }, {
      key: "componentDidUpdate",
      value: function(n) {
        this.renderPortal();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Wt.unmountComponentAtNode(this.defaultNode || this.props.node), this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null, this.portal = null;
      }
    }, {
      key: "renderPortal",
      value: function(n) {
        !this.props.node && !this.defaultNode && (this.defaultNode = document.createElement("div"), document.body.appendChild(this.defaultNode));
        var i = this.props.children;
        typeof this.props.children.type == "function" && (i = K.cloneElement(this.props.children)), this.portal = Wt.unstable_renderSubtreeIntoContainer(this, i, this.props.node || this.defaultNode);
      }
    }, {
      key: "render",
      value: function() {
        return null;
      }
    }]), e;
  }(K.Component);
  const Zw = xg;
  xg.propTypes = {
    children: F.node.isRequired,
    node: F.any
  };
  var tu = void 0;
  Wt.createPortal ? tu = Kw : tu = Zw;
  const _g = tu, Sg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAgKADAAQAAAABAAAAgAAAAAC7tGl0AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoZXuEHAAArZ0lEQVR4Ae19aaxl2XXWvm+sqlfz0FVd3dWTbYzt2B1wTBIBDgpBSgiCIKYQQXAifhhFIJBCTJAwIUjgH5GQkILgR/4RKVKEhPiBlERWjGkIKAbHbmxntONuu+exurqq3sz61rTX2nuf816V2+62q069d/YavvWttYdz7rnnnndr8dhjj+2Xu9sdOwJLd2zP73acR+DuArjDF8LdBXB3AdzhI3CHd//uGeDuArjDR+AO7/7dM8DdBXCHj8Ad3v27Z4C7C+AOH4E7vPt3zwB3F8AdPgJ3ePfvngHuLoA7fATu8O7fPQPcXQB3+Ajc4d1f+Vbv/6IsCn5kg3CLz78QXCJuMc5SvsXbb5kFkCaaJ22/7O/vlz36t7+HyRP9UPPBa0ZWzWIBZvpHLVYS/tn2rbAwvokXgEwFTStP9O7+LrV7PDc8TUtLZXlpmX5X/HeJ9SWazGX6pVbRaLBYsFywWPaIa29vt4Bzd29HZLScQxYTLwZw6AKppxlZFkz9TbD7plgAdtTZZPNk6WQv0USvLK+WtdUjZZ1+0a6urJdVsmHyMeky2cSCo3i/HsE2PzT3tOnxTA3y0IqQRUHtLi0GLIidve2ys7NVtnY3y/bOZtnauVl2drdooeww1hYD8slmuYRbjW+p5i27AOSUi3mQCeCjm8YTk3pk7Wg5ur7Bv+trx8rayhrbF7QYdB598nguMaU8p3SG4AnGHEBYwCMToo3PjuMWZWVptRT6XStHSlmTSeWXF10UWAyb29fLzZ3rvij26WxBK47OMvUsISnaRJ7xTRHecgsARw8me3cXp9y9skQ6jupjR46XjaMnaNKP04Svl+VlKZ3PBnt06qYZ3tvZ4UHkIW7GGQsgbTb50U6yqxoAXc4ItY08q0trZXX9SNlYP0X10mLd3eZFcHP79XJz+1rZ3L1BZ5Bt5qAXJe4P4n3hRbI3QX7LLAAc8Xs0kTt0eoV8hI7s48dOleNHT9GkH6PT+hofTVgcjMNkY5JwQPKsQZCjU3SdSmpUkuFlPRvT4ggTzwEaLGZPxqRwyXWDXHsAv0TXF0fXaKGunuAFvE39wWK4sX2V2539LaqSzguEC8Uj9E3Z3uQFIAOK11cc7XjtPn3iXDm5cZaO+A1+bccgyRkBR7kc4T7RmPA0Qaa4WQaVzH7EKQSOduLd5YJh1EBNcKmii0IdeNdBK5RxmOjVpfWyRmeI42tnyvbeFi2C18rrW6+WzZ1r/A4FCwG4N2t7ExYAdRfzRqOPK2xsx+i0foYm/sTGGTrdr7MNV+O7u3JqhwFDhIHicQ6zIJOoBmrc5aZoRF6ml50qbvIYcrNcDT2m+oxR6GRB8J4WNVCwy2LAy8V5XgybdAF5feuVcn3nFb64hF8uHiXeOL/e7Td0AfBpngZld2eXr85P0YSfOXmBT/V4y4ZTOybdp5EHTrQ4cSLnCVDNJ451N8ok+GASgbtcMIwaqAkuV+x6wLhqXaM4mkwyy6UmRVL/ZFuU9eVjZf3osXJi73y5vv0qnRVeLlt7N9j9jXx5+IYsAEw8jvhteguFq3hM+tmT9/BFHVY+3mbt6AUcj0AdSx942NuJ9wlyPAluNDwzuuJui+HWrRzvmmGM1B1Oh6r4h+vTVBVefeLCOIhES51Jlhcr5eTahbKxcobOBrQQtl+mC8fXGbREPieXsDd8/3VfAJjgHboyRotJP3fqIl/Rix03b/b5oo9P8iTz+OggobeTk85ODI+CuxgdK+NUvFozLxklj8VI2x7tsFYcJZQfA0sLTHKwwap0BSd69BnXPrjGwXgcXz1bji6fLDd2rpZr2y/SGeE6jQ2uEXBfIXSQY9+Y3ddtAaBDfHeOTnsnNk6XC6cvyxFPZwN7bce1AA+ETVLoIxaGb4OBbgc5wm2WnEEFbiJwiheJPZhElyXA1YCbX4gakRvPgTHgC11aCBgRnA2O0ELA9cG1nRfoGmGT3jVgqhiJrG/Y9oYvAHud36H38bhhc/Hs/eXU8bNUOk71ttq1KzaSoRWR9mozV9WrD6NQJ0eUFl8xldAx7JQd25LDuAdxjtNpdx1cFseS90M1NGqToFo/HwrUH7r4xcsDbRsrZ2khnOCzwfXdl+hsQddOb/Dbxzd0AWDycbpHkRfP3FfOn76X3tqtkk3u00sXU/+5ozIINCA6kD6erlcfB9DOB04Fhnqg+aPB6V047FHrLEFg0XXL59WFHGpzLGV1OfvaenCdQDe6y6nVS3xGeG37ubK5d43fLbxRLwtvyALA0Y3icZGHGzeXzl2h0/1Jvqrf3pHXf3Q1DppPujt8zBwY8QyLA3eYiSd8DLECWt7MXYM8VgO6uAqV3nmAdwHUtIkjTbxifdIrrNbM/Px5Jt2BPlrOrj1QXt95uby++zx//vBGXCR+zQsARz1u26K9dO7Bcp4u8vABzA5NPDZeHHFgWPbe1876AOQjJA0aY3TIImeIhQhSd3sqFxjCsB5023Gatkvc1y/pfeK9hhgajExMY0z/MJYby2fL+uJYubqLs8FVvTYQztvZfw0LAOUUPupxf/7y+Yfo6D/Jb+l2+S2dvqZxB6xz1DH5qbW67gL70sCpQggjChi2DnlhbGOYQkNiUDR5XMiXeRQdm0wwPM0LJAZxN7RGJwh9Ez/2GE2+DU73D5cXa+X0yv0F1wXX9p6Hh/y4tZw5yHDgdlsLAEc7LlZ26E7e2ZMXy6WzV/i2rR31Ui4KRv7aYS8vCGmigXafKK6qwE3dMX2PiWDUEHnJ17oDAYuux9g2SGmagFy/xncJvYRYmKBSblLkR4homrEQ8NYR28bSubK6OEJng2fKTqF3CnS9EJgZc9DulhcAn/Lpxg1KuXzuIX5fv0e3bXHVD5uMh/YiN14bH5fqQ4F50MTB+w4TDU6nwuGO9sDgBG09uSaKCEEsui5Crl+GXKsxRVra13iNNY9zwkDRSbdA9lgEXweslmPlzPID5bW9Z8vNfXpJ4DOBQw4UbmkBYPJxlY8Pbe4//wjdwj3Nr/98M4cnX6umxut3UzRKhxyDMqnHrAdj1dVIjbvdFI3S3zp4DurifCidMNZU44SRy1Ox+mKoFe82F2LN1chSVSU59snmZqIPDhfpRhK/ZVwqJxf30tSvlev7L/KBaGdhLXqyOfQCwOTjKn/jyMly34VH6Ombo36hB3a7ceO1sTCYVAdwEBemUJaxk0EIQBJdC0I7WCkuxjCp0HNFzqE213MQm6PPa5M43nOIg0KhKmaSZoIlru0HeFNf2MDZeKdRIRc+dKILxMV5XgTX9p8hHXcXD74uONQCwKkdk39q41y57/zDdJW/wpOPRYGZkYK0QNZbo3XIMGE9azA3dScdpZcWdeuqnltQlchiPJiEhjpMRI3T6gK2+pwTIDcHq9uEhQ8Im1mMEzaHi2BucVZ/7XW0GYpincdEzAOidst6Ocn3YV6jRUBPVxy4CA5cADz59Nzb2ROXyr3nHqAq9G0ftd4BLYgLj8UF2cBsCvaqq5Ea7gp9KohPCJdo8PhTQrrgxNtL2zw3RkN+zGWjwjxsVGrIKY4NjACFx5lQsYKRPJEsxHK8+FAvDg48r4inhPboRhg/l0g2O1Mqo6WqtTKPe6UuSVyNJA3rhZ2emVih64IT5b5yrTxNSwIPoEyfCQ5cANs0+edPXS6XzlzhzvCzbph8lEO7dtLZLONgAMEq3hsjUIOF2AAdo49K8QkhflfobuISPVhx8+ZNHliEaPIBNxclENu7SbNYMmFhKoEKMLiDOVhVdEtYKZj8tbV1rnNra4sXwfqR9bK5tckLmc+aYHUOZ3GbuwNvtUHCFuKguSrXBSt0PXBi/3J5bYFFQOM28Q5hdgHg+bZ7Tt9Pv/fxfXzJIqezduJrAbUarskLsyLVkBvuDzjBjuf9fuuz/6d88n/+erl69dVy/tyF8j1/6vvKO972zoJBlc7H0ypXI2by2iY1tYkU5nWJkOoHAZmVVegcH+OrERIeYsHkP/Pc0+UTj/1a+cpTT5K+Vr7j0e8s3/HHvov6tczPQmAROHelQErN5RLrrLnJBcFXlbCqUGO3kbEIrtEi2Ck3hotgYgHgan+LJ//CqfvpSp/u5dM/fpvXjFRVKav8aCdCw3XxboiBEV4M4CoN2K98/L+Wv/PhvyYEYf+ff/FXy3d+4E/ymWApz39AEU+Tz5zVLLXU2hUhZq2mtZmuoEbFTRo8zfSHT3yx/ODf/J5y/fo1RUjz0Z/8WPmRv/KhsqDC+SWClzoPhzFFhceDHZ5Oa4bRbUEhWzITP18I7i+Xjf1LvAh2F/2ZwB5g51zYYZIx+edPXi4XTuHIl2fewW6nZwyc/ZpQdSJxvwps0BgkIbOYaOIpELF79JqPo+dLX/6iT/4jD769PHD/Q+Xb3vUoosqH/9GHyrPPPkMDvaafLAoPfJZfakRe8WnDft05FnG8AY469J/ZpEbxxSDm5BiL36drlaVyc/NG+Xe/8G948t/zzkfL5Yv3l0cefEd5+Mrby8/+3D8pn378U/zhGNdKocjnvCBlm5jgYp8IWa3INpw9YIZD8uCezXI5vk9vE/fXyYNPGvXoISmdAfiCjx5cPHviIh39V/i2LgYGdmwg9A0JoEQb1GgkOblZV0tyIG6fL/o+/4XHOQUm/4tf/n2Wj6wfLQ+T/iXSYbt4z71MXCl6TrY4gAT5YT7eqU97IXa3KSx1GDXWcOEgAw0N7szh0fWnnv1q+eX/8h9p4q+Uz/3OZxz8rj/yXpaxAN5PLwf8EkBkNg1O2wisus3oxuNu9XRwyiIPnCyXY3QmeH3p6bK3wAd0cmHoC4CPfHp+/eTRc+Xi6Qf4NGWT76Q6AlWXosTs1jzYauayAwSRNQ5FQt/niyX4rt+4joY2vOugR8a25QFSbgkHKpzkeIuNylwEOSWHwCo2TLvjNaIJYHfAAJUg5IOOydzelg/A7PE2vGvBE8/bW2Lf3Lwpt3ERQL/7dC1gXQiCmJqcqJ1Nya5W0EFsN7aLB9cEy2W1bOxdLNeWnya8PIXELwFYkfizJzzPfu+Zh5gNq0aGGCzotAwaaudsYma7pYePf1EI4xAjsazDbBgjMhzpyHH/ZbzVLOXkiVP8mrpxdKPcc4FWrr6mXjh/j+Sk6wXJ4alEUKPlYTLOgdxWD1nNZmIKAFZ+rW4EcDzibFMOqLgVfubU2XLfpSvluRef5rPACl3M8h+1HDvGEQ9eeZg+M1mR+rFkkMTqNclMHEEKapZGoGwHuNaDEN84Xn21eMpG1x54oIReBo7tXlA4XrrIgYcy11aOlMtn6SYPPcyBJ3d4TbfJUQh5ZCBY8uJQpPbF/W7jGK5ZQIFX+OgPKug98+bmZvm2dz9a/u6P/kT53T/4Qtna3iyv37hWvvr0E+WlV14oH/2pf0WvqW9nnFxJK6cmsglilTKhHp90GwzYxMW1eweCzeOFQPsDQt0aXj570hnqNC2Aj/7Uxxj01LNPcv1H6G8CPvv5/1ve9573l+/+wAf5zIp7A1KF1mIqWq3O+8JstuPE2iezacsumnj+N/bBiptDK3vHytHdc4Skey0/9uM//jM4fV0++7ZyZHWDJj9+qFOJZFC4Qq5RJQGwgtS0RQfJoqrR9YjTODLh6hh/AfT+Rz9QTtFg/vff+HUwlgvn7ik/85GPlb/+l/8Wf+qIlwR5hl7ZlZ7BKldWsrqNEaTHAHUnE0UnPXIERxDBjAPn4QfeVt737j9efv9Lv1teeJE+s9+6WT70wx8uP/0Pf7ZcuucSvY2lv3wKf8OoFUkC4msoxU3FjO1wz/l6LxYrrHJBSNch/+2Tn9i/dPqhcnrjHnqtxWsVALJx0rrj6rwQFTi9GzXOdRLkxyhZN/ZukMmBRYAbP6ji2eefKTfoWmBj40S55/xFvilkD590sZwzDIbXoCmbAIXXujCQIYYdqgfWUH8QNRBHLc5MeDfz0ssvllevvsx9Qe2rq6t65opvvCRBl9eqIkdbktQ1ZZfAoXfUF4IvPvOpz+/LRV99eyAFeUQtwqvRFK7TYLh8a3EoOeWDri9BdkcNiwJHDja5gmZRdpQuddjrgJ22WhjjG5X9IcQ5ObT2XMmimxOLgfbOQQnw8fgaTThu/GBRbG3Tn5BTH/BWMSDb0pRcmJzPMyA09bR6GDznQ9YhY1l85Xde2cfrvl30eYGE9xAVmMSNqV5UZz9NYVApci5OIBxnMAwcJt4C4+cAUljokgVxprSrnAFjhSYTkGQQm3oCwMWmI9WuBJxRzmTyWo8/GJU/EXd2D1Iwh4b+BLPUNAhQ0zBqzse5JAFiV1CcTD4Z2xXGRJoi1KBmBBiTSa7DV3Fixr6OH3k1nO15xy8By6itviIxPnW4pke08lVSlqrKyaNaYxAaPCOxFl6RjnPB+4drlGWvndhDPOfV5EMzfOSorDXCjEMvBww9QkD+1ruC26/YPJkKDnQH1yREhiZfcKuikcFRO6nG3AQScsiP5pHCvBazxniW1SDwwIcAIawIJWFzY1W1WhmkAYGWAQkVnJoTmSvEOSbr8bCut8498Mz7LCt3Y1hMWXEzC/3kcV0RRLKrbdHR4bhgVJEbN4vQDRaZU4cVX8Nc4m6ylkwUnXSCqT7i9a7ogmHSGqKxmbDj1wS9XdjHdiRJFVnqcb1CpZiJOPNOJrTu0EuA9NdHxpPXWPK1bterzwJTHIyOVQTrYqzY6lOPGDQWSg2rxmrTeEJ1nBqchqpSWHmUIBgtn8Z6J8yeoKpQk8yIhWVoN1cfYSSpXuaSGIhDX8DM+duXopXWUMdhUDzXq/SxdoHGCq0c6Y9jRag5FMbxDkojydYmIKvTnGBPg9GlIEOwCZ6DINJWnaOcjKgQjuCdgjsXG1JFIUbEoVeJhj5laOexEusYdMUIgj8LqJ3zTLXrbnLBuUdxcHouFkSrWA13Okd7YA2rvmqz9GSRHzNIyzZGV7uq1cog97PdnS5IP6pKeFWoSWZmEmNvt7CJ6eOAad+Ep9beDay76KQ2rMaq5ZbOAGhpJz9srL3T9JHHcWoMPhZdF6GrgcypU4qvYS5xLawlE0UnXcoHeMQrdt2HuCBy33UnXU/OwNDZ4aPIriCxgyzVpGZJchs+o53Kh1okqWXqWu+CcuCTCasH0byNSGpOBymWmsoqNtdZdX/IFGyGqUEsVVUSkJ5MCGNbY1XVrbVwScQ63bGrALabCjt/SifofrGpPY2b2dAyUeqpeDXBwBP8k95xXyWS95OLUDFSlhYR4vQMAIsmbzB1/MgRfCy6LkLF1qypS463cQoGVJBUUuRHySonpFneQSCoF5Rgl/7Ofo+eaqbbjUrIaXQnpiV6sHIJD8KE2+LioaypRqVgW6rIuVEKtqF3zidhFDiMrJyjejRWXLSfwdDbQPUGUO3kwb6KrVklKhKKjy11p52gJkB5qJJeedmnag0O4U0xTqM5d+jLHo9uvlBOv/q5srr9ClHkW7Nguklf1/LyyfeUzZWT9KnZln5m76MUs2viad/Qo0VJ4xVmXtLmjug5H4ikuzPcYcD5baBlr+OnwbFxPhEqVqPJnDocY2tVlkqLdJUEJgilqW+CF15NQYJLHMSam3C6pw9Bl9fLmatfKJe/+m/LYvsJOh3g28gcxHFYECf3r5dzLz1anrzv75WrR6+UZfqev326q+ebkreR7FdjGgcLnPMpZm5imXOYVILFRftZTHCquPjDz7ykw6eW3ARCcsiPdcl93mGNBcDFdnLcoaiW080J6ITVmgPdzoJrFEfPwtAj5cc2ny2PPPXP6TNbmtByjlr65BP3mQENt2wLPTWz2Hmi7Ky9s/zeg/+4bK8cK8v8TZ9ytgjMqFQ2MvoYmM1aDZjzT/qIg33DpJ6aUdwPyxnajjtx0Y2gNgH7HSRCM4c8aIlY8TXMJS6li0e3MkRKJtuIF06GD4LELuGKYsXs8iTMopzZ/Gwp6y8Sz0M0wfR1bPjwc4dQu/TLYOOgr3Vdua+sbH2+nLn22+XpM3+CPjvHS0ECeUyqFxQB1vksBWCDvpibKQ7yI1HIZbFou7wdTgzY+0sAm+qO+VINEpPJ3cZw9EoFabIqvmwjHJlTwYGiigxybrez4BqomM+Byry0v13Wll8o5Sh92TNAu/RAJCbffrdJxoKwTR+HW996kfDyZY/mQnyq1x0kzPmAO8A/tyg03EigdtuwLsopmwiuqjW9C4DtlieoCeAEKQuVlXTNTLZUcMCIyAAFS8P2unNfb2ILdwYSfRJfdui7e/EAXKHn5OsCoHcCmPwl+kWLX2z8kkB/8k5f5uivD9QJ9TLEd2qc8DLs4IklkiG5maf9SNDlTlyiJFMoHu+H+glSdCJ2m0aHWWVXykCK/HgqFhToUBcEJirtg91FFlwTSFWtKEnjdn4BoP4tlWsrj9CXLW2UBT793KVur9Ahv0MzvUyLAAtgiVpMPF0aLOjqvyyfL68dfZBqwfjQL57gjRvnSCMUvdp/BmW7ahw57dYhIMAEpsuccKIkk1eRreEMQAjyJeKAZTFMOvjE5sxG0Nfc8nqw9Y8Bkajh5kzsH+ZE5gqpPExLT77Sg5BX9+8vF4+8nV7zvkITf1RO+duYfIIvMPkQ5M+sFzdfKTeOfHd5bf0SrQ+8C9DJ1xxpjGo2luaO9jkfgoXekzTMona5FW5etMkkjmwNKcI1QAgLAI4Po8uuAOV0pCcTgtSQCnYbsxImR7nGgmttCZHc0ihh5hWGJZrjbfr6Vfq+vaX3ltPrXy7727jSJy9eEvDLE0yLgNno7ED/8cOrJ7697ND/BbBG3/ePJZT6kbOxNje5HJu7kxicewLjfovqcGLozFKZRXH3MsbeBQASPCzWXaUJGAQ08yeJCJMKDjEuNoFsr07hsZLcDrMoTbjjUVCCWwgOYLqYe2nrXeX06Y+XxQpN6BZdEC7RH5vQFT4d+HSvAI/F0cKg7+HbP3KlvLzxTjr6cTew6U/NRvgum3vZM+MHUKJpP0Ez6E3AerTnrEIgVDFYPDPw4Qyg4aFoDkqRpMiPgi0G5gT0Qqs1B7qdBdeYMJRAuviyLaQnR46uNVlV+/R+f3lpq1y9cW956cafL2dP/aeyWN6Q0z9uCy/haWj6w8m9m/TS8EJ55thHyo2VU3QnsLkJZNSTxWjGYUHWE5AoYIDretNhOoRWFXhVzKFZsyB5Ioh9FdCohCWL/Fhc6EONY6eqbm0Gi+3V6XwNTHJi71iHsm9sl4BhCF3hLS12ypPPfRf9p08nytmNT9HfGLxcdreukoe+f2DlONnPluc3PlieX/6j9N6f7geEO4AHHu3dANV6vZ7pom1JDIJgEgbnqSj3sUkBGZe1GIqltPi933zOEX19BHGvhrLerMKAEZH2nS3W6qiEi0qXF+nJGGi1IOM9jA/RC3pMm75D48g2/R9DL5d//x/+dnnfe/9G+b4/88Pl1Zv0jR7LR+nuGB5Bp9cNgk+wcm72DQtit9bKJGLo9g174qpKlYygsaharVWyCGubjPwGiCe5DjgFY6D518KoZTPClQI59Fca9YAIhupWnII1nvMpzog4FOFuVxYycD3MGnZu15rMpakkJvpwMUA3e5dv0nP6q+XazVPl53/p8fLbT62Wm4szVNlSWd2nlwGuQftjnKFlDxcbjCpqaunlJEa4vZsWxByimMkxwWci0xPAsFHScrxpMrpdrwEkDQjTpjqCfetEMnQ2QrOtOhpV6Yi5QjwFC+QYupRoyjcRxfWYbw/XBItdegnYKu97x6Vy5hj9jRz/Z074v4vwZ9P9xrHDpIIVF+0nMZY9cCfswO/QAOxSBJ/jraZpn80P3QcYgDhJsHciA1I6hjjOBcsTsOIbpdVZGo8hhQ2HSFPdug9/kr5U/uCr+I8g8UYAOt04kpOE1zscH/eGmmqXgzf4zZpwoiST4eIoKCDjsuZhJAzHwgDNwNMlsG6eJBC7LYCCG1ZW686AgyNbApv8iqeSG152KO/IZYmnfGIfepUaw0RfSTM44HkAp0M9XmrQLqSGGaql42r8FUlSAJMYtOxLMYbLaIewufqqpG8DUznBW0WSqiKi6y40dqQX33By4ZMfr9MFDktViUvomNdFC1KDNJ3X48HKRzUgCcYe8RlnaB067gwju4o9CG5Rkinwm99qyrisxbAuZ3LmuJE2fiKISQieI0RlW3b0YyL+3k7EZMzRWrHyTvtQzsCrpqHPqIeFwEnBfJOIosGD3/YlADA44BtsXd6EEyWZEkfwqFgtVUohqnR5I6jpb2bKWn8jqOmsw1lwTcajqpRelCZ3LYscCW6eSbsAJqJ0ToaMGjgZyX54ES3vFCBIGPZVJKkqFcBSw59woiSTRwerisGSsnuICk3G6maCg1iy34LlRhB62fhZdZsIjUocbpEjyFit1dVQUeZA6ER3FNx5A0nnS7QBGOwQOY7caLk02uHbSOXbRiSO91p3E24M2ZzSBY6M4lg3ESyFNZrjOCojo0/Csn9OS7EYAzLQGaCGsOSqC4M84guhDbeQZyNpFDb0aKpb9lkCKqRWa8batlfy+P6BpdUFfa3bzfLSqy/Qlzm8wF/exH8lTUTyLRohvmVPyURJJg9trKRmS9Y8jITZHnFYja2SMfQW87TM+CSci+LJ5DizkJ3EageF+NxeWcVHDj+lRp/bOUH1aCp0tuvwnE8ZOBe4K6NLzKh53UgCYvANJPhSx8e/8Gl2/cIv/nx56ukny/GNk/SZUWWTqqqu3Vc6KVD2MQNktVpDLaUNdaqjCROrZG1cSqlEypRZTEPbbuIbMeNzTqlOizYVBcsmwegBd8Lt8MJmv7GD7GLe8YKAS8rB3jdNxbnAHX0GIozlNFNs3RdozQ8fvowKX4r1yd/4ePn7P/1j5c/+6R/g7/H5lz/3T/k7CFdW8M6YMvNjYSxClV8VrLI+hQPRhRrGBZhvFDXNKKEWWzkrS/UxNu2Ed4wQ6+Lz/+Mp1CqbC1BFqU7FsAvEExsFDH1qHHrnfJoGkze1Mee0m8PwFS34xq5PP/6b5Ud/4ofY9uc++IPln/3kv6bv9H2i/MiH/wLbvv97/1L5yD/4F+X0ydP8nUS4PvCxYES7C4m9H4YJPjNpOxwHw3BYja1SApgyaOfYM1t+IoipCCA/PfHs5A6Saq6Bx8bUllmfCxauQ0kGCOadcFezSlQ7pnKbvq/nB773h8pf/P6/Wr79ve8vR+l7CN9Nk/2rv/y/y2P/6xPlt/7fp+iraewJ0WHlWonxeldChTV7MLI4x9gOfM/SWyr/HPN03OJzjz1FXgGMDzIinoqfWRDDcpxn6A19mfYzxWRBQsHRnqvSQoIPX4uDL6XGYsC3euKiD9/qjRbfTSg4bppdJu3LyH4LFuvYJ0NffVXK0ab17fRY2bz2MbBI3PizAPbPEI8mXiufjDqEfzIW5fajjSp9E3raax53BAH8mGR8edON66/T2z96XEw/88fXuOKDAFwj9Lm8eGbLKbIW0ukQR0uQm/70LL2lRotvjBhbLbYd4/pZACPIPYpnWxuqlIofeud8taLJgZK0SmL40IqH9hMQ94cY/i/XyFG/dUwqx5c3Ao9vJms/EDL+mqZKgdrF4ViYNwxwz9JbLAztLK8VGQNUnouTBUBFDVOTccKjgz7hnYuTnkzych1hkAb90Vo5ycjdczOpQPk9Pv2Vz6hyvgscbwV3KQJRk3nE55CmPz1Lb/HYYaXVO7n6GTJXleQcvwTMLAjwDmm1D0Of1TvFy5zYTQ+EeGg/DenrSlhnsGpCG4AkBk0xvcWCD+pvxZkU22neiVHW4NuNQ3iOrS8BbJ/oDvmGHucaeqXYqVjvCgNU6xtJMY3pMkuAs0NIJk8RrCoGy2SU8GWkU4ozxfbI3lLjxTeNmPNM+6ZGAHn5w6BuEOFRvlv2IZa2/kJK7OwD+Uy94vICamCQuroSX2IIUZLdDQRLYezoLTVq7BOS7JvTPH/Il/GGGFvNi+rnEXNe8dWPg42V7JO0HDPple7MnsaZ3DJ1rZQ0jRlmliDi8uiOVwwOZGjQPHYUOM9K3kAURKXqLTHHsD8OmIudi5yPM3pD6UUgzBOkipzwMp/MuVFaCmk5buySWIcTaALX5U44UZIpcrpMAoEqrkoRYnKXszqEyPQDtABTcZK5Y8qxc3FAzvWn+qok7Lf3EqCVzZ7mZ84EtVwqp63IuFtHwlWlShrITbCSGDTyZi1HTfhg5jvC1V8lY+gt5kHOae+0Zz4O7POxln+MEmt+CVDkbLkzE8tx42xWi5R8EIej2z7OVlajvB9mmi9qyOohmczNTJ01y1bbIbO652OnI+fj4qLokY2FFvXBLwEol+KmC1Jfw10HwUpikmgOcsOeuERJphBp7DD162ouatrXEvXI3lJLEt8YMbZKbDMGlVCluVhApvIO4sK9jvF9AEtOsXNlzb4EOMegAPV13AkqSjIZp3Y2qhmXNceR0OXMTkbANGYYW4VijvnrEZer7DM0ljDpsXf1PoD0gn3zXSHihttCa0lzmIa94xJDZ+YkwUpi0MibtVzThM/NLgxYqi9yiiy+MWJsrRzNOFQHSXOxt5AzTToS9Lx1AdD5s3dLVZ5yCsDU5DzIL3SRVC2eISKSjxXlz2myFgmme0So8HrRM/SWyiu+acS0BwM0550dQI0cxzfWNPGNr3aEJX4mcArC5U45MYZMQftJzKDDCTvwe4EKzI16E4lHQBgyGhwDc9sTP8kOB22WRLS8H1alkLk4QMTfoxpLmvQap0mapsbqU8HZf6jXdhRWeRJB192EEyWZPDpYSQwaIbLmISp0ORNAY3MTEHPcc8zzcUgwjZj2xKge1VhuY+Ijg78EzE167QiFxug0hANHMh1yILsUiSRkRCnTPgaGo732wSjmYg9ivt3YubhcYY8MltuY9MyuY0Cfis6/CyAcp20GUsO56YYq1GmrJZlicJjAPsVc1LQvnuKRqkf2llqS+MaIsVViu1GolCzNxxq4RzWWNPGNz0i8rf4qwamacvkZwOMcQsAcGSBNhzucGDozMwQriUHzzCGRi01Gt7PAJHNM2TcIbuqIiOnY2ZpqYZEsyMI7Zg/WNOkID77AJmL1VclAZOm47EaQYrhDfaQxUOrgDGJM3pnZ2VhJzZaseUISUs7ogNycNnqW3lIp5phvN46Lqik6SXjH7I01TVbjOzSvxiWuGMzfEgYDASdyDIcpYUVJJs8RrCQGTXI6LguCy2hHNJMOe0ZmzeNYmGXumNrYOea2ijbW9J6jsaTJanxGwq34xgiyJp4YmCPSn4ZlWAbmURZfg9DwYCUxaL0/JiR5uNiAYZLMlDUHQRhsk8yE7ZkqwVwcUPOxxtOjGkuarMZnJN5Wf5XMSZbEZXa0PRrW7hogdTnFVKVKoLAtWEkMGgGyZhHWppxmtDYc8T1Lb7EwaeeY52JvNw5ZK2+VrKrG4pPV2A3ubfVXyZxkcR6zWdujzWP/Zw4vgK67KU6UZHKWYFUxWAiVNQsT69jHmDDp0DMya8ZZ2zn2udi5uL6Kmi/7+gyNpZusxp+Ia00Iy0jSOi4Lzkizctt87X39OLiLEUNnZpZgJTFo5M1aSs7eCT+bs29Oy7yCzPiImPag3mnvtEfYxT9GNdY0WY0vlspyz+uWxBMDZzg5ZuznB0IqjaepJpcCgYrBQqiseRh7pn0SVv1VMobeYh7LOY2Y8sxNOtin4qpvGtF4fMIae+2EStVfpZpvfLRnZEfZHO3ZL7F6DSDKmC5YSQwa8WUtJ4B3ws/m6quSMfQW80g7xXy7cWCdixXfNKLx+KQfjneMUs7EBSS2Jp8YdU++YYyBQizh6kuA+b0NQBKDRoiseQh7pn1v1vt21Ddd1bQnRvWo3lIHfuCLgxSqyUjVJicwoxPlIY52xwf+5l2AJsiNxk0nF8+En83ZN6d5kS7c3tE+FeW0YRKqzSSJxjjlWuEPljCQEhl8Ygj77BtqHR/CMzIQinjYie+4hZcWQEigYrDMFjA7yLNX8qg9Z5He2H6WeTZ2PnI+Z80uUkVXyTC3erQPGKQf3cRYhnEEew876QB3/JnXzwDNfFFkBnJi3U0OMkJQXAgN4iynUE8yHxB7u3HIKhXmOqUa85mWB3McIdjqq5KxkKWblOAzcdQeduI7/r4Kq4E+DYyZkhIdNEwTPjYHH4lBU47eUsnFN0aMrRI7WdEhcgIylbfJeZjB1IzgbKLdw/k6LnNPR9kNG0P2rcYOuQe8jhNfehcwIh9QVFhePU3nZyOJ44DBqlkaaS4O0Lm81Vclo28sPlBfI2fisVwHcZL/sEc7qFKOph/Jn33Q8jUAwLTNDvHspEs0kwx3s8yceRjGnlx8xh3ON0Y11oMG0xNLXBPNlTIk8XhQ9UeTy8Q2GQdQyNbhgs/4HDPwAUN+vwaAPjs9sxM/kQCkvM0xT8fORaXBsDSpFd4xe7D6IFlw8JkptVO8ZO+4LHCGk2Nm/Lc96cg9wRtyztwHsPhKUqVDdIwhc1PYswmr2Ke8k53SfPOVBdZusoLPSLzNvqqp1HFZYEWaxdswCW5Lwhz3gNdrGPiIl74JH3vPABW/6QzAXsZUIGxzGsf4TpAZb86x1bzIMo2Y9kh89VfJmHtLPVIHPgvTasYItfqgexAJ4whGzL6uAxFiO+7gYzLaJUzvhwVfdzMaWUPnBRBO8wawXKm4alRplCKCejbzzkdOx8V6elRvOWiwrB7jHTAQhKxp0GuUxUVLlefigArZOv7gM0LHDHxgI79AxG9wQ9N/jWEAOgOESW9K0XQWZtljK74xYmyV6Lk4IA6OHaOaOOs5J218bIu7qaWocYnL4g7gnD3iQ2zHHXyWKmHEj300x9O8MWQMaTGA4v8/GLYQ6Pgi2jsAAAAASUVORK5CYII=", Eg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAnCAYAAACMo1E1AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAE3SURBVHgB7ZdtbcMwEIbfDEEhBEIhbAwGwUOyMCiFQhiDlUHHwINQBtez+qFWipvz6w+1kh/p5B/JvXlkKckZ6HQ6r8GwdIOIrHUJ9T8Mww4ZaNZKl0+tg2b9IAcN28g9XmsEgfZ9l8oKYU7mSQ6dEbtmgUEbfyWOtwo+ELuwRioLciZBg1jgHalo02QI9jFBo1joXyGV0KS1Nz5gJMQCDiyMYBMxUnAjNhxKkSDYVqywoEMtMgUdakMKOrTiLOiNYhNaIvbPhUjOD76yWDtBUqy+YKZYPcEEMW+8Z0QJEsTCcEoPC1XFbnrqC0p8TI+KEYJ7MMjyJDwrRghGx/Q38Hzp8W4bu6jXDrp8aP3hMdQkPDE7NpOztIP0mO5zxAyCE1i0eZTTi7HT2gpzUrrPK5bV6XSeiSNPs80hxEV9awAAAABJRU5ErkJggg==", $w = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAAdCAYAAAD7En+mAAAACXBIWXMAABCcAAAQnAEmzTo0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAK1SURBVHgB1ZmBddowEIbPLFA2qEagE2AmKBuETBA6AWwQOgHNBE0mgE4AnUDuBPUGf3WWnMqOZJ8wJPC9dxgL3UknS6ezyEgIgNxcvhrhqzIypo/jaKQw8mJkn2VZQUMxDq6M/MV1szWi6BSM4sSIxm2xSnXyAbfLAYGnmwWc5FFZ021TGPli1m5ZFzQchQ04O5LBAYEN5fQ+lK5N5aQPDlKzN6X8uCFbk9qfGgl6Q1i3+roW6i1Djj4KlRcB3QUuh6YAkA0u7xbVNjiqn4q5LEnGMVC2p8vxO1L+i/phJyu/Rq4gJzklvS+fI+VTkvHAH7Wjd3S98H7e2B/dvZKp09jUzzOniEglfnpP1Jyuz37Ydvo8ReZ+58imi4rS2ZNN7djmnWeDywt3n3v9++6u01YffL7VGVAwCODUtIpeo3Fq6rgO2NDS/pn7TaTutto7oz8OpKPhGCpgYxmpuwzUHUfq7kYd/fxDw0kKXJG3kFJqu72kfEYdhqRRrYskG7CZmdTGVKj/+uO4Yyqt4DbcxA6zTWkC4qONTBJsrHwnEV/PmzrqcvahOvpeeN9n7SkGu7b8HFnRMOpZNvbav6f/UXdLzTZK6j4IuK8+kRY0VNsKbHS8JCrQXkpEV3Uweqbr5aU9g9z9nmRURy0jp7hPUFTCshBF5jDfZ0KdT5Fyaex4atwhvp+2eWxbgj2zkTBv6e0EOjxFVUtPulQOQdchX6tb2IGZQ+7kJtCedK1p2FdBbnMJ+SuaijnKIf2A86MR2aZwuXfZ7tdOnP/EQKMnZ4b8xEDKmiTAPtkfGM5PCBMO2GWgMQyernNKBXZaaaTDDS4oEdjZdOoA86AqGoJzeCdojOtwsBj0d4XnsEb/gHIAzftsZpSAc2DipHaG06+C7MZ89mMW2NxXuTZrCiNH095RaucfEDTBOCTCWakAAAAASUVORK5CYII=";
  function e4({
    playerState: t10,
    key: e,
    style: r,
    noDefault: n,
    defaultImage: i
  }) {
    var o = t10 ? t10.getState("profile") : false, s = t10 ? t10.getState("__gamepad") : false;
    return r = r || {}, o && (r.borderColor = o.color), o && o.photo ? (r.backgroundImage = `url(${o.photo})`, r.backgroundSize = "contain") : n || (i === "color" && o ? r.background = o.color : r.backgroundImage = `url(${i || Sg})`, r.backgroundSize = i ? "cover" : "contain"), /* @__PURE__ */ K.createElement(
      "div",
      {
        key: e || (t10 ? t10.id : ""),
        className: "avatar-holder",
        style: r
      },
      s && /* @__PURE__ */ K.createElement(
        "div",
        {
          className: "badge-gamepad",
          style: { backgroundImage: `url(${$w})` }
        }
      )
    );
  }
  function kg({
    centered: t10,
    bottom: e,
    showNames: r,
    showScores: n,
    onPlayerKick: i,
    showEmptySlots: o = 0,
    mobileMode: s,
    initialScore: a = 0,
    style: l = {}
  }) {
    const c = Va(true), u = Mu(), f = o - c.length;
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        className: "player-avatar-strip" + (s ? " mobile" : ""),
        style: l
      },
      c.map((d) => {
        var p, y, b, x;
        const h = p3() ? false : d.id === Hn().id, g = ((p = d.getState("profile")) == null ? void 0 : p.points) || ((y = d.getState("profile")) == null ? void 0 : y.score) || 0;
        return /* @__PURE__ */ K.createElement(
          "div",
          {
            key: d.id,
            className: "player-score-container",
            style: { backgroundColor: (b = d.getState("profile")) == null ? void 0 : b.color }
          },
          /* @__PURE__ */ K.createElement(e4, { playerState: d }),
          s && !h && u && /* @__PURE__ */ K.createElement(
            "span",
            {
              className: "player-remove",
              onClick: () => i(d)
            },
            /* @__PURE__ */ K.createElement(
              "svg",
              {
                width: "20",
                height: "20",
                viewBox: "0 0 20 20",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              },
              /* @__PURE__ */ K.createElement("circle", { cx: "10.2441", cy: "9.75", r: "9.75", fill: "white" }),
              /* @__PURE__ */ K.createElement(
                "rect",
                {
                  x: "15.2549",
                  y: "7.75",
                  width: "4",
                  height: "10",
                  rx: "2",
                  transform: "rotate(90 15.2549 7.75)",
                  fill: "black"
                }
              )
            )
          ),
          r && /* @__PURE__ */ K.createElement("span", null, (x = d.getState("profile")) == null ? void 0 : x.name),
          n && /* @__PURE__ */ K.createElement("span", null, a + g)
        );
      }),
      f > 0 && [...Array(f)].map((d, h) => /* @__PURE__ */ K.createElement(
        "div",
        {
          key: "empty" + h,
          className: "player-score-container",
          style: { backgroundColor: "#000000" }
        },
        /* @__PURE__ */ K.createElement("div", { className: "avatar-holder empty" })
      ))
    );
  }
  function An(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function ke() {
    return ke = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, ke.apply(this, arguments);
  }
  function Cg(t10) {
    var e, r, n = "";
    if (typeof t10 == "string" || typeof t10 == "number")
      n += t10;
    else if (typeof t10 == "object")
      if (Array.isArray(t10))
        for (e = 0; e < t10.length; e++)
          t10[e] && (r = Cg(t10[e])) && (n && (n += " "), n += r);
      else
        for (e in t10)
          t10[e] && (n && (n += " "), n += e);
    return n;
  }
  function uo() {
    for (var t10, e, r = 0, n = ""; r < arguments.length; )
      (t10 = arguments[r++]) && (e = Cg(t10)) && (n && (n += " "), n += e);
    return n;
  }
  function nf(t10, e) {
    return define_process_env_default.NODE_ENV === "production" ? () => null : function(...n) {
      return t10(...n) || e(...n);
    };
  }
  function fn() {
    return fn = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, fn.apply(this, arguments);
  }
  function ui(t10) {
    return t10 !== null && typeof t10 == "object" && t10.constructor === Object;
  }
  function Tg(t10) {
    if (!ui(t10))
      return t10;
    const e = {};
    return Object.keys(t10).forEach((r) => {
      e[r] = Tg(t10[r]);
    }), e;
  }
  function qr(t10, e, r = {
    clone: true
  }) {
    const n = r.clone ? fn({}, t10) : t10;
    return ui(t10) && ui(e) && Object.keys(e).forEach((i) => {
      i !== "__proto__" && (ui(e[i]) && i in t10 && ui(t10[i]) ? n[i] = qr(t10[i], e[i], r) : r.clone ? n[i] = ui(e[i]) ? Tg(e[i]) : e[i] : n[i] = e[i]);
    }), n;
  }
  function t4(t10) {
    const {
      prototype: e = {}
    } = t10;
    return !!e.isReactComponent;
  }
  function Og(t10, e, r, n, i) {
    const o = t10[e], s = i || e;
    if (o == null || // When server-side rendering React doesn't warn either.
    // This is not an accurate check for SSR.
    // This is only in place for Emotion compat.
    // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
    typeof window > "u")
      return null;
    let a;
    const l = o.type;
    return typeof l == "function" && !t4(l) && (a = "Did you accidentally use a plain function component for an element instead?"), a !== void 0 ? new Error(`Invalid ${n} \`${s}\` supplied to \`${r}\`. Expected an element that can hold a ref. ${a} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
  }
  const Ig = nf(F.element, Og);
  Ig.isRequired = nf(F.element.isRequired, Og);
  const Pg = Ig, r4 = "exact-prop: ";
  function n4(t10) {
    return define_process_env_default.NODE_ENV === "production" ? t10 : fn({}, t10, {
      [r4]: (e) => {
        const r = Object.keys(e).filter((n) => !t10.hasOwnProperty(n));
        return r.length > 0 ? new Error(`The following props are not supported: ${r.map((n) => `\`${n}\``).join(", ")}. Please remove them.`) : null;
      }
    });
  }
  function Ti(t10) {
    let e = "https://mui.com/production-error/?code=" + t10;
    for (let r = 1; r < arguments.length; r += 1)
      e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified MUI error #" + t10 + "; visit " + e + " for the full message.";
  }
  var Sa = {}, i4 = {
    get exports() {
      return Sa;
    },
    set exports(t10) {
      Sa = t10;
    }
  }, Xe = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var ap;
  function o4() {
    if (ap)
      return Xe;
    ap = 1;
    var t10 = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g;
    g = Symbol.for("react.module.reference");
    function p(y) {
      if (typeof y == "object" && y !== null) {
        var b = y.$$typeof;
        switch (b) {
          case t10:
            switch (y = y.type, y) {
              case r:
              case i:
              case n:
              case c:
              case u:
                return y;
              default:
                switch (y = y && y.$$typeof, y) {
                  case a:
                  case s:
                  case l:
                  case d:
                  case f:
                  case o:
                    return y;
                  default:
                    return b;
                }
            }
          case e:
            return b;
        }
      }
    }
    return Xe.ContextConsumer = s, Xe.ContextProvider = o, Xe.Element = t10, Xe.ForwardRef = l, Xe.Fragment = r, Xe.Lazy = d, Xe.Memo = f, Xe.Portal = e, Xe.Profiler = i, Xe.StrictMode = n, Xe.Suspense = c, Xe.SuspenseList = u, Xe.isAsyncMode = function() {
      return false;
    }, Xe.isConcurrentMode = function() {
      return false;
    }, Xe.isContextConsumer = function(y) {
      return p(y) === s;
    }, Xe.isContextProvider = function(y) {
      return p(y) === o;
    }, Xe.isElement = function(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t10;
    }, Xe.isForwardRef = function(y) {
      return p(y) === l;
    }, Xe.isFragment = function(y) {
      return p(y) === r;
    }, Xe.isLazy = function(y) {
      return p(y) === d;
    }, Xe.isMemo = function(y) {
      return p(y) === f;
    }, Xe.isPortal = function(y) {
      return p(y) === e;
    }, Xe.isProfiler = function(y) {
      return p(y) === i;
    }, Xe.isStrictMode = function(y) {
      return p(y) === n;
    }, Xe.isSuspense = function(y) {
      return p(y) === c;
    }, Xe.isSuspenseList = function(y) {
      return p(y) === u;
    }, Xe.isValidElementType = function(y) {
      return typeof y == "string" || typeof y == "function" || y === r || y === i || y === n || y === c || y === u || y === h || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === f || y.$$typeof === o || y.$$typeof === s || y.$$typeof === l || y.$$typeof === g || y.getModuleId !== void 0);
    }, Xe.typeOf = p, Xe;
  }
  var Je = {};
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var lp;
  function s4() {
    return lp || (lp = 1, define_process_env_default.NODE_ENV !== "production" && function() {
      var t10 = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), g = false, p = false, y = false, b = false, x = false, S;
      S = Symbol.for("react.module.reference");
      function O(ne) {
        return !!(typeof ne == "string" || typeof ne == "function" || ne === r || ne === i || x || ne === n || ne === c || ne === u || b || ne === h || g || p || y || typeof ne == "object" && ne !== null && (ne.$$typeof === d || ne.$$typeof === f || ne.$$typeof === o || ne.$$typeof === s || ne.$$typeof === l || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        ne.$$typeof === S || ne.getModuleId !== void 0));
      }
      function _(ne) {
        if (typeof ne == "object" && ne !== null) {
          var Ae = ne.$$typeof;
          switch (Ae) {
            case t10:
              var C = ne.type;
              switch (C) {
                case r:
                case i:
                case n:
                case c:
                case u:
                  return C;
                default:
                  var v = C && C.$$typeof;
                  switch (v) {
                    case a:
                    case s:
                    case l:
                    case d:
                    case f:
                    case o:
                      return v;
                    default:
                      return Ae;
                  }
              }
            case e:
              return Ae;
          }
        }
      }
      var L = s, N = o, j = t10, W = l, G = r, ee = d, fe = f, P10 = e, z10 = i, U = n, I = c, V = u, te = false, X = false;
      function H(ne) {
        return te || (te = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
      }
      function $(ne) {
        return X || (X = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
      }
      function se(ne) {
        return _(ne) === s;
      }
      function he(ne) {
        return _(ne) === o;
      }
      function pe(ne) {
        return typeof ne == "object" && ne !== null && ne.$$typeof === t10;
      }
      function me(ne) {
        return _(ne) === l;
      }
      function B(ne) {
        return _(ne) === r;
      }
      function q(ne) {
        return _(ne) === d;
      }
      function Z(ne) {
        return _(ne) === f;
      }
      function oe(ne) {
        return _(ne) === e;
      }
      function de(ne) {
        return _(ne) === i;
      }
      function R(ne) {
        return _(ne) === n;
      }
      function k(ne) {
        return _(ne) === c;
      }
      function re(ne) {
        return _(ne) === u;
      }
      Je.ContextConsumer = L, Je.ContextProvider = N, Je.Element = j, Je.ForwardRef = W, Je.Fragment = G, Je.Lazy = ee, Je.Memo = fe, Je.Portal = P10, Je.Profiler = z10, Je.StrictMode = U, Je.Suspense = I, Je.SuspenseList = V, Je.isAsyncMode = H, Je.isConcurrentMode = $, Je.isContextConsumer = se, Je.isContextProvider = he, Je.isElement = pe, Je.isForwardRef = me, Je.isFragment = B, Je.isLazy = q, Je.isMemo = Z, Je.isPortal = oe, Je.isProfiler = de, Je.isStrictMode = R, Je.isSuspense = k, Je.isSuspenseList = re, Je.isValidElementType = O, Je.typeOf = _;
    }()), Je;
  }
  (function(t10) {
    define_process_env_default.NODE_ENV === "production" ? t10.exports = o4() : t10.exports = s4();
  })(i4);
  const a4 = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  function l4(t10) {
    const e = `${t10}`.match(a4);
    return e && e[1] || "";
  }
  function Rg(t10, e = "") {
    return t10.displayName || t10.name || l4(t10) || e;
  }
  function cp(t10, e, r) {
    const n = Rg(e);
    return t10.displayName || (n !== "" ? `${r}(${n})` : r);
  }
  function c4(t10) {
    if (t10 != null) {
      if (typeof t10 == "string")
        return t10;
      if (typeof t10 == "function")
        return Rg(t10, "Component");
      if (typeof t10 == "object")
        switch (t10.$$typeof) {
          case Sa.ForwardRef:
            return cp(t10, t10.render, "ForwardRef");
          case Sa.Memo:
            return cp(t10, t10.type, "memo");
          default:
            return;
        }
    }
  }
  function Fo(t10, e, r, n, i) {
    if (define_process_env_default.NODE_ENV === "production")
      return null;
    const o = t10[e], s = i || e;
    return o == null ? null : o && o.nodeType !== 1 ? new Error(`Invalid ${n} \`${s}\` supplied to \`${r}\`. Expected an HTMLElement.`) : null;
  }
  const u4 = F.oneOfType([F.func, F.object]), Dg = u4;
  function or(t10) {
    if (typeof t10 != "string")
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : Ti(7));
    return t10.charAt(0).toUpperCase() + t10.slice(1);
  }
  function f4(...t10) {
    return t10.reduce((e, r) => r == null ? e : function(...i) {
      e.apply(this, i), r.apply(this, i);
    }, () => {
    });
  }
  function d4(t10, e = 166) {
    let r;
    function n(...i) {
      const o = () => {
        t10.apply(this, i);
      };
      clearTimeout(r), r = setTimeout(o, e);
    }
    return n.clear = () => {
      clearTimeout(r);
    }, n;
  }
  function h4(t10, e) {
    return define_process_env_default.NODE_ENV === "production" ? () => null : (r, n, i, o, s) => {
      const a = i || "<<anonymous>>", l = s || n;
      return typeof r[n] < "u" ? new Error(`The ${o} \`${l}\` of \`${a}\` is deprecated. ${e}`) : null;
    };
  }
  function p4(t10, e) {
    return /* @__PURE__ */ reactExports.isValidElement(t10) && e.indexOf(t10.type.muiName) !== -1;
  }
  function Ea(t10) {
    return t10 && t10.ownerDocument || document;
  }
  function g4(t10) {
    return Ea(t10).defaultView || window;
  }
  function m4(t10, e) {
    if (define_process_env_default.NODE_ENV === "production")
      return () => null;
    const r = e ? fn({}, e.propTypes) : null;
    return (i) => (o, s, a, l, c, ...u) => {
      const f = c || s, d = r == null ? void 0 : r[f];
      if (d) {
        const h = d(o, s, a, l, c, ...u);
        if (h)
          return h;
      }
      return typeof o[s] < "u" && !o[i] ? new Error(`The prop \`${f}\` of \`${t10}\` can only be used together with the \`${i}\` prop.`) : null;
    };
  }
  function ka(t10, e) {
    typeof t10 == "function" ? t10(e) : t10 && (t10.current = e);
  }
  const y4 = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, Oi = y4;
  let up = 0;
  function b4(t10) {
    const [e, r] = reactExports.useState(t10), n = t10 || e;
    return reactExports.useEffect(() => {
      e == null && (up += 1, r(`mui-${up}`));
    }, [e]), n;
  }
  const fp = reactExports.useId;
  function Mg(t10) {
    if (fp !== void 0) {
      const e = fp();
      return t10 ?? e;
    }
    return b4(t10);
  }
  function v4$1(t10, e, r, n, i) {
    if (define_process_env_default.NODE_ENV === "production")
      return null;
    const o = i || e;
    return typeof t10[e] < "u" ? new Error(`The prop \`${o}\` is not supported. Please remove it.`) : null;
  }
  function Ng({
    controlled: t10,
    default: e,
    name: r,
    state: n = "value"
  }) {
    const {
      current: i
    } = reactExports.useRef(t10 !== void 0), [o, s] = reactExports.useState(e), a = i ? t10 : o;
    if (define_process_env_default.NODE_ENV !== "production") {
      reactExports.useEffect(() => {
        i !== (t10 !== void 0) && console.error([`MUI: A component is changing the ${i ? "" : "un"}controlled ${n} state of ${r} to be ${i ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
      }, [n, r, t10]);
      const {
        current: c
      } = reactExports.useRef(e);
      reactExports.useEffect(() => {
        !i && c !== e && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
      }, [JSON.stringify(e)]);
    }
    const l = reactExports.useCallback((c) => {
      i || s(c);
    }, []);
    return [a, l];
  }
  function Lg(t10) {
    const e = reactExports.useRef(t10);
    return Oi(() => {
      e.current = t10;
    }), reactExports.useCallback((...r) => (
      // @ts-expect-error hide `this`
      // tslint:disable-next-line:ban-comma-operator
      (0, e.current)(...r)
    ), []);
  }
  function Xn(...t10) {
    return reactExports.useMemo(() => t10.every((e) => e == null) ? null : (e) => {
      t10.forEach((r) => {
        ka(r, e);
      });
    }, t10);
  }
  let Za = true, ru = false, dp;
  const A4 = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true
  };
  function w4(t10) {
    const {
      type: e,
      tagName: r
    } = t10;
    return !!(r === "INPUT" && A4[e] && !t10.readOnly || r === "TEXTAREA" && !t10.readOnly || t10.isContentEditable);
  }
  function x4(t10) {
    t10.metaKey || t10.altKey || t10.ctrlKey || (Za = true);
  }
  function gc() {
    Za = false;
  }
  function _4() {
    this.visibilityState === "hidden" && ru && (Za = true);
  }
  function S4(t10) {
    t10.addEventListener("keydown", x4, true), t10.addEventListener("mousedown", gc, true), t10.addEventListener("pointerdown", gc, true), t10.addEventListener("touchstart", gc, true), t10.addEventListener("visibilitychange", _4, true);
  }
  function E4(t10) {
    const {
      target: e
    } = t10;
    try {
      return e.matches(":focus-visible");
    } catch {
    }
    return Za || w4(e);
  }
  function Bg() {
    const t10 = reactExports.useCallback((i) => {
      i != null && S4(i.ownerDocument);
    }, []), e = reactExports.useRef(false);
    function r() {
      return e.current ? (ru = true, window.clearTimeout(dp), dp = window.setTimeout(() => {
        ru = false;
      }, 100), e.current = false, true) : false;
    }
    function n(i) {
      return E4(i) ? (e.current = true, true) : false;
    }
    return {
      isFocusVisibleRef: e,
      onFocus: n,
      onBlur: r,
      ref: t10
    };
  }
  function Fg(t10, e) {
    const r = fn({}, e);
    return Object.keys(t10).forEach((n) => {
      if (n.toString().match(/^(components|slots)$/))
        r[n] = fn({}, t10[n], r[n]);
      else if (n.toString().match(/^(componentsProps|slotProps)$/)) {
        const i = t10[n] || {}, o = e[n];
        r[n] = {}, !o || !Object.keys(o) ? r[n] = i : !i || !Object.keys(i) ? r[n] = o : (r[n] = fn({}, o), Object.keys(i).forEach((s) => {
          r[n][s] = Fg(i[s], o[s]);
        }));
      } else
        r[n] === void 0 && (r[n] = t10[n]);
    }), r;
  }
  function of(t10, e, r = void 0) {
    const n = {};
    return Object.keys(t10).forEach(
      // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      (i) => {
        n[i] = t10[i].reduce((o, s) => {
          if (s) {
            const a = e(s);
            a !== "" && o.push(a), r && r[s] && o.push(r[s]);
          }
          return o;
        }, []).join(" ");
      }
    ), n;
  }
  const hp = (t10) => t10, k4 = () => {
    let t10 = hp;
    return {
      configure(e) {
        t10 = e;
      },
      generate(e) {
        return t10(e);
      },
      reset() {
        t10 = hp;
      }
    };
  }, C4 = k4(), jg = C4, T4 = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    readOnly: "readOnly",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    required: "required",
    selected: "selected"
  };
  function Zo(t10, e, r = "Mui") {
    const n = T4[e];
    return n ? `${r}-${n}` : `${jg.generate(t10)}-${e}`;
  }
  function sf(t10, e, r = "Mui") {
    const n = {};
    return e.forEach((i) => {
      n[i] = Zo(t10, i, r);
    }), n;
  }
  function Nt() {
    return Nt = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, Nt.apply(this, arguments);
  }
  function O4(t10) {
    return typeof t10 == "string";
  }
  function fo(t10, e, r) {
    return t10 === void 0 || O4(t10) ? e : Nt({}, e, {
      ownerState: Nt({}, e.ownerState, r)
    });
  }
  var Ca = {}, I4 = {
    get exports() {
      return Ca;
    },
    set exports(t10) {
      Ca = t10;
    }
  }, ri = {};
  /** @license React v17.0.2
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var pp;
  function P4() {
    if (pp)
      return ri;
    pp = 1, tf();
    var t10 = K, e = 60103;
    if (ri.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
      var r = Symbol.for;
      e = r("react.element"), ri.Fragment = r("react.fragment");
    }
    var n = t10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, o = { key: true, ref: true, __self: true, __source: true };
    function s(a, l, c) {
      var u, f = {}, d = null, h = null;
      c !== void 0 && (d = "" + c), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
      for (u in l)
        i.call(l, u) && !o.hasOwnProperty(u) && (f[u] = l[u]);
      if (a && a.defaultProps)
        for (u in l = a.defaultProps, l)
          f[u] === void 0 && (f[u] = l[u]);
      return { $$typeof: e, type: a, key: d, ref: h, props: f, _owner: n.current };
    }
    return ri.jsx = s, ri.jsxs = s, ri;
  }
  var mc = {};
  /** @license React v17.0.2
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var gp;
  function R4() {
    return gp || (gp = 1, function(t10) {
      define_process_env_default.NODE_ENV !== "production" && function() {
        var e = K, r = tf(), n = 60103, i = 60106;
        t10.Fragment = 60107;
        var o = 60108, s = 60114, a = 60109, l = 60110, c = 60112, u = 60113, f = 60120, d = 60115, h = 60116, g = 60121, p = 60122, y = 60117, b = 60129, x = 60131;
        if (typeof Symbol == "function" && Symbol.for) {
          var S = Symbol.for;
          n = S("react.element"), i = S("react.portal"), t10.Fragment = S("react.fragment"), o = S("react.strict_mode"), s = S("react.profiler"), a = S("react.provider"), l = S("react.context"), c = S("react.forward_ref"), u = S("react.suspense"), f = S("react.suspense_list"), d = S("react.memo"), h = S("react.lazy"), g = S("react.block"), p = S("react.server.block"), y = S("react.fundamental"), S("react.scope"), S("react.opaque.id"), b = S("react.debug_trace_mode"), S("react.offscreen"), x = S("react.legacy_hidden");
        }
        var O = typeof Symbol == "function" && Symbol.iterator, _ = "@@iterator";
        function L(Y) {
          if (Y === null || typeof Y != "object")
            return null;
          var ge = O && Y[O] || Y[_];
          return typeof ge == "function" ? ge : null;
        }
        var N = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function j(Y) {
          {
            for (var ge = arguments.length, be = new Array(ge > 1 ? ge - 1 : 0), xe = 1; xe < ge; xe++)
              be[xe - 1] = arguments[xe];
            W("error", Y, be);
          }
        }
        function W(Y, ge, be) {
          {
            var xe = N.ReactDebugCurrentFrame, je = xe.getStackAddendum();
            je !== "" && (ge += "%s", be = be.concat([je]));
            var Ze = be.map(function(Pe) {
              return "" + Pe;
            });
            Ze.unshift("Warning: " + ge), Function.prototype.apply.call(console[Y], console, Ze);
          }
        }
        var G = false;
        function ee(Y) {
          return !!(typeof Y == "string" || typeof Y == "function" || Y === t10.Fragment || Y === s || Y === b || Y === o || Y === u || Y === f || Y === x || G || typeof Y == "object" && Y !== null && (Y.$$typeof === h || Y.$$typeof === d || Y.$$typeof === a || Y.$$typeof === l || Y.$$typeof === c || Y.$$typeof === y || Y.$$typeof === g || Y[0] === p));
        }
        function fe(Y, ge, be) {
          var xe = ge.displayName || ge.name || "";
          return Y.displayName || (xe !== "" ? be + "(" + xe + ")" : be);
        }
        function P10(Y) {
          return Y.displayName || "Context";
        }
        function z10(Y) {
          if (Y == null)
            return null;
          if (typeof Y.tag == "number" && j("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof Y == "function")
            return Y.displayName || Y.name || null;
          if (typeof Y == "string")
            return Y;
          switch (Y) {
            case t10.Fragment:
              return "Fragment";
            case i:
              return "Portal";
            case s:
              return "Profiler";
            case o:
              return "StrictMode";
            case u:
              return "Suspense";
            case f:
              return "SuspenseList";
          }
          if (typeof Y == "object")
            switch (Y.$$typeof) {
              case l:
                var ge = Y;
                return P10(ge) + ".Consumer";
              case a:
                var be = Y;
                return P10(be._context) + ".Provider";
              case c:
                return fe(Y, Y.render, "ForwardRef");
              case d:
                return z10(Y.type);
              case g:
                return z10(Y._render);
              case h: {
                var xe = Y, je = xe._payload, Ze = xe._init;
                try {
                  return z10(Ze(je));
                } catch {
                  return null;
                }
              }
            }
          return null;
        }
        var U = 0, I, V, te, X, H, $, se;
        function he() {
        }
        he.__reactDisabledLog = true;
        function pe() {
          {
            if (U === 0) {
              I = console.log, V = console.info, te = console.warn, X = console.error, H = console.group, $ = console.groupCollapsed, se = console.groupEnd;
              var Y = {
                configurable: true,
                enumerable: true,
                value: he,
                writable: true
              };
              Object.defineProperties(console, {
                info: Y,
                log: Y,
                warn: Y,
                error: Y,
                group: Y,
                groupCollapsed: Y,
                groupEnd: Y
              });
            }
            U++;
          }
        }
        function me() {
          {
            if (U--, U === 0) {
              var Y = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: r({}, Y, {
                  value: I
                }),
                info: r({}, Y, {
                  value: V
                }),
                warn: r({}, Y, {
                  value: te
                }),
                error: r({}, Y, {
                  value: X
                }),
                group: r({}, Y, {
                  value: H
                }),
                groupCollapsed: r({}, Y, {
                  value: $
                }),
                groupEnd: r({}, Y, {
                  value: se
                })
              });
            }
            U < 0 && j("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
        var B = N.ReactCurrentDispatcher, q;
        function Z(Y, ge, be) {
          {
            if (q === void 0)
              try {
                throw Error();
              } catch (je) {
                var xe = je.stack.trim().match(/\n( *(at )?)/);
                q = xe && xe[1] || "";
              }
            return `
` + q + Y;
          }
        }
        var oe = false, de;
        {
          var R = typeof WeakMap == "function" ? WeakMap : Map;
          de = new R();
        }
        function k(Y, ge) {
          if (!Y || oe)
            return "";
          {
            var be = de.get(Y);
            if (be !== void 0)
              return be;
          }
          var xe;
          oe = true;
          var je = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var Ze;
          Ze = B.current, B.current = null, pe();
          try {
            if (ge) {
              var Pe = function() {
                throw Error();
              };
              if (Object.defineProperty(Pe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Pe, []);
                } catch (cr) {
                  xe = cr;
                }
                Reflect.construct(Y, [], Pe);
              } else {
                try {
                  Pe.call();
                } catch (cr) {
                  xe = cr;
                }
                Y.call(Pe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (cr) {
                xe = cr;
              }
              Y();
            }
          } catch (cr) {
            if (cr && xe && typeof cr.stack == "string") {
              for (var Re = cr.stack.split(`
`), At = xe.stack.split(`
`), lt = Re.length - 1, ut = At.length - 1; lt >= 1 && ut >= 0 && Re[lt] !== At[ut]; )
                ut--;
              for (; lt >= 1 && ut >= 0; lt--, ut--)
                if (Re[lt] !== At[ut]) {
                  if (lt !== 1 || ut !== 1)
                    do
                      if (lt--, ut--, ut < 0 || Re[lt] !== At[ut]) {
                        var Zt = `
` + Re[lt].replace(" at new ", " at ");
                        return typeof Y == "function" && de.set(Y, Zt), Zt;
                      }
                    while (lt >= 1 && ut >= 0);
                  break;
                }
            }
          } finally {
            oe = false, B.current = Ze, me(), Error.prepareStackTrace = je;
          }
          var Gr = Y ? Y.displayName || Y.name : "", us = Gr ? Z(Gr) : "";
          return typeof Y == "function" && de.set(Y, us), us;
        }
        function re(Y, ge, be) {
          return k(Y, false);
        }
        function ne(Y) {
          var ge = Y.prototype;
          return !!(ge && ge.isReactComponent);
        }
        function Ae(Y, ge, be) {
          if (Y == null)
            return "";
          if (typeof Y == "function")
            return k(Y, ne(Y));
          if (typeof Y == "string")
            return Z(Y);
          switch (Y) {
            case u:
              return Z("Suspense");
            case f:
              return Z("SuspenseList");
          }
          if (typeof Y == "object")
            switch (Y.$$typeof) {
              case c:
                return re(Y.render);
              case d:
                return Ae(Y.type, ge, be);
              case g:
                return re(Y._render);
              case h: {
                var xe = Y, je = xe._payload, Ze = xe._init;
                try {
                  return Ae(Ze(je), ge, be);
                } catch {
                }
              }
            }
          return "";
        }
        var C = {}, v = N.ReactDebugCurrentFrame;
        function w(Y) {
          if (Y) {
            var ge = Y._owner, be = Ae(Y.type, Y._source, ge ? ge.type : null);
            v.setExtraStackFrame(be);
          } else
            v.setExtraStackFrame(null);
        }
        function D(Y, ge, be, xe, je) {
          {
            var Ze = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var Pe in Y)
              if (Ze(Y, Pe)) {
                var Re = void 0;
                try {
                  if (typeof Y[Pe] != "function") {
                    var At = Error((xe || "React class") + ": " + be + " type `" + Pe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Y[Pe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    throw At.name = "Invariant Violation", At;
                  }
                  Re = Y[Pe](ge, Pe, xe, be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (lt) {
                  Re = lt;
                }
                Re && !(Re instanceof Error) && (w(je), j("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xe || "React class", be, Pe, typeof Re), w(null)), Re instanceof Error && !(Re.message in C) && (C[Re.message] = true, w(je), j("Failed %s type: %s", be, Re.message), w(null));
              }
          }
        }
        var J = N.ReactCurrentOwner, ae = Object.prototype.hasOwnProperty, ue = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        }, Se, _e, we;
        we = {};
        function Ne(Y) {
          if (ae.call(Y, "ref")) {
            var ge = Object.getOwnPropertyDescriptor(Y, "ref").get;
            if (ge && ge.isReactWarning)
              return false;
          }
          return Y.ref !== void 0;
        }
        function E(Y) {
          if (ae.call(Y, "key")) {
            var ge = Object.getOwnPropertyDescriptor(Y, "key").get;
            if (ge && ge.isReactWarning)
              return false;
          }
          return Y.key !== void 0;
        }
        function m(Y, ge) {
          if (typeof Y.ref == "string" && J.current && ge && J.current.stateNode !== ge) {
            var be = z10(J.current.type);
            we[be] || (j('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z10(J.current.type), Y.ref), we[be] = true);
          }
        }
        function A(Y, ge) {
          {
            var be = function() {
              Se || (Se = true, j("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
            };
            be.isReactWarning = true, Object.defineProperty(Y, "key", {
              get: be,
              configurable: true
            });
          }
        }
        function M(Y, ge) {
          {
            var be = function() {
              _e || (_e = true, j("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
            };
            be.isReactWarning = true, Object.defineProperty(Y, "ref", {
              get: be,
              configurable: true
            });
          }
        }
        var Q = function(Y, ge, be, xe, je, Ze, Pe) {
          var Re = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: n,
            // Built-in properties that belong on the element
            type: Y,
            key: ge,
            ref: be,
            props: Pe,
            // Record the component responsible for creating this element.
            _owner: Ze
          };
          return Re._store = {}, Object.defineProperty(Re._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          }), Object.defineProperty(Re, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: xe
          }), Object.defineProperty(Re, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: je
          }), Object.freeze && (Object.freeze(Re.props), Object.freeze(Re)), Re;
        };
        function ie(Y, ge, be, xe, je) {
          {
            var Ze, Pe = {}, Re = null, At = null;
            be !== void 0 && (Re = "" + be), E(ge) && (Re = "" + ge.key), Ne(ge) && (At = ge.ref, m(ge, je));
            for (Ze in ge)
              ae.call(ge, Ze) && !ue.hasOwnProperty(Ze) && (Pe[Ze] = ge[Ze]);
            if (Y && Y.defaultProps) {
              var lt = Y.defaultProps;
              for (Ze in lt)
                Pe[Ze] === void 0 && (Pe[Ze] = lt[Ze]);
            }
            if (Re || At) {
              var ut = typeof Y == "function" ? Y.displayName || Y.name || "Unknown" : Y;
              Re && A(Pe, ut), At && M(Pe, ut);
            }
            return Q(Y, Re, At, je, xe, J.current, Pe);
          }
        }
        var le = N.ReactCurrentOwner, Ee = N.ReactDebugCurrentFrame;
        function Fe(Y) {
          if (Y) {
            var ge = Y._owner, be = Ae(Y.type, Y._source, ge ? ge.type : null);
            Ee.setExtraStackFrame(be);
          } else
            Ee.setExtraStackFrame(null);
        }
        var Ve;
        Ve = false;
        function Ge(Y) {
          return typeof Y == "object" && Y !== null && Y.$$typeof === n;
        }
        function Ue() {
          {
            if (le.current) {
              var Y = z10(le.current.type);
              if (Y)
                return `

Check the render method of \`` + Y + "`.";
            }
            return "";
          }
        }
        function bl(Y) {
          {
            return "";
          }
        }
        var ss = {};
        function as(Y) {
          {
            var ge = Ue();
            if (!ge) {
              var be = typeof Y == "string" ? Y : Y.displayName || Y.name;
              be && (ge = `

Check the top-level render call using <` + be + ">.");
            }
            return ge;
          }
        }
        function Fi(Y, ge) {
          {
            if (!Y._store || Y._store.validated || Y.key != null)
              return;
            Y._store.validated = true;
            var be = as(ge);
            if (ss[be])
              return;
            ss[be] = true;
            var xe = "";
            Y && Y._owner && Y._owner !== le.current && (xe = " It was passed a child from " + z10(Y._owner.type) + "."), Fe(Y), j('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', be, xe), Fe(null);
          }
        }
        function ji(Y, ge) {
          {
            if (typeof Y != "object")
              return;
            if (Array.isArray(Y))
              for (var be = 0; be < Y.length; be++) {
                var xe = Y[be];
                Ge(xe) && Fi(xe, ge);
              }
            else if (Ge(Y))
              Y._store && (Y._store.validated = true);
            else if (Y) {
              var je = L(Y);
              if (typeof je == "function" && je !== Y.entries)
                for (var Ze = je.call(Y), Pe; !(Pe = Ze.next()).done; )
                  Ge(Pe.value) && Fi(Pe.value, ge);
            }
          }
        }
        function ls(Y) {
          {
            var ge = Y.type;
            if (ge == null || typeof ge == "string")
              return;
            var be;
            if (typeof ge == "function")
              be = ge.propTypes;
            else if (typeof ge == "object" && (ge.$$typeof === c || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            ge.$$typeof === d))
              be = ge.propTypes;
            else
              return;
            if (be) {
              var xe = z10(ge);
              D(be, Y.props, "prop", xe, Y);
            } else if (ge.PropTypes !== void 0 && !Ve) {
              Ve = true;
              var je = z10(ge);
              j("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", je || "Unknown");
            }
            typeof ge.getDefaultProps == "function" && !ge.getDefaultProps.isReactClassApproved && j("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
        function cs(Y) {
          {
            for (var ge = Object.keys(Y.props), be = 0; be < ge.length; be++) {
              var xe = ge[be];
              if (xe !== "children" && xe !== "key") {
                Fe(Y), j("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xe), Fe(null);
                break;
              }
            }
            Y.ref !== null && (Fe(Y), j("Invalid attribute `ref` supplied to `React.Fragment`."), Fe(null));
          }
        }
        function Wi(Y, ge, be, xe, je, Ze) {
          {
            var Pe = ee(Y);
            if (!Pe) {
              var Re = "";
              (Y === void 0 || typeof Y == "object" && Y !== null && Object.keys(Y).length === 0) && (Re += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var At = bl();
              At ? Re += At : Re += Ue();
              var lt;
              Y === null ? lt = "null" : Array.isArray(Y) ? lt = "array" : Y !== void 0 && Y.$$typeof === n ? (lt = "<" + (z10(Y.type) || "Unknown") + " />", Re = " Did you accidentally export a JSX literal instead of a component?") : lt = typeof Y, j("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", lt, Re);
            }
            var ut = ie(Y, ge, be, je, Ze);
            if (ut == null)
              return ut;
            if (Pe) {
              var Zt = ge.children;
              if (Zt !== void 0)
                if (xe)
                  if (Array.isArray(Zt)) {
                    for (var Gr = 0; Gr < Zt.length; Gr++)
                      ji(Zt[Gr], Y);
                    Object.freeze && Object.freeze(Zt);
                  } else
                    j("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                else
                  ji(Zt, Y);
            }
            return Y === t10.Fragment ? cs(ut) : ls(ut), ut;
          }
        }
        function vl(Y, ge, be) {
          return Wi(Y, ge, be, true);
        }
        function Al(Y, ge, be) {
          return Wi(Y, ge, be, false);
        }
        var wl = Al, Ui = vl;
        t10.jsx = wl, t10.jsxs = Ui;
      }();
    }(mc)), mc;
  }
  var mp;
  function Wg() {
    return mp || (mp = 1, function(t10) {
      define_process_env_default.NODE_ENV === "production" ? t10.exports = P4() : t10.exports = R4();
    }(I4)), Ca;
  }
  var Lt = Wg();
  const D4 = {
    disableDefaultClasses: false
  }, M4 = /* @__PURE__ */ reactExports.createContext(D4);
  function N4(t10) {
    const {
      disableDefaultClasses: e
    } = reactExports.useContext(M4);
    return (r) => e ? "" : t10(r);
  }
  function L4(t10, e = []) {
    if (t10 === void 0)
      return {};
    const r = {};
    return Object.keys(t10).filter((n) => n.match(/^on[A-Z]/) && typeof t10[n] == "function" && !e.includes(n)).forEach((n) => {
      r[n] = t10[n];
    }), r;
  }
  function B4(t10, e) {
    return typeof t10 == "function" ? t10(e) : t10;
  }
  function af(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function Ug(t10) {
    var e, r, n = "";
    if (typeof t10 == "string" || typeof t10 == "number")
      n += t10;
    else if (typeof t10 == "object")
      if (Array.isArray(t10))
        for (e = 0; e < t10.length; e++)
          t10[e] && (r = Ug(t10[e])) && (n && (n += " "), n += r);
      else
        for (e in t10)
          t10[e] && (n && (n += " "), n += e);
    return n;
  }
  function yp() {
    for (var t10, e, r = 0, n = ""; r < arguments.length; )
      (t10 = arguments[r++]) && (e = Ug(t10)) && (n && (n += " "), n += e);
    return n;
  }
  function bp(t10) {
    if (t10 === void 0)
      return {};
    const e = {};
    return Object.keys(t10).filter((r) => !(r.match(/^on[A-Z]/) && typeof t10[r] == "function")).forEach((r) => {
      e[r] = t10[r];
    }), e;
  }
  function F4(t10) {
    const {
      getSlotProps: e,
      additionalProps: r,
      externalSlotProps: n,
      externalForwardedProps: i,
      className: o
    } = t10;
    if (!e) {
      const h = yp(i == null ? void 0 : i.className, n == null ? void 0 : n.className, o, r == null ? void 0 : r.className), g = Nt({}, r == null ? void 0 : r.style, i == null ? void 0 : i.style, n == null ? void 0 : n.style), p = Nt({}, r, i, n);
      return h.length > 0 && (p.className = h), Object.keys(g).length > 0 && (p.style = g), {
        props: p,
        internalRef: void 0
      };
    }
    const s = L4(Nt({}, i, n)), a = bp(n), l = bp(i), c = e(s), u = yp(c == null ? void 0 : c.className, r == null ? void 0 : r.className, o, i == null ? void 0 : i.className, n == null ? void 0 : n.className), f = Nt({}, c == null ? void 0 : c.style, r == null ? void 0 : r.style, i == null ? void 0 : i.style, n == null ? void 0 : n.style), d = Nt({}, c, r, l, a);
    return u.length > 0 && (d.className = u), Object.keys(f).length > 0 && (d.style = f), {
      props: d,
      internalRef: c.ref
    };
  }
  const j4 = ["elementType", "externalSlotProps", "ownerState"];
  function W4(t10) {
    var e;
    const {
      elementType: r,
      externalSlotProps: n,
      ownerState: i
    } = t10, o = af(t10, j4), s = B4(n, i), {
      props: a,
      internalRef: l
    } = F4(Nt({}, o, {
      externalSlotProps: s
    })), c = Xn(l, s == null ? void 0 : s.ref, (e = t10.additionalProps) == null ? void 0 : e.ref);
    return fo(r, Nt({}, a, {
      ref: c
    }), i);
  }
  var Ut = "top", sr = "bottom", ar = "right", zt = "left", $a = "auto", $o = [Ut, sr, ar, zt], Ii = "start", jo = "end", U4 = "clippingParents", zg = "viewport", Zi = "popper", z4 = "reference", vp = /* @__PURE__ */ $o.reduce(function(t10, e) {
    return t10.concat([e + "-" + Ii, e + "-" + jo]);
  }, []), Vg = /* @__PURE__ */ [].concat($o, [$a]).reduce(function(t10, e) {
    return t10.concat([e, e + "-" + Ii, e + "-" + jo]);
  }, []), V4 = "beforeRead", q4 = "read", H4 = "afterRead", Y4 = "beforeMain", K4 = "main", X4 = "afterMain", J4 = "beforeWrite", Q4 = "write", G4 = "afterWrite", nu = [V4, q4, H4, Y4, K4, X4, J4, Q4, G4];
  function Or(t10) {
    return t10 ? (t10.nodeName || "").toLowerCase() : null;
  }
  function Qt(t10) {
    if (t10 == null)
      return window;
    if (t10.toString() !== "[object Window]") {
      var e = t10.ownerDocument;
      return e && e.defaultView || window;
    }
    return t10;
  }
  function Jn(t10) {
    var e = Qt(t10).Element;
    return t10 instanceof e || t10 instanceof Element;
  }
  function Xt(t10) {
    var e = Qt(t10).HTMLElement;
    return t10 instanceof e || t10 instanceof HTMLElement;
  }
  function lf(t10) {
    if (typeof ShadowRoot > "u")
      return false;
    var e = Qt(t10).ShadowRoot;
    return t10 instanceof e || t10 instanceof ShadowRoot;
  }
  function Z4(t10) {
    var e = t10.state;
    Object.keys(e.elements).forEach(function(r) {
      var n = e.styles[r] || {}, i = e.attributes[r] || {}, o = e.elements[r];
      !Xt(o) || !Or(o) || (Object.assign(o.style, n), Object.keys(i).forEach(function(s) {
        var a = i[s];
        a === false ? o.removeAttribute(s) : o.setAttribute(s, a === true ? "" : a);
      }));
    });
  }
  function $4(t10) {
    var e = t10.state, r = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow), function() {
      Object.keys(e.elements).forEach(function(n) {
        var i = e.elements[n], o = e.attributes[n] || {}, s = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]), a = s.reduce(function(l, c) {
          return l[c] = "", l;
        }, {});
        !Xt(i) || !Or(i) || (Object.assign(i.style, a), Object.keys(o).forEach(function(l) {
          i.removeAttribute(l);
        }));
      });
    };
  }
  const ex = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: Z4,
    effect: $4,
    requires: ["computeStyles"]
  };
  function yr(t10) {
    return t10.split("-")[0];
  }
  var Wn = Math.max, Ta = Math.min, Pi = Math.round;
  function iu() {
    var t10 = navigator.userAgentData;
    return t10 != null && t10.brands && Array.isArray(t10.brands) ? t10.brands.map(function(e) {
      return e.brand + "/" + e.version;
    }).join(" ") : navigator.userAgent;
  }
  function qg() {
    return !/^((?!chrome|android).)*safari/i.test(iu());
  }
  function Ri(t10, e, r) {
    e === void 0 && (e = false), r === void 0 && (r = false);
    var n = t10.getBoundingClientRect(), i = 1, o = 1;
    e && Xt(t10) && (i = t10.offsetWidth > 0 && Pi(n.width) / t10.offsetWidth || 1, o = t10.offsetHeight > 0 && Pi(n.height) / t10.offsetHeight || 1);
    var s = Jn(t10) ? Qt(t10) : window, a = s.visualViewport, l = !qg() && r, c = (n.left + (l && a ? a.offsetLeft : 0)) / i, u = (n.top + (l && a ? a.offsetTop : 0)) / o, f = n.width / i, d = n.height / o;
    return {
      width: f,
      height: d,
      top: u,
      right: c + f,
      bottom: u + d,
      left: c,
      x: c,
      y: u
    };
  }
  function cf(t10) {
    var e = Ri(t10), r = t10.offsetWidth, n = t10.offsetHeight;
    return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
      x: t10.offsetLeft,
      y: t10.offsetTop,
      width: r,
      height: n
    };
  }
  function Hg(t10, e) {
    var r = e.getRootNode && e.getRootNode();
    if (t10.contains(e))
      return true;
    if (r && lf(r)) {
      var n = e;
      do {
        if (n && t10.isSameNode(n))
          return true;
        n = n.parentNode || n.host;
      } while (n);
    }
    return false;
  }
  function br(t10) {
    return Qt(t10).getComputedStyle(t10);
  }
  function tx(t10) {
    return ["table", "td", "th"].indexOf(Or(t10)) >= 0;
  }
  function wn(t10) {
    return ((Jn(t10) ? t10.ownerDocument : (
      // $FlowFixMe[prop-missing]
      t10.document
    )) || window.document).documentElement;
  }
  function el(t10) {
    return Or(t10) === "html" ? t10 : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      t10.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      t10.parentNode || // DOM Element detected
      (lf(t10) ? t10.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      wn(t10)
    );
  }
  function Ap(t10) {
    return !Xt(t10) || // https://github.com/popperjs/popper-core/issues/837
    br(t10).position === "fixed" ? null : t10.offsetParent;
  }
  function rx(t10) {
    var e = /firefox/i.test(iu()), r = /Trident/i.test(iu());
    if (r && Xt(t10)) {
      var n = br(t10);
      if (n.position === "fixed")
        return null;
    }
    var i = el(t10);
    for (lf(i) && (i = i.host); Xt(i) && ["html", "body"].indexOf(Or(i)) < 0; ) {
      var o = br(i);
      if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
        return i;
      i = i.parentNode;
    }
    return null;
  }
  function es(t10) {
    for (var e = Qt(t10), r = Ap(t10); r && tx(r) && br(r).position === "static"; )
      r = Ap(r);
    return r && (Or(r) === "html" || Or(r) === "body" && br(r).position === "static") ? e : r || rx(t10) || e;
  }
  function uf(t10) {
    return ["top", "bottom"].indexOf(t10) >= 0 ? "x" : "y";
  }
  function wo(t10, e, r) {
    return Wn(t10, Ta(e, r));
  }
  function nx(t10, e, r) {
    var n = wo(t10, e, r);
    return n > r ? r : n;
  }
  function Yg() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function Kg(t10) {
    return Object.assign({}, Yg(), t10);
  }
  function Xg(t10, e) {
    return e.reduce(function(r, n) {
      return r[n] = t10, r;
    }, {});
  }
  var ix = function(e, r) {
    return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
      placement: r.placement
    })) : e, Kg(typeof e != "number" ? e : Xg(e, $o));
  };
  function ox(t10) {
    var e, r = t10.state, n = t10.name, i = t10.options, o = r.elements.arrow, s = r.modifiersData.popperOffsets, a = yr(r.placement), l = uf(a), c = [zt, ar].indexOf(a) >= 0, u = c ? "height" : "width";
    if (!(!o || !s)) {
      var f = ix(i.padding, r), d = cf(o), h = l === "y" ? Ut : zt, g = l === "y" ? sr : ar, p = r.rects.reference[u] + r.rects.reference[l] - s[l] - r.rects.popper[u], y = s[l] - r.rects.reference[l], b = es(o), x = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, S = p / 2 - y / 2, O = f[h], _ = x - d[u] - f[g], L = x / 2 - d[u] / 2 + S, N = wo(O, L, _), j = l;
      r.modifiersData[n] = (e = {}, e[j] = N, e.centerOffset = N - L, e);
    }
  }
  function sx(t10) {
    var e = t10.state, r = t10.options, n = r.element, i = n === void 0 ? "[data-popper-arrow]" : n;
    if (i != null && !(typeof i == "string" && (i = e.elements.popper.querySelector(i), !i))) {
      if (define_process_env_default.NODE_ENV !== "production" && (Xt(i) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Hg(e.elements.popper, i)) {
        define_process_env_default.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
        return;
      }
      e.elements.arrow = i;
    }
  }
  const ax = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: ox,
    effect: sx,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Di(t10) {
    return t10.split("-")[1];
  }
  var lx = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function cx(t10, e) {
    var r = t10.x, n = t10.y, i = e.devicePixelRatio || 1;
    return {
      x: Pi(r * i) / i || 0,
      y: Pi(n * i) / i || 0
    };
  }
  function wp(t10) {
    var e, r = t10.popper, n = t10.popperRect, i = t10.placement, o = t10.variation, s = t10.offsets, a = t10.position, l = t10.gpuAcceleration, c = t10.adaptive, u = t10.roundOffsets, f = t10.isFixed, d = s.x, h = d === void 0 ? 0 : d, g = s.y, p = g === void 0 ? 0 : g, y = typeof u == "function" ? u({
      x: h,
      y: p
    }) : {
      x: h,
      y: p
    };
    h = y.x, p = y.y;
    var b = s.hasOwnProperty("x"), x = s.hasOwnProperty("y"), S = zt, O = Ut, _ = window;
    if (c) {
      var L = es(r), N = "clientHeight", j = "clientWidth";
      if (L === Qt(r) && (L = wn(r), br(L).position !== "static" && a === "absolute" && (N = "scrollHeight", j = "scrollWidth")), L = L, i === Ut || (i === zt || i === ar) && o === jo) {
        O = sr;
        var W = f && L === _ && _.visualViewport ? _.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          L[N]
        );
        p -= W - n.height, p *= l ? 1 : -1;
      }
      if (i === zt || (i === Ut || i === sr) && o === jo) {
        S = ar;
        var G = f && L === _ && _.visualViewport ? _.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          L[j]
        );
        h -= G - n.width, h *= l ? 1 : -1;
      }
    }
    var ee = Object.assign({
      position: a
    }, c && lx), fe = u === true ? cx({
      x: h,
      y: p
    }, Qt(r)) : {
      x: h,
      y: p
    };
    if (h = fe.x, p = fe.y, l) {
      var P10;
      return Object.assign({}, ee, (P10 = {}, P10[O] = x ? "0" : "", P10[S] = b ? "0" : "", P10.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + p + "px)" : "translate3d(" + h + "px, " + p + "px, 0)", P10));
    }
    return Object.assign({}, ee, (e = {}, e[O] = x ? p + "px" : "", e[S] = b ? h + "px" : "", e.transform = "", e));
  }
  function ux(t10) {
    var e = t10.state, r = t10.options, n = r.gpuAcceleration, i = n === void 0 ? true : n, o = r.adaptive, s = o === void 0 ? true : o, a = r.roundOffsets, l = a === void 0 ? true : a;
    if (define_process_env_default.NODE_ENV !== "production") {
      var c = br(e.elements.popper).transitionProperty || "";
      s && ["transform", "top", "right", "bottom", "left"].some(function(f) {
        return c.indexOf(f) >= 0;
      }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
    var u = {
      placement: yr(e.placement),
      variation: Di(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: i,
      isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, wp(Object.assign({}, u, {
      offsets: e.modifiersData.popperOffsets,
      position: e.options.strategy,
      adaptive: s,
      roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, wp(Object.assign({}, u, {
      offsets: e.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement
    });
  }
  const fx = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: ux,
    data: {}
  };
  var Rs = {
    passive: true
  };
  function dx(t10) {
    var e = t10.state, r = t10.instance, n = t10.options, i = n.scroll, o = i === void 0 ? true : i, s = n.resize, a = s === void 0 ? true : s, l = Qt(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return o && c.forEach(function(u) {
      u.addEventListener("scroll", r.update, Rs);
    }), a && l.addEventListener("resize", r.update, Rs), function() {
      o && c.forEach(function(u) {
        u.removeEventListener("scroll", r.update, Rs);
      }), a && l.removeEventListener("resize", r.update, Rs);
    };
  }
  const hx = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function() {
    },
    effect: dx,
    data: {}
  };
  var px = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Gs(t10) {
    return t10.replace(/left|right|bottom|top/g, function(e) {
      return px[e];
    });
  }
  var gx = {
    start: "end",
    end: "start"
  };
  function xp(t10) {
    return t10.replace(/start|end/g, function(e) {
      return gx[e];
    });
  }
  function ff(t10) {
    var e = Qt(t10), r = e.pageXOffset, n = e.pageYOffset;
    return {
      scrollLeft: r,
      scrollTop: n
    };
  }
  function df(t10) {
    return Ri(wn(t10)).left + ff(t10).scrollLeft;
  }
  function mx(t10, e) {
    var r = Qt(t10), n = wn(t10), i = r.visualViewport, o = n.clientWidth, s = n.clientHeight, a = 0, l = 0;
    if (i) {
      o = i.width, s = i.height;
      var c = qg();
      (c || !c && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
    }
    return {
      width: o,
      height: s,
      x: a + df(t10),
      y: l
    };
  }
  function yx(t10) {
    var e, r = wn(t10), n = ff(t10), i = (e = t10.ownerDocument) == null ? void 0 : e.body, o = Wn(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = Wn(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -n.scrollLeft + df(t10), l = -n.scrollTop;
    return br(i || r).direction === "rtl" && (a += Wn(r.clientWidth, i ? i.clientWidth : 0) - o), {
      width: o,
      height: s,
      x: a,
      y: l
    };
  }
  function hf(t10) {
    var e = br(t10), r = e.overflow, n = e.overflowX, i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(r + i + n);
  }
  function Jg(t10) {
    return ["html", "body", "#document"].indexOf(Or(t10)) >= 0 ? t10.ownerDocument.body : Xt(t10) && hf(t10) ? t10 : Jg(el(t10));
  }
  function xo(t10, e) {
    var r;
    e === void 0 && (e = []);
    var n = Jg(t10), i = n === ((r = t10.ownerDocument) == null ? void 0 : r.body), o = Qt(n), s = i ? [o].concat(o.visualViewport || [], hf(n) ? n : []) : n, a = e.concat(s);
    return i ? a : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      a.concat(xo(el(s)))
    );
  }
  function ou(t10) {
    return Object.assign({}, t10, {
      left: t10.x,
      top: t10.y,
      right: t10.x + t10.width,
      bottom: t10.y + t10.height
    });
  }
  function bx(t10, e) {
    var r = Ri(t10, false, e === "fixed");
    return r.top = r.top + t10.clientTop, r.left = r.left + t10.clientLeft, r.bottom = r.top + t10.clientHeight, r.right = r.left + t10.clientWidth, r.width = t10.clientWidth, r.height = t10.clientHeight, r.x = r.left, r.y = r.top, r;
  }
  function _p(t10, e, r) {
    return e === zg ? ou(mx(t10, r)) : Jn(e) ? bx(e, r) : ou(yx(wn(t10)));
  }
  function vx(t10) {
    var e = xo(el(t10)), r = ["absolute", "fixed"].indexOf(br(t10).position) >= 0, n = r && Xt(t10) ? es(t10) : t10;
    return Jn(n) ? e.filter(function(i) {
      return Jn(i) && Hg(i, n) && Or(i) !== "body";
    }) : [];
  }
  function Ax(t10, e, r, n) {
    var i = e === "clippingParents" ? vx(t10) : [].concat(e), o = [].concat(i, [r]), s = o[0], a = o.reduce(function(l, c) {
      var u = _p(t10, c, n);
      return l.top = Wn(u.top, l.top), l.right = Ta(u.right, l.right), l.bottom = Ta(u.bottom, l.bottom), l.left = Wn(u.left, l.left), l;
    }, _p(t10, s, n));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function Qg(t10) {
    var e = t10.reference, r = t10.element, n = t10.placement, i = n ? yr(n) : null, o = n ? Di(n) : null, s = e.x + e.width / 2 - r.width / 2, a = e.y + e.height / 2 - r.height / 2, l;
    switch (i) {
      case Ut:
        l = {
          x: s,
          y: e.y - r.height
        };
        break;
      case sr:
        l = {
          x: s,
          y: e.y + e.height
        };
        break;
      case ar:
        l = {
          x: e.x + e.width,
          y: a
        };
        break;
      case zt:
        l = {
          x: e.x - r.width,
          y: a
        };
        break;
      default:
        l = {
          x: e.x,
          y: e.y
        };
    }
    var c = i ? uf(i) : null;
    if (c != null) {
      var u = c === "y" ? "height" : "width";
      switch (o) {
        case Ii:
          l[c] = l[c] - (e[u] / 2 - r[u] / 2);
          break;
        case jo:
          l[c] = l[c] + (e[u] / 2 - r[u] / 2);
          break;
      }
    }
    return l;
  }
  function Wo(t10, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = n === void 0 ? t10.placement : n, o = r.strategy, s = o === void 0 ? t10.strategy : o, a = r.boundary, l = a === void 0 ? U4 : a, c = r.rootBoundary, u = c === void 0 ? zg : c, f = r.elementContext, d = f === void 0 ? Zi : f, h = r.altBoundary, g = h === void 0 ? false : h, p = r.padding, y = p === void 0 ? 0 : p, b = Kg(typeof y != "number" ? y : Xg(y, $o)), x = d === Zi ? z4 : Zi, S = t10.rects.popper, O = t10.elements[g ? x : d], _ = Ax(Jn(O) ? O : O.contextElement || wn(t10.elements.popper), l, u, s), L = Ri(t10.elements.reference), N = Qg({
      reference: L,
      element: S,
      strategy: "absolute",
      placement: i
    }), j = ou(Object.assign({}, S, N)), W = d === Zi ? j : L, G = {
      top: _.top - W.top + b.top,
      bottom: W.bottom - _.bottom + b.bottom,
      left: _.left - W.left + b.left,
      right: W.right - _.right + b.right
    }, ee = t10.modifiersData.offset;
    if (d === Zi && ee) {
      var fe = ee[i];
      Object.keys(G).forEach(function(P10) {
        var z10 = [ar, sr].indexOf(P10) >= 0 ? 1 : -1, U = [Ut, sr].indexOf(P10) >= 0 ? "y" : "x";
        G[P10] += fe[U] * z10;
      });
    }
    return G;
  }
  function wx(t10, e) {
    e === void 0 && (e = {});
    var r = e, n = r.placement, i = r.boundary, o = r.rootBoundary, s = r.padding, a = r.flipVariations, l = r.allowedAutoPlacements, c = l === void 0 ? Vg : l, u = Di(n), f = u ? a ? vp : vp.filter(function(g) {
      return Di(g) === u;
    }) : $o, d = f.filter(function(g) {
      return c.indexOf(g) >= 0;
    });
    d.length === 0 && (d = f, define_process_env_default.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
    var h = d.reduce(function(g, p) {
      return g[p] = Wo(t10, {
        placement: p,
        boundary: i,
        rootBoundary: o,
        padding: s
      })[yr(p)], g;
    }, {});
    return Object.keys(h).sort(function(g, p) {
      return h[g] - h[p];
    });
  }
  function xx(t10) {
    if (yr(t10) === $a)
      return [];
    var e = Gs(t10);
    return [xp(t10), e, xp(e)];
  }
  function _x(t10) {
    var e = t10.state, r = t10.options, n = t10.name;
    if (!e.modifiersData[n]._skip) {
      for (var i = r.mainAxis, o = i === void 0 ? true : i, s = r.altAxis, a = s === void 0 ? true : s, l = r.fallbackPlacements, c = r.padding, u = r.boundary, f = r.rootBoundary, d = r.altBoundary, h = r.flipVariations, g = h === void 0 ? true : h, p = r.allowedAutoPlacements, y = e.options.placement, b = yr(y), x = b === y, S = l || (x || !g ? [Gs(y)] : xx(y)), O = [y].concat(S).reduce(function(pe, me) {
        return pe.concat(yr(me) === $a ? wx(e, {
          placement: me,
          boundary: u,
          rootBoundary: f,
          padding: c,
          flipVariations: g,
          allowedAutoPlacements: p
        }) : me);
      }, []), _ = e.rects.reference, L = e.rects.popper, N = /* @__PURE__ */ new Map(), j = true, W = O[0], G = 0; G < O.length; G++) {
        var ee = O[G], fe = yr(ee), P10 = Di(ee) === Ii, z10 = [Ut, sr].indexOf(fe) >= 0, U = z10 ? "width" : "height", I = Wo(e, {
          placement: ee,
          boundary: u,
          rootBoundary: f,
          altBoundary: d,
          padding: c
        }), V = z10 ? P10 ? ar : zt : P10 ? sr : Ut;
        _[U] > L[U] && (V = Gs(V));
        var te = Gs(V), X = [];
        if (o && X.push(I[fe] <= 0), a && X.push(I[V] <= 0, I[te] <= 0), X.every(function(pe) {
          return pe;
        })) {
          W = ee, j = false;
          break;
        }
        N.set(ee, X);
      }
      if (j)
        for (var H = g ? 3 : 1, $ = function(me) {
          var B = O.find(function(q) {
            var Z = N.get(q);
            if (Z)
              return Z.slice(0, me).every(function(oe) {
                return oe;
              });
          });
          if (B)
            return W = B, "break";
        }, se = H; se > 0; se--) {
          var he = $(se);
          if (he === "break")
            break;
        }
      e.placement !== W && (e.modifiersData[n]._skip = true, e.placement = W, e.reset = true);
    }
  }
  const Sx = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: _x,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function Sp(t10, e, r) {
    return r === void 0 && (r = {
      x: 0,
      y: 0
    }), {
      top: t10.top - e.height - r.y,
      right: t10.right - e.width + r.x,
      bottom: t10.bottom - e.height + r.y,
      left: t10.left - e.width - r.x
    };
  }
  function Ep(t10) {
    return [Ut, ar, sr, zt].some(function(e) {
      return t10[e] >= 0;
    });
  }
  function Ex(t10) {
    var e = t10.state, r = t10.name, n = e.rects.reference, i = e.rects.popper, o = e.modifiersData.preventOverflow, s = Wo(e, {
      elementContext: "reference"
    }), a = Wo(e, {
      altBoundary: true
    }), l = Sp(s, n), c = Sp(a, i, o), u = Ep(l), f = Ep(c);
    e.modifiersData[r] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c,
      isReferenceHidden: u,
      hasPopperEscaped: f
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": u,
      "data-popper-escaped": f
    });
  }
  const kx = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Ex
  };
  function Cx(t10, e, r) {
    var n = yr(t10), i = [zt, Ut].indexOf(n) >= 0 ? -1 : 1, o = typeof r == "function" ? r(Object.assign({}, e, {
      placement: t10
    })) : r, s = o[0], a = o[1];
    return s = s || 0, a = (a || 0) * i, [zt, ar].indexOf(n) >= 0 ? {
      x: a,
      y: s
    } : {
      x: s,
      y: a
    };
  }
  function Tx(t10) {
    var e = t10.state, r = t10.options, n = t10.name, i = r.offset, o = i === void 0 ? [0, 0] : i, s = Vg.reduce(function(u, f) {
      return u[f] = Cx(f, e.rects, o), u;
    }, {}), a = s[e.placement], l = a.x, c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = s;
  }
  const Ox = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Tx
  };
  function Ix(t10) {
    var e = t10.state, r = t10.name;
    e.modifiersData[r] = Qg({
      reference: e.rects.reference,
      element: e.rects.popper,
      strategy: "absolute",
      placement: e.placement
    });
  }
  const Px = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: Ix,
    data: {}
  };
  function Rx(t10) {
    return t10 === "x" ? "y" : "x";
  }
  function Dx(t10) {
    var e = t10.state, r = t10.options, n = t10.name, i = r.mainAxis, o = i === void 0 ? true : i, s = r.altAxis, a = s === void 0 ? false : s, l = r.boundary, c = r.rootBoundary, u = r.altBoundary, f = r.padding, d = r.tether, h = d === void 0 ? true : d, g = r.tetherOffset, p = g === void 0 ? 0 : g, y = Wo(e, {
      boundary: l,
      rootBoundary: c,
      padding: f,
      altBoundary: u
    }), b = yr(e.placement), x = Di(e.placement), S = !x, O = uf(b), _ = Rx(O), L = e.modifiersData.popperOffsets, N = e.rects.reference, j = e.rects.popper, W = typeof p == "function" ? p(Object.assign({}, e.rects, {
      placement: e.placement
    })) : p, G = typeof W == "number" ? {
      mainAxis: W,
      altAxis: W
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, W), ee = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, fe = {
      x: 0,
      y: 0
    };
    if (L) {
      if (o) {
        var P10, z10 = O === "y" ? Ut : zt, U = O === "y" ? sr : ar, I = O === "y" ? "height" : "width", V = L[O], te = V + y[z10], X = V - y[U], H = h ? -j[I] / 2 : 0, $ = x === Ii ? N[I] : j[I], se = x === Ii ? -j[I] : -N[I], he = e.elements.arrow, pe = h && he ? cf(he) : {
          width: 0,
          height: 0
        }, me = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Yg(), B = me[z10], q = me[U], Z = wo(0, N[I], pe[I]), oe = S ? N[I] / 2 - H - Z - B - G.mainAxis : $ - Z - B - G.mainAxis, de = S ? -N[I] / 2 + H + Z + q + G.mainAxis : se + Z + q + G.mainAxis, R = e.elements.arrow && es(e.elements.arrow), k = R ? O === "y" ? R.clientTop || 0 : R.clientLeft || 0 : 0, re = (P10 = ee == null ? void 0 : ee[O]) != null ? P10 : 0, ne = V + oe - re - k, Ae = V + de - re, C = wo(h ? Ta(te, ne) : te, V, h ? Wn(X, Ae) : X);
        L[O] = C, fe[O] = C - V;
      }
      if (a) {
        var v, w = O === "x" ? Ut : zt, D = O === "x" ? sr : ar, J = L[_], ae = _ === "y" ? "height" : "width", ue = J + y[w], Se = J - y[D], _e = [Ut, zt].indexOf(b) !== -1, we = (v = ee == null ? void 0 : ee[_]) != null ? v : 0, Ne = _e ? ue : J - N[ae] - j[ae] - we + G.altAxis, E = _e ? J + N[ae] + j[ae] - we - G.altAxis : Se, m = h && _e ? nx(Ne, J, E) : wo(h ? Ne : ue, J, h ? E : Se);
        L[_] = m, fe[_] = m - J;
      }
      e.modifiersData[n] = fe;
    }
  }
  const Mx = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: Dx,
    requiresIfExists: ["offset"]
  };
  function Nx(t10) {
    return {
      scrollLeft: t10.scrollLeft,
      scrollTop: t10.scrollTop
    };
  }
  function Lx(t10) {
    return t10 === Qt(t10) || !Xt(t10) ? ff(t10) : Nx(t10);
  }
  function Bx(t10) {
    var e = t10.getBoundingClientRect(), r = Pi(e.width) / t10.offsetWidth || 1, n = Pi(e.height) / t10.offsetHeight || 1;
    return r !== 1 || n !== 1;
  }
  function Fx(t10, e, r) {
    r === void 0 && (r = false);
    var n = Xt(e), i = Xt(e) && Bx(e), o = wn(e), s = Ri(t10, i, r), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, l = {
      x: 0,
      y: 0
    };
    return (n || !n && !r) && ((Or(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    hf(o)) && (a = Lx(e)), Xt(e) ? (l = Ri(e, true), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = df(o))), {
      x: s.left + a.scrollLeft - l.x,
      y: s.top + a.scrollTop - l.y,
      width: s.width,
      height: s.height
    };
  }
  function jx(t10) {
    var e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
    t10.forEach(function(o) {
      e.set(o.name, o);
    });
    function i(o) {
      r.add(o.name);
      var s = [].concat(o.requires || [], o.requiresIfExists || []);
      s.forEach(function(a) {
        if (!r.has(a)) {
          var l = e.get(a);
          l && i(l);
        }
      }), n.push(o);
    }
    return t10.forEach(function(o) {
      r.has(o.name) || i(o);
    }), n;
  }
  function Wx(t10) {
    var e = jx(t10);
    return nu.reduce(function(r, n) {
      return r.concat(e.filter(function(i) {
        return i.phase === n;
      }));
    }, []);
  }
  function Ux(t10) {
    var e;
    return function() {
      return e || (e = new Promise(function(r) {
        Promise.resolve().then(function() {
          e = void 0, r(t10());
        });
      })), e;
    };
  }
  function Zr(t10) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      r[n - 1] = arguments[n];
    return [].concat(r).reduce(function(i, o) {
      return i.replace(/%s/, o);
    }, t10);
  }
  var On = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', zx = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', kp = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function Vx(t10) {
    t10.forEach(function(e) {
      [].concat(Object.keys(e), kp).filter(function(r, n, i) {
        return i.indexOf(r) === n;
      }).forEach(function(r) {
        switch (r) {
          case "name":
            typeof e.name != "string" && console.error(Zr(On, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
            break;
          case "enabled":
            typeof e.enabled != "boolean" && console.error(Zr(On, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
            break;
          case "phase":
            nu.indexOf(e.phase) < 0 && console.error(Zr(On, e.name, '"phase"', "either " + nu.join(", "), '"' + String(e.phase) + '"'));
            break;
          case "fn":
            typeof e.fn != "function" && console.error(Zr(On, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
            break;
          case "effect":
            e.effect != null && typeof e.effect != "function" && console.error(Zr(On, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
            break;
          case "requires":
            e.requires != null && !Array.isArray(e.requires) && console.error(Zr(On, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
            break;
          case "requiresIfExists":
            Array.isArray(e.requiresIfExists) || console.error(Zr(On, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + kp.map(function(n) {
              return '"' + n + '"';
            }).join(", ") + '; but "' + r + '" was provided.');
        }
        e.requires && e.requires.forEach(function(n) {
          t10.find(function(i) {
            return i.name === n;
          }) == null && console.error(Zr(zx, String(e.name), n, n));
        });
      });
    });
  }
  function qx(t10, e) {
    var r = /* @__PURE__ */ new Set();
    return t10.filter(function(n) {
      var i = e(n);
      if (!r.has(i))
        return r.add(i), true;
    });
  }
  function Hx(t10) {
    var e = t10.reduce(function(r, n) {
      var i = r[n.name];
      return r[n.name] = i ? Object.assign({}, i, n, {
        options: Object.assign({}, i.options, n.options),
        data: Object.assign({}, i.data, n.data)
      }) : n, r;
    }, {});
    return Object.keys(e).map(function(r) {
      return e[r];
    });
  }
  var Cp = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", Yx = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", Tp = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Op() {
    for (var t10 = arguments.length, e = new Array(t10), r = 0; r < t10; r++)
      e[r] = arguments[r];
    return !e.some(function(n) {
      return !(n && typeof n.getBoundingClientRect == "function");
    });
  }
  function Kx(t10) {
    t10 === void 0 && (t10 = {});
    var e = t10, r = e.defaultModifiers, n = r === void 0 ? [] : r, i = e.defaultOptions, o = i === void 0 ? Tp : i;
    return function(a, l, c) {
      c === void 0 && (c = o);
      var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Tp, o),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l
        },
        attributes: {},
        styles: {}
      }, f = [], d = false, h = {
        state: u,
        setOptions: function(b) {
          var x = typeof b == "function" ? b(u.options) : b;
          p(), u.options = Object.assign({}, o, u.options, x), u.scrollParents = {
            reference: Jn(a) ? xo(a) : a.contextElement ? xo(a.contextElement) : [],
            popper: xo(l)
          };
          var S = Wx(Hx([].concat(n, u.options.modifiers)));
          if (u.orderedModifiers = S.filter(function(ee) {
            return ee.enabled;
          }), define_process_env_default.NODE_ENV !== "production") {
            var O = qx([].concat(S, u.options.modifiers), function(ee) {
              var fe = ee.name;
              return fe;
            });
            if (Vx(O), yr(u.options.placement) === $a) {
              var _ = u.orderedModifiers.find(function(ee) {
                var fe = ee.name;
                return fe === "flip";
              });
              _ || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
            var L = br(l), N = L.marginTop, j = L.marginRight, W = L.marginBottom, G = L.marginLeft;
            [N, j, W, G].some(function(ee) {
              return parseFloat(ee);
            }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
          return g(), h.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function() {
          if (!d) {
            var b = u.elements, x = b.reference, S = b.popper;
            if (!Op(x, S)) {
              define_process_env_default.NODE_ENV !== "production" && console.error(Cp);
              return;
            }
            u.rects = {
              reference: Fx(x, es(S), u.options.strategy === "fixed"),
              popper: cf(S)
            }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(ee) {
              return u.modifiersData[ee.name] = Object.assign({}, ee.data);
            });
            for (var O = 0, _ = 0; _ < u.orderedModifiers.length; _++) {
              if (define_process_env_default.NODE_ENV !== "production" && (O += 1, O > 100)) {
                console.error(Yx);
                break;
              }
              if (u.reset === true) {
                u.reset = false, _ = -1;
                continue;
              }
              var L = u.orderedModifiers[_], N = L.fn, j = L.options, W = j === void 0 ? {} : j, G = L.name;
              typeof N == "function" && (u = N({
                state: u,
                options: W,
                name: G,
                instance: h
              }) || u);
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: Ux(function() {
          return new Promise(function(y) {
            h.forceUpdate(), y(u);
          });
        }),
        destroy: function() {
          p(), d = true;
        }
      };
      if (!Op(a, l))
        return define_process_env_default.NODE_ENV !== "production" && console.error(Cp), h;
      h.setOptions(c).then(function(y) {
        !d && c.onFirstUpdate && c.onFirstUpdate(y);
      });
      function g() {
        u.orderedModifiers.forEach(function(y) {
          var b = y.name, x = y.options, S = x === void 0 ? {} : x, O = y.effect;
          if (typeof O == "function") {
            var _ = O({
              state: u,
              name: b,
              instance: h,
              options: S
            }), L = function() {
            };
            f.push(_ || L);
          }
        });
      }
      function p() {
        f.forEach(function(y) {
          return y();
        }), f = [];
      }
      return h;
    };
  }
  var Xx = [hx, Px, fx, ex, Ox, Sx, Mx, ax, kx], Jx = /* @__PURE__ */ Kx({
    defaultModifiers: Xx
  });
  function Qx(t10) {
    return typeof t10 == "function" ? t10() : t10;
  }
  const Oa = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      children: n,
      container: i,
      disablePortal: o = false
    } = e, [s, a] = reactExports.useState(null), l = Xn(/* @__PURE__ */ reactExports.isValidElement(n) ? n.ref : null, r);
    if (Oi(() => {
      o || a(Qx(i) || document.body);
    }, [i, o]), Oi(() => {
      if (s && !o)
        return ka(r, s), () => {
          ka(r, null);
        };
    }, [r, s, o]), o) {
      if (/* @__PURE__ */ reactExports.isValidElement(n)) {
        const c = {
          ref: l
        };
        return /* @__PURE__ */ reactExports.cloneElement(n, c);
      }
      return /* @__PURE__ */ Lt.jsx(reactExports.Fragment, {
        children: n
      });
    }
    return /* @__PURE__ */ Lt.jsx(reactExports.Fragment, {
      children: s && /* @__PURE__ */ reactDomExports.createPortal(n, s)
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (Oa.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The children to render into the `container`.
     */
    children: F.node,
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: F.oneOfType([Fo, F.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: F.bool
  });
  define_process_env_default.NODE_ENV !== "production" && (Oa["propTypes"] = n4(Oa.propTypes));
  const Gx = Oa;
  function Zx(t10) {
    return Zo("MuiPopper", t10);
  }
  sf("MuiPopper", ["root"]);
  const $x = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], e_ = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
  function t_(t10, e) {
    if (e === "ltr")
      return t10;
    switch (t10) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return t10;
    }
  }
  function Ia(t10) {
    return typeof t10 == "function" ? t10() : t10;
  }
  function tl(t10) {
    return t10.nodeType !== void 0;
  }
  function r_(t10) {
    return !tl(t10);
  }
  const n_ = () => of({
    root: ["root"]
  }, N4(Zx)), i_ = {}, o_ = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n;
    const {
      anchorEl: i,
      children: o,
      direction: s,
      disablePortal: a,
      modifiers: l,
      open: c,
      placement: u,
      popperOptions: f,
      popperRef: d,
      slotProps: h = {},
      slots: g = {},
      TransitionProps: p
      // @ts-ignore internal logic
      // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    } = e, y = af(e, $x), b = reactExports.useRef(null), x = Xn(b, r), S = reactExports.useRef(null), O = Xn(S, d), _ = reactExports.useRef(O);
    Oi(() => {
      _.current = O;
    }, [O]), reactExports.useImperativeHandle(d, () => S.current, []);
    const L = t_(u, s), [N, j] = reactExports.useState(L), [W, G] = reactExports.useState(Ia(i));
    reactExports.useEffect(() => {
      S.current && S.current.forceUpdate();
    }), reactExports.useEffect(() => {
      i && G(Ia(i));
    }, [i]), Oi(() => {
      if (!W || !c)
        return;
      const U = (te) => {
        j(te.placement);
      };
      if (define_process_env_default.NODE_ENV !== "production" && W && tl(W) && W.nodeType === 1) {
        const te = W.getBoundingClientRect();
        define_process_env_default.NODE_ENV !== "test" && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      }
      let I = [{
        name: "preventOverflow",
        options: {
          altBoundary: a
        }
      }, {
        name: "flip",
        options: {
          altBoundary: a
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state: te
        }) => {
          U(te);
        }
      }];
      l != null && (I = I.concat(l)), f && f.modifiers != null && (I = I.concat(f.modifiers));
      const V = Jx(W, b.current, Nt({
        placement: L
      }, f, {
        modifiers: I
      }));
      return _.current(V), () => {
        V.destroy(), _.current(null);
      };
    }, [W, a, l, c, f, L]);
    const ee = {
      placement: N
    };
    p !== null && (ee.TransitionProps = p);
    const fe = n_(), P10 = (n = g.root) != null ? n : "div", z10 = W4({
      elementType: P10,
      externalSlotProps: h.root,
      externalForwardedProps: y,
      additionalProps: {
        role: "tooltip",
        ref: x
      },
      ownerState: e,
      className: fe.root
    });
    return /* @__PURE__ */ Lt.jsx(P10, Nt({}, z10, {
      children: typeof o == "function" ? o(ee) : o
    }));
  }), Gg = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      anchorEl: n,
      children: i,
      container: o,
      direction: s = "ltr",
      disablePortal: a = false,
      keepMounted: l = false,
      modifiers: c,
      open: u,
      placement: f = "bottom",
      popperOptions: d = i_,
      popperRef: h,
      style: g,
      transition: p = false,
      slotProps: y = {},
      slots: b = {}
    } = e, x = af(e, e_), [S, O] = reactExports.useState(true), _ = () => {
      O(false);
    }, L = () => {
      O(true);
    };
    if (!l && !u && (!p || S))
      return null;
    let N;
    if (o)
      N = o;
    else if (n) {
      const G = Ia(n);
      N = G && tl(G) ? Ea(G).body : Ea(null).body;
    }
    const j = !u && l && (!p || S) ? "none" : void 0, W = p ? {
      in: u,
      onEnter: _,
      onExited: L
    } : void 0;
    return /* @__PURE__ */ Lt.jsx(Gx, {
      disablePortal: a,
      container: N,
      children: /* @__PURE__ */ Lt.jsx(o_, Nt({
        anchorEl: n,
        direction: s,
        disablePortal: a,
        modifiers: c,
        ref: r,
        open: p ? !S : u,
        placement: f,
        popperOptions: d,
        popperRef: h,
        slotProps: y,
        slots: b
      }, x, {
        style: Nt({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display: j
        }, g),
        TransitionProps: W,
        children: i
      }))
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (Gg.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: nf(F.oneOfType([Fo, F.object, F.func]), (t10) => {
      if (t10.open) {
        const e = Ia(t10.anchorEl);
        if (e && tl(e) && e.nodeType === 1) {
          const r = e.getBoundingClientRect();
          if (define_process_env_default.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
            return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
        } else if (!e || typeof e.getBoundingClientRect != "function" || r_(e) && e.contextElement != null && e.contextElement.nodeType !== 1)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
      }
      return null;
    }),
    /**
     * Popper render function or node.
     */
    children: F.oneOfType([F.node, F.func]),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: F.oneOfType([Fo, F.func]),
    /**
     * Direction of the text.
     * @default 'ltr'
     */
    direction: F.oneOf(["ltr", "rtl"]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: F.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: F.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: F.arrayOf(F.shape({
      data: F.object,
      effect: F.func,
      enabled: F.bool,
      fn: F.func,
      name: F.any,
      options: F.object,
      phase: F.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: F.arrayOf(F.string),
      requiresIfExists: F.arrayOf(F.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: F.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: F.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: F.shape({
      modifiers: F.array,
      onFirstUpdate: F.func,
      placement: F.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: F.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: Dg,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: F.shape({
      root: F.oneOfType([F.func, F.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: F.shape({
      root: F.elementType
    }),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: F.bool
  });
  const s_ = Gg;
  function su() {
    return su = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, su.apply(this, arguments);
  }
  function a_(t10) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(r) {
      return e[r] === void 0 && (e[r] = t10(r)), e[r];
    };
  }
  var l_ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, c_ = /* @__PURE__ */ a_(
    function(t10) {
      return l_.test(t10) || t10.charCodeAt(0) === 111 && t10.charCodeAt(1) === 110 && t10.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  function u_(t10) {
    if (t10.sheet)
      return t10.sheet;
    for (var e = 0; e < document.styleSheets.length; e++)
      if (document.styleSheets[e].ownerNode === t10)
        return document.styleSheets[e];
  }
  function f_(t10) {
    var e = document.createElement("style");
    return e.setAttribute("data-emotion", t10.key), t10.nonce !== void 0 && e.setAttribute("nonce", t10.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
  }
  var d_ = /* @__PURE__ */ function() {
    function t10(r) {
      var n = this;
      this._insertTag = function(i) {
        var o;
        n.tags.length === 0 ? n.insertionPoint ? o = n.insertionPoint.nextSibling : n.prepend ? o = n.container.firstChild : o = n.before : o = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(i, o), n.tags.push(i);
      }, this.isSpeedy = r.speedy === void 0 ? define_process_env_default.NODE_ENV === "production" : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
    }
    var e = t10.prototype;
    return e.hydrate = function(n) {
      n.forEach(this._insertTag);
    }, e.insert = function(n) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(f_(this));
      var i = this.tags[this.tags.length - 1];
      if (define_process_env_default.NODE_ENV !== "production") {
        var o = n.charCodeAt(0) === 64 && n.charCodeAt(1) === 105;
        o && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + n + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !o;
      }
      if (this.isSpeedy) {
        var s = u_(i);
        try {
          s.insertRule(n, s.cssRules.length);
        } catch (a) {
          define_process_env_default.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(n) && console.error('There was a problem inserting the following rule: "' + n + '"', a);
        }
      } else
        i.appendChild(document.createTextNode(n));
      this.ctr++;
    }, e.flush = function() {
      this.tags.forEach(function(n) {
        return n.parentNode && n.parentNode.removeChild(n);
      }), this.tags = [], this.ctr = 0, define_process_env_default.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = false);
    }, t10;
  }(), Ot = "-ms-", Pa = "-moz-", qe = "-webkit-", pf = "comm", gf = "rule", mf = "decl", h_ = "@import", Zg = "@keyframes", p_ = "@layer", g_ = Math.abs, rl = String.fromCharCode, m_ = Object.assign;
  function y_(t10, e) {
    return Ct(t10, 0) ^ 45 ? (((e << 2 ^ Ct(t10, 0)) << 2 ^ Ct(t10, 1)) << 2 ^ Ct(t10, 2)) << 2 ^ Ct(t10, 3) : 0;
  }
  function $g(t10) {
    return t10.trim();
  }
  function b_(t10, e) {
    return (t10 = e.exec(t10)) ? t10[0] : t10;
  }
  function He(t10, e, r) {
    return t10.replace(e, r);
  }
  function au(t10, e) {
    return t10.indexOf(e);
  }
  function Ct(t10, e) {
    return t10.charCodeAt(e) | 0;
  }
  function Uo(t10, e, r) {
    return t10.slice(e, r);
  }
  function xr(t10) {
    return t10.length;
  }
  function yf(t10) {
    return t10.length;
  }
  function Ds(t10, e) {
    return e.push(t10), t10;
  }
  function v_(t10, e) {
    return t10.map(e).join("");
  }
  var nl = 1, Mi = 1, em = 0, Vt = 0, bt = 0, Bi = "";
  function il(t10, e, r, n, i, o, s) {
    return { value: t10, root: e, parent: r, type: n, props: i, children: o, line: nl, column: Mi, length: s, return: "" };
  }
  function $i(t10, e) {
    return m_(il("", null, null, "", null, null, 0), t10, { length: -t10.length }, e);
  }
  function A_() {
    return bt;
  }
  function w_() {
    return bt = Vt > 0 ? Ct(Bi, --Vt) : 0, Mi--, bt === 10 && (Mi = 1, nl--), bt;
  }
  function Jt() {
    return bt = Vt < em ? Ct(Bi, Vt++) : 0, Mi++, bt === 10 && (Mi = 1, nl++), bt;
  }
  function Tr() {
    return Ct(Bi, Vt);
  }
  function Zs() {
    return Vt;
  }
  function ts(t10, e) {
    return Uo(Bi, t10, e);
  }
  function zo(t10) {
    switch (t10) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function tm(t10) {
    return nl = Mi = 1, em = xr(Bi = t10), Vt = 0, [];
  }
  function rm(t10) {
    return Bi = "", t10;
  }
  function $s(t10) {
    return $g(ts(Vt - 1, lu(t10 === 91 ? t10 + 2 : t10 === 40 ? t10 + 1 : t10)));
  }
  function x_(t10) {
    for (; (bt = Tr()) && bt < 33; )
      Jt();
    return zo(t10) > 2 || zo(bt) > 3 ? "" : " ";
  }
  function __(t10, e) {
    for (; --e && Jt() && !(bt < 48 || bt > 102 || bt > 57 && bt < 65 || bt > 70 && bt < 97); )
      ;
    return ts(t10, Zs() + (e < 6 && Tr() == 32 && Jt() == 32));
  }
  function lu(t10) {
    for (; Jt(); )
      switch (bt) {
        case t10:
          return Vt;
        case 34:
        case 39:
          t10 !== 34 && t10 !== 39 && lu(bt);
          break;
        case 40:
          t10 === 41 && lu(t10);
          break;
        case 92:
          Jt();
          break;
      }
    return Vt;
  }
  function S_(t10, e) {
    for (; Jt() && t10 + bt !== 47 + 10; )
      if (t10 + bt === 42 + 42 && Tr() === 47)
        break;
    return "/*" + ts(e, Vt - 1) + "*" + rl(t10 === 47 ? t10 : Jt());
  }
  function E_(t10) {
    for (; !zo(Tr()); )
      Jt();
    return ts(t10, Vt);
  }
  function k_(t10) {
    return rm(ea("", null, null, null, [""], t10 = tm(t10), 0, [0], t10));
  }
  function ea(t10, e, r, n, i, o, s, a, l) {
    for (var c = 0, u = 0, f = s, d = 0, h = 0, g = 0, p = 1, y = 1, b = 1, x = 0, S = "", O = i, _ = o, L = n, N = S; y; )
      switch (g = x, x = Jt()) {
        case 40:
          if (g != 108 && Ct(N, f - 1) == 58) {
            au(N += He($s(x), "&", "&\f"), "&\f") != -1 && (b = -1);
            break;
          }
        case 34:
        case 39:
        case 91:
          N += $s(x);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          N += x_(g);
          break;
        case 92:
          N += __(Zs() - 1, 7);
          continue;
        case 47:
          switch (Tr()) {
            case 42:
            case 47:
              Ds(C_(S_(Jt(), Zs()), e, r), l);
              break;
            default:
              N += "/";
          }
          break;
        case 123 * p:
          a[c++] = xr(N) * b;
        case 125 * p:
        case 59:
        case 0:
          switch (x) {
            case 0:
            case 125:
              y = 0;
            case 59 + u:
              b == -1 && (N = He(N, /\f/g, "")), h > 0 && xr(N) - f && Ds(h > 32 ? Pp(N + ";", n, r, f - 1) : Pp(He(N, " ", "") + ";", n, r, f - 2), l);
              break;
            case 59:
              N += ";";
            default:
              if (Ds(L = Ip(N, e, r, c, u, i, a, S, O = [], _ = [], f), o), x === 123)
                if (u === 0)
                  ea(N, e, L, L, O, o, f, a, _);
                else
                  switch (d === 99 && Ct(N, 3) === 110 ? 100 : d) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      ea(t10, L, L, n && Ds(Ip(t10, L, L, 0, 0, i, a, S, i, O = [], f), _), i, _, f, a, n ? O : _);
                      break;
                    default:
                      ea(N, L, L, L, [""], _, 0, a, _);
                  }
          }
          c = u = h = 0, p = b = 1, S = N = "", f = s;
          break;
        case 58:
          f = 1 + xr(N), h = g;
        default:
          if (p < 1) {
            if (x == 123)
              --p;
            else if (x == 125 && p++ == 0 && w_() == 125)
              continue;
          }
          switch (N += rl(x), x * p) {
            case 38:
              b = u > 0 ? 1 : (N += "\f", -1);
              break;
            case 44:
              a[c++] = (xr(N) - 1) * b, b = 1;
              break;
            case 64:
              Tr() === 45 && (N += $s(Jt())), d = Tr(), u = f = xr(S = N += E_(Zs())), x++;
              break;
            case 45:
              g === 45 && xr(N) == 2 && (p = 0);
          }
      }
    return o;
  }
  function Ip(t10, e, r, n, i, o, s, a, l, c, u) {
    for (var f = i - 1, d = i === 0 ? o : [""], h = yf(d), g = 0, p = 0, y = 0; g < n; ++g)
      for (var b = 0, x = Uo(t10, f + 1, f = g_(p = s[g])), S = t10; b < h; ++b)
        (S = $g(p > 0 ? d[b] + " " + x : He(x, /&\f/g, d[b]))) && (l[y++] = S);
    return il(t10, e, r, i === 0 ? gf : a, l, c, u);
  }
  function C_(t10, e, r) {
    return il(t10, e, r, pf, rl(A_()), Uo(t10, 2, -2), 0);
  }
  function Pp(t10, e, r, n) {
    return il(t10, e, r, mf, Uo(t10, 0, n), Uo(t10, n + 1, -1), n);
  }
  function vi(t10, e) {
    for (var r = "", n = yf(t10), i = 0; i < n; i++)
      r += e(t10[i], i, t10, e) || "";
    return r;
  }
  function T_(t10, e, r, n) {
    switch (t10.type) {
      case p_:
        if (t10.children.length)
          break;
      case h_:
      case mf:
        return t10.return = t10.return || t10.value;
      case pf:
        return "";
      case Zg:
        return t10.return = t10.value + "{" + vi(t10.children, n) + "}";
      case gf:
        t10.value = t10.props.join(",");
    }
    return xr(r = vi(t10.children, n)) ? t10.return = t10.value + "{" + r + "}" : "";
  }
  function O_(t10) {
    var e = yf(t10);
    return function(r, n, i, o) {
      for (var s = "", a = 0; a < e; a++)
        s += t10[a](r, n, i, o) || "";
      return s;
    };
  }
  function I_(t10) {
    return function(e) {
      e.root || (e = e.return) && t10(e);
    };
  }
  var P_ = function(e, r, n) {
    for (var i = 0, o = 0; i = o, o = Tr(), i === 38 && o === 12 && (r[n] = 1), !zo(o); )
      Jt();
    return ts(e, Vt);
  }, R_ = function(e, r) {
    var n = -1, i = 44;
    do
      switch (zo(i)) {
        case 0:
          i === 38 && Tr() === 12 && (r[n] = 1), e[n] += P_(Vt - 1, r, n);
          break;
        case 2:
          e[n] += $s(i);
          break;
        case 4:
          if (i === 44) {
            e[++n] = Tr() === 58 ? "&\f" : "", r[n] = e[n].length;
            break;
          }
        default:
          e[n] += rl(i);
      }
    while (i = Jt());
    return e;
  }, D_ = function(e, r) {
    return rm(R_(tm(e), r));
  }, Rp = /* @__PURE__ */ new WeakMap(), M_ = function(e) {
    if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    e.length < 1)) {
      for (var r = e.value, n = e.parent, i = e.column === n.column && e.line === n.line; n.type !== "rule"; )
        if (n = n.parent, !n)
          return;
      if (!(e.props.length === 1 && r.charCodeAt(0) !== 58 && !Rp.get(n)) && !i) {
        Rp.set(e, true);
        for (var o = [], s = D_(r, o), a = n.props, l = 0, c = 0; l < s.length; l++)
          for (var u = 0; u < a.length; u++, c++)
            e.props[c] = o[l] ? s[l].replace(/&\f/g, a[u]) : a[u] + " " + s[l];
      }
    }
  }, N_ = function(e) {
    if (e.type === "decl") {
      var r = e.value;
      r.charCodeAt(0) === 108 && // charcode for b
      r.charCodeAt(2) === 98 && (e.return = "", e.value = "");
    }
  }, L_ = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", B_ = function(e) {
    return e.type === "comm" && e.children.indexOf(L_) > -1;
  }, F_ = function(e) {
    return function(r, n, i) {
      if (!(r.type !== "rule" || e.compat)) {
        var o = r.value.match(/(:first|:nth|:nth-last)-child/g);
        if (o) {
          for (var s = !!r.parent, a = s ? r.parent.children : (
            // globalThis rule at the root level
            i
          ), l = a.length - 1; l >= 0; l--) {
            var c = a[l];
            if (c.line < r.line)
              break;
            if (c.column < r.column) {
              if (B_(c))
                return;
              break;
            }
          }
          o.forEach(function(u) {
            console.error('The pseudo class "' + u + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + u.split("-child")[0] + '-of-type".');
          });
        }
      }
    };
  }, nm = function(e) {
    return e.type.charCodeAt(1) === 105 && e.type.charCodeAt(0) === 64;
  }, j_ = function(e, r) {
    for (var n = e - 1; n >= 0; n--)
      if (!nm(r[n]))
        return true;
    return false;
  }, Dp = function(e) {
    e.type = "", e.value = "", e.return = "", e.children = "", e.props = "";
  }, W_ = function(e, r, n) {
    nm(e) && (e.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within globalThis styles."), Dp(e)) : j_(r, n) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), Dp(e)));
  };
  function im(t10, e) {
    switch (y_(t10, e)) {
      case 5103:
        return qe + "print-" + t10 + t10;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return qe + t10 + t10;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return qe + t10 + Pa + t10 + Ot + t10 + t10;
      case 6828:
      case 4268:
        return qe + t10 + Ot + t10 + t10;
      case 6165:
        return qe + t10 + Ot + "flex-" + t10 + t10;
      case 5187:
        return qe + t10 + He(t10, /(\w+).+(:[^]+)/, qe + "box-$1$2" + Ot + "flex-$1$2") + t10;
      case 5443:
        return qe + t10 + Ot + "flex-item-" + He(t10, /flex-|-self/, "") + t10;
      case 4675:
        return qe + t10 + Ot + "flex-line-pack" + He(t10, /align-content|flex-|-self/, "") + t10;
      case 5548:
        return qe + t10 + Ot + He(t10, "shrink", "negative") + t10;
      case 5292:
        return qe + t10 + Ot + He(t10, "basis", "preferred-size") + t10;
      case 6060:
        return qe + "box-" + He(t10, "-grow", "") + qe + t10 + Ot + He(t10, "grow", "positive") + t10;
      case 4554:
        return qe + He(t10, /([^-])(transform)/g, "$1" + qe + "$2") + t10;
      case 6187:
        return He(He(He(t10, /(zoom-|grab)/, qe + "$1"), /(image-set)/, qe + "$1"), t10, "") + t10;
      case 5495:
      case 3959:
        return He(t10, /(image-set\([^]*)/, qe + "$1$`$1");
      case 4968:
        return He(He(t10, /(.+:)(flex-)?(.*)/, qe + "box-pack:$3" + Ot + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + qe + t10 + t10;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return He(t10, /(.+)-inline(.+)/, qe + "$1$2") + t10;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (xr(t10) - 1 - e > 6)
          switch (Ct(t10, e + 1)) {
            case 109:
              if (Ct(t10, e + 4) !== 45)
                break;
            case 102:
              return He(t10, /(.+:)(.+)-([^]+)/, "$1" + qe + "$2-$3$1" + Pa + (Ct(t10, e + 3) == 108 ? "$3" : "$2-$3")) + t10;
            case 115:
              return ~au(t10, "stretch") ? im(He(t10, "stretch", "fill-available"), e) + t10 : t10;
          }
        break;
      case 4949:
        if (Ct(t10, e + 1) !== 115)
          break;
      case 6444:
        switch (Ct(t10, xr(t10) - 3 - (~au(t10, "!important") && 10))) {
          case 107:
            return He(t10, ":", ":" + qe) + t10;
          case 101:
            return He(t10, /(.+:)([^;!]+)(;|!.+)?/, "$1" + qe + (Ct(t10, 14) === 45 ? "inline-" : "") + "box$3$1" + qe + "$2$3$1" + Ot + "$2box$3") + t10;
        }
        break;
      case 5936:
        switch (Ct(t10, e + 11)) {
          case 114:
            return qe + t10 + Ot + He(t10, /[svh]\w+-[tblr]{2}/, "tb") + t10;
          case 108:
            return qe + t10 + Ot + He(t10, /[svh]\w+-[tblr]{2}/, "tb-rl") + t10;
          case 45:
            return qe + t10 + Ot + He(t10, /[svh]\w+-[tblr]{2}/, "lr") + t10;
        }
        return qe + t10 + Ot + t10 + t10;
    }
    return t10;
  }
  var U_ = function(e, r, n, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case mf:
          e.return = im(e.value, e.length);
          break;
        case Zg:
          return vi([$i(e, {
            value: He(e.value, "@", "@" + qe)
          })], i);
        case gf:
          if (e.length)
            return v_(e.props, function(o) {
              switch (b_(o, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return vi([$i(e, {
                    props: [He(o, /:(read-\w+)/, ":" + Pa + "$1")]
                  })], i);
                case "::placeholder":
                  return vi([$i(e, {
                    props: [He(o, /:(plac\w+)/, ":" + qe + "input-$1")]
                  }), $i(e, {
                    props: [He(o, /:(plac\w+)/, ":" + Pa + "$1")]
                  }), $i(e, {
                    props: [He(o, /:(plac\w+)/, Ot + "input-$1")]
                  })], i);
              }
              return "";
            });
      }
  }, z_ = [U_], V_ = function(e) {
    var r = e.key;
    if (define_process_env_default.NODE_ENV !== "production" && !r)
      throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
    if (r === "css") {
      var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(n, function(p) {
        var y = p.getAttribute("data-emotion");
        y.indexOf(" ") !== -1 && (document.head.appendChild(p), p.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || z_;
    if (define_process_env_default.NODE_ENV !== "production" && /[^a-z-]/.test(r))
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + r + '" was passed');
    var o = {}, s, a = [];
    s = e.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
      function(p) {
        for (var y = p.getAttribute("data-emotion").split(" "), b = 1; b < y.length; b++)
          o[y[b]] = true;
        a.push(p);
      }
    );
    var l, c = [M_, N_];
    define_process_env_default.NODE_ENV !== "production" && c.push(F_({
      get compat() {
        return g.compat;
      }
    }), W_);
    {
      var u, f = [T_, define_process_env_default.NODE_ENV !== "production" ? function(p) {
        p.root || (p.return ? u.insert(p.return) : p.value && p.type !== pf && u.insert(p.value + "{}"));
      } : I_(function(p) {
        u.insert(p);
      })], d = O_(c.concat(i, f)), h = function(y) {
        return vi(k_(y), d);
      };
      l = function(y, b, x, S) {
        u = x, define_process_env_default.NODE_ENV !== "production" && b.map !== void 0 && (u = {
          insert: function(_) {
            x.insert(_ + b.map);
          }
        }), h(y ? y + "{" + b.styles + "}" : b.styles), S && (g.inserted[b.name] = true);
      };
    }
    var g = {
      key: r,
      sheet: new d_({
        key: r,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint
      }),
      nonce: e.nonce,
      inserted: o,
      registered: {},
      insert: l
    };
    return g.sheet.hydrate(a), g;
  }, q_ = true;
  function om(t10, e, r) {
    var n = "";
    return r.split(" ").forEach(function(i) {
      t10[i] !== void 0 ? e.push(t10[i] + ";") : n += i + " ";
    }), n;
  }
  var bf = function(e, r, n) {
    var i = e.key + "-" + r.name;
    (n === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is globalThis or not
    // also, note that this check will be dead code eliminated in the browser
    q_ === false) && e.registered[i] === void 0 && (e.registered[i] = r.styles);
  }, sm = function(e, r, n) {
    bf(e, r, n);
    var i = e.key + "-" + r.name;
    if (e.inserted[r.name] === void 0) {
      var o = r;
      do
        e.insert(r === o ? "." + i : "", o, e.sheet, true), o = o.next;
      while (o !== void 0);
    }
  };
  function H_(t10) {
    for (var e = 0, r, n = 0, i = t10.length; i >= 4; ++n, i -= 4)
      r = t10.charCodeAt(n) & 255 | (t10.charCodeAt(++n) & 255) << 8 | (t10.charCodeAt(++n) & 255) << 16 | (t10.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
      (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
      r >>> 24, e = /* Math.imul(k, m): */
      (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    switch (i) {
      case 3:
        e ^= (t10.charCodeAt(n + 2) & 255) << 16;
      case 2:
        e ^= (t10.charCodeAt(n + 1) & 255) << 8;
      case 1:
        e ^= t10.charCodeAt(n) & 255, e = /* Math.imul(h, m): */
        (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
    }
    return e ^= e >>> 13, e = /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
  }
  var Y_ = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  function K_(t10) {
    var e = /* @__PURE__ */ Object.create(null);
    return function(r) {
      return e[r] === void 0 && (e[r] = t10(r)), e[r];
    };
  }
  var Mp = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, X_ = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", J_ = /[A-Z]|^ms/g, am = /_EMO_([^_]+?)_([^]*?)_EMO_/g, vf = function(e) {
    return e.charCodeAt(1) === 45;
  }, Np = function(e) {
    return e != null && typeof e != "boolean";
  }, yc = /* @__PURE__ */ K_(function(t10) {
    return vf(t10) ? t10 : t10.replace(J_, "-$&").toLowerCase();
  }), Ra = function(e, r) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof r == "string")
          return r.replace(am, function(n, i, o) {
            return dr = {
              name: i,
              styles: o,
              next: dr
            }, i;
          });
    }
    return Y_[e] !== 1 && !vf(e) && typeof r == "number" && r !== 0 ? r + "px" : r;
  };
  if (define_process_env_default.NODE_ENV !== "production") {
    var Q_ = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, G_ = ["normal", "none", "initial", "inherit", "unset"], Z_ = Ra, $_ = /^-ms-/, e9 = /-(.)/g, Lp = {};
    Ra = function(e, r) {
      if (e === "content" && (typeof r != "string" || G_.indexOf(r) === -1 && !Q_.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")))
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + r + "\"'`");
      var n = Z_(e, r);
      return n !== "" && !vf(e) && e.indexOf("-") !== -1 && Lp[e] === void 0 && (Lp[e] = true, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + e.replace($_, "ms-").replace(e9, function(i, o) {
        return o.toUpperCase();
      }) + "?")), n;
    };
  }
  var lm = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function Vo(t10, e, r) {
    if (r == null)
      return "";
    if (r.__emotion_styles !== void 0) {
      if (define_process_env_default.NODE_ENV !== "production" && r.toString() === "NO_COMPONENT_SELECTOR")
        throw new Error(lm);
      return r;
    }
    switch (typeof r) {
      case "boolean":
        return "";
      case "object": {
        if (r.anim === 1)
          return dr = {
            name: r.name,
            styles: r.styles,
            next: dr
          }, r.name;
        if (r.styles !== void 0) {
          var n = r.next;
          if (n !== void 0)
            for (; n !== void 0; )
              dr = {
                name: n.name,
                styles: n.styles,
                next: dr
              }, n = n.next;
          var i = r.styles + ";";
          return define_process_env_default.NODE_ENV !== "production" && r.map !== void 0 && (i += r.map), i;
        }
        return t9(t10, e, r);
      }
      case "function": {
        if (t10 !== void 0) {
          var o = dr, s = r(t10);
          return dr = o, Vo(t10, e, s);
        } else
          define_process_env_default.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
        break;
      }
      case "string":
        if (define_process_env_default.NODE_ENV !== "production") {
          var a = [], l = r.replace(am, function(u, f, d) {
            var h = "animation" + a.length;
            return a.push("const " + h + " = keyframes`" + d.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + h + "}";
          });
          a.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(a, ["`" + l + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + l + "`"));
        }
        break;
    }
    if (e == null)
      return r;
    var c = e[r];
    return c !== void 0 ? c : r;
  }
  function t9(t10, e, r) {
    var n = "";
    if (Array.isArray(r))
      for (var i = 0; i < r.length; i++)
        n += Vo(t10, e, r[i]) + ";";
    else
      for (var o in r) {
        var s = r[o];
        if (typeof s != "object")
          e != null && e[s] !== void 0 ? n += o + "{" + e[s] + "}" : Np(s) && (n += yc(o) + ":" + Ra(o, s) + ";");
        else {
          if (o === "NO_COMPONENT_SELECTOR" && define_process_env_default.NODE_ENV !== "production")
            throw new Error(lm);
          if (Array.isArray(s) && typeof s[0] == "string" && (e == null || e[s[0]] === void 0))
            for (var a = 0; a < s.length; a++)
              Np(s[a]) && (n += yc(o) + ":" + Ra(o, s[a]) + ";");
          else {
            var l = Vo(t10, e, s);
            switch (o) {
              case "animation":
              case "animationName": {
                n += yc(o) + ":" + l + ";";
                break;
              }
              default:
                define_process_env_default.NODE_ENV !== "production" && o === "undefined" && console.error(X_), n += o + "{" + l + "}";
            }
          }
        }
      }
    return n;
  }
  var Bp = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cm;
  define_process_env_default.NODE_ENV !== "production" && (cm = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
  var dr, cu = function(e, r, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
      return e[0];
    var i = true, o = "";
    dr = void 0;
    var s = e[0];
    s == null || s.raw === void 0 ? (i = false, o += Vo(n, r, s)) : (define_process_env_default.NODE_ENV !== "production" && s[0] === void 0 && console.error(Mp), o += s[0]);
    for (var a = 1; a < e.length; a++)
      o += Vo(n, r, e[a]), i && (define_process_env_default.NODE_ENV !== "production" && s[a] === void 0 && console.error(Mp), o += s[a]);
    var l;
    define_process_env_default.NODE_ENV !== "production" && (o = o.replace(cm, function(d) {
      return l = d, "";
    })), Bp.lastIndex = 0;
    for (var c = "", u; (u = Bp.exec(o)) !== null; )
      c += "-" + // $FlowFixMe we know it's not null
      u[1];
    var f = H_(o) + c;
    return define_process_env_default.NODE_ENV !== "production" ? {
      name: f,
      styles: o,
      map: l,
      next: dr,
      toString: function() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    } : {
      name: f,
      styles: o,
      next: dr
    };
  }, r9 = function(e) {
    return e();
  }, n9 = reactExports.useInsertionEffect ? reactExports.useInsertionEffect : false, um = n9 || r9, i9 = {}.hasOwnProperty, Af = /* @__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < "u" ? /* @__PURE__ */ V_({
      key: "css"
    }) : null
  );
  define_process_env_default.NODE_ENV !== "production" && (Af.displayName = "EmotionCacheContext");
  Af.Provider;
  var fm = function(e) {
    return /* @__PURE__ */ reactExports.forwardRef(function(r, n) {
      var i = reactExports.useContext(Af);
      return e(r, i, n);
    });
  }, ol = /* @__PURE__ */ reactExports.createContext({});
  define_process_env_default.NODE_ENV !== "production" && (ol.displayName = "EmotionThemeContext");
  var Fp = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", jp = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", o9 = function(e) {
    var r = e.cache, n = e.serialized, i = e.isStringTag;
    return bf(r, n, i), um(function() {
      return sm(r, n, i);
    }), null;
  }, s9 = /* @__PURE__ */ fm(function(t10, e, r) {
    var n = t10.css;
    typeof n == "string" && e.registered[n] !== void 0 && (n = e.registered[n]);
    var i = t10[Fp], o = [n], s = "";
    typeof t10.className == "string" ? s = om(e.registered, o, t10.className) : t10.className != null && (s = t10.className + " ");
    var a = cu(o, void 0, reactExports.useContext(ol));
    if (define_process_env_default.NODE_ENV !== "production" && a.name.indexOf("-") === -1) {
      var l = t10[jp];
      l && (a = cu([a, "label:" + l + ";"]));
    }
    s += e.key + "-" + a.name;
    var c = {};
    for (var u in t10)
      i9.call(t10, u) && u !== "css" && u !== Fp && (define_process_env_default.NODE_ENV === "production" || u !== jp) && (c[u] = t10[u]);
    return c.ref = r, c.className = s, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(o9, {
      cache: e,
      serialized: a,
      isStringTag: typeof i == "string"
    }), /* @__PURE__ */ reactExports.createElement(i, c));
  });
  define_process_env_default.NODE_ENV !== "production" && (s9.displayName = "EmotionCssPropInternal");
  var a9 = c_, l9 = function(e) {
    return e !== "theme";
  }, Wp = function(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96 ? a9 : l9;
  }, Up = function(e, r, n) {
    var i;
    if (r) {
      var o = r.shouldForwardProp;
      i = e.__emotion_forwardProp && o ? function(s) {
        return e.__emotion_forwardProp(s) && o(s);
      } : o;
    }
    return typeof i != "function" && n && (i = e.__emotion_forwardProp), i;
  }, zp = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, c9 = function(e) {
    var r = e.cache, n = e.serialized, i = e.isStringTag;
    return bf(r, n, i), um(function() {
      return sm(r, n, i);
    }), null;
  }, u9 = function t(e, r) {
    if (define_process_env_default.NODE_ENV !== "production" && e === void 0)
      throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
    var n = e.__emotion_real === e, i = n && e.__emotion_base || e, o, s;
    r !== void 0 && (o = r.label, s = r.target);
    var a = Up(e, r, n), l = a || Wp(i), c = !l("as");
    return function() {
      var u = arguments, f = n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (o !== void 0 && f.push("label:" + o + ";"), u[0] == null || u[0].raw === void 0)
        f.push.apply(f, u);
      else {
        define_process_env_default.NODE_ENV !== "production" && u[0][0] === void 0 && console.error(zp), f.push(u[0][0]);
        for (var d = u.length, h = 1; h < d; h++)
          define_process_env_default.NODE_ENV !== "production" && u[0][h] === void 0 && console.error(zp), f.push(u[h], u[0][h]);
      }
      var g = fm(function(p, y, b) {
        var x = c && p.as || i, S = "", O = [], _ = p;
        if (p.theme == null) {
          _ = {};
          for (var L in p)
            _[L] = p[L];
          _.theme = reactExports.useContext(ol);
        }
        typeof p.className == "string" ? S = om(y.registered, O, p.className) : p.className != null && (S = p.className + " ");
        var N = cu(f.concat(O), y.registered, _);
        S += y.key + "-" + N.name, s !== void 0 && (S += " " + s);
        var j = c && a === void 0 ? Wp(x) : l, W = {};
        for (var G in p)
          c && G === "as" || // $FlowFixMe
          j(G) && (W[G] = p[G]);
        return W.className = S, W.ref = b, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(c9, {
          cache: y,
          serialized: N,
          isStringTag: typeof x == "string"
        }), /* @__PURE__ */ reactExports.createElement(x, W));
      });
      return g.displayName = o !== void 0 ? o : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", g.defaultProps = e.defaultProps, g.__emotion_real = g, g.__emotion_base = i, g.__emotion_styles = f, g.__emotion_forwardProp = a, Object.defineProperty(g, "toString", {
        value: function() {
          return s === void 0 && define_process_env_default.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + s;
        }
      }), g.withComponent = function(p, y) {
        return t(p, su({}, r, y, {
          shouldForwardProp: Up(g, y, true)
        })).apply(void 0, f);
      }, g;
    };
  };
  const f9 = u9;
  var d9 = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], uu = f9.bind();
  d9.forEach(function(t10) {
    uu[t10] = uu(t10);
  });
  const h9 = uu;
  /**
   * @mui/styled-engine v5.12.3
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function p9(t10, e) {
    const r = h9(t10, e);
    return define_process_env_default.NODE_ENV !== "production" ? (...n) => {
      const i = typeof t10 == "string" ? `"${t10}"` : "component";
      return n.length === 0 ? console.error([`MUI: Seems like you called \`styled(${i})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : n.some((o) => o === void 0) && console.error(`MUI: the styled(${i})(...args) API requires all its args to be defined.`), r(...n);
    } : r;
  }
  const g9 = (t10, e) => {
    Array.isArray(t10.__emotion_styles) && (t10.__emotion_styles = e(t10.__emotion_styles));
  };
  function kt() {
    return kt = Object.assign ? Object.assign.bind() : function(t10) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
      }
      return t10;
    }, kt.apply(this, arguments);
  }
  function sl(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  const m9 = ["values", "unit", "step"], y9 = (t10) => {
    const e = Object.keys(t10).map((r) => ({
      key: r,
      val: t10[r]
    })) || [];
    return e.sort((r, n) => r.val - n.val), e.reduce((r, n) => kt({}, r, {
      [n.key]: n.val
    }), {});
  };
  function b9(t10) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: e = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: r = "px",
      step: n = 5
    } = t10, i = sl(t10, m9), o = y9(e), s = Object.keys(o);
    function a(d) {
      return `@media (min-width:${typeof e[d] == "number" ? e[d] : d}${r})`;
    }
    function l(d) {
      return `@media (max-width:${(typeof e[d] == "number" ? e[d] : d) - n / 100}${r})`;
    }
    function c(d, h) {
      const g = s.indexOf(h);
      return `@media (min-width:${typeof e[d] == "number" ? e[d] : d}${r}) and (max-width:${(g !== -1 && typeof e[s[g]] == "number" ? e[s[g]] : h) - n / 100}${r})`;
    }
    function u(d) {
      return s.indexOf(d) + 1 < s.length ? c(d, s[s.indexOf(d) + 1]) : a(d);
    }
    function f(d) {
      const h = s.indexOf(d);
      return h === 0 ? a(s[1]) : h === s.length - 1 ? l(s[h]) : c(d, s[s.indexOf(d) + 1]).replace("@media", "@media not all and");
    }
    return kt({
      keys: s,
      values: o,
      up: a,
      down: l,
      between: c,
      only: u,
      not: f,
      unit: r
    }, i);
  }
  const v9 = {
    borderRadius: 4
  }, A9 = v9, w9 = define_process_env_default.NODE_ENV !== "production" ? F.oneOfType([F.number, F.string, F.object, F.array]) : {}, xn = w9;
  function _o(t10, e) {
    return e ? qr(t10, e, {
      clone: false
      // No need to clone deep, it's way faster.
    }) : t10;
  }
  const wf = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  }, Vp = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (t10) => `@media (min-width:${wf[t10]}px)`
  };
  function Kr(t10, e, r) {
    const n = t10.theme || {};
    if (Array.isArray(e)) {
      const o = n.breakpoints || Vp;
      return e.reduce((s, a, l) => (s[o.up(o.keys[l])] = r(e[l]), s), {});
    }
    if (typeof e == "object") {
      const o = n.breakpoints || Vp;
      return Object.keys(e).reduce((s, a) => {
        if (Object.keys(o.values || wf).indexOf(a) !== -1) {
          const l = o.up(a);
          s[l] = r(e[a], a);
        } else {
          const l = a;
          s[l] = e[l];
        }
        return s;
      }, {});
    }
    return r(e);
  }
  function x9(t10 = {}) {
    var e;
    return ((e = t10.keys) == null ? void 0 : e.reduce((n, i) => {
      const o = t10.up(i);
      return n[o] = {}, n;
    }, {})) || {};
  }
  function _9(t10, e) {
    return t10.reduce((r, n) => {
      const i = r[n];
      return (!i || Object.keys(i).length === 0) && delete r[n], r;
    }, e);
  }
  function al(t10, e, r = true) {
    if (!e || typeof e != "string")
      return null;
    if (t10 && t10.vars && r) {
      const n = `vars.${e}`.split(".").reduce((i, o) => i && i[o] ? i[o] : null, t10);
      if (n != null)
        return n;
    }
    return e.split(".").reduce((n, i) => n && n[i] != null ? n[i] : null, t10);
  }
  function Da(t10, e, r, n = r) {
    let i;
    return typeof t10 == "function" ? i = t10(r) : Array.isArray(t10) ? i = t10[r] || n : i = al(t10, r) || n, e && (i = e(i, n, t10)), i;
  }
  function Qe(t10) {
    const {
      prop: e,
      cssProperty: r = t10.prop,
      themeKey: n,
      transform: i
    } = t10, o = (s) => {
      if (s[e] == null)
        return null;
      const a = s[e], l = s.theme, c = al(l, n) || {};
      return Kr(s, a, (f) => {
        let d = Da(c, i, f);
        return f === d && typeof f == "string" && (d = Da(c, i, `${e}${f === "default" ? "" : or(f)}`, f)), r === false ? d : {
          [r]: d
        };
      });
    };
    return o.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
      [e]: xn
    } : {}, o.filterProps = [e], o;
  }
  function S9(t10) {
    const e = {};
    return (r) => (e[r] === void 0 && (e[r] = t10(r)), e[r]);
  }
  const E9 = {
    m: "margin",
    p: "padding"
  }, k9 = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  }, qp = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  }, C9 = S9((t10) => {
    if (t10.length > 2)
      if (qp[t10])
        t10 = qp[t10];
      else
        return [t10];
    const [e, r] = t10.split(""), n = E9[e], i = k9[r] || "";
    return Array.isArray(i) ? i.map((o) => n + o) : [n + i];
  }), ll = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], cl = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], T9 = [...ll, ...cl];
  function rs(t10, e, r, n) {
    var i;
    const o = (i = al(t10, e, false)) != null ? i : r;
    return typeof o == "number" ? (s) => typeof s == "string" ? s : (define_process_env_default.NODE_ENV !== "production" && typeof s != "number" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${s}.`), o * s) : Array.isArray(o) ? (s) => typeof s == "string" ? s : (define_process_env_default.NODE_ENV !== "production" && (Number.isInteger(s) ? s > o.length - 1 && console.error([`MUI: The value provided (${s}) overflows.`, `The supported values are: ${JSON.stringify(o)}.`, `${s} > ${o.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${e}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${e}\` as a number.`].join(`
`))), o[s]) : typeof o == "function" ? o : (define_process_env_default.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${e}\` value (${o}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
    });
  }
  function dm(t10) {
    return rs(t10, "spacing", 8, "spacing");
  }
  function ns(t10, e) {
    if (typeof e == "string" || e == null)
      return e;
    const r = Math.abs(e), n = t10(r);
    return e >= 0 ? n : typeof n == "number" ? -n : `-${n}`;
  }
  function O9(t10, e) {
    return (r) => t10.reduce((n, i) => (n[i] = ns(e, r), n), {});
  }
  function I9(t10, e, r, n) {
    if (e.indexOf(r) === -1)
      return null;
    const i = C9(r), o = O9(i, n), s = t10[r];
    return Kr(t10, s, o);
  }
  function hm(t10, e) {
    const r = dm(t10.theme);
    return Object.keys(t10).map((n) => I9(t10, e, n, r)).reduce(_o, {});
  }
  function ft(t10) {
    return hm(t10, ll);
  }
  ft.propTypes = define_process_env_default.NODE_ENV !== "production" ? ll.reduce((t10, e) => (t10[e] = xn, t10), {}) : {};
  ft.filterProps = ll;
  function dt(t10) {
    return hm(t10, cl);
  }
  dt.propTypes = define_process_env_default.NODE_ENV !== "production" ? cl.reduce((t10, e) => (t10[e] = xn, t10), {}) : {};
  dt.filterProps = cl;
  define_process_env_default.NODE_ENV !== "production" && T9.reduce((t10, e) => (t10[e] = xn, t10), {});
  function P9(t10 = 8) {
    if (t10.mui)
      return t10;
    const e = dm({
      spacing: t10
    }), r = (...n) => (define_process_env_default.NODE_ENV !== "production" && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((o) => {
      const s = e(o);
      return typeof s == "number" ? `${s}px` : s;
    }).join(" "));
    return r.mui = true, r;
  }
  function ul(...t10) {
    const e = t10.reduce((n, i) => (i.filterProps.forEach((o) => {
      n[o] = i;
    }), n), {}), r = (n) => Object.keys(n).reduce((i, o) => e[o] ? _o(i, e[o](n)) : i, {});
    return r.propTypes = define_process_env_default.NODE_ENV !== "production" ? t10.reduce((n, i) => Object.assign(n, i.propTypes), {}) : {}, r.filterProps = t10.reduce((n, i) => n.concat(i.filterProps), []), r;
  }
  function Sr(t10) {
    return typeof t10 != "number" ? t10 : `${t10}px solid`;
  }
  const R9 = Qe({
    prop: "border",
    themeKey: "borders",
    transform: Sr
  }), D9 = Qe({
    prop: "borderTop",
    themeKey: "borders",
    transform: Sr
  }), M9 = Qe({
    prop: "borderRight",
    themeKey: "borders",
    transform: Sr
  }), N9 = Qe({
    prop: "borderBottom",
    themeKey: "borders",
    transform: Sr
  }), L9 = Qe({
    prop: "borderLeft",
    themeKey: "borders",
    transform: Sr
  }), B9 = Qe({
    prop: "borderColor",
    themeKey: "palette"
  }), F9 = Qe({
    prop: "borderTopColor",
    themeKey: "palette"
  }), j9 = Qe({
    prop: "borderRightColor",
    themeKey: "palette"
  }), W9 = Qe({
    prop: "borderBottomColor",
    themeKey: "palette"
  }), U9 = Qe({
    prop: "borderLeftColor",
    themeKey: "palette"
  }), fl = (t10) => {
    if (t10.borderRadius !== void 0 && t10.borderRadius !== null) {
      const e = rs(t10.theme, "shape.borderRadius", 4, "borderRadius"), r = (n) => ({
        borderRadius: ns(e, n)
      });
      return Kr(t10, t10.borderRadius, r);
    }
    return null;
  };
  fl.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    borderRadius: xn
  } : {};
  fl.filterProps = ["borderRadius"];
  ul(R9, D9, M9, N9, L9, B9, F9, j9, W9, U9, fl);
  const dl = (t10) => {
    if (t10.gap !== void 0 && t10.gap !== null) {
      const e = rs(t10.theme, "spacing", 8, "gap"), r = (n) => ({
        gap: ns(e, n)
      });
      return Kr(t10, t10.gap, r);
    }
    return null;
  };
  dl.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    gap: xn
  } : {};
  dl.filterProps = ["gap"];
  const hl = (t10) => {
    if (t10.columnGap !== void 0 && t10.columnGap !== null) {
      const e = rs(t10.theme, "spacing", 8, "columnGap"), r = (n) => ({
        columnGap: ns(e, n)
      });
      return Kr(t10, t10.columnGap, r);
    }
    return null;
  };
  hl.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    columnGap: xn
  } : {};
  hl.filterProps = ["columnGap"];
  const pl = (t10) => {
    if (t10.rowGap !== void 0 && t10.rowGap !== null) {
      const e = rs(t10.theme, "spacing", 8, "rowGap"), r = (n) => ({
        rowGap: ns(e, n)
      });
      return Kr(t10, t10.rowGap, r);
    }
    return null;
  };
  pl.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    rowGap: xn
  } : {};
  pl.filterProps = ["rowGap"];
  const z9 = Qe({
    prop: "gridColumn"
  }), V9 = Qe({
    prop: "gridRow"
  }), q9 = Qe({
    prop: "gridAutoFlow"
  }), H9 = Qe({
    prop: "gridAutoColumns"
  }), Y9 = Qe({
    prop: "gridAutoRows"
  }), K9 = Qe({
    prop: "gridTemplateColumns"
  }), X9 = Qe({
    prop: "gridTemplateRows"
  }), J9 = Qe({
    prop: "gridTemplateAreas"
  }), Q9 = Qe({
    prop: "gridArea"
  });
  ul(dl, hl, pl, z9, V9, q9, H9, Y9, K9, X9, J9, Q9);
  function Ai(t10, e) {
    return e === "grey" ? e : t10;
  }
  const G9 = Qe({
    prop: "color",
    themeKey: "palette",
    transform: Ai
  }), Z9 = Qe({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Ai
  }), $9 = Qe({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: Ai
  });
  ul(G9, Z9, $9);
  function Kt(t10) {
    return t10 <= 1 && t10 !== 0 ? `${t10 * 100}%` : t10;
  }
  const e8 = Qe({
    prop: "width",
    transform: Kt
  }), xf = (t10) => {
    if (t10.maxWidth !== void 0 && t10.maxWidth !== null) {
      const e = (r) => {
        var n, i, o;
        return {
          maxWidth: ((n = t10.theme) == null || (i = n.breakpoints) == null || (o = i.values) == null ? void 0 : o[r]) || wf[r] || Kt(r)
        };
      };
      return Kr(t10, t10.maxWidth, e);
    }
    return null;
  };
  xf.filterProps = ["maxWidth"];
  const t8 = Qe({
    prop: "minWidth",
    transform: Kt
  }), r8 = Qe({
    prop: "height",
    transform: Kt
  }), n8 = Qe({
    prop: "maxHeight",
    transform: Kt
  }), i8 = Qe({
    prop: "minHeight",
    transform: Kt
  });
  Qe({
    prop: "size",
    cssProperty: "width",
    transform: Kt
  });
  Qe({
    prop: "size",
    cssProperty: "height",
    transform: Kt
  });
  const o8 = Qe({
    prop: "boxSizing"
  });
  ul(e8, xf, t8, r8, n8, i8, o8);
  const s8 = {
    // borders
    border: {
      themeKey: "borders",
      transform: Sr
    },
    borderTop: {
      themeKey: "borders",
      transform: Sr
    },
    borderRight: {
      themeKey: "borders",
      transform: Sr
    },
    borderBottom: {
      themeKey: "borders",
      transform: Sr
    },
    borderLeft: {
      themeKey: "borders",
      transform: Sr
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: fl
    },
    // palette
    color: {
      themeKey: "palette",
      transform: Ai
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: Ai
    },
    backgroundColor: {
      themeKey: "palette",
      transform: Ai
    },
    // spacing
    p: {
      style: dt
    },
    pt: {
      style: dt
    },
    pr: {
      style: dt
    },
    pb: {
      style: dt
    },
    pl: {
      style: dt
    },
    px: {
      style: dt
    },
    py: {
      style: dt
    },
    padding: {
      style: dt
    },
    paddingTop: {
      style: dt
    },
    paddingRight: {
      style: dt
    },
    paddingBottom: {
      style: dt
    },
    paddingLeft: {
      style: dt
    },
    paddingX: {
      style: dt
    },
    paddingY: {
      style: dt
    },
    paddingInline: {
      style: dt
    },
    paddingInlineStart: {
      style: dt
    },
    paddingInlineEnd: {
      style: dt
    },
    paddingBlock: {
      style: dt
    },
    paddingBlockStart: {
      style: dt
    },
    paddingBlockEnd: {
      style: dt
    },
    m: {
      style: ft
    },
    mt: {
      style: ft
    },
    mr: {
      style: ft
    },
    mb: {
      style: ft
    },
    ml: {
      style: ft
    },
    mx: {
      style: ft
    },
    my: {
      style: ft
    },
    margin: {
      style: ft
    },
    marginTop: {
      style: ft
    },
    marginRight: {
      style: ft
    },
    marginBottom: {
      style: ft
    },
    marginLeft: {
      style: ft
    },
    marginX: {
      style: ft
    },
    marginY: {
      style: ft
    },
    marginInline: {
      style: ft
    },
    marginInlineStart: {
      style: ft
    },
    marginInlineEnd: {
      style: ft
    },
    marginBlock: {
      style: ft
    },
    marginBlockStart: {
      style: ft
    },
    marginBlockEnd: {
      style: ft
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (t10) => ({
        "@media print": {
          display: t10
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: dl
    },
    rowGap: {
      style: pl
    },
    columnGap: {
      style: hl
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: Kt
    },
    maxWidth: {
      style: xf
    },
    minWidth: {
      transform: Kt
    },
    height: {
      transform: Kt
    },
    maxHeight: {
      transform: Kt
    },
    minHeight: {
      transform: Kt
    },
    boxSizing: {},
    // typography
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  }, _f = s8;
  function a8(...t10) {
    const e = t10.reduce((n, i) => n.concat(Object.keys(i)), []), r = new Set(e);
    return t10.every((n) => r.size === Object.keys(n).length);
  }
  function l8(t10, e) {
    return typeof t10 == "function" ? t10(e) : t10;
  }
  function c8() {
    function t10(r, n, i, o) {
      const s = {
        [r]: n,
        theme: i
      }, a = o[r];
      if (!a)
        return {
          [r]: n
        };
      const {
        cssProperty: l = r,
        themeKey: c,
        transform: u,
        style: f
      } = a;
      if (n == null)
        return null;
      if (c === "typography" && n === "inherit")
        return {
          [r]: n
        };
      const d = al(i, c) || {};
      return f ? f(s) : Kr(s, n, (g) => {
        let p = Da(d, u, g);
        return g === p && typeof g == "string" && (p = Da(d, u, `${r}${g === "default" ? "" : or(g)}`, g)), l === false ? p : {
          [l]: p
        };
      });
    }
    function e(r) {
      var n;
      const {
        sx: i,
        theme: o = {}
      } = r || {};
      if (!i)
        return null;
      const s = (n = o.unstable_sxConfig) != null ? n : _f;
      function a(l) {
        let c = l;
        if (typeof l == "function")
          c = l(o);
        else if (typeof l != "object")
          return l;
        if (!c)
          return null;
        const u = x9(o.breakpoints), f = Object.keys(u);
        let d = u;
        return Object.keys(c).forEach((h) => {
          const g = l8(c[h], o);
          if (g != null)
            if (typeof g == "object")
              if (s[h])
                d = _o(d, t10(h, g, o, s));
              else {
                const p = Kr({
                  theme: o
                }, g, (y) => ({
                  [h]: y
                }));
                a8(p, g) ? d[h] = e({
                  sx: g,
                  theme: o
                }) : d = _o(d, p);
              }
            else
              d = _o(d, t10(h, g, o, s));
        }), _9(f, d);
      }
      return Array.isArray(i) ? i.map(a) : a(i);
    }
    return e;
  }
  const pm = c8();
  pm.filterProps = ["sx"];
  const Sf = pm, u8 = ["breakpoints", "palette", "spacing", "shape"];
  function Ef(t10 = {}, ...e) {
    const {
      breakpoints: r = {},
      palette: n = {},
      spacing: i,
      shape: o = {}
    } = t10, s = sl(t10, u8), a = b9(r), l = P9(i);
    let c = qr({
      breakpoints: a,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: kt({
        mode: "light"
      }, n),
      spacing: l,
      shape: kt({}, A9, o)
    }, s);
    return c = e.reduce((u, f) => qr(u, f), c), c.unstable_sxConfig = kt({}, _f, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function(f) {
      return Sf({
        sx: f,
        theme: this
      });
    }, c;
  }
  function f8(t10) {
    return Object.keys(t10).length === 0;
  }
  function gm(t10 = null) {
    const e = reactExports.useContext(ol);
    return !e || f8(e) ? t10 : e;
  }
  const d8 = Ef();
  function mm(t10 = d8) {
    return gm(t10);
  }
  const h8 = ["variant"];
  function Hp(t10) {
    return t10.length === 0;
  }
  function ym(t10) {
    const {
      variant: e
    } = t10, r = sl(t10, h8);
    let n = e || "";
    return Object.keys(r).sort().forEach((i) => {
      i === "color" ? n += Hp(n) ? t10[i] : or(t10[i]) : n += `${Hp(n) ? i : or(i)}${or(t10[i].toString())}`;
    }), n;
  }
  const p8 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function g8(t10) {
    return Object.keys(t10).length === 0;
  }
  function m8(t10) {
    return typeof t10 == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    t10.charCodeAt(0) > 96;
  }
  const y8 = (t10, e) => e.components && e.components[t10] && e.components[t10].styleOverrides ? e.components[t10].styleOverrides : null, b8 = (t10, e) => {
    let r = [];
    e && e.components && e.components[t10] && e.components[t10].variants && (r = e.components[t10].variants);
    const n = {};
    return r.forEach((i) => {
      const o = ym(i.props);
      n[o] = i.style;
    }), n;
  }, v8 = (t10, e, r, n) => {
    var i, o;
    const {
      ownerState: s = {}
    } = t10, a = [], l = r == null || (i = r.components) == null || (o = i[n]) == null ? void 0 : o.variants;
    return l && l.forEach((c) => {
      let u = true;
      Object.keys(c.props).forEach((f) => {
        s[f] !== c.props[f] && t10[f] !== c.props[f] && (u = false);
      }), u && a.push(e[ym(c.props)]);
    }), a;
  };
  function ta(t10) {
    return t10 !== "ownerState" && t10 !== "theme" && t10 !== "sx" && t10 !== "as";
  }
  const A8 = Ef(), w8 = (t10) => t10.charAt(0).toLowerCase() + t10.slice(1);
  function eo({
    defaultTheme: t10,
    theme: e,
    themeId: r
  }) {
    return g8(e) ? t10 : e[r] || e;
  }
  function x8(t10 = {}) {
    const {
      themeId: e,
      defaultTheme: r = A8,
      rootShouldForwardProp: n = ta,
      slotShouldForwardProp: i = ta
    } = t10, o = (s) => Sf(kt({}, s, {
      theme: eo(kt({}, s, {
        defaultTheme: r,
        themeId: e
      }))
    }));
    return o.__mui_systemSx = true, (s, a = {}) => {
      g9(s, (O) => O.filter((_) => !(_ != null && _.__mui_systemSx)));
      const {
        name: l,
        slot: c,
        skipVariantsResolver: u,
        skipSx: f,
        overridesResolver: d
      } = a, h = sl(a, p8), g = u !== void 0 ? u : c && c !== "Root" || false, p = f || false;
      let y;
      define_process_env_default.NODE_ENV !== "production" && l && (y = `${l}-${w8(c || "Root")}`);
      let b = ta;
      c === "Root" ? b = n : c ? b = i : m8(s) && (b = void 0);
      const x = p9(s, kt({
        shouldForwardProp: b,
        label: y
      }, h)), S = (O, ..._) => {
        const L = _ ? _.map((G) => typeof G == "function" && G.__emotion_real !== G ? (ee) => G(kt({}, ee, {
          theme: eo(kt({}, ee, {
            defaultTheme: r,
            themeId: e
          }))
        })) : G) : [];
        let N = O;
        l && d && L.push((G) => {
          const ee = eo(kt({}, G, {
            defaultTheme: r,
            themeId: e
          })), fe = y8(l, ee);
          if (fe) {
            const P10 = {};
            return Object.entries(fe).forEach(([z10, U]) => {
              P10[z10] = typeof U == "function" ? U(kt({}, G, {
                theme: ee
              })) : U;
            }), d(G, P10);
          }
          return null;
        }), l && !g && L.push((G) => {
          const ee = eo(kt({}, G, {
            defaultTheme: r,
            themeId: e
          }));
          return v8(G, b8(l, ee), ee, l);
        }), p || L.push(o);
        const j = L.length - _.length;
        if (Array.isArray(O) && j > 0) {
          const G = new Array(j).fill("");
          N = [...O, ...G], N.raw = [...O.raw, ...G];
        } else
          typeof O == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
          // component stays as a function. This condition makes sure that we do not interpolate functions
          // which are basically components used as a selectors.
          O.__emotion_real !== O && (N = (G) => O(kt({}, G, {
            theme: eo(kt({}, G, {
              defaultTheme: r,
              themeId: e
            }))
          })));
        const W = x(N, ...L);
        if (define_process_env_default.NODE_ENV !== "production") {
          let G;
          l && (G = `${l}${c || ""}`), G === void 0 && (G = `Styled(${c4(s)})`), W.displayName = G;
        }
        return s.muiName && (W.muiName = s.muiName), W;
      };
      return x.withConfig && (S.withConfig = x.withConfig), S;
    };
  }
  function _8(t10) {
    const {
      theme: e,
      name: r,
      props: n
    } = t10;
    return !e || !e.components || !e.components[r] || !e.components[r].defaultProps ? n : Fg(e.components[r].defaultProps, n);
  }
  function S8({
    props: t10,
    name: e,
    defaultTheme: r,
    themeId: n
  }) {
    let i = mm(r);
    return n && (i = i[n] || i), _8({
      theme: i,
      name: e,
      props: t10
    });
  }
  function kf(t10, e = 0, r = 1) {
    return define_process_env_default.NODE_ENV !== "production" && (t10 < e || t10 > r) && console.error(`MUI: The value provided ${t10} is out of range [${e}, ${r}].`), Math.min(Math.max(e, t10), r);
  }
  function E8(t10) {
    t10 = t10.slice(1);
    const e = new RegExp(`.{1,${t10.length >= 6 ? 2 : 1}}`, "g");
    let r = t10.match(e);
    return r && r[0].length === 1 && (r = r.map((n) => n + n)), r ? `rgb${r.length === 4 ? "a" : ""}(${r.map((n, i) => i < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
  }
  function Qn(t10) {
    if (t10.type)
      return t10;
    if (t10.charAt(0) === "#")
      return Qn(E8(t10));
    const e = t10.indexOf("("), r = t10.substring(0, e);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(r) === -1)
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: Unsupported \`${t10}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : Ti(9, t10));
    let n = t10.substring(e + 1, t10.length - 1), i;
    if (r === "color") {
      if (n = n.split(" "), i = n.shift(), n.length === 4 && n[3].charAt(0) === "/" && (n[3] = n[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1)
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: unsupported \`${i}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : Ti(10, i));
    } else
      n = n.split(",");
    return n = n.map((o) => parseFloat(o)), {
      type: r,
      values: n,
      colorSpace: i
    };
  }
  function gl(t10) {
    const {
      type: e,
      colorSpace: r
    } = t10;
    let {
      values: n
    } = t10;
    return e.indexOf("rgb") !== -1 ? n = n.map((i, o) => o < 3 ? parseInt(i, 10) : i) : e.indexOf("hsl") !== -1 && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), e.indexOf("color") !== -1 ? n = `${r} ${n.join(" ")}` : n = `${n.join(", ")}`, `${e}(${n})`;
  }
  function k8(t10) {
    t10 = Qn(t10);
    const {
      values: e
    } = t10, r = e[0], n = e[1] / 100, i = e[2] / 100, o = n * Math.min(i, 1 - i), s = (c, u = (c + r / 30) % 12) => i - o * Math.max(Math.min(u - 3, 9 - u, 1), -1);
    let a = "rgb";
    const l = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
    return t10.type === "hsla" && (a += "a", l.push(e[3])), gl({
      type: a,
      values: l
    });
  }
  function Yp(t10) {
    t10 = Qn(t10);
    let e = t10.type === "hsl" || t10.type === "hsla" ? Qn(k8(t10)).values : t10.values;
    return e = e.map((r) => (t10.type !== "color" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3));
  }
  function Kp(t10, e) {
    const r = Yp(t10), n = Yp(e);
    return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05);
  }
  function bm(t10, e) {
    return t10 = Qn(t10), e = kf(e), (t10.type === "rgb" || t10.type === "hsl") && (t10.type += "a"), t10.type === "color" ? t10.values[3] = `/${e}` : t10.values[3] = e, gl(t10);
  }
  function C8(t10, e) {
    if (t10 = Qn(t10), e = kf(e), t10.type.indexOf("hsl") !== -1)
      t10.values[2] *= 1 - e;
    else if (t10.type.indexOf("rgb") !== -1 || t10.type.indexOf("color") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] *= 1 - e;
    return gl(t10);
  }
  function T8(t10, e) {
    if (t10 = Qn(t10), e = kf(e), t10.type.indexOf("hsl") !== -1)
      t10.values[2] += (100 - t10.values[2]) * e;
    else if (t10.type.indexOf("rgb") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] += (255 - t10.values[r]) * e;
    else if (t10.type.indexOf("color") !== -1)
      for (let r = 0; r < 3; r += 1)
        t10.values[r] += (1 - t10.values[r]) * e;
    return gl(t10);
  }
  function O8(t10, e) {
    return ke({
      toolbar: {
        minHeight: 56,
        [t10.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [t10.up("sm")]: {
          minHeight: 64
        }
      }
    }, e);
  }
  const I8 = {
    black: "#000",
    white: "#fff"
  }, qo = I8, P8 = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  }, R8 = P8, D8 = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  }, ni = D8, M8 = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  }, ii = M8, N8 = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  }, to = N8, L8 = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  }, oi = L8, B8 = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  }, si = B8, F8 = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  }, ai = F8, j8 = ["mode", "contrastThreshold", "tonalOffset"], Xp = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: qo.white,
      default: qo.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  }, bc = {
    text: {
      primary: qo.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: qo.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
  function Jp(t10, e, r, n) {
    const i = n.light || n, o = n.dark || n * 1.5;
    t10[e] || (t10.hasOwnProperty(r) ? t10[e] = t10[r] : e === "light" ? t10.light = T8(t10.main, i) : e === "dark" && (t10.dark = C8(t10.main, o)));
  }
  function W8(t10 = "light") {
    return t10 === "dark" ? {
      main: oi[200],
      light: oi[50],
      dark: oi[400]
    } : {
      main: oi[700],
      light: oi[400],
      dark: oi[800]
    };
  }
  function U8(t10 = "light") {
    return t10 === "dark" ? {
      main: ni[200],
      light: ni[50],
      dark: ni[400]
    } : {
      main: ni[500],
      light: ni[300],
      dark: ni[700]
    };
  }
  function z8(t10 = "light") {
    return t10 === "dark" ? {
      main: ii[500],
      light: ii[300],
      dark: ii[700]
    } : {
      main: ii[700],
      light: ii[400],
      dark: ii[800]
    };
  }
  function V8(t10 = "light") {
    return t10 === "dark" ? {
      main: si[400],
      light: si[300],
      dark: si[700]
    } : {
      main: si[700],
      light: si[500],
      dark: si[900]
    };
  }
  function q8(t10 = "light") {
    return t10 === "dark" ? {
      main: ai[400],
      light: ai[300],
      dark: ai[700]
    } : {
      main: ai[800],
      light: ai[500],
      dark: ai[900]
    };
  }
  function H8(t10 = "light") {
    return t10 === "dark" ? {
      main: to[400],
      light: to[300],
      dark: to[700]
    } : {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: to[500],
      dark: to[900]
    };
  }
  function Y8(t10) {
    const {
      mode: e = "light",
      contrastThreshold: r = 3,
      tonalOffset: n = 0.2
    } = t10, i = An(t10, j8), o = t10.primary || W8(e), s = t10.secondary || U8(e), a = t10.error || z8(e), l = t10.info || V8(e), c = t10.success || q8(e), u = t10.warning || H8(e);
    function f(p) {
      const y = Kp(p, bc.text.primary) >= r ? bc.text.primary : Xp.text.primary;
      if (define_process_env_default.NODE_ENV !== "production") {
        const b = Kp(p, y);
        b < 3 && console.error([`MUI: The contrast ratio of ${b}:1 for ${y} on ${p}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
      }
      return y;
    }
    const d = ({
      color: p,
      name: y,
      mainShade: b = 500,
      lightShade: x = 300,
      darkShade: S = 700
    }) => {
      if (p = ke({}, p), !p.main && p[b] && (p.main = p[b]), !p.hasOwnProperty("main"))
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${b}\` property.` : Ti(11, y ? ` (${y})` : "", b));
      if (typeof p.main != "string")
        throw new Error(define_process_env_default.NODE_ENV !== "production" ? `MUI: The color${y ? ` (${y})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(p.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : Ti(12, y ? ` (${y})` : "", JSON.stringify(p.main)));
      return Jp(p, "light", x, n), Jp(p, "dark", S, n), p.contrastText || (p.contrastText = f(p.main)), p;
    }, h = {
      dark: bc,
      light: Xp
    };
    return define_process_env_default.NODE_ENV !== "production" && (h[e] || console.error(`MUI: The palette mode \`${e}\` is not supported.`)), qr(ke({
      // A collection of common colors.
      common: ke({}, qo),
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode: e,
      // The colors used to represent primary interface elements for a user.
      primary: d({
        color: o,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: d({
        color: s,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: d({
        color: a,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: d({
        color: u,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: d({
        color: l,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: d({
        color: c,
        name: "success"
      }),
      // The grey colors.
      grey: R8,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: r,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: f,
      // Generate a rich color object.
      augmentColor: d,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: n
    }, h[e]), i);
  }
  const K8 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
  function X8(t10) {
    return Math.round(t10 * 1e5) / 1e5;
  }
  const Qp = {
    textTransform: "uppercase"
  }, Gp = '"Roboto", "Helvetica", "Arial", sans-serif';
  function J8(t10, e) {
    const r = typeof e == "function" ? e(t10) : e, {
      fontFamily: n = Gp,
      // The default font size of the Material Specification.
      fontSize: i = 14,
      // px
      fontWeightLight: o = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: l = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: c = 16,
      // Apply the CSS properties to all the variants.
      allVariants: u,
      pxToRem: f
    } = r, d = An(r, K8);
    define_process_env_default.NODE_ENV !== "production" && (typeof i != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof c != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
    const h = i / 14, g = f || ((b) => `${b / c * h}rem`), p = (b, x, S, O, _) => ke({
      fontFamily: n,
      fontWeight: b,
      fontSize: g(x),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: S
    }, n === Gp ? {
      letterSpacing: `${X8(O / x)}em`
    } : {}, _, u), y = {
      h1: p(o, 96, 1.167, -1.5),
      h2: p(o, 60, 1.2, -0.5),
      h3: p(s, 48, 1.167, 0),
      h4: p(s, 34, 1.235, 0.25),
      h5: p(s, 24, 1.334, 0),
      h6: p(a, 20, 1.6, 0.15),
      subtitle1: p(s, 16, 1.75, 0.15),
      subtitle2: p(a, 14, 1.57, 0.1),
      body1: p(s, 16, 1.5, 0.15),
      body2: p(s, 14, 1.43, 0.15),
      button: p(a, 14, 1.75, 0.4, Qp),
      caption: p(s, 12, 1.66, 0.4),
      overline: p(s, 12, 2.66, 1, Qp),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return qr(ke({
      htmlFontSize: c,
      pxToRem: g,
      fontFamily: n,
      fontSize: i,
      fontWeightLight: o,
      fontWeightRegular: s,
      fontWeightMedium: a,
      fontWeightBold: l
    }, y), d, {
      clone: false
      // No need to clone deep
    });
  }
  const Q8 = 0.2, G8 = 0.14, Z8 = 0.12;
  function ct(...t10) {
    return [`${t10[0]}px ${t10[1]}px ${t10[2]}px ${t10[3]}px rgba(0,0,0,${Q8})`, `${t10[4]}px ${t10[5]}px ${t10[6]}px ${t10[7]}px rgba(0,0,0,${G8})`, `${t10[8]}px ${t10[9]}px ${t10[10]}px ${t10[11]}px rgba(0,0,0,${Z8})`].join(",");
  }
  const $8 = ["none", ct(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), ct(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), ct(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), ct(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), ct(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), ct(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), ct(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), ct(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), ct(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), ct(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), ct(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), ct(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), ct(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), ct(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), ct(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), ct(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), ct(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), ct(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), ct(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), ct(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), ct(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), ct(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), ct(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), ct(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], e7 = $8, t7 = ["duration", "easing", "delay"], r7 = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  }, n7 = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function Zp(t10) {
    return `${Math.round(t10)}ms`;
  }
  function i7(t10) {
    if (!t10)
      return 0;
    const e = t10 / 36;
    return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
  }
  function o7(t10) {
    const e = ke({}, r7, t10.easing), r = ke({}, n7, t10.duration);
    return ke({
      getAutoHeightDuration: i7,
      create: (i = ["all"], o = {}) => {
        const {
          duration: s = r.standard,
          easing: a = e.easeInOut,
          delay: l = 0
        } = o, c = An(o, t7);
        if (define_process_env_default.NODE_ENV !== "production") {
          const u = (d) => typeof d == "string", f = (d) => !isNaN(parseFloat(d));
          !u(i) && !Array.isArray(i) && console.error('MUI: Argument "props" must be a string or Array.'), !f(s) && !u(s) && console.error(`MUI: Argument "duration" must be a number or a string but found ${s}.`), u(a) || console.error('MUI: Argument "easing" must be a string.'), !f(l) && !u(l) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(c).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(c).join(",")}].`);
        }
        return (Array.isArray(i) ? i : [i]).map((u) => `${u} ${typeof s == "string" ? s : Zp(s)} ${a} ${typeof l == "string" ? l : Zp(l)}`).join(",");
      }
    }, t10, {
      easing: e,
      duration: r
    });
  }
  const s7 = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  }, a7 = s7, l7 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
  function c7(t10 = {}, ...e) {
    const {
      mixins: r = {},
      palette: n = {},
      transitions: i = {},
      typography: o = {}
    } = t10, s = An(t10, l7);
    if (t10.vars)
      throw new Error(define_process_env_default.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : Ti(18));
    const a = Y8(n), l = Ef(t10);
    let c = qr(l, {
      mixins: O8(l.breakpoints, r),
      palette: a,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: e7.slice(),
      typography: J8(a, o),
      transitions: o7(i),
      zIndex: ke({}, a7)
    });
    if (c = qr(c, s), c = e.reduce((u, f) => qr(u, f), c), define_process_env_default.NODE_ENV !== "production") {
      const u = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], f = (d, h) => {
        let g;
        for (g in d) {
          const p = d[g];
          if (u.indexOf(g) !== -1 && Object.keys(p).length > 0) {
            if (define_process_env_default.NODE_ENV !== "production") {
              const y = Zo("", g);
              console.error([`MUI: The \`${h}\` component increases the CSS specificity of the \`${g}\` internal state.`, "You can not override it like this: ", JSON.stringify(d, null, 2), "", `Instead, you need to use the '&.${y}' syntax:`, JSON.stringify({
                root: {
                  [`&.${y}`]: p
                }
              }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
            }
            d[g] = {};
          }
        }
      };
      Object.keys(c.components).forEach((d) => {
        const h = c.components[d].styleOverrides;
        h && d.indexOf("Mui") === 0 && f(h, d);
      });
    }
    return c.unstable_sxConfig = ke({}, _f, s == null ? void 0 : s.unstable_sxConfig), c.unstable_sx = function(f) {
      return Sf({
        sx: f,
        theme: this
      });
    }, c;
  }
  const u7 = c7(), Cf = u7, Tf = "$$material", f7 = (t10) => ta(t10) && t10 !== "classes", d7 = x8({
    themeId: Tf,
    defaultTheme: Cf,
    rootShouldForwardProp: f7
  }), is = d7;
  function Of({
    props: t10,
    name: e
  }) {
    return S8({
      props: t10,
      name: e,
      defaultTheme: Cf,
      themeId: Tf
    });
  }
  function h7(t10, e) {
    if (t10 == null)
      return {};
    var r = {}, n = Object.keys(t10), i, o;
    for (o = 0; o < n.length; o++)
      i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t10[i]);
    return r;
  }
  function p7(t10, e) {
    t10.prototype = Object.create(e.prototype), t10.prototype.constructor = t10, t10.__proto__ = e;
  }
  const $p = {
    disabled: false
  };
  var g7 = define_process_env_default.NODE_ENV !== "production" ? F.oneOfType([F.number, F.shape({
    enter: F.number,
    exit: F.number,
    appear: F.number
  }).isRequired]) : null;
  define_process_env_default.NODE_ENV !== "production" && F.oneOfType([F.string, F.shape({
    enter: F.string,
    exit: F.string,
    active: F.string
  }), F.shape({
    enter: F.string,
    enterDone: F.string,
    enterActive: F.string,
    exit: F.string,
    exitDone: F.string,
    exitActive: F.string
  })]);
  const vm = K.createContext(null);
  var m7 = function(e) {
    return e.scrollTop;
  }, ho = "unmounted", Mn = "exited", Nn = "entering", fi = "entered", fu = "exiting", Qr = /* @__PURE__ */ function(t10) {
    p7(e, t10);
    function e(n, i) {
      var o;
      o = t10.call(this, n, i) || this;
      var s = i, a = s && !s.isMounting ? n.enter : n.appear, l;
      return o.appearStatus = null, n.in ? a ? (l = Mn, o.appearStatus = Nn) : l = fi : n.unmountOnExit || n.mountOnEnter ? l = ho : l = Mn, o.state = {
        status: l
      }, o.nextCallback = null, o;
    }
    e.getDerivedStateFromProps = function(i, o) {
      var s = i.in;
      return s && o.status === ho ? {
        status: Mn
      } : null;
    };
    var r = e.prototype;
    return r.componentDidMount = function() {
      this.updateStatus(true, this.appearStatus);
    }, r.componentDidUpdate = function(i) {
      var o = null;
      if (i !== this.props) {
        var s = this.state.status;
        this.props.in ? s !== Nn && s !== fi && (o = Nn) : (s === Nn || s === fi) && (o = fu);
      }
      this.updateStatus(false, o);
    }, r.componentWillUnmount = function() {
      this.cancelNextCallback();
    }, r.getTimeouts = function() {
      var i = this.props.timeout, o, s, a;
      return o = s = a = i, i != null && typeof i != "number" && (o = i.exit, s = i.enter, a = i.appear !== void 0 ? i.appear : s), {
        exit: o,
        enter: s,
        appear: a
      };
    }, r.updateStatus = function(i, o) {
      if (i === void 0 && (i = false), o !== null)
        if (this.cancelNextCallback(), o === Nn) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var s = this.props.nodeRef ? this.props.nodeRef.current : Wt.findDOMNode(this);
            s && m7(s);
          }
          this.performEnter(i);
        } else
          this.performExit();
      else
        this.props.unmountOnExit && this.state.status === Mn && this.setState({
          status: ho
        });
    }, r.performEnter = function(i) {
      var o = this, s = this.props.enter, a = this.context ? this.context.isMounting : i, l = this.props.nodeRef ? [a] : [Wt.findDOMNode(this), a], c = l[0], u = l[1], f = this.getTimeouts(), d = a ? f.appear : f.enter;
      if (!i && !s || $p.disabled) {
        this.safeSetState({
          status: fi
        }, function() {
          o.props.onEntered(c);
        });
        return;
      }
      this.props.onEnter(c, u), this.safeSetState({
        status: Nn
      }, function() {
        o.props.onEntering(c, u), o.onTransitionEnd(d, function() {
          o.safeSetState({
            status: fi
          }, function() {
            o.props.onEntered(c, u);
          });
        });
      });
    }, r.performExit = function() {
      var i = this, o = this.props.exit, s = this.getTimeouts(), a = this.props.nodeRef ? void 0 : Wt.findDOMNode(this);
      if (!o || $p.disabled) {
        this.safeSetState({
          status: Mn
        }, function() {
          i.props.onExited(a);
        });
        return;
      }
      this.props.onExit(a), this.safeSetState({
        status: fu
      }, function() {
        i.props.onExiting(a), i.onTransitionEnd(s.exit, function() {
          i.safeSetState({
            status: Mn
          }, function() {
            i.props.onExited(a);
          });
        });
      });
    }, r.cancelNextCallback = function() {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
    }, r.safeSetState = function(i, o) {
      o = this.setNextCallback(o), this.setState(i, o);
    }, r.setNextCallback = function(i) {
      var o = this, s = true;
      return this.nextCallback = function(a) {
        s && (s = false, o.nextCallback = null, i(a));
      }, this.nextCallback.cancel = function() {
        s = false;
      }, this.nextCallback;
    }, r.onTransitionEnd = function(i, o) {
      this.setNextCallback(o);
      var s = this.props.nodeRef ? this.props.nodeRef.current : Wt.findDOMNode(this), a = i == null && !this.props.addEndListener;
      if (!s || a) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var l = this.props.nodeRef ? [this.nextCallback] : [s, this.nextCallback], c = l[0], u = l[1];
        this.props.addEndListener(c, u);
      }
      i != null && setTimeout(this.nextCallback, i);
    }, r.render = function() {
      var i = this.state.status;
      if (i === ho)
        return null;
      var o = this.props, s = o.children;
      o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
      var a = h7(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ K.createElement(vm.Provider, {
          value: null
        }, typeof s == "function" ? s(i, a) : K.cloneElement(K.Children.only(s), a))
      );
    }, e;
  }(K.Component);
  Qr.contextType = vm;
  Qr.propTypes = define_process_env_default.NODE_ENV !== "production" ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: F.shape({
      current: typeof Element > "u" ? F.any : function(t10, e, r, n, i, o) {
        var s = t10[e];
        return F.instanceOf(s && "ownerDocument" in s ? s.ownerDocument.defaultView.Element : Element)(t10, e, r, n, i, o);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: F.oneOfType([F.func.isRequired, F.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: F.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: F.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: F.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: F.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: F.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: F.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function(e) {
      var r = g7;
      e.addEndListener || (r = r.isRequired);
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
        i[o - 1] = arguments[o];
      return r.apply(void 0, [e].concat(i));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: F.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: F.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: F.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: F.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: F.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: F.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: F.func
  } : {};
  function li() {
  }
  Qr.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: li,
    onEntering: li,
    onEntered: li,
    onExit: li,
    onExiting: li,
    onExited: li
  };
  Qr.UNMOUNTED = ho;
  Qr.EXITED = Mn;
  Qr.ENTERING = Nn;
  Qr.ENTERED = fi;
  Qr.EXITING = fu;
  const y7 = Qr;
  function Am() {
    const t10 = mm(Cf);
    return define_process_env_default.NODE_ENV !== "production" && reactExports.useDebugValue(t10), t10[Tf] || t10;
  }
  const b7 = (t10) => t10.scrollTop;
  function e0(t10, e) {
    var r, n;
    const {
      timeout: i,
      easing: o,
      style: s = {}
    } = t10;
    return {
      duration: (r = s.transitionDuration) != null ? r : typeof i == "number" ? i : i[e.mode] || 0,
      easing: (n = s.transitionTimingFunction) != null ? n : typeof o == "object" ? o[e.mode] : o,
      delay: s.transitionDelay
    };
  }
  const v7 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  function du(t10) {
    return `scale(${t10}, ${t10 ** 2})`;
  }
  const A7 = {
    entering: {
      opacity: 1,
      transform: du(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  }, vc = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), If = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const {
      addEndListener: n,
      appear: i = true,
      children: o,
      easing: s,
      in: a,
      onEnter: l,
      onEntered: c,
      onEntering: u,
      onExit: f,
      onExited: d,
      onExiting: h,
      style: g,
      timeout: p = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent: y = y7
    } = e, b = An(e, v7), x = reactExports.useRef(), S = reactExports.useRef(), O = Am(), _ = reactExports.useRef(null), L = Xn(_, o.ref, r), N = (U) => (I) => {
      if (U) {
        const V = _.current;
        I === void 0 ? U(V) : U(V, I);
      }
    }, j = N(u), W = N((U, I) => {
      b7(U);
      const {
        duration: V,
        delay: te,
        easing: X
      } = e0({
        style: g,
        timeout: p,
        easing: s
      }, {
        mode: "enter"
      });
      let H;
      p === "auto" ? (H = O.transitions.getAutoHeightDuration(U.clientHeight), S.current = H) : H = V, U.style.transition = [O.transitions.create("opacity", {
        duration: H,
        delay: te
      }), O.transitions.create("transform", {
        duration: vc ? H : H * 0.666,
        delay: te,
        easing: X
      })].join(","), l && l(U, I);
    }), G = N(c), ee = N(h), fe = N((U) => {
      const {
        duration: I,
        delay: V,
        easing: te
      } = e0({
        style: g,
        timeout: p,
        easing: s
      }, {
        mode: "exit"
      });
      let X;
      p === "auto" ? (X = O.transitions.getAutoHeightDuration(U.clientHeight), S.current = X) : X = I, U.style.transition = [O.transitions.create("opacity", {
        duration: X,
        delay: V
      }), O.transitions.create("transform", {
        duration: vc ? X : X * 0.666,
        delay: vc ? V : V || X * 0.333,
        easing: te
      })].join(","), U.style.opacity = 0, U.style.transform = du(0.75), f && f(U);
    }), P10 = N(d), z10 = (U) => {
      p === "auto" && (x.current = setTimeout(U, S.current || 0)), n && n(_.current, U);
    };
    return reactExports.useEffect(() => () => {
      clearTimeout(x.current);
    }, []), /* @__PURE__ */ Lt.jsx(y, ke({
      appear: i,
      in: a,
      nodeRef: _,
      onEnter: W,
      onEntered: G,
      onEntering: j,
      onExit: fe,
      onExited: P10,
      onExiting: ee,
      addEndListener: z10,
      timeout: p === "auto" ? null : p
    }, b, {
      children: (U, I) => /* @__PURE__ */ reactExports.cloneElement(o, ke({
        style: ke({
          opacity: 0,
          transform: du(0.75),
          visibility: U === "exited" && !a ? "hidden" : void 0
        }, A7[U], g, o.props.style),
        ref: L
      }, I))
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (If.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * Add a custom transition end trigger. Called with the transitioning DOM
     * node and a done callback. Allows for more fine grained transition end
     * logic. Note: Timeouts are still used as a fallback if provided.
     */
    addEndListener: F.func,
    /**
     * Perform the enter transition when it first mounts if `in` is also `true`.
     * Set this to `false` to disable this behavior.
     * @default true
     */
    appear: F.bool,
    /**
     * A single child content element.
     */
    children: Pg.isRequired,
    /**
     * The transition timing function.
     * You may specify a single easing or a object containing enter and exit values.
     */
    easing: F.oneOfType([F.shape({
      enter: F.string,
      exit: F.string
    }), F.string]),
    /**
     * If `true`, the component will transition in.
     */
    in: F.bool,
    /**
     * @ignore
     */
    onEnter: F.func,
    /**
     * @ignore
     */
    onEntered: F.func,
    /**
     * @ignore
     */
    onEntering: F.func,
    /**
     * @ignore
     */
    onExit: F.func,
    /**
     * @ignore
     */
    onExited: F.func,
    /**
     * @ignore
     */
    onExiting: F.func,
    /**
     * @ignore
     */
    style: F.object,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     *
     * Set to 'auto' to automatically calculate transition time based on height.
     * @default 'auto'
     */
    timeout: F.oneOfType([F.oneOf(["auto"]), F.number, F.shape({
      appear: F.number,
      enter: F.number,
      exit: F.number
    })])
  });
  If.muiSupportAuto = true;
  const t0 = If, w7 = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"], x7 = is(s_, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (t10, e) => e.root
  })({}), wm = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n;
    const i = gm(), o = Of({
      props: e,
      name: "MuiPopper"
    }), {
      anchorEl: s,
      component: a,
      components: l,
      componentsProps: c,
      container: u,
      disablePortal: f,
      keepMounted: d,
      modifiers: h,
      open: g,
      placement: p,
      popperOptions: y,
      popperRef: b,
      transition: x,
      slots: S,
      slotProps: O
    } = o, _ = An(o, w7), L = (n = S == null ? void 0 : S.root) != null ? n : l == null ? void 0 : l.Root, N = ke({
      anchorEl: s,
      container: u,
      disablePortal: f,
      keepMounted: d,
      modifiers: h,
      open: g,
      placement: p,
      popperOptions: y,
      popperRef: b,
      transition: x
    }, _);
    return /* @__PURE__ */ Lt.jsx(x7, ke({
      as: a,
      direction: i == null ? void 0 : i.direction,
      slots: {
        root: L
      },
      slotProps: O ?? c
    }, N, {
      ref: r
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (wm.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: F.oneOfType([Fo, F.object, F.func]),
    /**
     * Popper render function or node.
     */
    children: F.oneOfType([F.node, F.func]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: F.elementType,
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    components: F.shape({
      Root: F.elementType
    }),
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    componentsProps: F.shape({
      root: F.oneOfType([F.func, F.object])
    }),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: F.oneOfType([Fo, F.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: F.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: F.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: F.arrayOf(F.shape({
      data: F.object,
      effect: F.func,
      enabled: F.bool,
      fn: F.func,
      name: F.any,
      options: F.object,
      phase: F.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: F.arrayOf(F.string),
      requiresIfExists: F.arrayOf(F.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: F.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: F.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: F.shape({
      modifiers: F.array,
      onFirstUpdate: F.func,
      placement: F.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: F.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: Dg,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: F.shape({
      root: F.oneOfType([F.func, F.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: F.shape({
      root: F.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: F.oneOfType([F.arrayOf(F.oneOfType([F.func, F.object, F.bool])), F.func, F.object]),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: F.bool
  });
  const xm = wm;
  function _7(t10) {
    return Zo("MuiTooltip", t10);
  }
  const S7 = sf("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]), an = S7, E7 = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
  function k7(t10) {
    return Math.round(t10 * 1e5) / 1e5;
  }
  const C7 = (t10) => {
    const {
      classes: e,
      disableInteractive: r,
      arrow: n,
      touch: i,
      placement: o
    } = t10, s = {
      popper: ["popper", !r && "popperInteractive", n && "popperArrow"],
      tooltip: ["tooltip", n && "tooltipArrow", i && "touch", `tooltipPlacement${or(o.split("-")[0])}`],
      arrow: ["arrow"]
    };
    return of(s, _7, e);
  }, T7 = is(xm, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.popper, !r.disableInteractive && e.popperInteractive, r.arrow && e.popperArrow, !r.open && e.popperClose];
    }
  })(({
    theme: t10,
    ownerState: e,
    open: r
  }) => ke({
    zIndex: (t10.vars || t10).zIndex.tooltip,
    pointerEvents: "none"
  }, !e.disableInteractive && {
    pointerEvents: "auto"
  }, !r && {
    pointerEvents: "none"
  }, e.arrow && {
    [`&[data-popper-placement*="bottom"] .${an.arrow}`]: {
      top: 0,
      marginTop: "-0.71em",
      "&::before": {
        transformOrigin: "0 100%"
      }
    },
    [`&[data-popper-placement*="top"] .${an.arrow}`]: {
      bottom: 0,
      marginBottom: "-0.71em",
      "&::before": {
        transformOrigin: "100% 0"
      }
    },
    [`&[data-popper-placement*="right"] .${an.arrow}`]: ke({}, e.isRtl ? {
      right: 0,
      marginRight: "-0.71em"
    } : {
      left: 0,
      marginLeft: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "100% 100%"
      }
    }),
    [`&[data-popper-placement*="left"] .${an.arrow}`]: ke({}, e.isRtl ? {
      left: 0,
      marginLeft: "-0.71em"
    } : {
      right: 0,
      marginRight: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "0 0"
      }
    })
  })), O7 = is("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.tooltip, r.touch && e.touch, r.arrow && e.tooltipArrow, e[`tooltipPlacement${or(r.placement.split("-")[0])}`]];
    }
  })(({
    theme: t10,
    ownerState: e
  }) => ke({
    backgroundColor: t10.vars ? t10.vars.palette.Tooltip.bg : bm(t10.palette.grey[700], 0.92),
    borderRadius: (t10.vars || t10).shape.borderRadius,
    color: (t10.vars || t10).palette.common.white,
    fontFamily: t10.typography.fontFamily,
    padding: "4px 8px",
    fontSize: t10.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: t10.typography.fontWeightMedium
  }, e.arrow && {
    position: "relative",
    margin: 0
  }, e.touch && {
    padding: "8px 16px",
    fontSize: t10.typography.pxToRem(14),
    lineHeight: `${k7(16 / 14)}em`,
    fontWeight: t10.typography.fontWeightRegular
  }, {
    [`.${an.popper}[data-popper-placement*="left"] &`]: ke({
      transformOrigin: "right center"
    }, e.isRtl ? ke({
      marginLeft: "14px"
    }, e.touch && {
      marginLeft: "24px"
    }) : ke({
      marginRight: "14px"
    }, e.touch && {
      marginRight: "24px"
    })),
    [`.${an.popper}[data-popper-placement*="right"] &`]: ke({
      transformOrigin: "left center"
    }, e.isRtl ? ke({
      marginRight: "14px"
    }, e.touch && {
      marginRight: "24px"
    }) : ke({
      marginLeft: "14px"
    }, e.touch && {
      marginLeft: "24px"
    })),
    [`.${an.popper}[data-popper-placement*="top"] &`]: ke({
      transformOrigin: "center bottom",
      marginBottom: "14px"
    }, e.touch && {
      marginBottom: "24px"
    }),
    [`.${an.popper}[data-popper-placement*="bottom"] &`]: ke({
      transformOrigin: "center top",
      marginTop: "14px"
    }, e.touch && {
      marginTop: "24px"
    })
  })), I7 = is("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (t10, e) => e.arrow
  })(({
    theme: t10
  }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: t10.vars ? t10.vars.palette.Tooltip.bg : bm(t10.palette.grey[700], 0.9),
    "&::before": {
      content: '""',
      margin: "auto",
      display: "block",
      width: "100%",
      height: "100%",
      backgroundColor: "currentColor",
      transform: "rotate(45deg)"
    }
  }));
  let Ms = false, Ac = null, ro = {
    x: 0,
    y: 0
  };
  function Ns(t10, e) {
    return (r) => {
      e && e(r), t10(r);
    };
  }
  const _m = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    var n, i, o, s, a, l, c, u, f, d, h, g, p, y, b, x, S, O, _;
    const L = Of({
      props: e,
      name: "MuiTooltip"
    }), {
      arrow: N = false,
      children: j,
      components: W = {},
      componentsProps: G = {},
      describeChild: ee = false,
      disableFocusListener: fe = false,
      disableHoverListener: P10 = false,
      disableInteractive: z10 = false,
      disableTouchListener: U = false,
      enterDelay: I = 100,
      enterNextDelay: V = 0,
      enterTouchDelay: te = 700,
      followCursor: X = false,
      id: H,
      leaveDelay: $ = 0,
      leaveTouchDelay: se = 1500,
      onClose: he,
      onOpen: pe,
      open: me,
      placement: B = "bottom",
      PopperComponent: q,
      PopperProps: Z = {},
      slotProps: oe = {},
      slots: de = {},
      title: R,
      TransitionComponent: k = t0,
      TransitionProps: re
    } = L, ne = An(L, E7), Ae = Am(), C = Ae.direction === "rtl", [v, w] = reactExports.useState(), [D, J] = reactExports.useState(null), ae = reactExports.useRef(false), ue = z10 || X, Se = reactExports.useRef(), _e = reactExports.useRef(), we = reactExports.useRef(), Ne = reactExports.useRef(), [E, m] = Ng({
      controlled: me,
      default: false,
      name: "Tooltip",
      state: "open"
    });
    let A = E;
    if (define_process_env_default.NODE_ENV !== "production") {
      const {
        current: De
      } = reactExports.useRef(me !== void 0);
      reactExports.useEffect(() => {
        v && v.disabled && !De && R !== "" && v.tagName.toLowerCase() === "button" && console.error(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
`));
      }, [R, v, De]);
    }
    const M = Mg(H), Q = reactExports.useRef(), ie = reactExports.useCallback(() => {
      Q.current !== void 0 && (document.body.style.WebkitUserSelect = Q.current, Q.current = void 0), clearTimeout(Ne.current);
    }, []);
    reactExports.useEffect(() => () => {
      clearTimeout(Se.current), clearTimeout(_e.current), clearTimeout(we.current), ie();
    }, [ie]);
    const le = (De) => {
      clearTimeout(Ac), Ms = true, m(true), pe && !A && pe(De);
    }, Ee = Lg(
      /**
       * @param {React.SyntheticEvent | Event} event
       */
      (De) => {
        clearTimeout(Ac), Ac = setTimeout(() => {
          Ms = false;
        }, 800 + $), m(false), he && A && he(De), clearTimeout(Se.current), Se.current = setTimeout(() => {
          ae.current = false;
        }, Ae.transitions.duration.shortest);
      }
    ), Fe = (De) => {
      ae.current && De.type !== "touchstart" || (v && v.removeAttribute("title"), clearTimeout(_e.current), clearTimeout(we.current), I || Ms && V ? _e.current = setTimeout(() => {
        le(De);
      }, Ms ? V : I) : le(De));
    }, Ve = (De) => {
      clearTimeout(_e.current), clearTimeout(we.current), we.current = setTimeout(() => {
        Ee(De);
      }, $);
    }, {
      isFocusVisibleRef: Ge,
      onBlur: Ue,
      onFocus: bl,
      ref: ss
    } = Bg(), [, as] = reactExports.useState(false), Fi = (De) => {
      Ue(De), Ge.current === false && (as(false), Ve(De));
    }, ji = (De) => {
      v || w(De.currentTarget), bl(De), Ge.current === true && (as(true), Fe(De));
    }, ls = (De) => {
      ae.current = true;
      const qt = j.props;
      qt.onTouchStart && qt.onTouchStart(De);
    }, cs = Fe, Wi = Ve, vl = (De) => {
      ls(De), clearTimeout(we.current), clearTimeout(Se.current), ie(), Q.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Ne.current = setTimeout(() => {
        document.body.style.WebkitUserSelect = Q.current, Fe(De);
      }, te);
    }, Al = (De) => {
      j.props.onTouchEnd && j.props.onTouchEnd(De), ie(), clearTimeout(we.current), we.current = setTimeout(() => {
        Ee(De);
      }, se);
    };
    reactExports.useEffect(() => {
      if (!A)
        return;
      function De(qt) {
        (qt.key === "Escape" || qt.key === "Esc") && Ee(qt);
      }
      return document.addEventListener("keydown", De), () => {
        document.removeEventListener("keydown", De);
      };
    }, [Ee, A]);
    const wl = Xn(j.ref, ss, w, r);
    !R && R !== 0 && (A = false);
    const Ui = reactExports.useRef(), Y = (De) => {
      const qt = j.props;
      qt.onMouseMove && qt.onMouseMove(De), ro = {
        x: De.clientX,
        y: De.clientY
      }, Ui.current && Ui.current.update();
    }, ge = {}, be = typeof R == "string";
    ee ? (ge.title = !A && be && !P10 ? R : null, ge["aria-describedby"] = A ? M : null) : (ge["aria-label"] = be ? R : null, ge["aria-labelledby"] = A && !be ? M : null);
    const xe = ke({}, ge, ne, j.props, {
      className: uo(ne.className, j.props.className),
      onTouchStart: ls,
      ref: wl
    }, X ? {
      onMouseMove: Y
    } : {});
    define_process_env_default.NODE_ENV !== "production" && (xe["data-mui-internal-clone-element"] = true, reactExports.useEffect(() => {
      v && !v.getAttribute("data-mui-internal-clone-element") && console.error(["MUI: The `children` component of the Tooltip is not forwarding its props correctly.", "Please make sure that props are spread on the same element that the ref is applied to."].join(`
`));
    }, [v]));
    const je = {};
    U || (xe.onTouchStart = vl, xe.onTouchEnd = Al), P10 || (xe.onMouseOver = Ns(cs, xe.onMouseOver), xe.onMouseLeave = Ns(Wi, xe.onMouseLeave), ue || (je.onMouseOver = cs, je.onMouseLeave = Wi)), fe || (xe.onFocus = Ns(ji, xe.onFocus), xe.onBlur = Ns(Fi, xe.onBlur), ue || (je.onFocus = ji, je.onBlur = Fi)), define_process_env_default.NODE_ENV !== "production" && j.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${j.props.title}\` or the Tooltip component.`].join(`
`));
    const Ze = reactExports.useMemo(() => {
      var De;
      let qt = [{
        name: "arrow",
        enabled: !!D,
        options: {
          element: D,
          padding: 4
        }
      }];
      return (De = Z.popperOptions) != null && De.modifiers && (qt = qt.concat(Z.popperOptions.modifiers)), ke({}, Z.popperOptions, {
        modifiers: qt
      });
    }, [D, Z]), Pe = ke({}, L, {
      isRtl: C,
      arrow: N,
      disableInteractive: ue,
      placement: B,
      PopperComponentProp: q,
      touch: ae.current
    }), Re = C7(Pe), At = (n = (i = de.popper) != null ? i : W.Popper) != null ? n : T7, lt = (o = (s = (a = de.transition) != null ? a : W.Transition) != null ? s : k) != null ? o : t0, ut = (l = (c = de.tooltip) != null ? c : W.Tooltip) != null ? l : O7, Zt = (u = (f = de.arrow) != null ? f : W.Arrow) != null ? u : I7, Gr = fo(At, ke({}, Z, (d = oe.popper) != null ? d : G.popper, {
      className: uo(Re.popper, Z == null ? void 0 : Z.className, (h = (g = oe.popper) != null ? g : G.popper) == null ? void 0 : h.className)
    }), Pe), us = fo(lt, ke({}, re, (p = oe.transition) != null ? p : G.transition), Pe), cr = fo(ut, ke({}, (y = oe.tooltip) != null ? y : G.tooltip, {
      className: uo(Re.tooltip, (b = (x = oe.tooltip) != null ? x : G.tooltip) == null ? void 0 : b.className)
    }), Pe), zm = fo(Zt, ke({}, (S = oe.arrow) != null ? S : G.arrow, {
      className: uo(Re.arrow, (O = (_ = oe.arrow) != null ? _ : G.arrow) == null ? void 0 : O.className)
    }), Pe);
    return /* @__PURE__ */ Lt.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ reactExports.cloneElement(j, xe), /* @__PURE__ */ Lt.jsx(At, ke({
        as: q ?? xm,
        placement: B,
        anchorEl: X ? {
          getBoundingClientRect: () => ({
            top: ro.y,
            left: ro.x,
            right: ro.x,
            bottom: ro.y,
            width: 0,
            height: 0
          })
        } : v,
        popperRef: Ui,
        open: v ? A : false,
        id: M,
        transition: true
      }, je, Gr, {
        popperOptions: Ze,
        children: ({
          TransitionProps: De
        }) => /* @__PURE__ */ Lt.jsx(lt, ke({
          timeout: Ae.transitions.duration.shorter
        }, De, us, {
          children: /* @__PURE__ */ Lt.jsxs(ut, ke({}, cr, {
            children: [R, N ? /* @__PURE__ */ Lt.jsx(Zt, ke({}, zm, {
              ref: J
            })) : null]
          }))
        }))
      }))]
    });
  });
  define_process_env_default.NODE_ENV !== "production" && (_m.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * If `true`, adds an arrow to the tooltip.
     * @default false
     */
    arrow: F.bool,
    /**
     * Tooltip reference element.
     */
    children: Pg.isRequired,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: F.object,
    /**
     * @ignore
     */
    className: F.string,
    /**
     * The components used for each slot inside.
     *
     * This prop is an alias for the `slots` prop.
     * It's recommended to use the `slots` prop instead.
     *
     * @default {}
     */
    components: F.shape({
      Arrow: F.elementType,
      Popper: F.elementType,
      Tooltip: F.elementType,
      Transition: F.elementType
    }),
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * This prop is an alias for the `slotProps` prop.
     * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
     *
     * @default {}
     */
    componentsProps: F.shape({
      arrow: F.object,
      popper: F.object,
      tooltip: F.object,
      transition: F.object
    }),
    /**
     * Set to `true` if the `title` acts as an accessible description.
     * By default the `title` acts as an accessible label for the child.
     * @default false
     */
    describeChild: F.bool,
    /**
     * Do not respond to focus-visible events.
     * @default false
     */
    disableFocusListener: F.bool,
    /**
     * Do not respond to hover events.
     * @default false
     */
    disableHoverListener: F.bool,
    /**
     * Makes a tooltip not interactive, i.e. it will close when the user
     * hovers over the tooltip before the `leaveDelay` is expired.
     * @default false
     */
    disableInteractive: F.bool,
    /**
     * Do not respond to long press touch events.
     * @default false
     */
    disableTouchListener: F.bool,
    /**
     * The number of milliseconds to wait before showing the tooltip.
     * This prop won't impact the enter touch delay (`enterTouchDelay`).
     * @default 100
     */
    enterDelay: F.number,
    /**
     * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
     * @default 0
     */
    enterNextDelay: F.number,
    /**
     * The number of milliseconds a user must touch the element before showing the tooltip.
     * @default 700
     */
    enterTouchDelay: F.number,
    /**
     * If `true`, the tooltip follow the cursor over the wrapped element.
     * @default false
     */
    followCursor: F.bool,
    /**
     * This prop is used to help implement the accessibility logic.
     * If you don't provide this prop. It falls back to a randomly generated id.
     */
    id: F.string,
    /**
     * The number of milliseconds to wait before hiding the tooltip.
     * This prop won't impact the leave touch delay (`leaveTouchDelay`).
     * @default 0
     */
    leaveDelay: F.number,
    /**
     * The number of milliseconds after the user stops touching an element before hiding the tooltip.
     * @default 1500
     */
    leaveTouchDelay: F.number,
    /**
     * Callback fired when the component requests to be closed.
     *
     * @param {React.SyntheticEvent} event The event source of the callback.
     */
    onClose: F.func,
    /**
     * Callback fired when the component requests to be open.
     *
     * @param {React.SyntheticEvent} event The event source of the callback.
     */
    onOpen: F.func,
    /**
     * If `true`, the component is shown.
     */
    open: F.bool,
    /**
     * Tooltip placement.
     * @default 'bottom'
     */
    placement: F.oneOf(["bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * The component used for the popper.
     * @default Popper
     */
    PopperComponent: F.elementType,
    /**
     * Props applied to the [`Popper`](/material-ui/api/popper/) element.
     * @default {}
     */
    PopperProps: F.object,
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
     *
     * @default {}
     */
    slotProps: F.shape({
      arrow: F.object,
      popper: F.object,
      tooltip: F.object,
      transition: F.object
    }),
    /**
     * The components used for each slot inside.
     *
     * This prop is an alias for the `components` prop, which will be deprecated in the future.
     *
     * @default {}
     */
    slots: F.shape({
      arrow: F.elementType,
      popper: F.elementType,
      tooltip: F.elementType,
      transition: F.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: F.oneOfType([F.arrayOf(F.oneOfType([F.func, F.object, F.bool])), F.func, F.object]),
    /**
     * Tooltip title. Zero-length titles string, undefined, null and false are never displayed.
     */
    title: F.node,
    /**
     * The component used for the transition.
     * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     * @default Grow
     */
    TransitionComponent: F.elementType,
    /**
     * Props applied to the transition element.
     * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
     */
    TransitionProps: F.object
  });
  const P7 = _m;
  var hu = {}, R7 = {
    get exports() {
      return hu;
    },
    set exports(t10) {
      hu = t10;
    }
  };
  (function(t10) {
    function e(r) {
      return r && r.__esModule ? r : {
        default: r
      };
    }
    t10.exports = e, t10.exports.__esModule = true, t10.exports.default = t10.exports;
  })(R7);
  var wc = {};
  function D7(t10) {
    return Zo("MuiSvgIcon", t10);
  }
  sf("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const M7 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], N7 = (t10) => {
    const {
      color: e,
      fontSize: r,
      classes: n
    } = t10, i = {
      root: ["root", e !== "inherit" && `color${or(e)}`, `fontSize${or(r)}`]
    };
    return of(i, D7, n);
  }, L7 = is("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (t10, e) => {
      const {
        ownerState: r
      } = t10;
      return [e.root, r.color !== "inherit" && e[`color${or(r.color)}`], e[`fontSize${or(r.fontSize)}`]];
    }
  })(({
    theme: t10,
    ownerState: e
  }) => {
    var r, n, i, o, s, a, l, c, u, f, d, h, g, p, y, b, x;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: "currentColor",
      flexShrink: 0,
      transition: (r = t10.transitions) == null || (n = r.create) == null ? void 0 : n.call(r, "fill", {
        duration: (i = t10.transitions) == null || (o = i.duration) == null ? void 0 : o.shorter
      }),
      fontSize: {
        inherit: "inherit",
        small: ((s = t10.typography) == null || (a = s.pxToRem) == null ? void 0 : a.call(s, 20)) || "1.25rem",
        medium: ((l = t10.typography) == null || (c = l.pxToRem) == null ? void 0 : c.call(l, 24)) || "1.5rem",
        large: ((u = t10.typography) == null || (f = u.pxToRem) == null ? void 0 : f.call(u, 35)) || "2.1875rem"
      }[e.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color: (d = (h = (t10.vars || t10).palette) == null || (g = h[e.color]) == null ? void 0 : g.main) != null ? d : {
        action: (p = (t10.vars || t10).palette) == null || (y = p.action) == null ? void 0 : y.active,
        disabled: (b = (t10.vars || t10).palette) == null || (x = b.action) == null ? void 0 : x.disabled,
        inherit: void 0
      }[e.color]
    };
  }), Pf = /* @__PURE__ */ reactExports.forwardRef(function(e, r) {
    const n = Of({
      props: e,
      name: "MuiSvgIcon"
    }), {
      children: i,
      className: o,
      color: s = "inherit",
      component: a = "svg",
      fontSize: l = "medium",
      htmlColor: c,
      inheritViewBox: u = false,
      titleAccess: f,
      viewBox: d = "0 0 24 24"
    } = n, h = An(n, M7), g = ke({}, n, {
      color: s,
      component: a,
      fontSize: l,
      instanceFontSize: e.fontSize,
      inheritViewBox: u,
      viewBox: d
    }), p = {};
    u || (p.viewBox = d);
    const y = N7(g);
    return /* @__PURE__ */ Lt.jsxs(L7, ke({
      as: a,
      className: uo(y.root, o),
      focusable: "false",
      color: c,
      "aria-hidden": f ? void 0 : true,
      role: f ? "img" : void 0,
      ref: r
    }, p, h, {
      ownerState: g,
      children: [i, f ? /* @__PURE__ */ Lt.jsx("title", {
        children: f
      }) : null]
    }));
  });
  define_process_env_default.NODE_ENV !== "production" && (Pf.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
     * Node passed into the SVG element.
     */
    children: F.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: F.object,
    /**
     * @ignore
     */
    className: F.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
     * @default 'inherit'
     */
    color: F.oneOfType([F.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), F.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: F.elementType,
    /**
     * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
     * @default 'medium'
     */
    fontSize: F.oneOfType([F.oneOf(["inherit", "large", "medium", "small"]), F.string]),
    /**
     * Applies a color attribute to the SVG element.
     */
    htmlColor: F.string,
    /**
     * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
     * prop will be ignored.
     * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
     * `component`'s viewBox to the root node.
     * @default false
     */
    inheritViewBox: F.bool,
    /**
     * The shape-rendering attribute. The behavior of the different options is described on the
     * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
     * If you are having issues with blurry icons you should investigate this prop.
     */
    shapeRendering: F.string,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: F.oneOfType([F.arrayOf(F.oneOfType([F.func, F.object, F.bool])), F.func, F.object]),
    /**
     * Provides a human-readable title for the element that contains it.
     * https://www.w3.org/TR/SVG-access/#Equivalent
     */
    titleAccess: F.string,
    /**
     * Allows you to redefine what the coordinates without units mean inside an SVG element.
     * For example, if the SVG element is 500 (width) by 200 (height),
     * and you pass viewBox="0 0 50 20",
     * this means that the coordinates inside the SVG will go from the top left corner (0,0)
     * to bottom right (50,20) and each unit will be worth 10px.
     * @default '0 0 24 24'
     */
    viewBox: F.string
  });
  Pf.muiName = "SvgIcon";
  const r0 = Pf;
  function B7(t10, e) {
    function r(n, i) {
      return /* @__PURE__ */ Lt.jsx(r0, ke({
        "data-testid": `${e}Icon`,
        ref: i
      }, n, {
        children: t10
      }));
    }
    return define_process_env_default.NODE_ENV !== "production" && (r.displayName = `${e}Icon`), r.muiName = r0.muiName, /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(r));
  }
  const F7 = {
    configure: (t10) => {
      define_process_env_default.NODE_ENV !== "production" && console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join(`
`)), jg.configure(t10);
    }
  }, j7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    capitalize: or,
    createChainedFunction: f4,
    createSvgIcon: B7,
    debounce: d4,
    deprecatedPropType: h4,
    isMuiElement: p4,
    ownerDocument: Ea,
    ownerWindow: g4,
    requirePropFactory: m4,
    setRef: ka,
    unstable_ClassNameGenerator: F7,
    unstable_useEnhancedEffect: Oi,
    unstable_useId: Mg,
    unsupportedProp: v4$1,
    useControlled: Ng,
    useEventCallback: Lg,
    useForkRef: Xn,
    useIsFocusVisible: Bg
  }, Symbol.toStringTag, { value: "Module" })), W7 = /* @__PURE__ */ g0(j7);
  var n0;
  function U7() {
    return n0 || (n0 = 1, function(t10) {
      Object.defineProperty(t10, "__esModule", {
        value: true
      }), Object.defineProperty(t10, "default", {
        enumerable: true,
        get: function() {
          return e.createSvgIcon;
        }
      });
      var e = W7;
    }(wc)), wc;
  }
  const z7 = ({ text: t10, displayText: e }) => {
    const [r, n] = reactExports.useState(false);
    return /* @__PURE__ */ K.createElement(P7, { title: r ? "Copied link!" : "Copy link to clipboard" }, /* @__PURE__ */ K.createElement(
      "button",
      {
        id: "btn-invite",
        className: "button-black btn-invite",
        onClick: () => {
          const i = { url: t10, title: "Join my room" };
          navigator.share ? navigator.share(i).then(
            () => console.log("Hooray! Your content was shared to tha world")
          ).catch((o) => {
            console.log(
              `Oops! I couldn't share to the world because: ${o}`
            ), prompt("Copy the link below", t10);
          }) : (n(true), navigator.clipboard.writeText(t10).catch((o) => {
            console.log(
              `Oops! I couldn't share to the world because: ${o}`
            ), prompt("Copy the link below", t10);
          }), setTimeout(() => n(false), 1e3));
        }
      },
      r ? "Copied!" : "Share link"
    ));
  };
  var Rf = {}, V7 = hu;
  Object.defineProperty(Rf, "__esModule", {
    value: true
  });
  var Sm = Rf.default = void 0, q7 = V7(U7()), H7 = Wg(), Y7 = (0, q7.default)(/* @__PURE__ */ (0, H7.jsx)("path", {
    d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"
  }), "Refresh");
  Sm = Rf.default = Y7;
  const Em = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzEiIGhlaWdodD0iMjYiIHZpZXdCb3g9IjAgMCAzMSAyNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wLjQ4OTEzNiA1LjI1MzE3QzAuNDg5MTM2IDIuNDkxNzUgMi43Mjc3MSAwLjI1MzE3NCA1LjQ4OTE0IDAuMjUzMTc0SDI1LjQ4OTFDMjguMjUwNiAwLjI1MzE3NCAzMC40ODkxIDIuNDkxNzUgMzAuNDg5MSA1LjI1MzE3VjE3LjI1MzJDMzAuNDg5MSAyMC4wMTQ2IDI4LjI1MDYgMjIuMjUzMiAyNS40ODkxIDIyLjI1MzJIMjIuNzM5MVYyMC4yNTMySDI1LjQ4OTFDMjcuMTQ2IDIwLjI1MzIgMjguNDg5MSAxOC45MSAyOC40ODkxIDE3LjI1MzJWNS4yNTMxN0MyOC40ODkxIDMuNTk2MzIgMjcuMTQ2IDIuMjUzMTcgMjUuNDg5MSAyLjI1MzE3SDUuNDg5MTRDMy44MzIyOCAyLjI1MzE3IDIuNDg5MTQgMy41OTYzMiAyLjQ4OTE0IDUuMjUzMTdWMTcuMjUzMkMyLjQ4OTE0IDE4LjkxIDMuODMyMjggMjAuMjUzMiA1LjQ4OTE0IDIwLjI1MzJINy40ODkxNFYyMi4yNTMySDUuNDg5MTRDMi43Mjc3MSAyMi4yNTMyIDAuNDg5MTM2IDIwLjAxNDYgMC40ODkxMzYgMTcuMjUzMlY1LjI1MzE3WiIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTE0Ljk4OTEgMTUuMjUzMkwyMi4zNTA0IDI1Ljc1MzJINy42Mjc5MkwxNC45ODkxIDE1LjI1MzJaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K";
  var km = {}, Cm = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  }, K7 = Cm;
  function Tm(t10) {
    this.mode = K7.MODE_8BIT_BYTE, this.data = t10;
  }
  Tm.prototype = {
    getLength: function(t10) {
      return this.data.length;
    },
    write: function(t10) {
      for (var e = 0; e < this.data.length; e++)
        t10.put(this.data.charCodeAt(e), 8);
    }
  };
  var X7 = Tm, Om = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  }, Ls = Om;
  function Er(t10, e) {
    this.totalCount = t10, this.dataCount = e;
  }
  Er.RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    // 1
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    // 2
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    // 3
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    // 4		
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    // 5
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    // 6
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    // 7		
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    // 8
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    // 9
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    // 10		
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    // 11
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    // 12
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    // 13
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    // 14
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    // 15
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    // 16
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    // 17
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    // 18
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    // 19
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    // 20
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    // 21
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    // 22
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    // 23
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    // 24
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    // 25
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    // 26
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    // 27
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    // 28
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    // 29
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    // 30
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    // 31
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    // 32
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    // 33
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    // 34
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    // 35
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    // 36
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    // 37
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    // 38
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    // 39
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    // 40
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  Er.getRSBlocks = function(t10, e) {
    var r = Er.getRsBlockTable(t10, e);
    if (r == null)
      throw new Error("bad rs block @ typeNumber:" + t10 + "/errorCorrectLevel:" + e);
    for (var n = r.length / 3, i = new Array(), o = 0; o < n; o++)
      for (var s = r[o * 3 + 0], a = r[o * 3 + 1], l = r[o * 3 + 2], c = 0; c < s; c++)
        i.push(new Er(a, l));
    return i;
  };
  Er.getRsBlockTable = function(t10, e) {
    switch (e) {
      case Ls.L:
        return Er.RS_BLOCK_TABLE[(t10 - 1) * 4 + 0];
      case Ls.M:
        return Er.RS_BLOCK_TABLE[(t10 - 1) * 4 + 1];
      case Ls.Q:
        return Er.RS_BLOCK_TABLE[(t10 - 1) * 4 + 2];
      case Ls.H:
        return Er.RS_BLOCK_TABLE[(t10 - 1) * 4 + 3];
      default:
        return;
    }
  };
  var J7 = Er;
  function Im() {
    this.buffer = new Array(), this.length = 0;
  }
  Im.prototype = {
    get: function(t10) {
      var e = Math.floor(t10 / 8);
      return (this.buffer[e] >>> 7 - t10 % 8 & 1) == 1;
    },
    put: function(t10, e) {
      for (var r = 0; r < e; r++)
        this.putBit((t10 >>> e - r - 1 & 1) == 1);
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(t10) {
      var e = Math.floor(this.length / 8);
      this.buffer.length <= e && this.buffer.push(0), t10 && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
    }
  };
  var Q7 = Im, pr = {
    glog: function(t10) {
      if (t10 < 1)
        throw new Error("glog(" + t10 + ")");
      return pr.LOG_TABLE[t10];
    },
    gexp: function(t10) {
      for (; t10 < 0; )
        t10 += 255;
      for (; t10 >= 256; )
        t10 -= 255;
      return pr.EXP_TABLE[t10];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };
  for (var Tt = 0; Tt < 8; Tt++)
    pr.EXP_TABLE[Tt] = 1 << Tt;
  for (var Tt = 8; Tt < 256; Tt++)
    pr.EXP_TABLE[Tt] = pr.EXP_TABLE[Tt - 4] ^ pr.EXP_TABLE[Tt - 5] ^ pr.EXP_TABLE[Tt - 6] ^ pr.EXP_TABLE[Tt - 8];
  for (var Tt = 0; Tt < 255; Tt++)
    pr.LOG_TABLE[pr.EXP_TABLE[Tt]] = Tt;
  var Pm = pr, In = Pm;
  function ra(t10, e) {
    if (t10.length == null)
      throw new Error(t10.length + "/" + e);
    for (var r = 0; r < t10.length && t10[r] == 0; )
      r++;
    this.num = new Array(t10.length - r + e);
    for (var n = 0; n < t10.length - r; n++)
      this.num[n] = t10[n + r];
  }
  ra.prototype = {
    get: function(t10) {
      return this.num[t10];
    },
    getLength: function() {
      return this.num.length;
    },
    multiply: function(t10) {
      for (var e = new Array(this.getLength() + t10.getLength() - 1), r = 0; r < this.getLength(); r++)
        for (var n = 0; n < t10.getLength(); n++)
          e[r + n] ^= In.gexp(In.glog(this.get(r)) + In.glog(t10.get(n)));
      return new ra(e, 0);
    },
    mod: function(t10) {
      if (this.getLength() - t10.getLength() < 0)
        return this;
      for (var e = In.glog(this.get(0)) - In.glog(t10.get(0)), r = new Array(this.getLength()), n = 0; n < this.getLength(); n++)
        r[n] = this.get(n);
      for (var n = 0; n < t10.getLength(); n++)
        r[n] ^= In.gexp(In.glog(t10.get(n)) + e);
      return new ra(r, 0).mod(t10);
    }
  };
  var Rm = ra, er = Cm, i0 = Rm, G7 = Pm, $r = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  }, Et = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(t10) {
      for (var e = t10 << 10; Et.getBCHDigit(e) - Et.getBCHDigit(Et.G15) >= 0; )
        e ^= Et.G15 << Et.getBCHDigit(e) - Et.getBCHDigit(Et.G15);
      return (t10 << 10 | e) ^ Et.G15_MASK;
    },
    getBCHTypeNumber: function(t10) {
      for (var e = t10 << 12; Et.getBCHDigit(e) - Et.getBCHDigit(Et.G18) >= 0; )
        e ^= Et.G18 << Et.getBCHDigit(e) - Et.getBCHDigit(Et.G18);
      return t10 << 12 | e;
    },
    getBCHDigit: function(t10) {
      for (var e = 0; t10 != 0; )
        e++, t10 >>>= 1;
      return e;
    },
    getPatternPosition: function(t10) {
      return Et.PATTERN_POSITION_TABLE[t10 - 1];
    },
    getMask: function(t10, e, r) {
      switch (t10) {
        case $r.PATTERN000:
          return (e + r) % 2 == 0;
        case $r.PATTERN001:
          return e % 2 == 0;
        case $r.PATTERN010:
          return r % 3 == 0;
        case $r.PATTERN011:
          return (e + r) % 3 == 0;
        case $r.PATTERN100:
          return (Math.floor(e / 2) + Math.floor(r / 3)) % 2 == 0;
        case $r.PATTERN101:
          return e * r % 2 + e * r % 3 == 0;
        case $r.PATTERN110:
          return (e * r % 2 + e * r % 3) % 2 == 0;
        case $r.PATTERN111:
          return (e * r % 3 + (e + r) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + t10);
      }
    },
    getErrorCorrectPolynomial: function(t10) {
      for (var e = new i0([1], 0), r = 0; r < t10; r++)
        e = e.multiply(new i0([1, G7.gexp(r)], 0));
      return e;
    },
    getLengthInBits: function(t10, e) {
      if (1 <= e && e < 10)
        switch (t10) {
          case er.MODE_NUMBER:
            return 10;
          case er.MODE_ALPHA_NUM:
            return 9;
          case er.MODE_8BIT_BYTE:
            return 8;
          case er.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + t10);
        }
      else if (e < 27)
        switch (t10) {
          case er.MODE_NUMBER:
            return 12;
          case er.MODE_ALPHA_NUM:
            return 11;
          case er.MODE_8BIT_BYTE:
            return 16;
          case er.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + t10);
        }
      else if (e < 41)
        switch (t10) {
          case er.MODE_NUMBER:
            return 14;
          case er.MODE_ALPHA_NUM:
            return 13;
          case er.MODE_8BIT_BYTE:
            return 16;
          case er.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + t10);
        }
      else
        throw new Error("type:" + e);
    },
    getLostPoint: function(t10) {
      for (var e = t10.getModuleCount(), r = 0, n = 0; n < e; n++)
        for (var i = 0; i < e; i++) {
          for (var o = 0, s = t10.isDark(n, i), a = -1; a <= 1; a++)
            if (!(n + a < 0 || e <= n + a))
              for (var l = -1; l <= 1; l++)
                i + l < 0 || e <= i + l || a == 0 && l == 0 || s == t10.isDark(n + a, i + l) && o++;
          o > 5 && (r += 3 + o - 5);
        }
      for (var n = 0; n < e - 1; n++)
        for (var i = 0; i < e - 1; i++) {
          var c = 0;
          t10.isDark(n, i) && c++, t10.isDark(n + 1, i) && c++, t10.isDark(n, i + 1) && c++, t10.isDark(n + 1, i + 1) && c++, (c == 0 || c == 4) && (r += 3);
        }
      for (var n = 0; n < e; n++)
        for (var i = 0; i < e - 6; i++)
          t10.isDark(n, i) && !t10.isDark(n, i + 1) && t10.isDark(n, i + 2) && t10.isDark(n, i + 3) && t10.isDark(n, i + 4) && !t10.isDark(n, i + 5) && t10.isDark(n, i + 6) && (r += 40);
      for (var i = 0; i < e; i++)
        for (var n = 0; n < e - 6; n++)
          t10.isDark(n, i) && !t10.isDark(n + 1, i) && t10.isDark(n + 2, i) && t10.isDark(n + 3, i) && t10.isDark(n + 4, i) && !t10.isDark(n + 5, i) && t10.isDark(n + 6, i) && (r += 40);
      for (var u = 0, i = 0; i < e; i++)
        for (var n = 0; n < e; n++)
          t10.isDark(n, i) && u++;
      var f = Math.abs(100 * u / e / e - 50) / 5;
      return r += f * 10, r;
    }
  }, Z7 = Et, $7 = X7, Dm = J7, Mm = Q7, _n = Z7, eS = Rm;
  function kr(t10, e) {
    this.typeNumber = t10, this.errorCorrectLevel = e, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
  }
  var Gt = kr.prototype;
  Gt.addData = function(t10) {
    var e = new $7(t10);
    this.dataList.push(e), this.dataCache = null;
  };
  Gt.isDark = function(t10, e) {
    if (t10 < 0 || this.moduleCount <= t10 || e < 0 || this.moduleCount <= e)
      throw new Error(t10 + "," + e);
    return this.modules[t10][e];
  };
  Gt.getModuleCount = function() {
    return this.moduleCount;
  };
  Gt.make = function() {
    if (this.typeNumber < 1) {
      var t10 = 1;
      for (t10 = 1; t10 < 40; t10++) {
        for (var e = Dm.getRSBlocks(t10, this.errorCorrectLevel), r = new Mm(), n = 0, i = 0; i < e.length; i++)
          n += e[i].dataCount;
        for (var i = 0; i < this.dataList.length; i++) {
          var o = this.dataList[i];
          r.put(o.mode, 4), r.put(o.getLength(), _n.getLengthInBits(o.mode, t10)), o.write(r);
        }
        if (r.getLengthInBits() <= n * 8)
          break;
      }
      this.typeNumber = t10;
    }
    this.makeImpl(false, this.getBestMaskPattern());
  };
  Gt.makeImpl = function(t10, e) {
    this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
    for (var r = 0; r < this.moduleCount; r++) {
      this.modules[r] = new Array(this.moduleCount);
      for (var n = 0; n < this.moduleCount; n++)
        this.modules[r][n] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t10, e), this.typeNumber >= 7 && this.setupTypeNumber(t10), this.dataCache == null && (this.dataCache = kr.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e);
  };
  Gt.setupPositionProbePattern = function(t10, e) {
    for (var r = -1; r <= 7; r++)
      if (!(t10 + r <= -1 || this.moduleCount <= t10 + r))
        for (var n = -1; n <= 7; n++)
          e + n <= -1 || this.moduleCount <= e + n || (0 <= r && r <= 6 && (n == 0 || n == 6) || 0 <= n && n <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= n && n <= 4 ? this.modules[t10 + r][e + n] = true : this.modules[t10 + r][e + n] = false);
  };
  Gt.getBestMaskPattern = function() {
    for (var t10 = 0, e = 0, r = 0; r < 8; r++) {
      this.makeImpl(true, r);
      var n = _n.getLostPoint(this);
      (r == 0 || t10 > n) && (t10 = n, e = r);
    }
    return e;
  };
  Gt.createMovieClip = function(t10, e, r) {
    var n = t10.createEmptyMovieClip(e, r), i = 1;
    this.make();
    for (var o = 0; o < this.modules.length; o++)
      for (var s = o * i, a = 0; a < this.modules[o].length; a++) {
        var l = a * i, c = this.modules[o][a];
        c && (n.beginFill(0, 100), n.moveTo(l, s), n.lineTo(l + i, s), n.lineTo(l + i, s + i), n.lineTo(l, s + i), n.endFill());
      }
    return n;
  };
  Gt.setupTimingPattern = function() {
    for (var t10 = 8; t10 < this.moduleCount - 8; t10++)
      this.modules[t10][6] == null && (this.modules[t10][6] = t10 % 2 == 0);
    for (var e = 8; e < this.moduleCount - 8; e++)
      this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0);
  };
  Gt.setupPositionAdjustPattern = function() {
    for (var t10 = _n.getPatternPosition(this.typeNumber), e = 0; e < t10.length; e++)
      for (var r = 0; r < t10.length; r++) {
        var n = t10[e], i = t10[r];
        if (this.modules[n][i] == null)
          for (var o = -2; o <= 2; o++)
            for (var s = -2; s <= 2; s++)
              o == -2 || o == 2 || s == -2 || s == 2 || o == 0 && s == 0 ? this.modules[n + o][i + s] = true : this.modules[n + o][i + s] = false;
      }
  };
  Gt.setupTypeNumber = function(t10) {
    for (var e = _n.getBCHTypeNumber(this.typeNumber), r = 0; r < 18; r++) {
      var n = !t10 && (e >> r & 1) == 1;
      this.modules[Math.floor(r / 3)][r % 3 + this.moduleCount - 8 - 3] = n;
    }
    for (var r = 0; r < 18; r++) {
      var n = !t10 && (e >> r & 1) == 1;
      this.modules[r % 3 + this.moduleCount - 8 - 3][Math.floor(r / 3)] = n;
    }
  };
  Gt.setupTypeInfo = function(t10, e) {
    for (var r = this.errorCorrectLevel << 3 | e, n = _n.getBCHTypeInfo(r), i = 0; i < 15; i++) {
      var o = !t10 && (n >> i & 1) == 1;
      i < 6 ? this.modules[i][8] = o : i < 8 ? this.modules[i + 1][8] = o : this.modules[this.moduleCount - 15 + i][8] = o;
    }
    for (var i = 0; i < 15; i++) {
      var o = !t10 && (n >> i & 1) == 1;
      i < 8 ? this.modules[8][this.moduleCount - i - 1] = o : i < 9 ? this.modules[8][15 - i - 1 + 1] = o : this.modules[8][15 - i - 1] = o;
    }
    this.modules[this.moduleCount - 8][8] = !t10;
  };
  Gt.mapData = function(t10, e) {
    for (var r = -1, n = this.moduleCount - 1, i = 7, o = 0, s = this.moduleCount - 1; s > 0; s -= 2)
      for (s == 6 && s--; ; ) {
        for (var a = 0; a < 2; a++)
          if (this.modules[n][s - a] == null) {
            var l = false;
            o < t10.length && (l = (t10[o] >>> i & 1) == 1);
            var c = _n.getMask(e, n, s - a);
            c && (l = !l), this.modules[n][s - a] = l, i--, i == -1 && (o++, i = 7);
          }
        if (n += r, n < 0 || this.moduleCount <= n) {
          n -= r, r = -r;
          break;
        }
      }
  };
  kr.PAD0 = 236;
  kr.PAD1 = 17;
  kr.createData = function(t10, e, r) {
    for (var n = Dm.getRSBlocks(t10, e), i = new Mm(), o = 0; o < r.length; o++) {
      var s = r[o];
      i.put(s.mode, 4), i.put(s.getLength(), _n.getLengthInBits(s.mode, t10)), s.write(i);
    }
    for (var a = 0, o = 0; o < n.length; o++)
      a += n[o].dataCount;
    if (i.getLengthInBits() > a * 8)
      throw new Error("code length overflow. (" + i.getLengthInBits() + ">" + a * 8 + ")");
    for (i.getLengthInBits() + 4 <= a * 8 && i.put(0, 4); i.getLengthInBits() % 8 != 0; )
      i.putBit(false);
    for (; !(i.getLengthInBits() >= a * 8 || (i.put(kr.PAD0, 8), i.getLengthInBits() >= a * 8)); )
      i.put(kr.PAD1, 8);
    return kr.createBytes(i, n);
  };
  kr.createBytes = function(t10, e) {
    for (var r = 0, n = 0, i = 0, o = new Array(e.length), s = new Array(e.length), a = 0; a < e.length; a++) {
      var l = e[a].dataCount, c = e[a].totalCount - l;
      n = Math.max(n, l), i = Math.max(i, c), o[a] = new Array(l);
      for (var u = 0; u < o[a].length; u++)
        o[a][u] = 255 & t10.buffer[u + r];
      r += l;
      var f = _n.getErrorCorrectPolynomial(c), d = new eS(o[a], f.getLength() - 1), h = d.mod(f);
      s[a] = new Array(f.getLength() - 1);
      for (var u = 0; u < s[a].length; u++) {
        var g = u + h.getLength() - s[a].length;
        s[a][u] = g >= 0 ? h.get(g) : 0;
      }
    }
    for (var p = 0, u = 0; u < e.length; u++)
      p += e[u].totalCount;
    for (var y = new Array(p), b = 0, u = 0; u < n; u++)
      for (var a = 0; a < e.length; a++)
        u < o[a].length && (y[b++] = o[a][u]);
    for (var u = 0; u < i; u++)
      for (var a = 0; a < e.length; a++)
        u < s[a].length && (y[b++] = s[a][u]);
    return y;
  };
  var tS = kr, Df = {};
  Object.defineProperty(Df, "__esModule", {
    value: true
  });
  var rS = Object.assign || function(t10) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
    }
    return t10;
  }, nS = F, tr = Lm(nS), Nm = K, Bs = Lm(Nm);
  function Lm(t10) {
    return t10 && t10.__esModule ? t10 : { default: t10 };
  }
  function iS(t10, e) {
    var r = {};
    for (var n in t10)
      e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t10, n) && (r[n] = t10[n]);
    return r;
  }
  var oS = {
    bgColor: tr.default.oneOfType([tr.default.object, tr.default.string]).isRequired,
    bgD: tr.default.string.isRequired,
    fgColor: tr.default.oneOfType([tr.default.object, tr.default.string]).isRequired,
    fgD: tr.default.string.isRequired,
    size: tr.default.number.isRequired,
    title: tr.default.string,
    viewBoxSize: tr.default.number.isRequired,
    xmlns: tr.default.string
  }, sS = {
    title: void 0,
    xmlns: "http://www.w3.org/2000/svg"
  }, ml = (0, Nm.forwardRef)(function(t10, e) {
    var r = t10.bgColor, n = t10.bgD, i = t10.fgD, o = t10.fgColor, s = t10.size, a = t10.title, l = t10.viewBoxSize, c = iS(t10, ["bgColor", "bgD", "fgD", "fgColor", "size", "title", "viewBoxSize"]);
    return Bs.default.createElement(
      "svg",
      rS({}, c, { height: s, ref: e, viewBox: "0 0 " + l + " " + l, width: s }),
      a ? Bs.default.createElement(
        "title",
        null,
        a
      ) : null,
      Bs.default.createElement("path", { d: n, fill: r }),
      Bs.default.createElement("path", { d: i, fill: o })
    );
  });
  ml.displayName = "QRCodeSvg";
  ml.propTypes = oS;
  ml.defaultProps = sS;
  Df.default = ml;
  Object.defineProperty(km, "__esModule", {
    value: true
  });
  var aS = Object.assign || function(t10) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t10[n] = r[n]);
    }
    return t10;
  }, lS = tS, cS = os(lS), uS = Om, fS = os(uS), dS = F, Rr = os(dS), Bm = K, hS = os(Bm), pS = Df, gS = os(pS);
  function os(t10) {
    return t10 && t10.__esModule ? t10 : { default: t10 };
  }
  function mS(t10, e) {
    var r = {};
    for (var n in t10)
      e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t10, n) && (r[n] = t10[n]);
    return r;
  }
  var yS = {
    bgColor: Rr.default.oneOfType([Rr.default.object, Rr.default.string]),
    fgColor: Rr.default.oneOfType([Rr.default.object, Rr.default.string]),
    level: Rr.default.string,
    size: Rr.default.number,
    value: Rr.default.string.isRequired
  }, bS = {
    bgColor: "#FFFFFF",
    fgColor: "#000000",
    level: "L",
    size: 256
  }, yl = (0, Bm.forwardRef)(function(t10, e) {
    var r = t10.bgColor, n = t10.fgColor, i = t10.level, o = t10.size, s = t10.value, a = mS(t10, ["bgColor", "fgColor", "level", "size", "value"]), l = new cS.default(-1, fS.default[i]);
    l.addData(s), l.make();
    var c = l.modules;
    return hS.default.createElement(gS.default, aS({}, a, {
      bgColor: r,
      bgD: c.map(function(u, f) {
        return u.map(function(d, h) {
          return d ? "" : "M " + h + " " + f + " l 1 0 0 1 -1 0 Z";
        }).join(" ");
      }).join(" "),
      fgColor: n,
      fgD: c.map(function(u, f) {
        return u.map(function(d, h) {
          return d ? "M " + h + " " + f + " l 1 0 0 1 -1 0 Z" : "";
        }).join(" ");
      }).join(" "),
      ref: e,
      size: o,
      viewBoxSize: c.length
    }));
  });
  yl.displayName = "QRCode";
  yl.propTypes = yS;
  yl.defaultProps = bS;
  var Fm = km.default = yl;
  function vS({
    zIndex: t10,
    demoMode: e,
    noAbsolute: r,
    noText: n,
    size: i = 256,
    containerStyles: o = {},
    baseUrl: s = "https://joinplayroom.com/"
  }) {
    const l = Ie().currentRoom, c = m3(s, l);
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        className: "room-code-sticker",
        style: {
          zIndex: t10 || "initial",
          position: r ? "initial" : "absolute",
          ...o
        }
      },
      /* @__PURE__ */ K.createElement("div", { className: "qr-code" }, /* @__PURE__ */ K.createElement(
        Fm,
        {
          id: "QRCodeScaled",
          size: i,
          style: { height: "auto", maxWidth: "100%", width: "100%" },
          value: c,
          viewBox: `0 0 ${i} ${i}`
        }
      )),
      !n && l && /* @__PURE__ */ K.createElement("div", { className: "room-code" }, /* @__PURE__ */ K.createElement("b", null, l), /* @__PURE__ */ K.createElement("span", null, "Scan QR code to join the room")),
      !n && !l && /* @__PURE__ */ K.createElement("div", { className: "room-code" }, /* @__PURE__ */ K.createElement("b", null, "Scan to start"), /* @__PURE__ */ K.createElement("span", null, "Download the game from the Appstore"))
    );
  }
  const AS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwLjI3NDcgMC4wODEzNzY3QzcuNzI1NTcgMC4wODEzNzY3IDUuMjgwOTggMS4wOTM5NiAzLjQ3ODU3IDIuODk2MzdDMS42NzYxNSA0LjY5OSAwLjY2MzU3NCA3LjE0MzY0IDAuNjYzNTc0IDkuNjkyNUMwLjY2MzU3NCAxMi4yNDE0IDEuNjc2MTUgMTQuNjg2MiAzLjQ3ODU3IDE2LjQ4ODZDNS4yODEyIDE4LjI5MSA3LjcyNTg0IDE5LjMwMzYgMTAuMjc0NyAxOS4zMDM2QzEyLjgyMzUgMTkuMzAzNiAxNS4yNjg0IDE4LjI5MSAxNy4wNzA4IDE2LjQ4ODZDMTguODczMiAxNC42ODYgMTkuODg1OCAxMi4yNDE0IDE5Ljg4NTggOS42OTI1QzE5Ljg4NTggOC4wMDUyOSAxOS40NDE2IDYuMzQ3ODUgMTguNTk4MSA0Ljg4NjY3QzE3Ljc1NDYgMy40MjU1NCAxNi41NDEzIDIuMjEyMjUgMTUuMDgwMiAxLjM2ODczQzEzLjYxOTEgMC41MjUyMDkgMTEuOTYxNiAwLjA4MTA1NDcgMTAuMjc0NCAwLjA4MTA1NDdMMTAuMjc0NyAwLjA4MTM3NjdaTTEwLjI3NDcgMi40ODQyOUMxMC43NzkyIDIuNDg0MjkgMTEuODc4NSA0LjIwODQgMTIuMjUxIDcuNDQwMDhDMTAuOTQxMiA3LjI0MDQxIDkuNjA4MjggNy4yNDA0MSA4LjI5ODQgNy40NDAwOEM4LjY3MDkxIDQuMjA4MTMgOS43NzAyIDIuNDg0MjkgMTAuMjc0NyAyLjQ4NDI5SDEwLjI3NDdaTTMuNDgwNzEgMTIuMDk1N0M0LjE4NzIgMTEuNTIyNyA0Ljk2MzI1IDExLjA0MTMgNS43OTAzNiAxMC42NjMxQzUuODQ1NjYgMTIuNDgzOSA2LjE4NjEzIDE0LjI4NDkgNi43OTk1NiAxNi4wMDA0QzUuMjU0NTkgMTUuMTQ2NSA0LjA3NDYyIDEzLjc1OCAzLjQ4MDY2IDEyLjA5NTdIMy40ODA3MVpNNS44Mjk1NiA4LjA2MTk4QzQuODU4MDcgOC40MDc0NyAzLjkzMDU1IDguODY2MDggMy4wNjYyNyA5LjQyODQ1QzMuMTYyODYgNi44OTgxNSA0LjU4MDI0IDQuNjA0MjMgNi43OTk1NiAzLjM4NTM2QzYuMjU1MDUgNC44OTAxIDUuOTI4MiA2LjQ2NDc4IDUuODI5NTEgOC4wNjIwOUw1LjgyOTU2IDguMDYxOThaTTEwLjI3NDggMTYuOTAxMUM5LjY3NDE0IDE2LjkwMTEgOC4yMjAzIDE0LjQ0NyA4LjE3MjM1IDkuODk5NTNDOS41NjAzOCA5LjYyMzgxIDEwLjk4OTMgOS42MjM4MSAxMi4zNzcyIDkuODk5NTNDMTIuMzI5MyAxNC40NDcgMTAuODc1NSAxNi45MDExIDEwLjI3NDggMTYuOTAxMVpNMTMuNzUgMTZWMTYuMDAwMkMxNC4zNjM2IDE0LjI4MzYgMTQuNzA0MSAxMi40ODE2IDE0Ljc1OTIgMTAuNjU5N0MxNS41ODY2IDExLjAzOTEgMTYuMzYyNiAxMS41MjE0IDE3LjA2ODggMTIuMDk1NUMxNi40NzQ5IDEzLjc1NzggMTUuMjk0OSAxNS4xNDYyIDEzLjc0OTkgMTYuMDAwMkwxMy43NSAxNlpNMTQuNzIgOC4wNjE5M0MxNC42MjE0IDYuNDY0NjIgMTQuMjk0NSA0Ljg4OTg5IDEzLjc1IDMuMzg1MkMxNS45Njk0IDQuNjA0MTcgMTcuMzg2NyA2Ljg5ODEgMTcuNDgzMyA5LjQyODI5QzE2LjYxOSA4Ljg2NTk4IDE1LjY5MTUgOC40MDczNCAxNC43MiA4LjA2MTgyTDE0LjcyIDguMDYxOTNaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K", wS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTkiIHZpZXdCb3g9IjAgMCAyMCAxOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iNS43ODI0NyIgY3k9IjQuMjk2NjMiIHI9IjIuNDY5NTgiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+CjxjaXJjbGUgY3g9IjE0LjM4NDYiIGN5PSI0LjI5NjYzIiByPSIyLjQ2OTU4IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIuMiIvPgo8cmVjdCB4PSIxLjYiIHk9IjkuNzE4NDEiIHdpZHRoPSI4LjM2NDk5IiBoZWlnaHQ9IjcuNDIxNTgiIHJ4PSIxLjkiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+CjxyZWN0IHg9IjEwLjIwMjEiIHk9IjkuNzE4NDEiIHdpZHRoPSI4LjM2NDk5IiBoZWlnaHQ9IjcuNDIxNTgiIHJ4PSIxLjkiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMi4yIi8+Cjwvc3ZnPgo=";
  const xS = [
    // 10.0.0.0 - 10.255.255.255
    /^(:{2}f{4}:)?10(?:\.\d{1,3}){3}$/,
    // 127.0.0.0 - 127.255.255.255
    /^(:{2}f{4}:)?127(?:\.\d{1,3}){3}$/,
    // 169.254.1.0 - 169.254.254.255
    /^(::f{4}:)?169\.254\.([1-9]|1?\d\d|2[0-4]\d|25[0-4])\.\d{1,3}$/,
    // 172.16.0.0 - 172.31.255.255
    /^(:{2}f{4}:)?(172\.1[6-9]|172\.2\d|172\.3[01])(?:\.\d{1,3}){2}$/,
    // 192.168.0.0 - 192.168.255.255
    /^(:{2}f{4}:)?192\.168(?:\.\d{1,3}){2}$/,
    // fc00::/7
    /^f[cd][\da-f]{2}(::1$|:[\da-f]{1,4}){1,7}$/,
    // fe80::/10
    /^fe[89ab][\da-f](::1$|:[\da-f]{1,4}){1,7}$/
  ], _S = new RegExp(
    `^(${xS.map((t10) => t10.source).join("|")})$`
  );
  function SS(t10) {
    const e = (
      // eslint-disable-next-line regexp/no-dupe-disjunctions
      new RegExp("(?![\\w-]{64})((^(?=[-\\w.]{1,253}\\.?$)((\\w{1,63}|(\\w[-\\w]{0,61}\\w))\\.?)+$)(?<!\\.{2}))")
    );
    return typeof t10 != "string" ? false : _S.test(t10) || t10 === "localhost" ? true : (e.test(t10), false);
  }
  function jm() {
    const t10 = location.hostname;
    try {
      if (SS(t10))
        return "LOCAL";
    } catch {
    }
    return da(location.hostname + location.pathname).slice(0, 9);
  }
  function o0(t10, e) {
    return Math.floor(Math.random() * (e - t10 + 1)) + t10;
  }
  function ES(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  const ci = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ], Fs = [
    "Eclipse",
    "Crankshaft",
    "Firetruck",
    "President",
    "Bat",
    "Avocado",
    "Holiday",
    "Salad",
    "Boom",
    "Cornflakes"
  ];
  function s0(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Ha(qa(ES(10)));
  }
  function kS({ hide: t10, playerState: e }) {
    var r;
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ K.createElement(
        Li,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ K.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ K.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ K.createElement("div", null, /* @__PURE__ */ K.createElement("h1", { style: { marginBottom: "1rem", marginTop: "0rem" } }, "Kick Player"), /* @__PURE__ */ K.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                marginBottom: "2rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Remove ",
            ((r = e.getState("profile")) == null ? void 0 : r.name) || "this player",
            " ",
            "from the party?"
          )),
          /* @__PURE__ */ K.createElement(
            "button",
            {
              id: "btn-invite",
              className: "close-btn",
              onClick: () => {
                e.kick(), t10();
              }
            },
            "Kick"
          ),
          /* @__PURE__ */ K.createElement("button", { id: "btn-invite", className: "close-btn white", onClick: t10 }, "Cancel")
        )
      )
    );
  }
  function CS({
    baseUrl: t10,
    avatarsOverride: e,
    lockedNameField: r,
    lockedPhotoField: n,
    matchmakingOptions: i,
    onTurnbasedLaunch: o
  }) {
    var $, se, he, pe, me;
    const s = Ie(), a = Mu(), l = i && a, c = Va(), u = (B) => {
      if (!l)
        return { data: null, error: null, isLoading: false };
      const q = jm(), Z = s.connection.getHostname(false) + "/api/game/" + q + "/matchmaking_total_players";
      return fetch(Z).then((oe) => oe.json());
    }, { data: f } = Dw(
      "dummy",
      u,
      {
        refreshInterval: 1e4
      }
    ), d = (f == null ? void 0 : f.totalPlayers) || 0, [h, g] = reactExports.useState(null), [p, y] = yi("__matchmakingqueue"), [b, x] = yi(
      "__matchmakingChosenRoom"
    ), [S, O] = reactExports.useState(
      !!window.isRunningOnNative
    ), [_, L] = reactExports.useState(false), [N, j] = reactExports.useState(ci), W = s.getMyPlayerState() ? s.getMyPlayerState().getState("profile") : {
      name: Fs[Math.floor(Math.random() * Fs.length)] + o0(10, 99),
      color: ci[Math.floor(Math.random() * ci.length)]
    }, [G, ee] = reactExports.useState({
      color: (W == null ? void 0 : W.color) || fe()[0],
      name: xt.get("playerName") || (W == null ? void 0 : W.name) || Fs[Math.floor(Math.random() * Fs.length)] + o0(10, 99),
      photo: (W == null ? void 0 : W.photo) || (xt.get("playerPhoto") && xt.get("playerPhoto") !== "false" ? xt.get("playerPhoto") : s0(e))
    });
    n1((B, q, Z, oe) => {
      const de = fe();
      j(de);
    });
    function fe() {
      const B = s.getPlayers();
      if (!B)
        return ci;
      const q = Object.keys(B).filter((oe) => oe !== s.connection.myId).map((oe) => {
        var de;
        return (de = B[oe].state.profile) == null ? void 0 : de.color;
      });
      return ci.filter(
        (oe) => !q.includes(oe)
      );
    }
    function P10(B) {
      var Z;
      xt.set("playerName", B.name), B.photo && xt.set("playerPhoto", B.photo), xt.set("playerColor", B.color), s.getMyPlayerState().setState("profile", B, true), (Z = window._PLAYROOM_CONFIG) != null && Z.skipProfile && (B != null && B.photo) && s.setState("__launched", true);
    }
    const [z10, U] = reactExports.useState(false);
    reactExports.useEffect(() => {
      function B(Z) {
        var oe;
        (oe = Z.data) != null && oe.isRunningOnNative && (window.isRunningOnNative = Z.data.isRunningOnNative, O(Z.data.isRunningOnNative), L(true));
      }
      var q = { ...s == null ? void 0 : s.sdkOptions };
      return delete q.botOptions, window.parent.postMessage(
        {
          joinRoomURL: `${window.location.href}&streaming=true`,
          sdkOptions: q ?? {}
        },
        // "http://10.10.10.32:5175"
        "*"
      ), window.addEventListener("message", B, false), () => window.removeEventListener("message", B);
    }, [s]);
    const I = S && (($ = s == null ? void 0 : s.sdkOptions) == null ? void 0 : $.streamMode);
    if (h)
      return /* @__PURE__ */ K.createElement(
        kS,
        {
          playerState: h,
          hide: () => g(null)
        }
      );
    const V = (c == null ? void 0 : c.length) || 0, te = a && ((se = s.sdkOptions) == null ? void 0 : se.enableBots) && (!((he = s.sdkOptions) != null && he.maxPlayersPerRoom) || V < ((pe = s.sdkOptions) == null ? void 0 : pe.maxPlayersPerRoom)), X = (me = s.sdkOptions) == null ? void 0 : me.turnBased, H = () => l ? /* @__PURE__ */ K.createElement(
      "span",
      {
        style: {
          opacity: d > 0 ? 1 : 0,
          color: "#00df59",
          marginTop: "1rem"
        }
      },
      /* @__PURE__ */ K.createElement(
        "span",
        {
          style: {
            backgroundColor: "#00df59",
            width: "0.5rem",
            height: "0.5rem",
            borderRadius: "50%",
            display: "inline-block",
            verticalAlign: "middle",
            marginBottom: "0.3rem",
            marginRight: "0.4rem"
          }
        }
      ),
      d,
      " ",
      d === 1 ? "player" : "players",
      " online"
    ) : null;
    return /* @__PURE__ */ K.createElement("div", { className: "main-menu" }, /* @__PURE__ */ K.createElement("div", { className: "platform" }, /* @__PURE__ */ K.createElement("div", { className: "profilecontainer" }, /* @__PURE__ */ K.createElement(
      "div",
      {
        style: { position: "relative", zIndex: 1, display: "inline-block" },
        onClick: () => {
          if (n)
            return;
          const B = s0(e);
          ee({ ...G, photo: B }), P10({ ...G, photo: B });
        }
      },
      !n && /* @__PURE__ */ K.createElement("a", { className: "refresh-button" }, /* @__PURE__ */ K.createElement(Sm, { style: { color: "white" } })),
      /* @__PURE__ */ K.createElement(
        "div",
        {
          className: "avatar-photo ",
          style: {
            backgroundImage: `url(${G && G.photo || Sg})`,
            borderColor: G.color
            // boxShadow: `0 0 70px 50px ${profile.color}44`,
          }
        }
      )
    ), /* @__PURE__ */ K.createElement(
      "input",
      {
        type: "text",
        value: G.name,
        disabled: r,
        onChange: (B) => {
          ee({ ...G, name: B.target.value }), B.target.value && P10({ ...G, name: B.target.value });
        },
        style: { borderColor: G.color },
        className: "input-name",
        maxLength: 10
      }
    ), /* @__PURE__ */ K.createElement("div", { className: "color-tray" }, ci.map((B) => {
      const q = N.includes(B);
      return /* @__PURE__ */ K.createElement(
        "span",
        {
          key: B,
          className: "color" + (B === G.color ? " active" : ""),
          style: {
            backgroundColor: B,
            opacity: q ? 1 : 0.5
          },
          onClick: q ? () => {
            ee({ ...G, color: B }), P10({ ...G, color: B });
          } : () => {
          }
        }
      );
    })), !X && /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement("div", { className: "party-hr" }, /* @__PURE__ */ K.createElement("span", null, "Party")), /* @__PURE__ */ K.createElement(
      kg,
      {
        mobileMode: true,
        showEmptySlots: 4,
        onPlayerKick: (B) => {
          g(B);
        }
      }
    )), /* @__PURE__ */ K.createElement("div", null, te && /* @__PURE__ */ K.createElement(
      "button",
      {
        id: "btn-addbot",
        className: "button-bot",
        onClick: () => {
          F5();
        }
      },
      " +"
    ))), p ? /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(H, null), /* @__PURE__ */ K.createElement(
      "button",
      {
        id: "btn-matchmaking",
        style: {
          cursor: "pointer",
          marginTop: "1rem",
          marginBottom: "6rem"
        },
        className: "button-black launch-btn btn-icon disabled",
        onClick: () => {
          a && y(false);
        }
      },
      b ? "Joining..." : "Connecting...",
      a && /* @__PURE__ */ K.createElement(
        "small",
        {
          style: {
            float: "right",
            padding: "0 1rem",
            fontSize: "0.8rem",
            marginTop: "0.2rem"
          }
        },
        "Cancel"
      )
    )) : /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(H, null), l && /* @__PURE__ */ K.createElement(
      "button",
      {
        id: "btn-matchmaking",
        style: {
          backgroundImage: `url(${AS})`,
          marginTop: "1rem"
        },
        className: "button-black launch-btn btn-icon",
        onClick: async () => {
          y(true);
        }
      },
      "Play Online"
    ), /* @__PURE__ */ K.createElement(
      "section",
      {
        style: {
          width: "100%",
          display: "flex",
          marginBottom: "1rem",
          gap: "1rem"
        }
      },
      I && /* @__PURE__ */ K.createElement(
        "button",
        {
          id: "btn-launchjoin",
          className: "button-black airplay-btn",
          onClick: () => L(true)
        },
        /* @__PURE__ */ K.createElement(
          "img",
          {
            src: Em,
            alt: "airplay-icon",
            className: "airplay-icon"
          }
        )
      ),
      /* @__PURE__ */ K.createElement(
        "section",
        {
          style: { width: "100rem", display: "flex", gap: "1rem" }
        },
        /* @__PURE__ */ K.createElement(
          "button",
          {
            id: "btn-launchjoin",
            style: l ? {
              marginTop: "1rem",
              backgroundImage: `url(${wS})`
            } : void 0,
            className: "button-black" + (a || X ? " launch-btn" : " disabled") + (l ? " btn-icon" : ""),
            onClick: () => {
              a && !X && s.setState("__launched", true), X && o();
            }
          },
          a || X ? l ? "Start Private" : "Launch" : "Waiting for host to start"
        ),
        l && /* @__PURE__ */ K.createElement(
          "button",
          {
            id: "btn-invite",
            style: {
              marginTop: "1rem",
              padding: "0rem 3rem 0rem 2rem"
            },
            className: "button-black",
            onClick: () => {
              U(true);
            }
          },
          "Invite"
        )
      )
    ), !l && (!X || a && X) && /* @__PURE__ */ K.createElement(
      "button",
      {
        id: "btn-invite",
        className: "button-black launch-btn",
        onClick: () => {
          U(true);
        }
      },
      "Invite"
    )), /* @__PURE__ */ K.createElement("p", { className: "sdk-version" }, "Multiplayer by Playroom v.", Gu.version), /* @__PURE__ */ K.createElement(
      TS,
      {
        show: z10,
        onClose: () => {
          U(false);
        },
        baseUrl: t10
      }
    ), /* @__PURE__ */ K.createElement(
      OS,
      {
        show: _,
        onClose: () => {
          L(false);
        }
      }
    )));
  }
  function TS({ show: t10, onClose: e, baseUrl: r }) {
    const n = Ie(), i = (r || window.location.href.split("#")[0]) + "#r=", o = n.currentRoom, s = g3(i, o);
    return t10 ? /* @__PURE__ */ K.createElement(_g, null, /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          zIndex: 101
          // "-webkit-backdrop-filter": "blur(0.3rem)",
          // backdropFilter: "blur(0.3rem)",
        }
      },
      /* @__PURE__ */ K.createElement(
        Li,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            // width: "70rem",
            maxWidth: "500px",
            // height: "99rem",
            // maxHeight: "160vh",
            bottom: "0.7rem",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-10%) scale(0.9)",
            display: "flex",
            // height: "100%",
            // transform: "translate(-50%, -50%) scale(0.5)",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ K.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              // padding: "2rem",
              // gap: "2rem",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "95%",
              padding: "1rem"
            }
          },
          /* @__PURE__ */ K.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Party maker"),
          /* @__PURE__ */ K.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Invite friends to play together"
          ),
          /* @__PURE__ */ K.createElement(
            "div",
            {
              style: {
                backgroundColor: "#ff3666",
                height: "4rem",
                width: "4rem",
                transform: "scale(0.7)",
                borderRadius: "50%",
                position: "absolute",
                top: "1.5rem",
                right: "1rem",
                padding: "1rem",
                cursor: "pointer",
                textAlign: "center",
                display: e ? "flex" : "none",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center"
              },
              onClick: e
            },
            /* @__PURE__ */ K.createElement("img", { src: Eg })
          ),
          /* @__PURE__ */ K.createElement(
            vS,
            {
              noAbsolute: true,
              baseUrl: i,
              size: 128,
              noText: true,
              containerStyles: {
                // transform: "scale(2.5)",
              }
            }
          ),
          /* @__PURE__ */ K.createElement(z7, { text: s })
        )
      )
    )) : null;
  }
  function OS({ show: t10, onClose: e }) {
    return t10 ? /* @__PURE__ */ K.createElement(_g, null, /* @__PURE__ */ K.createElement("div", { className: "airplay-instruction-modal" }, /* @__PURE__ */ K.createElement(
      Li,
      {
        visible: true,
        center: true,
        style: {
          color: "#000",
          maxWidth: "500px",
          bottom: "0.7rem",
          position: "absolute",
          width: "100%",
          left: "50%",
          transform: "translateX(-50%) scale(0.9)",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          borderRadius: "4.5rem"
        }
      },
      /* @__PURE__ */ K.createElement("div", { className: "airplay-instruction-container" }, /* @__PURE__ */ K.createElement(
        "div",
        {
          style: {
            display: e ? "flex" : "none"
          },
          onClick: e,
          className: "close-icon"
        },
        /* @__PURE__ */ K.createElement("img", { src: Eg, alt: "close-icon" })
      ), /* @__PURE__ */ K.createElement(
        "img",
        {
          src: Em,
          alt: "airplay-icon",
          className: "airplay-icon"
        }
      ), /* @__PURE__ */ K.createElement("h1", { className: "airplay-instruction-title" }, "Airplay on TV"), /* @__PURE__ */ K.createElement("ol", null, /* @__PURE__ */ K.createElement("li", null, "Connect your iPhone, iPad, or iPod touch to the same Wi-Fi network as your Apple TV."), /* @__PURE__ */ K.createElement("li", null, "Swipe down from the upper-right corner of the screen to open Control Center on this phone."), /* @__PURE__ */ K.createElement("li", null, "Tap Screen Mirroring ", /* @__PURE__ */ K.createElement("span", { className: "icon-screenmirror" }), "."), /* @__PURE__ */ K.createElement("li", null, "Select your Apple TV or any AirPlay compatible device."), /* @__PURE__ */ K.createElement("li", null, "If an AirPlay passcode appears on your TV screen, enter the passcode on your iOS or iPadOS device."), /* @__PURE__ */ K.createElement("li", null, "Return to this app to continue.")))
    ))) : null;
  }
  const IS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAxNyAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC42NDIxODgiIHk9IjAuNjQyMTg4IiB3aWR0aD0iMTQuNzcwMyIgaGVpZ2h0PSIyNi4zMjk3IiByeD0iMS45MjY1NiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIxLjI4NDM4Ii8+CjxyZWN0IHg9IjYuMTAwODMiIHk9IjIuMjQ3NjkiIHdpZHRoPSIzLjg1MzEzIiBoZWlnaHQ9IjEuMjg0MzgiIHJ4PSIwLjY0MjE4OCIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==", PS = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQ4IiBoZWlnaHQ9IjQ0OCIgdmlld0JveD0iMCAwIDY0OCA0NDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMV84KSI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIxX2RfMV84KSI+CjxwYXRoIGQ9Ik00OTAuNjY3IDIwQzU1My41MiAyMCA1ODQuOTQ3IDIwIDYwNC40NzMgMzkuNTI2M0M2MjQgNTkuMDUyMyA2MjQgOTAuNDc5MyA2MjQgMTUzLjMzM1YyODYuNjY3QzYyNCAzNDkuNTIgNjI0IDM4MC45NDcgNjA0LjQ3MyA0MDAuNDczQzU4NC45NDcgNDIwIDU1My41MiA0MjAgNDkwLjY2NyA0MjBINDU3LjMzM0gxOTAuNjY3SDE1Ny4zMzNDOTQuNDc5MyA0MjAgNjMuMDUyMyA0MjAgNDMuNTI2MyA0MDAuNDczQzI0IDM4MC45NDcgMjQgMzQ5LjUyIDI0IDI4Ni42NjdWMTUzLjMzM0MyNCA5MC40NzkzIDI0IDU5LjA1MjMgNDMuNTI2MyAzOS41MjYzQzYzLjA1MjMgMjAgOTQuNDc5MyAyMCAxNTcuMzMzIDIwSDE5MC42NjdINDU3LjMzM0g0OTAuNjY3WiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSI0MCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc2hhcGUtcmVuZGVyaW5nPSJjcmlzcEVkZ2VzIi8+CjwvZz4KPHBhdGggZD0iTTQyNCAxNTMuMzMzVjE1My42NjciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iNjYuNjY2NyIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik00OTAuNjY3IDI4Ni42NjdWMjg3IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjY2LjY2NjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjA3LjMzMyAxMzYuNjY3VjMwMy4zMzMiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjkwLjY2NyAyMjBIMTI0IiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjI4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9nPgo8ZGVmcz4KPGZpbHRlciBpZD0iZmlsdGVyMF9kXzFfOCIgeD0iLTMuMDUxNzZlLTA1IiB5PSItMy4wNTE3NmUtMDUiIHdpZHRoPSI2NDgiIGhlaWdodD0iNDQ4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMV84IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8ZmlsdGVyIGlkPSJmaWx0ZXIxX2RfMV84IiB4PSItMy4wNTE3NmUtMDUiIHk9Ii0zLjA1MTc2ZS0wNSIgd2lkdGg9IjY0OCIgaGVpZ2h0PSI0NDgiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+CjxmZU9mZnNldCBkeT0iNCIvPgo8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIyIi8+CjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYSIgb3BlcmF0b3I9Im91dCIvPgo8ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4yNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzFfOCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzgiIHJlc3VsdD0ic2hhcGUiLz4KPC9maWx0ZXI+CjwvZGVmcz4KPC9zdmc+Cg==";
  function RS({
    zIndex: t10,
    demoMode: e,
    noAbsolute: r,
    noText: n,
    size: i = 256,
    containerStyles: o = {},
    baseUrl: s = "https://joinplayroom.com/"
  }) {
    const l = Ie().currentRoom;
    return reactExports.useEffect(() => {
    }, []), /* @__PURE__ */ K.createElement(
      "div",
      {
        className: "room-code-sticker",
        style: {
          zIndex: t10 || "initial",
          position: r ? "initial" : "absolute",
          ...o
        }
      },
      /* @__PURE__ */ K.createElement("div", { className: "qr-code" }, /* @__PURE__ */ K.createElement(
        Fm,
        {
          id: "QRCodeScaled",
          size: i,
          style: { height: "auto", maxWidth: "100%", width: "100%" },
          value: e ? "https://joinplayroom.com/demohost" : `${s}R${l || ""}`,
          viewBox: `0 0 ${i} ${i}`
        }
      )),
      !n && l && /* @__PURE__ */ K.createElement("div", { className: "room-code" }, /* @__PURE__ */ K.createElement("b", null, l), /* @__PURE__ */ K.createElement("span", null, "Scan QR code to join the room")),
      !n && !l && /* @__PURE__ */ K.createElement("div", { className: "room-code" }, /* @__PURE__ */ K.createElement("b", null, "Scan to start"), /* @__PURE__ */ K.createElement("span", null, "Download the game from the Appstore"))
    );
  }
  function a0() {
    const { innerWidth: t10, innerHeight: e } = window;
    return {
      width: t10,
      height: e
    };
  }
  function DS() {
    let t10 = document.querySelector('meta[name="viewport"]');
    t10 || (t10 = document.createElement("meta"), t10.name = "viewport", t10.content = "width=device-width, initial-scale=1.0", document.head.appendChild(t10));
  }
  function Wm() {
    const [t10, e] = reactExports.useState(
      a0()
    );
    return reactExports.useEffect(() => {
      function r() {
        e(a0());
      }
      return DS(), window.addEventListener("resize", r), () => window.removeEventListener("resize", r);
    }, []), t10;
  }
  class Um {
    /**
     * Constructor
     */
    constructor(e) {
      this.start = Date.now(), this.current = this.start, this.elapsed = 0, this.delta = 16, this.onTick = e, this.tick = this.tick.bind(this), this.tick();
    }
    /**
     * Tick
     */
    tick() {
      this.ticker = window.requestAnimationFrame(this.tick);
      const e = Date.now();
      this.delta = e - this.current, this.elapsed = e - this.start, this.current = e, this.delta > 60 && (this.delta = 60), this.onTick(this.delta, this.elapsed);
    }
    /**
     * Stop
     */
    stop() {
      window.cancelAnimationFrame(this.ticker);
    }
  }
  const l0 = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ];
  function MS(t10) {
    var e = Math.PI / 2, r, n;
    t10 > -e && t10 < e ? r = "right" : r = "left", t10 > 0 ? n = "up" : n = "down";
    let i = {};
    return r && (i.x = r), n && (i.y = n), i;
  }
  function NS(t10, e) {
    return t10 === 0 && e === 0 ? NaN : -Math.atan2(e, t10);
  }
  function LS() {
    return new Promise((t10, e) => {
      Ie().connection.once("sync", () => {
        t10();
      });
    });
  }
  async function BS() {
    const t10 = Ie();
    await LS(), Object.values(t10.getPlayers()).filter(
      (o) => o.getState("__proxyBy")
    ).forEach((o) => {
      t10.connection.removeProxyPlayer(o.id);
    });
    let r = [];
    function n(o, s) {
      const a = r.find(
        (c) => c.joystick.id == o.id && c.joystick.index == o.index
      );
      if (a)
        return a.player;
      if (!s)
        return;
      const l = t10.connection.addProxyPlayer();
      return l.setState("profile", {
        name: "Gamepad " + (r.length + 1),
        // TODO: check and use avatars override here if provided.
        photo: Ha(qa(l.id)),
        color: l0[r.length % l0.length]
      }), l.setState("__gamepad", true), r.push({ player: l, joystick: o }), l.on("quit", () => {
        const c = r.findIndex((u) => u.player.id == l.id);
        r.splice(c, 1);
      }), l;
    }
    const i = new Um(() => {
      var l;
      const o = (l = navigator.getGamepads()) == null ? void 0 : l.map((c, u) => [c, u]).filter(([c, u]) => c && c.connected), s = t10.sdkOptions, a = (s == null ? void 0 : s.joystickConfig) || false;
      o.forEach(([c]) => {
        let u = n(c);
        const f = c.buttons.slice(0, 4).map((p) => p.pressed);
        if (!u) {
          if (!f.some((b) => b))
            return;
          const y = Object.keys(t10.getPlayers()).length;
          if (s.maxPlayersPerRoom && y >= s.maxPlayersPerRoom)
            return;
          u = n(c, true);
        }
        f.forEach((p, y) => {
          var x, S;
          let b = `ctr-button${y + 1}`;
          a && a.buttons && (u.getState(b) && u.setState(b, void 0), b = (x = a.buttons[y]) != null && x.id ? `ctr-${(S = a.buttons[y]) == null ? void 0 : S.id}` : b), u.setState(b, p);
        });
        let d = c.axes;
        Math.abs(d[0]) < 0.1 && Math.abs(d[1]) < 0.1 && (d = [0, 0]);
        const h = NS(d[0], d[1]), g = Math.PI * 0.5;
        isNaN(h) ? (u.setState("ctr-joystick", false), u.setState("ctr-angle", 0), u.setState("ctr-dpad", null)) : (u.setState("ctr-joystick", true), u.setState("ctr-angle", h + g), u.setState("ctr-dpad", MS(h)));
      });
    });
    return () => {
      i.stop();
    };
  }
  function FS(t10, e) {
    return Math.floor(Math.random() * (e - t10 + 1)) + t10;
  }
  function jS(t10) {
    let e = "";
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = r.length;
    for (let i = 0; i < t10; ++i)
      e += r.charAt(Math.floor(Math.random() * n));
    return e;
  }
  const c0 = [
    "#59BF82",
    "#FFF27A",
    "#F14EEB",
    "#FF7F56",
    "#6BDCFF",
    "#3905F5",
    "#FF3666"
  ], u0 = [
    "Eclipse",
    "Crankshaft",
    "Firetruck",
    "President",
    "Bat",
    "Avocado",
    "Holiday",
    "Salad",
    "Boom",
    "Cornflakes",
    "Pancake",
    "Penguin",
    "Pirate",
    "Pumpkin",
    "Rainbow",
    "Squirrel"
  ];
  function WS(t10) {
    return t10 && t10.length > 0 ? t10[Math.floor(Math.random() * t10.length)] : Ha(qa(jS(10)));
  }
  function US(t10) {
    const e = {
      color: c0[Math.floor(Math.random() * c0.length)],
      name: xt.get("playerName") || u0[Math.floor(Math.random() * u0.length)] + FS(10, 99),
      photo: xt.get("playerPhoto") && xt.get("playerPhoto") !== "false" ? xt.get("playerPhoto") : WS(t10)
    };
    return xt.set("playerName", e.name), xt.set("playerPhoto", e.photo), e;
  }
  function zS({ options: t10 = {}, onStart: e, onReject: r }) {
    const { height: n } = Wm(), i = Mu(), [o, s] = reactExports.useState(false), [a, l] = reactExports.useState(false), [c, u] = reactExports.useState(false), [f, d] = yi("__matchmakingqueue"), [h, g] = yi(
      "__matchmakingChosenRoom"
    ), p = Xc.getUrlHashParameter("streaming"), y = Dn("player_name") ? decodeURIComponent(Dn("player_name")) : void 0, b = Dn("player_photo") ? decodeURIComponent(Dn("player_photo")) : void 0, x = Xc.getUrlHashParameter("skipLobby");
    let S = {
      ...t10
    };
    const O = US(S.avatars);
    S.profile = S.profile || {
      name: O.name,
      photo: O.photo
    }, y && (S.profile = {
      ...S.profile,
      name: y
    }), b && (S.profile = {
      ...S.profile,
      photo: b
    });
    const _ = Ie(S), L = t10.streamMode || false, N = p || L && !Z5(), [j] = yi("__launched"), [W, G] = reactExports.useState(false), ee = t10.skipLobby || x;
    reactExports.useEffect(() => {
      o && (t10.skipLobby || x) && !t10.matchmaking && _.setState("__launched", true);
    }, [o]), reactExports.useEffect(() => {
      (j || W) && e();
    }, [j, W]), reactExports.useEffect(() => {
      var V, te;
      const U = document.createElement("style");
      U.innerHTML = [lg, cg, ug].join(`
`), document.head.appendChild(U);
      let I = Dn("r") ? Dn("r").slice(1) : t10.roomCode;
      I ? N ? _.spectateRoom(I, false, true, true) : _.joinRoom(I, true, true) : N ? _.spectateRoom(void 0, true, true) : _.createRoom(void 0, true, true), _.once("connection_initiated", () => {
        _.connection.once("connected", () => {
          Kc("r", "R" + _.currentRoom), s(true), mi.track("SDK: Connected", { gameId: t10.gameId }), t10.matchmaking && ee && d(true);
        }), _.connection.once("disconnected", (X) => {
          Ln.roomLimitExceed.code === X.eventCode ? fe() : Ln.playerKicked.code === X.eventCode ? P10() : X.reason === "MANUAL_DISCONNECT" ? s(false) : window.location.reload();
        });
      }), mi.track("SDK: Insert Coin", {
        ...t10,
        isStreamScreen: N
      }), (V = Ie().sdkOptions) != null && V.allowGamepads && N && BS(), (te = Ie().sdkOptions) != null && te.enableBots && N5();
    }, []), reactExports.useEffect(() => {
      (async () => {
        var H;
        if (!f || !i)
          return;
        const I = Math.max(
          1,
          parseInt(
            (((H = t10.matchmaking) == null ? void 0 : H.waitBeforeCreatingNewRoom) || 5e3) / 1e3
          )
        ), V = jm(), te = Object.keys(_.getPlayers()).length, X = _.connection.getHostname(false) + "/api/game/" + V + "/matchmaking_find?forPlayers=" + te;
        mi.track("SDK: Matchmaking", { gameId: t10.gameId });
        for (let $ = 0; $ < I; $++) {
          if (await Bl(1e3), !_.getState("__matchmakingqueue"))
            return;
          const se = await fetch(X, {
            method: "GET",
            headers: {
              "Content-Type": "application/json"
            }
          });
          if (se.ok) {
            const he = await se.json(), pe = $ === I - 1;
            he.room && (he.new && pe || !he.new) && g(he.room);
          }
        }
      })();
    }, [f, i]), reactExports.useEffect(() => {
      (async () => {
        if (h) {
          await Bl(1e3);
          const I = JSON.parse(
            JSON.stringify(_.getMyPlayerState().getState())
          );
          _.leaveRoom(), Kc("r", void 0), await Bl(100), _.joinRoom(h, true, true), _.once("connected", () => {
            Object.keys(I || {}).forEach((V) => {
              _.getMyPlayerState().setState(V, I[V]);
            }), _.setState("__launched", true), _.emit("matchmaking_room_joined");
          });
        }
      })();
    }, [h]);
    const fe = () => {
      !(S != null && S.skipLobby) && !x && l(true), r({ message: Ln.roomLimitExceed.reason });
    }, P10 = () => {
      !(S != null && S.skipLobby) && !x && u(true), r({ message: Ln.playerKicked.reason });
    }, z10 = () => {
      l(false);
    };
    return a ? /* @__PURE__ */ K.createElement(HS, { hide: z10 }) : c ? /* @__PURE__ */ K.createElement(YS, { hide: () => u(false) }) : !o || j || ee || W ? null : /* @__PURE__ */ K.createElement("div", { className: "bootstrap-wrapper" }, /* @__PURE__ */ K.createElement("div", { className: "playroom" }, /* @__PURE__ */ K.createElement("div", { className: "modal-container fullscreen " }, /* @__PURE__ */ K.createElement("div", { "data-pop": "slide-up", id: "popup", className: "show" }, /* @__PURE__ */ K.createElement("div", { className: "popupcontrols" }), /* @__PURE__ */ K.createElement(
      "div",
      {
        className: "popupcontent",
        style: { transform: `scale(${Math.min(1, n / 880)})` }
      },
      !N && o && /* @__PURE__ */ K.createElement(
        CS,
        {
          baseUrl: t10.baseUrl,
          avatarsOverride: t10.avatars,
          lockedNameField: !!y,
          lockedPhotoField: !!b,
          matchmakingOptions: t10.matchmaking,
          onTurnbasedLaunch: () => G(true)
        }
      ),
      N && /* @__PURE__ */ K.createElement(VS, { baseUrl: t10.baseUrl, show: true })
    )), /* @__PURE__ */ K.createElement("div", { id: "overlay", className: "show" }))));
  }
  function VS({ show: t10, baseUrl: e }) {
    var u, f, d;
    const r = Ie(), n = (e || window.location.href.split("#")[0]) + "#r=", i = (u = r.sdkOptions) == null ? void 0 : u.allowGamepads, o = Va(true), [s] = yi("__gamepadPressedTime"), a = o.every((h) => h.getState("__gamepad")) && o.length > 0, l = (o == null ? void 0 : o.length) || 0, c = !((f = r.sdkOptions) != null && f.maxPlayersPerRoom) || l < ((d = r.sdkOptions) == null ? void 0 : d.maxPlayersPerRoom);
    return reactExports.useEffect(() => {
      let h = {};
      if (a) {
        let g = function() {
          const y = Object.values(r.getPlayers()).map(
            (S) => new Pc(S)
          );
          let b = {};
          y.forEach((S) => {
            S.isAnyButtonPressed() ? (h[S.playerState.id] || (h[S.playerState.id] = (/* @__PURE__ */ new Date()).getTime()), b[S.playerState.id] = (/* @__PURE__ */ new Date()).getTime() - h[S.playerState.id], b[S.playerState.id] > 2e3 && r.setState("__launched", true)) : (h[S.playerState.id] = void 0, b[S.playerState.id] = void 0);
          });
          let x = 0;
          Object.values(b).forEach((S) => {
            S > x && (x = S);
          }), r.setState("__gamepadPressedTime", x);
        };
        const p = new Um(g);
        return () => {
          p.stop(), r.setState("__gamepadPressedTime", void 0);
        };
      }
    }, [a]), t10 ? /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          zIndex: 101
          // "-webkit-backdrop-filter": "blur(0.3rem)",
          // backdropFilter: "blur(0.3rem)",
        }
      },
      /* @__PURE__ */ K.createElement(
        Li,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            // width: "70rem",
            maxWidth: "500px",
            // height: "99rem",
            // maxHeight: "160vh",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            // height: "100%",
            // transform: "translate(-50%, -50%) scale(0.5)",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ K.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              // padding: "2rem",
              // gap: "2rem",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "95%",
              padding: "1rem"
            }
          },
          /* @__PURE__ */ K.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Party maker"),
          /* @__PURE__ */ K.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Invite friends to play together"
          ),
          /* @__PURE__ */ K.createElement(
            RS,
            {
              noAbsolute: true,
              baseUrl: n,
              size: 128,
              noText: true,
              containerStyles: {
                // transform: "scale(2.5)",
              }
            }
          ),
          i ? /* @__PURE__ */ K.createElement("div", { style: { marginBottom: "2rem" } }, /* @__PURE__ */ K.createElement(f0, { expanded: true }), /* @__PURE__ */ K.createElement("hr", null), /* @__PURE__ */ K.createElement(
            qS,
            {
              allGamepads: a,
              holdProgress: s,
              playerLimitHasReached: !c
            }
          )) : /* @__PURE__ */ K.createElement(f0, null),
          /* @__PURE__ */ K.createElement(kg, { showEmptySlots: 4 })
        )
      )
    ) : null;
  }
  function qS({ allGamepads: t10, holdProgress: e, playerLimitHasReached: r }) {
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          display: "flex",
          flexDirection: "row",
          padding: "1rem 2rem",
          transform: "scale(0.8)",
          marginTop: "2rem",
          alignItems: "center"
        }
      },
      /* @__PURE__ */ K.createElement(
        "img",
        {
          src: PS,
          style: {
            objectFit: "contain",
            height: "105%",
            width: "3rem",
            marginRight: "1rem",
            animation: "1s wiggle 3s ease-in-out infinite"
          }
        }
      ),
      /* @__PURE__ */ K.createElement(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            lineHeight: "normal",
            textAlign: "left",
            justifyContent: "center"
          }
        },
        /* @__PURE__ */ K.createElement(
          "h2",
          {
            style: {
              padding: "0",
              margin: "0",
              lineHeight: "normal"
            }
          },
          r ? "Room is full" : "Press button on game pad",
          t10 && /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement("br", null), /* @__PURE__ */ K.createElement(
            "div",
            {
              style: {
                backgroundImage: "linear-gradient(to right, rgb(141 107 237), rgb(141 107 237))",
                backgroundRepeat: "no-repeat",
                backgroundPositionY: "bottom",
                paddingBottom: "0.5rem",
                backgroundSize: `${e ? e / 2e3 * 100 : 0}% 20%`
              }
            },
            "Press & hold to launch"
          ))
        )
      )
    );
  }
  function f0({ expanded: t10 }) {
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          // background: "#000000",
          // color: "#ffffff",
          transform: "scale(0.8)",
          display: "flex",
          flexDirection: "row",
          borderRadius: "1rem",
          padding: "1rem 2rem",
          marginTop: "-3rem",
          marginBottom: "2rem"
        }
      },
      /* @__PURE__ */ K.createElement(
        "img",
        {
          src: IS,
          style: {
            objectFit: "contain",
            height: "105%",
            width: "2rem",
            marginRight: t10 ? "2rem" : "1rem",
            animation: "1s wiggle 3s ease-in-out infinite"
          }
        }
      ),
      /* @__PURE__ */ K.createElement(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            lineHeight: "normal",
            textAlign: "left",
            justifyContent: "center"
          }
        },
        /* @__PURE__ */ K.createElement(
          "h2",
          {
            style: {
              padding: "0",
              margin: "0",
              lineHeight: "normal"
            }
          },
          "Scan the code ",
          t10 ? " from phone" : ""
        )
      )
    );
  }
  function HS({ hide: t10 }) {
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ K.createElement(
        Li,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ K.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ K.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ K.createElement("div", null, /* @__PURE__ */ K.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Room is full"), /* @__PURE__ */ K.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "Looks like the game is in progress"
          )),
          /* @__PURE__ */ K.createElement("button", { id: "btn-invite", className: "close-btn", onClick: t10 }, "Close")
        )
      )
    );
  }
  function YS({ hide: t10 }) {
    return /* @__PURE__ */ K.createElement(
      "div",
      {
        "data-testid": "full-room-popup",
        id: "full-room-popup",
        className: "full-room-container"
      },
      /* @__PURE__ */ K.createElement(
        Li,
        {
          visible: true,
          center: true,
          style: {
            color: "#000",
            maxWidth: "500px",
            top: "50%",
            position: "absolute",
            width: "100%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%) scale(0.9)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            borderRadius: "4.5rem"
          }
        },
        /* @__PURE__ */ K.createElement(
          "div",
          {
            className: "create-room-modal",
            style: {
              fontFamily: '"Russo One", sans-serif',
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "space-between",
              textAlign: "center",
              margin: "1rem 0rem",
              background: "#fff",
              border: "2px solid #000000",
              boxShadow: "0px 12px 0px rgba(0, 0, 0, 0.25)",
              borderRadius: "20px",
              width: "100%",
              maxWidth: "360px",
              aspectRatio: "1/1",
              padding: "2.5rem 2rem 2.5rem 2rem"
            }
          },
          /* @__PURE__ */ K.createElement("span", { style: { fontSize: "40px" } }, ""),
          /* @__PURE__ */ K.createElement("div", null, /* @__PURE__ */ K.createElement("h1", { style: { marginBottom: "0.1rem", marginTop: "0rem" } }, "Disconnected"), /* @__PURE__ */ K.createElement(
            "h3",
            {
              style: {
                fontWeight: "bold",
                fontSize: "1rem",
                lineHeight: "normal",
                margin: "0rem",
                fontFamily: "'Open Sans', sans-serif"
              }
            },
            "You were removed from the party"
          )),
          /* @__PURE__ */ K.createElement("button", { id: "btn-invite", className: "close-btn", onClick: t10 }, "Close")
        )
      )
    );
  }
  function d0(t10 = {}, e, r) {
    if (window.__playroomjs_mounted)
      return;
    var n = document.createElement("div");
    document.body.appendChild(n), window.__playroomjs_mounted = true;
    const i = (o) => {
      delete window.__playroomjs_mounted, Ie.reset(), r(o);
    };
    KS(
      /* @__PURE__ */ K.createElement(zS, { options: t10, onStart: e, onReject: i }),
      n
    );
  }
  function KS(t10, e) {
    Wt.createRoot ? Wt.createRoot(e).render(t10) : Wt.render(t10, e);
  }
  const XS = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0oAAANKCAYAAAC02r7tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAJKMSURBVHgB7P13lGTped95/u69YdNX2vKuq7ur2gNomAZAoOFEigBJQCIJzpwjDXfEkTlaacThH7ua0e5yjjRnj2bnSHtmNbPSWVkuJVKOFEkJokhCAEk4gnDtvSlvs9Jnhrv3zvPcG1FVHV3VXSYzKyPy++m+FZGRmZGZkVFR7+8+7/u8gaRUAAAAAIArQgEAAAAA3oKgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCgIAAHdFUCzaH8F135c2GgIA3D0EJQDA3WVBIbAjmppSUC7bv0z2T1Nqt6fJDT4+lMLwHUPGVuc/r6JIKpXsx7nO5A57d+OFF6Q4VrK6KgDA5iMoAQDuqiwoWDiqfurTKuzZq3DHDilJlNygohJ4uLBAVZieVuBhowdlP0N1QEGlkgema9/nIcqOi7/w80qWl5S89JIAAJuPoAQAuLu8omRBqfzIoyo98KCisRGlaarUqinX/XD7WA9I4eBg71aUPBxZRSwoXKcqFuR/ZD9n2JtBEAD6AUEJAHB3tStK5UcfU+VDT1hQGspuTm/w4b0ZjW6Dh6kerZgBQD8gKAEAtoS0VlO6uqrUg1JiFaVGV0XJE1IQZtWmIE3Vt4qhVZxoSgsAdxtBCQCwRVg4uraBQ3cY8jeDpP2u/g1KQftHu26TBwDApiEoAQC2llQ3nnfXz5WkbtWqAquyAQDuDk5XAQCwBXmziqxdOgDgrqCiBADAFhSNT0hsOgsAdw1BCQCALcYnGBYOHHjrmi0AwKZi6h0AAFtQMDCgoFwRAODuoKIEAMAWVD56TEGzKQDA3UFFCQCALSgcGckbOpRKtAoHgLuAV14AALagaHpG4eSUgmpVKjABBAA2G0EJALDtpVvoSOwP7+EQjY4qmppS8fA9WXUJALC5CEoAgG1vKwWlzjfklSSfehdOTmbT7wAAm4taPgCg77SUh46WelArtj/sGBtSsntGlSc+rOTCBbXOnNFEVLQznEH2YXUrO/nRTFMlVyMWAGCdEJQAAH2jExcGgjxMvNs/cv5+n1oR6eYF13zO7UzLKLfvo/0tvqO4WNLazE6tTcyoNTKlqSRU1P4hZ+O6HU2djWuqJbEAAOuLoAQA6Bu+Pav/w7bHUsiwXU69SxjZYe/3SW2DuonU0ub3X7EPH2lf3goPVzvte/OAVXy3z7VKUWvHuJZ+5EeUHp9XujqsvbOrKsT5JrR/VLusP1q7rF9fPq3TyZoAAOuLoAQA6HmdSpJHCM8fD1gYOWxX3h+9cxrxkOShpXALQSmrJAVXP/dW+MdXg6tVqXeS1YgqJTWnJ6S9+5QentPA3EuKWi374mXdm7TUsjD15dULOh/U7XoiAMD6ISgBAPpC1jHODs9Gu+04YmHpifAWSz5biAcl3z8pHBpSOj4uTUxZuno9qzQFUUnThYpWk6aGwojOTACwAQhKAABsQdeGn6X33q/6zLhGvvu8onheBasm7QrLGq8UdU9xSJdaDb3RXBEAYP1wEgoAgC0oaB+ZSlnp2LDiSik7lCQq+s1WTRoJihoKOO8JAOuNoAQAwBZX2j2lgWOHtPrYfVo5dlDpyprCOFE5LOi+0pAeKg0LALC+CEoAAGxxhShSqVhQeGSfAjsUdv75TrW/NKjD5SEBANYXtXoAALa4QsGDUajovv3SQCVvu+cbMaWp9hUHtJz05Na6ALClEZQAANji0vYRHT2sdHKHVu47qNLcoop2HIqqisrSfaXhLDCdabGnEgCsB4ISAABbXGefqHBiRGkcq7lzQlGjqeLsvIajosbCWFOFkpJWKgDA+mCNEgAAW1zYPgYqJZUnR7X8hY+rcXR/1v1uICposlDVh8vjurc4KADA+iAoAQDQQ8JCIeuCF0yPqzkxpiRNVUxSHSwNamdUVTEI1Lvb7ALA1kFQAgCglxQjDTx0j3TfAa0d3K2kVFCh2dT7KxM6XB5UJYgUBkQlALhTBCUAAHqI14vKlZLS+/Zr9TMfUH16TGmpqPuLg3YM6f7yiAbZgBYA7hivpAAA9BAvFoVRqHR4QPHMuJJySYUw1HAaaDgs2lFQREUJAO4YFSUAAHpMZEf12EGNfuFJNT72Hq08dp9Ub+reoKqfGzmonVFFAIA7Q1ACAKAHeVgq+hVfp3Rot9JCQdVCUXuKAxqPStoRlgQAuH0EJQAAepDPnfe6UfDwESUfflRJqajx8oAeLY/qUHFQuwtUlQDgTrBGCQCAHlbaN52tWVp7z/0Kz8+q+toJvc/Ckq9Veq6xKADA7SEoAQDQw8KRIYVxqsa+GZWbLZVeTrU7qiihoQMA3BGm3gEA0MMG7Bgaqkr/p88q/RMfULp7Sk+WxvVT2qE9hap2RKxVAoDbQVACAKAPFKoVqy4NqjUzoUKlonJU0K5CRRMEJQC4LUy9AwCgx4XFgob271RjtablC/Maml9SsZnqRwd36qn6gl5tLAsAcGuoKAEA0Ad8RVI4PqrosfvUstBU3zWp94ZDOhJUNRIWVQz4Jx8AbgUVJQAA+oDHoGh8RNF77lfrwC6lq3W999VBnQvXsg54cZKqmSYCANwcTi8BANAnvE14pVpW8wsfV+3P/4R2jU/rkbEZ/fTwXu0vDggAcPOoKAEA0CeCIFAYWGVpdEixXx8a1Eiyqt1RWaNBIZt+R1UJAG4OQQkAgD4RtI+RI/uU2uXcp96nqVeP64t/uKw3okVdjGp6rbUqAMC7IygBANBnOlvNpk88rMJASeXXT+nohWUtLKZ6bYmgBAA3gzVKAAD0mawDnl/58CMqPnKfRvbs1LHRKX2oOiEAwM2hogQAQJ8aHRtSev8Brf70Z3Tkt0Lt+06ih0ojWklivdFaEQDgxqgoAQDQp4rFgoKpMSX37tP45IR27ZjQ/qiqibCUNX4IrkzSAwB0o6IEAEAfCyfHVPRjflHR4X36P/9PL+rZeFnPNBcUB6laqQAA10FQAgCgj3nNKLIj3TWtVjPR7j17tLA8p0P1M5qNm7oY1wUAeDuCEgAAfSxsH7WjB9Q6slcPP/iQipfP64OXT+ipxgJBCQBugKAEAMA2UCpGKhYiJf/Vj2nny2/oZ19+Xb+2dEoXWnVdTBpsRAsAXQhKAABsA2GY929qHdyt8vKKDpYGNRmVVQ3o6wQA10NQAgBgGwkeOKDqzh06OPI/6Au/8ds6Ysdfu/AUU/AAoAunkQAA2EayhuCVkrRrUjsO7dehY0d1z+CY9herAgBcRUUJAIBtJDtDWi1LDxzWnvkl7YkjfeTlp/SmXZ5orgkAkCMoAQB6XtA+XJJKS2mqWqBrbsVbBPa4RKGC+/ZLI0P68e98RyfOndUf/tF/0EoaayVpCQC2O4ISAKCv+P6pXhdpCu8otLA0PS5N7tCDh45oLCxqOIjUShOtCABAUAIA9BUPSqt20Jrg3aVhaEeqsb/6M6qcvai/9dor+nfnXtWvn3slC0w0DAewnRGUAAB9xwf4qfCu2tMTI6sqhXFLRx55UPeUmrpn7bJOLM9rpUVdDsD2Rdc7AAC2Kc9J2UBgoKzqnp16/Bf+vD73Ez+u/+aBD2rX4IgAYDujogQAALLmDsn0Du196Kg+tLqmb144odJaQ883lgQA2xEVJQAAkAWldGZcex46pg998km9d2qvjhWHBQDbFRUlAACQ8bOnwb4ZadeE/uv/+1/Xx59+Tmf+x7+hS626XqGyBGCbISgBAIBM1tuhEGXH4M5pTc0vaNfklJqLcyo2V9RM6YMHYPsgKAEAgLcZfOw+7TuyR//X1f+Hvvatb2rtn/0TvdlaZTNaANsGQQkAAFxXoVTS7vc8qEejRJ+fvaRf+9pXdPrSRS0mtA0H0P8ISgAA4LqiUlF73vOQykODGo5DfefF57V4eY6gBGBbICgBAIB3NLxrWkd/9BP66bnz+vCJk/rbf+/vKk6lehoLAPoVQQkAALwjryj5cfSRh7VjYlLT45NarK2qubqiNE2zAwD6DUEJAADclA9/5hPZ5crikv7oe9/RL//bf6XV+poaTabiAeg/BCUAAHBL7nngPi3FDX3k3Bk98+wzOnfhvJqtJpUlAH2FoAQAAG7JE5/+hHYfuUfTe/bon/zjf6TFry9oMW4RlAD0FYISAAC4ZVNTk/rYkx9TUinqYz/2Of3jX/qnOnv6tBbtAIB+QFACAAC3bGBwIDuOHL1f5R07VBoaUqlaFQD0C4ISAGBLSJstpQ2aAvSa99x3X3ZM/JNf0ndefEF/43/7e2q89JIdLwoAehlBCQBw9yWJ0paFpGZD6E3DpaJ2WWXp8Yce0vlAOhe3tHzunFq1mv1uWwKAXhPZ8YsCAOAuCfyPNNXAJz+pcGxMhb178nfEiW6Vb3/qZwAPhYH2BYEeCwNhc8wMDerwnt168pOf0PDBQ1ravUdnnn5asXfDaxCAAfQeKkoAgC0hbcVK2Y+np5Ut8E7HqZ48fFj7R0cUWaXw8sWLevq3fkvxxQuKL1wQAPQKghIAYGvwCtJtVJGwdYR2jFhYum9yUvtmpvWVWkOnzp/Xc9/9rtLaGkEJQE8hKAEAgPURBDayCOW97ypWTfobDxzVwoPHdOzhR/Sdp36g7z31lJZ/6zcVnz6t1skTAoCtjKAEAADWj4WlwKpKvjpsqlJRKZUe2Tmj+tJh1eJYr5w7p6VdpxSUSkobdSWzs0pqtayhBwBsJQQlAACwvryyZIdPxdthV3/GqkzvOXqfnrz/Pv1/nviwXp6b0/Jv/oaar7yitd//qmTVpWR1VQCwlRCUAADAhpv0GlOQ6icGKjoejOkPPvhBzR88qDMHDij5/veUWniqP/WDrKFHsrAgALjbCEoAAGDDTVhOmrCwNDRQ1dlqVac/+CGdqdV0+UNPKN25U+n582qeOqV0bZWgBGBLICgBAIBNsysINGWh6W8XQ70SVvX75ZJ++2e+qNlmQwOf/Wy2Zqn+x3+smlWZWqdPZ9Pz0uVlJctLAoDNRFACAACbxtctFe2YssC0HEn7gkj7igVFVmma3Z2oOTSs1sULKl6eVVCwYYqFpHhx0T7JrjdbSltNqV7P7itNUwHARiEoAQCATeUd8cp2HLWwdDQK9HiSat6OvzMyouWxUb10+IAGfvKnFFkOajzztOJz56zC9H01X35ZjZdfUuPZZ5R6p7xGQwCwUQhKAADgrpqx5DRqlz9hoemSxahhC02nE2neKkbpzLSCoUFVBwdUuvdeVR5/v5qvvKxkbU1N75Y3N5cfCwt5u3GrPmWVpjgWANwJghIAALirdno7ceVB6bRlnHqcqOZVJp9Zt3NGob2/fOQeqyI1sqN1wgLSyrLWvvPHar3+uh2vWWg6mYWkZGVFQZIoJSgBuEMEJQAAsCWM2FGxzPRno1CPBanOKtWX4lTn00SnLDgFYSgNVVU8vF+FVkvF/XusslSz8LSm1plzipeW1XrzzazxQ+vcOas0XVa6tKTmieP2MXXFFy9m0/V8nVNqny/WOAF4BwQlAACwJRTbx6CFpWYYaMpyzIsWZgp2uZDmtzUtRGlwMFvnFI6OKmp/bjSzW4kHpekpxQsLis6cUXL+vN22pKBcVlKrKRwYyNqPZ3s1+Qa3VnVKrfqUBSavQq2tZffl7wcAghIAANhyjgR+BHqPhaOzlmO+FCd62qpKTzdinbBLqwepqryLnh/R+JiiyXGVrNrUkTYt/NjHZgHIKkixhaZ0ccFCk1Wgjh+3ypMFq3aYipcWVf/KV7IOe62TJwQABCUAALBleQgaDbxDnlWbLDSNWfXnu1ZPWrLwdMmuWz1IXv8pxKmCNFF7uVMuyI+gWFAaRQpTqyAVAgWNAbvZPrfZUMEqUF5t8uYQrZdessQVEZQAZAhKAABgy/KpeDvs+GQU6j0WjOYV6V9adem8BaX/aOGoZpc+Ya5it0Xd/RsiT0kWtSoVhR6ahqr57X7zPYff9rVq3/5jBeWK6k8/JQAgKAEAgJ4waOUiD06fs9C0aAFpv739uoWn15JUx+2o2ft8K9rOdLzQG0B4zcnXH/kdBF136OWnMMzXKfnh+zKxPglAG0EJAAD0hFL7eMgCTiPIO+QNWRWpaZeX7Kin+dolb/CQZaK0/cd1mttdCU5+WGUqtYqU4lZ+AIAISgAAoAd5YHqvBab3FgL9N3b9Kd+k1i5/s5XorAWm5+1tn5Ln9aEB5XkoEgDcPIISAADoed5SfNTKRPeGgYa9OGRvX7bbF+1Ybe+X5EuYgmsOAHgnBCUAANDzvJW4txT/kAWl8xaMXrFs9C2rKr1hx5fjNAtJK8orUT748TVMBCYA74SgBAAA+oYHoB0Wmu4PvFteoJUw1WF7e95ufyHJu+X59WULU6kdgXfLs0um5QHoRlACAAB9wytE1faxM+zcIl20MNRIA9WUaqXd38GrTFlYIigBuA6CEgAA6GvvDfNJdj9k1aWz2V5M0lfjVKctLT1vx2wY6nLWQpyJeACuIigBAIC+Vu5cBoFSO0YtLN1nmWjCjiiRztvlBYU6WS5rrVpVPch2X1KSpgKwfRGUAADAtjHuf1gQ+slCkG1Oe9EOrzKds0z0z6ZndHGtpqUgUiNN7P0EJWA7IygBAIBtydcljcgbQAQaCVJ9bnq/lmuhPjywX2fVtPDU1IW4plqS6HRrLQtPtTQWgO2BoAQAALYlHwR5UBrJliYFmpzep1a9qIYFpedU0/Na07P1BS3ETS0mTa1aSKrFBCVguyAoAQCAbc2jT0t5J7yC1ZfGC1VNlkf04XJJrSRWyypJL3lgsrB0tlnTy60lXWw19N3anFWZYs226lq2y3qaCED/ICgBAIBtLW0fHQWrLhWCSNXQhklBlL13NRnQaNxS2dcv2dsDQV2zcT2bilcOQgtRLfuYOJueFyvNjzS/pCkE0JsISgAAAFf4JrQWbxI/WhaZ8pbhB8s+SS+//hmPVb5eyT7Gp+Odbq7qjeaKLlll6bnGouas8vSmvX2mtaYzzTWt2MckNIYAeg5BCQAA4AauxJsr0+o8OuW3FoJAVUWaLlRUCiPtKybaUxrSWtrKpuN9e21W39ZlPW/hqUFVCeg5BCUAAIAbageca4JO2q4zZVP0wlBVC0kzwYA6FSevHjXipipBmFWZXmkuZ1PyAPQWghIAAMAtSa+pNPk1C0jeNjzI602h3VIKCxaUIg0EYTs+Aeg1BCUAAIA7kr7lwje0De2I/CAmAT2LoAQAALCevMpkFaY4TdQIUto4AD0qFAAAAADgLQhKAAAAANCFqXcAAACmVSkpsAMAHBUlAAAAkxQipXYAgCMoAQAAAEAXpt4BAIBtzRt4Z3sf+WW2LdKdt/T27WVTiY53QA8jKAEAgG0tah8TaR5tUs9Jd5CV/F7iNFbT24MniQD0JqbeAQAArBerRsV2UbeQtJK0tBA3rbpEXQnoRQQlAACAdZWqZdUpD0trVllKU4IS0IsISgAAAADQhaAEAAAAAF0ISgAAAADQhaAEAAAAAF0ISgAAAADQhaAEAAAAAF3YcBYAgK3INypt2RHH9q91lB/BHeyCineVhnb+OArtMrCHOhCPNrC9EZQAANiK5pakpRXpxePSA4elXZP2r3ZIWNpAqyODSkaHlAyUVA5CVTyshky+AbYrghIAAFuRb1I6vyw986qN4GvS1A7pwUPSQEWqlIX1F1slKbFglEY2PErYJBbY7ghKAABsRbFVM+YWlXzp69LOCQXDAwr+6s9Ik2P2NkFpXXkotaNhFbu4GCkqFJW0YqnVsgpeShUP2KYISgAAbEWRr5eJFBSL0htnFSyvWJHDBu3Dgwo+/6R0YKeCA7uEdeBBKAtDBCIAVxGUAADYinzgHraPxWXp8qL0wpvSxKh0aV6aGhMAYOMQlAAA2OpKRaUDFQWnLkinL0p//e9JRw8qtSP4U5+w6tKubHoeAGD9EJQAAOgV0TVd7+aswvT6aaXffFbBmUvS++6XqtW84hQyhex2BKWCQgulQbmkIK1LLQHYxghKAAD0imIhD0reaOCkVZdeP6P05HmlM+M2sE+lvTMKxoaV7SdPWLplkVfthqoKB+3S96/yboMR7cGB7YqgBABAr+kM3n1j1IVlqWmlj1/9HWn3lNJnXlXwgQeypg86SLOHm9LuegcA1yIoAQDQa7yqFLWrRvWmtFaXZheyoKTVNWl6R36doAQAt42gBAB3SRBF9ipcUFAq2YA3VDA4dPOfbGe/09UVpfW60lpN2IY6La3L7epSkkjnZ6UT55T84Q/suRUp/MlPSffslT78SL5h7fCAcB3tx3JkaTXb5De4vJBPb2TaHbCtEZQAYB0EYWcqlF0Wiwo8ALUvVSxlg9YsGEV2uw3Isr1xfI8cf3+5nH1eODR8818wTZRYUFKtnoUlf1s+e6jVsgxlV+JYaaORDZ7TplUckjgPVb6Bpr2dXaK/dIKTPdeyJ0Nix9lLWcc8vfimtGwhYHzUqk3jeSUq+zhcK7C/RmrPwGOFFwCCEgCsBw9FHpKsOlSY2algeFiFnTsVDg4qmJ5WNDyi0G4Lx8aykBTtGM8/3j+vUslCUzQ6evNfzwJQstKuKFkgShsWhuKW4sWF7LZkdVXxeassWLUpuXhJ6dKiWufPK75wXsniotKFBaHPeEjyZg92BLGN+FsWiP/916QhqyJNjkkffFA6uFvBT386/7jxEeGtQm/gkB0pS5YAEJQA4GaFO3YoLFiwGRtVODCgcHRM0bidnR8aUmn/gWwKnQeh7KhUFdjtgQ9aLSR12g57dckDUuBVJK8seVgK85bP3pL4pvkormlVIqsUZVUjHxin7eqRV5OsYpTU8gpSurSc3Z6uranx3HNqnjmlxX/w94U+5lPG/DlSKefVRt+s9jsvZhvWJrPz0g57Tj54WNo1qWDXlDQ2mD8PkUm84pZSVQK2O4ISANykLPxY9Seams5CUmHXLhX271doYanyyKMWdOx9MzNZiMqCkE+/8+l2vi+Lz4p6l3HorZ7AfrdBXOeMeFpr5mua7PCwF73xOkFpO8gqTPb88xDtDR7eXM2fFGu1fL2SByN/jowOSSMDWUdxtJGQAIigBABvka8jilS6/34Fo6Mqv/dxFSYnFU1OqXjwoIKBQRUOWDjySlG5vQapPeUuE/nLapgPtNL2YQPV9CbaD6/3TJ+0s2bFqguBt5G2I7JqWGI/C7aPlv3emyV7TgdR/o/+uVnp9EXpudeVWmBKp8YUfOL9Fp7s8oceswppNZ+uBwDbHEEJwLYVtINEp/rjR2gVI68aFfYfUDgyqoKFIw9KhakpRbv3ZGuOCjt3ZdWhoHh1MXx6zZW0E5A6c3f8jL6/tc6LHm7q3vxrtjce7YSl7OfG9mC/61Yaa9WeLfW0JYvsGm2FCv2pubSaTf1MfU3OqfOSNwU5c0naMZx3fKtW8vuwEwIAsB0RlABsX9Vq1lih9OhjWQOG8nveo9K996l4330qWCjK1hyNDFyZhdMJJmkzrxCltS3eOa4TzGK/9J8iVLK2pmRpUdgeAqsizSZ1PV27rKfrCzrdXNN/P3FUJat8TgwPK603FJy0kPTLX8oqqcm//F0F9+5TcGSf9MQj2RomPXyPAGA7IigB2B68gYId0a7dCgYGVDxwIO9KNzKi0sOPZA0Yirvs7YkJReMTCv1semgVo1bSLg5dU7/xtss92hHLmzp4WOpnXr9btoPdpa6K7fn7emNFT9Xn9UsLxzVVKOuHBmc0bsOAcZ826nsweaVxxR61N88qXbBHcH5Jmhi1t09Lw4PSzHje+KFqH38rjUcAoEcRlABsC9naIwtKhX37FE1NqfLRH1LJK0czMyo99LDCStk+Ju90lc2ca++nkk1Luon1Rb3CW4lvh6BkQ3yCUltiz10/Xmsu69trl7USt3RPaUg7CxXdWx7RRLHa3ofLnuMr9tzwkPTaKaWvnJAGraJ64py0xwLSw/dKA/ax4TBBCcC2QFAC0J/s7Hi2xmhiUsWj96t4/1EV9uxV5QMfyEJRtHNG4dCghaNC1ogha6/dSt+y1ugKNlTpOfU0+3VCvkQtUMFOEhRlRxDqzdaqLsR1nW6t6dHKmB4tj+lzQ7u0IyxqR9kqqcW85XyWOFctbv7RcxaYLCB94xkl+2asolRW+PixrMW4Du+xqtOYNGoVp0qJFuMA+gpBCUDf6OxJlO1f5NWj3XsU7dljFaOHVH7svSrs3aPKo49lHxMOlq98XtJIrrTPRu/z32K7IIg2X6HmM+s8xqwkLa0p1kLSzJsy2vP+EassrURllaKSimGgop9A8GpqsyUtt6tMvg+YT8fzS68oTe/ITyJ4+3lvP+7BqeRNUfLOkdleTr0WnLyq7M1P/HUkSARgeyMoAegbwaAFpOFhDX72cyrec0SDf/JPKtoxpuK+PVc+xvdn9cFdstUbMQAbyFfeNezvwfdqc9nxzdVZTVpI+ss77tGDVmXyI/LNle1jUw8+7emnwexCtkYv/dXfyQORd8TbOSmNWHX24SNZeEofvTdfzzQzkXfQ66WwNDJkSbJuryNWIVtatRDYyAMfgG2JoASgp4VDwwqqFRUPHlK0c2fWrKHy+PusmrRb0fhYtvlrpz13hlID8DZLacsKSKn+YO2SLqVNXUoaur80osGwoLGwM1RI8pJUYH+BioWrAWh5Na8+vXFaunQ539B2x6g0bhWm/TN59ck3tfVLn57n0/g8fBS34BDEq0lWVUqzNvoCsM0RlAD0tHBm2qpG4xr86S+q/NDDKj/8sAqTdja7vdjc1x4ljVgAbuxsK2/w8dr8so5ZQDpWGtZ/Obpf9xaHtWNgIp+7ZykpDdvNTa6pMmluUboYK/WmDz7lrvKUNFBR6p0jHz+adcwLjh3KO+hNjkl7py0sVbZmUIquThvMwpIAbGcEJQA9JSgUsil2paNHVbRj4DM/rGhySuUH7s82gw0GBq1gZGer6/nUOpYdAbfmeGtFl9rNHiYLJX1ucLf2FKt6vwWm8bCskleYUp+8l16tLhXy27IyTNY9r5Y3gvja03mF5qvfzRo+pCND+ZQ8D0rTdjlsFd+ddmJj91TWJEI7J/Kqjt+f3y/T3gDcRQQlAL0lCLNNYsPxCRUOHFTlkUfzPZD27bra2rvRsjEbCQm4HatJrFXFalrwuRAX9YBVlUphqJrdnkRZW4j8A7MFTLo6Ba8zw9WDknfN8ymvq5fzt1tWcfJQNDSQN4Tw6XeLq9L4aH4n/rZ9TFZ1ajdl4SwHgLuNoARgy/Ng5AOnoc//KRXvv19Df/onVZiZsmP6ymawyVpT/SjpuuxcT7tuu1aqty/D6gxvaWGBmzWfNLPj/zX3ioaDgqajkn50eLd2Far62dEDqoZFjRWsMpSdobAK07XFH7/u0/NUvHJT4CcvFlekrCFEkm/c7NPcSgWlXjmyalTqa5kq5awZhCZHFXiw8mYRXoHyaXsWqIKhat4kwqtO/vFZF77i+rQn9/sqFQUAjqAEYMsKymWFo6MqHjqsaGyHqh/5cN6wYXzM3le52qShx088d779TgC69sfpDPui9vW3rJnwGUr2h7+Ql6752PCat698vA1CfZZUwwa8cVTUeGlIvgIj7Fqx7i3SfVKVVxOadj1ufz++YWnL3lNLrsazur03Kx7QHaPvWY1WS2ms5+oLOtuqWViqaMoOb/jg3fKGooI9l8L2861d2u1+XnR6lHuAStoVI59mFwRXP7TezCtLVrkKvCmEhx8PVj4Nb2QwW/uUhabR4fx+vDudtyT3kynVUn6bhyX/WlnDCL/tFsLTxXnp8mLeFj1pf38Ati2CEoAtK6hUVDxyrwY/92MqP/yIBj/5pIKBava+tBn3fJOGtOtoti+vrfr4bk8ekgpBfm7eh6L5ZX6bDRM1YAPNkeDqC7qdg5ede1fJN9299gtasKxbFaBZHNB8ZbK9EWn0tu+pGbe0mLa0kLTUkIelVI041ooNlH3tSsclb5Rh6YtZjv1vzX73a/Yc+M+rF7O3X6gv6sHyqH54cEYfqE7ooD3rBqKyZR4PPfaMCdLrlDXzjnJvWXfUaQiR5hvcBt5Bz9++NH/1fXFyZRpemjWJsK/jbbz9fgbaTSE8IPn1Tstyr1R5eBqzvyHeVOJmLS7na6vW6nknv3alC8D2RFACsKV4Fck3ix347OcUzcxo4MlPqnTkHkWTE0p9UN/Mu26lPbQX5LUboCZdt/tRbm8EOmUhqGLXh5QHpKJd39UORqN2ZtsjoleKRmzg5vFm2N8O8tuurShdqTD5yfquvl1xsaKkPKxmaacNAq0K0DWI9AX6XlWq23faSPOQlI1VLTi1Uh8wJ3YZZz/Hby+f02vNZX2nNidsL2esqrRsz4nTrVV9szarmaiiD1cnNV0o64hVKytBpIpVLq/8RU3Tdm7qrjIFVxtAdHTWPXVuuyaJZ5tKe7XH1zn5E9w3wu3cR7a2qXM9aHfga1eZbpbftx1BvZFPD+y1DXMBrCuCEoAtxbva+dqD8nt9L6Q9Gvj0ZxTameKgVMgqSGmc9twi704g8vrX9YKSRxkfjo3ZAM/Dz1QnLNnlEbvNQ9OkDfz8Ng9SE0Eensbbn3fdaXk3UrDP9HUl0Wh+Jr46eJ1v2KpE9jXe8r0mPvkqv63hQck+xqdgeZAiKG0/c0kjO443Vy0s1TTh0+/sRMbBZFB77PkVWUipXFkZdxN/X6+t2gRX/ni7pF1h8kCTnXlIrqlKpVdv64Sn26kI+cf7dL7OfQDYtghKALaEaHo6m2Y3+nN/XsXDhzXw8Y9mg55sHNSyQXqPNGvwINEJRHZOOhvueajxalDFBl17LfD41Lj7Ag9Ege6xtyeDvII0HeTvG9cmyZLa9QexYZq+ddpecPWsfFYpsJ/sQKGq49GKsL292VzJju9aYK7a82R3VNYjlTE9XB7VF0b2aCws6WB55Gp1M21XhW9nbZtXirLpojdZJUpv88QKlSQAIigB2AKK+/ersGu3Sg89lHWyi0ZH2wlJ12/htoWk17n0IZxXg4ZtYJhNlbNj2N+2ILS/PYVurx3jXh2yS2+Q7C/GHpZK2rjvM2/K4A9tmq1fYjdNrDdv7FFLE12M6zreWtUz9QUN+ro4e74NhgUNBAUN+do4dVVr0rddWR9UhADcAYISgLvKu9oNffG/yELSwI/8SRXG7Mxzqbjl2313T6fzBgydiUYz7VB0zA6vDh2xcLTXru+zy4Ptpgy3sGpiXfj36I/oWpyqGSfZ9L48KN36wDSgyx1uoG4h6XRc0+m1mr62Nqt/v3xGwxaUPje0W8esqnSsNKzHrNrkVaYgq1J2Kj7XXcG0PghLAG4TQQnApssaNpTKKj/+eFZNGvjMpxVNTSvMOtoFWUe7reja7nSdnOGtEArtpgtVu9xng7JdQd5w4VDgHeiCrHI0GuSVpYK2SCHnTip1PrC1H2I5jbOBMXAjq/b8iJOmvl27nE3P+15hTk9blWmqULbQZCdJrMrk14csNBUCn+7mR/vJeb0W4wCwiQhKADadh6RgeFgDT35C5UceyYJSZzyUNlpX90faYjqd67xBdqeJgk+xG7RQ9IBXj+x4Igq0O8gbM+zU1n2RDdoL3297GGqfv5y0smlWwI2sJbHWrO767bXLFoS8W2Oghyqj2l2o6vODsXYVqyra7ZVCJT+JELTXBt2oxTgAbCKCEoBN45Wk0kMPa+CTn1T1k59S5cFjCnfsUNpK2otnts6oqFNw8Sl1nYDka4h8GPfRMMgaMXhDhmMWjHba9QPtz6u2W3dn+xypv11OGlpJ1m+KZNpqWlBuCP0pbm9g/HRtQc8Fi/rm6qwGwkg7rKr0RHXSLov6oF2ORcVsmt5IVFLl2n2+0quVpnSLJyh/zfCTCKsWFJfSlnp7xzdg+yIoAdgU4eBgvoHsvn0q7N2n4t69CkfHstuTZvKOHdg2U+c76NRJfJpcZ+PWTjvuvWGoKbvcZ2/ssY+Ybq9F2m6SdH2Gq75vk1e4vLth0mzebENp9JjOKqRm6ocFCYsPpSTUioWh1xrLmrRgtNMqS3NxUcMWnsYtaHgjiMEospMPoaJ2J8as5hSEetuzZKtsG9DeFiqx/3zHsRZVV6BnEZQAbAqvIHlAGv/F/1HRYNUC0oDSug2May1tJZ3GDH4GOAtHQd6A4aBdfjLKQ9F7wrxqVBTWRZJklaTk0iXFZ89kNxGWtoeGhYjZONHvrl7I3v6VpVNXWowfLg1pslDW54Z2adoC1JHSsEYtOI1ZiMobQXSeJemNN7S9K4Ls9WPFqknLdixme5AB6EUEJQAbqrBnj6I9ezX4Iz+qaOdOC0hVKSpkDRu2yglgH9R0ptp5+PEGDQctDPlWrA/b5Z4gX3d0yFscB1uoIQPQh5p2umIuaeq11orOxXULU2kWkPYUq5qx4DQTVazyNKCSVXZ3Zo0gCllTCF8DFeh6+x+lb7nYjDAV+ndiVS8a7gG9jaAEYEN5SCp/4AMa/NHPKhwfzypJ8pDU2jrTUTotvv3SQ5I3Z3jUBmG+EeyPZOuR8s1gAWy8lgWjy2lTlxv5+jffi6lsFSSfmnegOJAdD5fHNGLh6NHKqIWlqkoWTCJ7f/i2v6fXNITIClBeedqEeqV9iSgLbrxuAL2MoARg3QXFoqKpKVU/9nFVn/yEqp/4hFWWdmXv8+l2d3seSrbxqvI23345HOQtvB+1UHTErt9r1x+woGSRLmvrvVGbwAK4Oc000SWrLnmnxVeby/p2bS7btNbD0w4/wpL2lgaytU1Hi8Masqq1r3fyPZwqFrLGPUTZ/RTCqCu8pG9d23TN9dueypemW2e9FIA7QlACsH6CfAgSTkyosHuPyo88qvKxYyodOaIrZ3Zbd3dN0rXDF9//yL/jnV4xsssHLCjd3+5mtzfgBRLYKhL7m1tP03zfLvv/gurZ9LbTdkJjKChadamoM601jRdKaiZx9vZ8sWFvlzUQFNRIkmyfprI3hrBL/1yfqhemPlkvyafK2de5tiIVqFN9ukXtghX1JKD3MQ4AsG6Cgr2k2MBl9C/9ZZUfekjDf+rz8nFNdnLVN5G9i2dZO2uQ1pTvf+RVovfYMGavhaM/XQizsHQf0+uAnuHhyZslLCvWubiml5tL2e3/+pqP8WrTgFWUHimPqmrVJN+/aaq9rml/YUAjVnnaZbd5sBq1atTIW6bvdQWdIHyX76hTSYrsPvLXmJCoBPQ0ghKAO+eVJAtIxXvuUTQ5pfIDD6iwZ3d7A6L2/kh3KSR1AlJnH5NJ+15H7fKwjV8e8s1h2xWlIUIS0HfqaZxFldNWbfKKknegO2XXfTre8Wgl67DnnfV8yt5I1oq8kLUi9/2dyvbxPmGv2K5ADUbFK1Unf1/UDkH+dqHTRiKrJiWqt/dPqmUNwrf+vk8Aro+gBOCOeUiSVZPKH/iQyo8/rsE/8WmFwyNKso1kk7u6kWxWzFKe2fw4ZKd699nA5qcin2anbLNYAP3JN3xdtbByOX77RsalwENQkFWcBi0oDVqVqWwByW/bE1U1bsHIN8EdsiqTh6UDVnkqZCEp0li7UuX8Nu+6l03pa7+e+BTBi62aluOmWinbzQK9iqAE4I5444bivfeq+pkf1tCf/BGVH3pQwcBQ3tUuzs+lbrZOFcmHRt7u25s1HLPxy34LST8T2dnibA2SDW4EYLvy7nqxHY0g1ZIFqihotDe0DfR6sJIFoEK2limfQOcBKWyva8yrTDmvLOUVqCi73fn91qyidKK1qnmrYsU0dwB6EkEJwJ2xalI0Pp5Nuyvs35/tm5RVku5y56fOdDsPSv5CNxPklaRj7c1iBwRgO0vaJ3E8xGSNyG/z5coDlU/hq1pFqtiuKGWVbKskrdrhHfsA9CaCEoA7MvZ/+euqPPaohr/weaXNREk9zqfb3QWd6XU+6PGF1J+w6tEjNnD5XOSbxtr3uo2n2fl5bg+NzVpN6dKKUj81/m5r0wG8K69M+XqkJd3djp4A1h9BCcBtKd17r4JKRZVHHlFx/4GrZ2PTuzPVzqtHPu73atFBC0RjlgOesDBw0AOSf790nxLntQEAuHkEJQC3pfy+x1XYt1+DP/4T2dtJnOZrku7SdLu6f09+WB56fxRkrb6/WAizKkpF8JDkYZKVEgAA3ByCEoBbEk3PqHjwkAY/+zkV7zmS7y3ic/Bbm9vZqTPg94DktSLvXvdgmB9PeNcqu6y034ermvZ7atTq2doy0fEPAIAbIigBuCXh4KAKhw6p9OBDKh09dmUX+rs15c5XBfh0uxH7Po60p9s9aseYcD2xBaVWs72WgqAEAMANEZQA3JSgXFbpoYdV/egPafQv/kUVdu1UUCkorW/uAmYPR51pZP6VPxAF2mUD/r9YCDWpfENZXtgAAMCdYjwB4F35XkkelMoPP6zSAw+osNNCUnVg01uAp9ccQxaIBu3yoTDUXrvc036b9Ug3RjMHAABuHkEJwLsKRkezxg1jP/8LinaMKRobySpJaX1z1yV52+9OLPMNZD9gIelno1CjQd7IATdGMwcAAG4NQQnAjVkQCeyofvAJlY4dU2FmyipLFaXNeFOXJHUG+P6CNWqVo4ctGL3Pvq/3hVZFCvI1SnhnvhopFM0tAAC4WQQlADfkIUlRpMqHPqSKtwOfmVYaJ0obm1tJ8mqIr0fyUDRpx5NWRXrMQtJ7Qob9N8sfKQIlAAA3j6AE4IbKj79f5Q9+SEM/8eMqHj5sAclCUrp5K138KzXs8LVHRask/Vwh1D2W3Z4MQpXISLekEzbvTPCWitRcq66VeHObeQAAsFkISgCuK6xWFY6Pq7Bvn8KhIXt7QElj8wbFPtUuq4LYH0N2zdt/77FjRqGGCEm3pdMIY720LDQnrHoCAPQpghKAtwksJJU/+kMa+vwXNPxTX7S3K0riZFM73K3aUbFAtNsqST8ThXp/e6odXe22jstJSyvp5k7DBABgsxCUALxFVj3aMa7BP/HDKt1/v8JKKa8ZJJsTkrxm5V9pzELStIWkT1g4eiiU9ga8YN0JmjkAAHBrGHcAeItg0ILS5KQGLChlXe4sKMlbgSebszbJg5LXKLyStN9G9X/Cqkn3tEMTbh/NHAAAuDUEJQBvMfgTP6HikXtVOnww63iX7Ze0CcUkD0e+T5K3/7Zopv+2GGrcLh+0itKAcKdC+yWW7BhdWVM6u2g3BJSXAAB4BwQlAJmgWMyO0oMPqXjooMLBQaWt2I6NryR1cpiP23cF+dqkBy0wVe0YEdZD0D5KTavZNZrX3AoAAK6HoAQgUzx8T7YmafhP/6Si6WklHpA2YV2Sf4WaHV41mrBg9OcKoe7zdUlMtQMAAHcRQQnY5oIospRUUmHvHpUfe0zhQFWeUVIPSRuckzq1qqLykPRIKM3Y1x4XAADA3UVQAra7MMo63ZUfeUyDP/EFhYMWlKJAaXPj2z77V/AsVrVwdJ+FpD9diPSoVZMISgAA4G4jKAHbXDQ5oYHPfk6VDz+h0n33WImpYCFpY0tJXknykOST66p2/NeFUPdbRenxkDVJG8YrhL4+aWlV6dyigtCSKdMbAQC4oVAAtrdyWdHuPYomJrLKUpqm2bGR/N4TXa0mHbIBu7cD90oSZ282iP9OvcX7tc0cyEkAANwQYxJgGyu/73GVH31M4z//CwpKRSWtNK88bGBQ6uyT5Jd/Jgr1kFWRfjLinM2G899ryx75WkPBas1Ok1FRAgDgnRCUgG2suG9f1uEuKET5vjobHJKcV5IG7EsNWjljt33NPYzVAQDAFkRQAraxoZ/8KRVmphUOVbPmDb5v0kbpTLXzVuAPWCXjvRaSftyOQyFJCQAAbD0EJWAbinbvVrRjXJX3vV8ql5TG6UYXklT3r2vHAxaMPhyF+pRdjjL1CwAAbFEEJWAbisbHFe3arcKBA9k6lSwkbXBQ8lqVv+B404Yjlo8etqA0IAAAgK2JoARsI1lL6EJBA5/6tCof/ZjCSiHbWHYj90zye/Yea1MWkHZaQPr5QqBddn1QNF0DAABbF0EJ2E5KJUUTk9nUu6JXk9I8rGxUO/BOocq/xl7LaPYVs5A0bAd97m5B9kC2H83kmt9VZ31XeBOPpn+oT3UknQIAcFMISsA2Uti1W+UPfFBVOyqPv1dJI96wLnd+r506la9N+mIUam/gXe4Yqd8S3/so23gqzfc/iq+p/nm3wuzQu4clf9wjWoIDAHCzCErANhEUClkr8Mrj71c0OZHfuIEdHDpByafb7bTB+f12TDNGf6tGS6rVpeXVbI+jdGVN8mmQa/X8aDbzDWL999S53cOShycPPANlqxIW8yNr8R4qGKhIRXtpr5SUVitZOArGhtrVpFuoQAEAsM0RlIDtIoryoPR+D0pTnTl32ki+qayvTfLGDUft641RzXirlj1CiyvSuVmp3pDOX5Z8M9i5JenyQn59rZEHo4ZdLq1mG8Yqbgel0UELROX8KFtYKlpYGh+1AGUBaWxYmhjJQ9SBXflltZz/zmnJDgDAuyIoAdvEwMc+ruqHnlD50ceutATfKL5XUtWrSHb5aatefL4QaGS7hiQPOXWrAi0sS/MrSp96ya5bOHrxjbyatGjh5/xsHoDml/Ipdv45eZLNg821j92VDoXpW9cbBfkf2Xozryz5m4OVrHlHsndagVeZBqtKT1+UZuetwsg0PAAA3glBCehzQXswHE1NKRwdUVipZAPpNNm4tUnOvoqm7OtMWPVi21WSPOh41cerRD5VbnnNKkSL+XHqQh6aTp3PA1T2voW8cuRT8Doinyp3zRS5rAoUdIWmJA9SnQfdr8fX3Obhq7OOyYOSVZSChSWlPp1vHabfJfZFEgEA0J8ISkC/KxazwfXgn/pJFQ/sV+AtwX1tTGv9g1LSPsp27Lfx/F+2StIBu9yhbcan0FkYSr/3otKzl6RvPy9dnMuOwNcZeZjxsNJpsOBBxq8Pr9/OUnnRKa9IBV5FykJUnE3BC/xrrkNQWkhbWks3rrU8AAB3E0EJ6HPhxERWRSoeOaJox458yt0GzbrzIbMHpWPZmqQ8JI1tl37Uc1YtWqkpfeOM9NpJ6YIFoxffVLC4amHpYt6IoRXnlaEgal92HRvB79eDmAclD0jr2PluJWmpTlACAPQpghLQ5yIPSiOjFpTuVWCD82zK3QYFJb9bb+Bwrw3Ej9rXOridptx5AwYPR1/7gfT0K9LJC3acy8JR0KkaRZ2AZB9fKGrDdR7/aJ1/D+0mICuxBaWEyXcAgP5EUAL6XPnxD6h48KBVlYpZuSf1aV/rnJS8ptC0Y8jG41VLAZ8phLqn3zOSry9aXFH6whsWiM4r/fK3s4pScPxs3p3Oq0e+LqhUvKZqJBooAADQIwhKQJ8KfA2KVTAKe/eoePhwVtXIlt6v89qkThM2j19DlgQmwnx90nQ/BwJv271gFaTzVkHyoOTh6NnX8nVHXlnqBKJOSAIAAD2HoAT0qWBgMOt0V/3gh1R+z3vz2VIbMOUubt9tZMfHLSS9zwLaPZYUBtWH2tPM0t/+Zl5J+r1vZ3sgBQvLCnwvI59W53sVAQCAnkdQAvpUMFC1atJehcPD2XXfnydNN6bTXdn3PrVwtC8IddCuF/utiOLT6Lxa9MrJvOX3d19QcOqC0uU1Bf6YeuUoa5IgAADQJwhKQJ/yJg7FRx9VtGuXorFRpY34yiL89eRrkyYtIdxn1ZRHraz0Aaso3Xnj6S3G9yNaWVP6+9/L9z/6ta/kbbdbebttqkgAAPQfghLQh4JiUdH0tCqPvUfhYDVbJpO299RZL52WECU79tr9PxkF2mOByUNS3xRWvPGFN2rw9UfPvnp1P6TO5q++DiykjAQAQD8iKAH9JsgH8OHgkAr79iustjcxTTemiYOvTRqz4z77usNBn80+8w1aZxekl45LX39aevmEtLSSbwybPc6EJAAA+hVBCegzQbGk0kMPq/Se96r6kY9m1aWktf5T7urK90z6QhTqgxYYPmpHX8UGn2Z39pKS//evZG3AAztUKeUhKey7yYUAAKALQQnoQ97tLtqxQ0G20Wiaz5NbRx67PCr4C8hOq6xMBHlI6ougtFbPj+Pn8g1jG628YUOhs1nsVv0pg3d88+be+Q6BOm1/Vj6PUwAA9DuCEtBngsEBVT/2cZXvv0+hVUDSektpsn5JyYfI3hLc2xf4wPmHLYxNBeqfBg6nL0ivnlLyD/9dNu0uWFnLN47d4g0b3hJ9usNcEN7oI7ukb72edr3NnlAAgG2EoAT0kSCKLBxVVD52LOt2txE8cvmUuyNWXRloX/ZFz7fFVasinVH6zWeUfusZBfPLUr2Zd7XbMmuRgqtVnWsvXSfU2GXLgnEjTbSYNtWyt5fSlneHt99bopq9r55ePziPRIUs8BYtWJUUqWz3PxAUVLDLkfCafy4Cph4CAPofQQnoJxaUglIpC0nh2Jg2Qqei5PfuU+6m1CdaFv9OX5ReelP64+ellVoePoolbV3dAS4PS4ldNtJYi3EzC0WX4rr9ztIsPC3YbWtJfN17myqUs1BUCSINWDAasMskTFUJQ4285Z8LKksAgP5HUAL6SOmBB1W857CKh48oKJflhYP1XE7SGV5X7PhUFOqefhkvf/s56dnXlPzTf591tQs8JPl0uy3w8wVBu+H6lbVBqWYt+NQt7HgAOtuq63xzTa80lrWYNPRGazULRKsWiFaUV5bW7PDw5NUlfzu+wZOiEkZXKkpF+3oF+7pDFpaKdmvFqk2jYVG7ihUdKQ5nIWrRKlVraSwAAPoRQQnoI8HIiKLpnQqrFmUKhXVdm+T83go2Xh+2AfR4kDdy6GnNVn68flp644x0aU5BK9GVzhSb/vO9vb+6h5umRdSl2MJP0lQtaem0BSMPKKdaa7rUqmWB6WRzVfMWjk7HNTUtDHmQWrPP89+ZhyPPRnE7LCU3aNpQSvIpdV5VstqkIq8uWUjyt4txlE2/m7MwthS3sopTzb5GI13nTiEAAGwRBCWgjxQPHVLx3nsVDlWV2sA6bazf2X4fWjfsmLAB9NEw0P02eL631/cRujQvLSwr/dXfzZo4BMtr+ZokP+6CoPPnNWuAli0MXY4b+tbarJ6tL+iMhaRnGotatsD0cnNZ66kTehrvVIWsCwCAbYGgBPSDMLSxtZ35n5xSYWZG662zuawP30flm8tKQ+rhFxDvbNBsSs+8qtQ3kT1/WVpph6S7sUfSlWAUqGaVogWrEHnVyKs3312d1aJVkl5sLOlCq64lu37e3k8lBwCAjUVQAvqAhyRv5OD7JxV27tRG6AQlb+Jwn1WThrM1LD3KpyTWm0qfeU362g+kC7OSVeDuVgvwILi6C5U3WrhgIem7VkF6o7mif7VwwsJTkk2pAwAAm4egBPSBYHBI4ehI3szh6FGlcar1LDh4O/DIjv02oH8gCvTJKNRIL8+6O3VB+vWvSF/5Y+m517OQqfLmTrcLOlUke0yPN5azgPRL82/olIWk7zfmNW+VI18LtEqzBAAA7gqCEtAHgkJBYXVAqpQVVAYsJKXr2u6uM/VuyMb2QxaQBu24O6t41sFaXVpdk85eknyvpGbc7nC3Scmv/XUS+/3U7VGt2+XpVi3rUvemVZC8i93Z1pqWLTjVmV4HAMBdQ1AC+kA0OanS/feruHNG0diIUh/8r2NQ8opSycb3HwlDHbOB/pB62O9/T3rlpNJf/2r+tk+3C6NNaQUeZPMXo2yJ1GK8pufqi/qdlXP6jeUzOmPh6GLcEAAA2BoISkAfCEdHVThwwKpJlfyGdH0qSp1Kkr9QVO04bGFiulen3DWalvhipd95QTpn1aQ4zqfc+fquDf+Zguw/hYFONVezTV+/vHJWJ+z6d2pzWXMGptgBALC1EJSAPhCOjSna3w5KwfpNu/N7yfZOsmPABvqHrZo01ctBqW7Hdy0oLa9moSkPShv9AwV5Dgvytt8nm8s621zTLy0c16xVkHy6HQAA2HoISkAfiCYmVT56VOFANRuUr9ekOw9JFi2038LEAbvjQ3Y5qN6UvnhCev2U9OJxZY9QpbzhISm4Zj+k5+oL2VS7fzT/WjbN7rhVk1iDBADA1kVQAvpAUC4rHB5REK3vX+lORckn9A0GeUjq2SYO84v5fklLVsEpRJveCtz3Qjpl1aOnLTD5BrLsgwQAwNZGUAJ6me+dtGNc0fS0opmdCkolrRcfxncqU/d7W3DfO0k9yLvcLa5k+yWlv/89e4yKGz/dLsjXJNWTRK82l/X3517Vt2uX9e21ywIAAL2BoAT0MN9o1hs5BIODCqpVpT5AX79md9k0Pn+RmAyliV5dm7SyJr15RppdsGrSah6SNqwVeJD970vEErv8QW1OLzWW9KIdl1p1YfO0LOZ7D0HfptdPH4QCAODWEJSAXmZBKZqZUWFiUpEFJkVFJes0o8vvxjeZ9al2+2z0f0/Qm0kpvTgvfft56bVTCi5czqfcbdTPEuStG3yQHiex/tXCCT3fWNTvrZ4XNo+fK/CAZBFZnVYZFQEAcGsISkAviwoqHDyoaGpCYbWST5VL1qcteLY2KfC24IF22un4nWGPBSUv63gF6eR5pd7p7tJCVoHL2oFvAG/c4JvItuyR+/rqJb1UX9Tvr13SxbgmbJ5AV7u9+3PYq0pVAQBw6whKQA8LCpHC8XEFQ0NSyf46N5N1bQ3uFSUPSyM29BxRj/HA6OuT5pek42ft+iYEFqtUxVbS85D0TQ9LzSUtJy1h81wblPw5zO5UAIDbRVACelkUqbh7j6Lh4Xw2WZrY/+sTlHx4v0t5E4e9dn2HekzNQtKX/1j6zgsKXjlpZYXSBnW6C64MzN9sLOvvX35F/3H1vJ61sAQAAHoXQQnoUT6NLGvmULbBf2Fj/ioXLQFYrSqrLPWkS/PS4nJ7TdLGrUvyP861ajrdWtNJOxbipgAAQG8jKAG9ysJRUKlkzRzCwfXdBrYzZcmrSEfCQNVea+TgHS2W15R8/SkLS3MKonADO91F2X1/aelM1uHuV5dOCQAA9D6CEtCjgmIx2zcp8jVK3ho8vbrv0Z3o7J80aLli3ELSLjt67oXi3GXp9AXpzMV8nVIhWv+g5K3Yg1CXrJK0GLf0ry0g+aayAACgPxCUgF4V2eC/YGFpYNBC0/ptNNsJW36PXqca9eu91hl8eVW6vJg3coiTPCRtyM8QZOFo1sLSd2uX1dT6rA8DAAB3H0EJ6FFBpapwaEjR7j0Khoe1Xrydsr8w7LZwsc+OQ1ZRWr8YtjnSF9+UXj6hoLPBbHF9X+q8ktSyEl4jaejfLJzUH65e1CzVJAAA+gpBCehVXlGySlI4MJBNw8uKGetY0Bi0kDRgGWNAPfZC4V3/vKI0O9+uJrXXJ63n1Du7r0YS60xzTSebq3rTjiSlmgQAQD8hKAE9KhiwitLgQLZGyasmqYeCdeBNHAqWKSaDvJlDT+2f5I+BB6XTF6VTF+xt+2k2pJFDqBMWkn5v+ay+U7usZxsLAgAA/YWgBPSo0KfeVat2JczX36xDRcPvwe5NVp/SlHyNUo8tTmq2rmwym84vK/C26f74rJd24JqP63qjuayvrc3qvF0HAAD9h6AE9ChvDe5HVjHxKsodBqXOzL1OUJq0kDSgHtNoSitrSufajRy82120fkGps7WsB6U3s6B0SfOsTQIAoC8RlIAeFY2OKhwba6+/SddtfZKHpAELBL5/0vg6FmM2xeJK1hY8OHlBOjdrr3BhvkZp3eTVu19ZOKHv1easmlTT+kx4BAAAWw1BCehR3sAhLBS13sL24Y0ceu4FohXnU+9arfx6eZ0en/aUu5bHojTUuXgtawveooEDAAB9i6AE9KjQKkrB6KjWiw/5vTrieyZV7NinfA+lXpJNuXvjjLRSsx8mWccmDp3NZVdVS2L928XTWk1jAQCA/kVQAnpUUCopKJezLJDVNdapuuF7JpXtqMqn4fVYM4daQ1pYXueQ1BHodHNNC1ZJWrOQVE+ZdAcAQD8jKAE9KhgczPZQ8iwTWFRK16GZg9dIqhYwBu0+R8MgC0w9xfdPOnspb+qwrkEpv68X60s60VzR5bghAADQ3whKADKdrndTFgp2+vQ75Y0dekbLKjyzC9Jrp6S19QsyPuWuadWjVtLS9+tzeq7GnkkbJWk0lNZptw4A2Bp6racVgA3kQcmn3HklKZJ6Z+JdlvLsj7pVkpbX8o1m1/XuU8UWluatknSRfZM2jj3GaczaLwDA1kBFCUCm08zBN5qdVl5R6hm+JumyVXrmFpXOLynwfaXWZaPZIGsvfrq5qjcbS/pubU4/qM0LGyO5cEFxuaeeeQCAPkZFCehRQcnqPpX1W0XUWeHkHe+q6jFeTapZpacZX21qsY5rlBaSho4317IpeAAAYHsgKAE9KhgeVjA4tG7z4zrNHEa9kUPQY93uvIK0uJqHJd8/yb/9dXx1O9OqWTXpsuaTpgAAwPZAUAJ6VFCtZl3v1jvSjLSPnmJVpHR5RWknKK1Dq3Rv4uBVqVrc0sVmTa82VlRPqChtKN9AuVQSAABbAUEJ6FHZPkrF9e9LV24fPSWbeteQmq18vdL6bCmVNXFopbGWrJJ0Ma6xd9JGi+yfpCgSAABbAUEJQNbEwV8MPHbtCIPs2PasmuRNxn/gLcEbC3q5saTVtCVsnHB0VNHkpAAA2AoISkCPStd5zxmPRpF6rC34hgqyY9UqSg2rUsVZfQkbKQgjBVSUAABbBO3BgR4VX7yocHDwjgfvnbbg/mIQBXlVqac2mt1ArTTRqcaaZuOGVhP299loPpU0KPfcxE8AQJ8iKAG9qtnMj3Uqc+RT74KsPXh5W5eUgryiluabzJ5trWmZbncbKgjztUnR+LgKU9NU7tZZvtbO/kx5ZAHgVjD1DuhVXuGI16/K0emoXRBnUHKpEgtKC1ZNqtHEYWN5O3oLS0F1IGt7j/Xl+YiQBAC3jvEQsM11pt75tLsBO4bs+oC2sSD/w7vdrSUtvdRc0aWkIWygqKBwaFjFfXtVPHQof1Iyrl8ngQX92CqjNS3Z87lBYAKAm0ZFCUA2Jg10tarUky8MUZhP4VqnzXJ9D1tv4FC3QWaL/ZM2ViHK2t37PkphqUxQ6vBQY0/EtPP8u83ntj+Xfb1d4tPveGAB4KYRlAD0Pg9J0+PSsNXCil4o95RzZwNCPwu/Erd0KW5ojal3GyocGlLBKknhjh0KBgbyqWJCtjfY6po0u6C00bIHqnM6AwCwGQhKQI9KFpeULC1lI8rUB093UEnJu94FGrTLijd0UI/xAaSHpGqlHZTu/KWtZY9qw46FpJmFJmyccHBIxf37LTANWmWpmG8anBCV1Gja0co2Ug48rPvfcXISAGwaghLQo5LlJcUWlK4sOQhuPyx5UPKW4AP2+QNZ17seG40F9lI2bDGvWlZQKKzLK5t3CWtaQPJmDnWC0obyNveFffuzwCSfguchiemO7aDUVGBBKfuLTkgCgE1FUAJ6Vb1hx/ptONvh23323D5KPoAcsGrS6JDSybFszYvWYdG634NvONtkAfyGCkdGVDr2gMLhIYXeVYTHO5P6lLvFlU7bOgEANhdd74AelTYbSlvX7KPkYWEdxlKhevDEtVfAPBxVSvkUvOBOBtt5ZS6xBzNu7z+TsGJmw2SbzA4NK5qayvZSyhAKcqv1/IQIjwcA3BVUlIAe1bp0UfHFi7qSjnptutxGmNqh4IFDeXXpjqZuBZpPmlqIW8LG8ZBUOHyPikfvV/k978kCUxITCjqCi3MK5pbyqYg8LACw6QhKQK9qNJU27Gxzq8UZ57bAA9L4aNYF7041bHBat5qSxy0e3g1SKKiwZ4+iySmFA9X8Npo4XLW8Kq3V20/A239cvCKaPY8FALgVBCWgRyWrq0pXVpTW6nlYoqIkjQ4qOLAzryg5ryrdZspZSZtatopSM02yKXhYf15RKj7wgIqHDiraMarQp97FNM7oyNYozVtFqRXfUcrxT221wxIA4OYRlIAeldZqWVBqXThvoWlFQUjrYI2NSId2S3unle6cyNoqM/Demrw7YTgwoMHP/AlVHnlEuI6zl7I9lK6E/fD2/sleS2OdbdW0mjKVFABuBc0cgF5lASCxSpIHpryiJJTsJW2wqrRatuvFfBoXj8vWZIP+oFxWYWZGweCgcB1eLfYW4Xc499NPFfheYFSUAODWEJSAHuX7KAUL82qdOKGwUlJh53R2+7aeJDYymB3Bo/fleyu9dsoCk7/jVl7qfOF8ol1RRY1CrLLdT6f7HdZP5f0fUOnoUZUfeSzvMthM1uXJe20Y8Db3o+rBdvcejny63dlZaWVNd8p7CVbtjEEkAMCtICgBvcoH7l5RWl2Vmk2tFz/73PNnnqfG8qPom88G+QD8FitLkQ3eI9Z9rT97TAOrJhX37Vdx/wEFvm+S/XLSdQyiPkFtWMo2Ty6qB+eY1xp5W/BOYLrD56E/tk1fo0TWB4BbQlACelTazLveteYuq7h252edOzwk9fpKhmDvTDbYTH1fJR8c+jol74R3CwPOchBlB9ZX4A0b7Cg++KDK73tcQamgNLZnXWP91pJ5MJq03/WYBbCKepBXkRaW7bKWhyV/zMLbjXtWDbW/1atxy6qiTL4DgFtBUAJ6WJokii9cyDrg3QmPA94Va81CxaodNU8XvVxNObwnaz2d7t8pLa5k+9FkP090az+Tf/RQWMwWw7dYCL8uookJhTMzKj/0sIrHHlDaSta1muTyoGS/O/Uobwt+aT577madGwvhLVdEg84nJLGadh/L/hymeyMA3BKCEtDLbACULi1J9bruhA+p/Fxzw45mdga6x6ecefc7r1D4nko+0Dx/Wbcj9IpEEGYtwrE+gqEhRTM7Fe3Zo8LOmTvdIui6wnZI6slqkvOpd8tWVVqr5QH/Tk5a2AMc2/O3lrW5BwDcCtqDA72s1VLzxAm1Ls9ni+FTn54T3d50MR9ENdqXPT+g8jPwY4MKvvgZBe9/IA9LneMmeUAaCCKNWUXJr+MO+dqkclkDn/ikJv6H/5vK996jsFzI1+DEdx5EPWsl7cPPAD5kX29Pj1ZFUwv26Ssn8yl43vkuDG89LLUDlleHa/aoeFWUvncAcGv41x/ocenamtK6nXluNhTYWeM7HRum/dRPe9wqSztGlI4O5Y0dbiYodbasscchtAdzICyoQFBaF4XduxVOTioctUpfGG1I15CofXjD8WovPpW940KjtT7VJL87eUUpb+YQ07kRAG4J//oDPSxtttQ6fSpbpxTPzWdrlm51HU63vKLUB2GpWlbwgQel9xyVHjisdKBig8/GzX2uDSi9ijRkg/l9hapGw55rML3lhMPDqn72c6p89IdUevhhK9kNKGmtf1LybvBD9vy9JwyydUo9xUOSV9cuLUinLuYNSMI7+2e6kcRaSVuaixtqEpQA4JYQlIBeZoOgrJnDwkLeJtyC0q2ODf3j/YXAWxWs2UCq1j56X5BXkWZ2SI8fUzA9nm9I64PRm/j5wqw9eKjhqJjtpYTbF/q6pPEJVZ/4sIr79rWLJDf3e7hZnW6NI0EekEaDfO+gnuInOrwt+GULSmcvWQkuysPS7cqm3iWq2euEHzFr7QDglvCvP9DD0tiD0nkl8/NKvEV4Eut2xob+KbGNWb3JuB931hpii/AfyoPS9IQCC0pZYOpMv0tuJiiFKgaRhsOCSiEvlXciGBxSOOFB6SNZUMp+N+n6ByXfTcwD0pRVk0Z92mSvVZR8vda1QelO2oIH+f5UtXYjh1rSyjZOBgDcPLreAb3MBpq+l5KHpeaLL6i4e0YaHNDtSPK7ywab/dQIO/CNZ3c8bAPPWQtN40r/xW/nZ+qrN+qJlub701pIKllIerA0ojcbK8LtG/sLf1HFgwctJO2SFzXS+vo/wzqNHPZZPjgc5GuUei0npas1pcfPSRcuK5idz9v33aFlC0iLSVOzaVN1KkoAcEsISkCvs3ST1OtKVlZuq3tYoKvtwf3Sh7D5mec+aergociPHcPSzslsf6VMp5rxLovlB9sVJZ+Kl7DG45Z4lzs/Cvv2ZkcQFbwMag/9+g7YO89WPwbtz2FvxKEe1PC24Ct5pzvfJPmOmzkE2XS7lj1vfbNZYhIA3BqCEtAHkkuX1HjhBcUf/yEbIE7pVnmXsHr7mLNB1VA/db7r+KHHJG/u8DvfklZq0hunrapUuhqc3iZVwQaph0oDmi6UNWgVplXFdA67BaVHH1P5Ax/Q4Be+oGjHeN68IVn/x88bkPhv0Rs5PGBVmEfD3nz+BpcWFHz7+aw9eNb5rnwnTUTyx2DJqknLVk1aTthFCQBuFUEJ6APxwoJaJ09kU3eyUaOfhb7NAX3DuxP3YU5SqZit90g/8T7p3Kx08bKCtN1lLNun5u2f4gFyOqpoIixlne8accI6j5vgVaRoekblRx7RwMc+rrDcnubo68PW+eHr7J9UtWPInve77fe4sxefvz6N1v/+nrmYB3l/bt5RRSmvs83GDUISANwmVigDfcC73vnGs8lazcZXdzbA8jVKzX7MAh6UBioWlB5X+r5j0mA136DXF9Bfb/Ruj2MelMoat8ODEvsp3ZygUlFh3z6VH35E1Y8/KVU8KKU33XHwVvlvsGzP97EsKOVHz/HHZWVN6emLFpjWrgalO7tTzbYsKMX9tOoQADYP/+oDfSBZXFTr1Cm1Tp9WfO6cgmKo4DbbCi/Z+GxB/Ss8elDpBx7Sys/+mBoPHlJsj1XqYSl+61n3LHDa/0OFsvYWBvRQaSSbfod3VpiaVvnRx7Tj539BA5/4hApjI1klKW1sXFXDo9cuyxTv89bgyqtLPefUhbyadH423+8rut3nWpD91+kqeL5V00J8k/uHAQDegqAE9IG0UVe6vJy3CbfQFGQVpVu6iyuL4bP24Kn6doJZMDIozYwrfuCgkskdSkaH8krH29bOpNnj4VWkkaioXYVKtmYJ1xdYdS4II0W7d6uwZ69KDz2ows4ZC+2Fqy0V11mqq40chr2SFPo6pR5t5LCwbGcpVqXlmoIkueONZnNp1vWuQbc7ALgtrFEC+kC6tqbYjsbzzymoVlR+8OhtBSUfms3ayLMapFe64PXj2ZRwdFCVT30gW49Ve+iIRv/Bv1WwvJpv7nmdaYv3lIf0Ge3Ul2sXdcbO0OPtfK8kX5s09tf+O5Xuv0/lo/cpbcZKahs37asz/B+yX9dROz4ZBpro0Sds+spJ6Y0zCs5dyps4FNanevlGa0UXEypKAHA7CEpAH4kvX1Y8O9s+g69bburg8cDignzXIL+Lfp1o5j+n/2zR3unsrdr9BxWdPq/y+bk8LF0ZpOaP3YB9tDd1GA0KVrkoaCllzUdH4FPEiiWVHnhAhV27VTx8SNH4eN4kY4PLkp1udzvtdzhuz/VR9fBz1huMeFWpE9TXYX2SP7fn4mZWVQIA3DqCEtBH4rNn1HpzXElnPyUf9GcD1ncfsXam3l1WvsYjVv9WlPznyhovHz2o2I7Zl4+r+Pzrmvq1r+Rn8729dGfqU5poIippMAi128LS2WhNSy0GnlcUiwqHhjTwiU+q8pGPqvr4+7JmDkl94x8jr5P4b+mo/b4O2a9sV9iD0+6S9t/VF49bWLrc/ot450EpW2NnYelkc1XzSVMAgFtHUAL6SOP1N5TagD6Zm88G/NHwsNKb3IS2E4qWbHC1kAbZxrP9vogxah+Dn/uokkfu1UW7PvDScQ36oLVSygJTakfRQlMhLOt9AxMasdD02sIbgj08g4MqPfSwhn7ypzXw5MdUPHTIglNZaWtj18R0WoKX7RixJ+6nokD3BHlI6rlVZIsr2Z5J6Yv2nFpYUVAs3tn6pCD/wytJjTS2kNTQCu3BAeC2EJSAPpKuLCtdtqjTbNiAK7paJrqFKVB+lt6GbVcWyvezznC0sH9n1ha9vmda5dMX8w54aaejRWofF9oJ/lA7LCRNFcpCW6GgaHpapaNHs8YN0YRVM727XbKxz5zOc9NDbsWe4NMWkgaDHgxJrmmPV6PZDkyNvJq5Dj9Iw6Jkzaqh3siBvb8A4PYQlIA+km06a4Ot+nPPqbh7lwo7RrPbb2aY1Fm3s2ABwQefJ2ywO2U3Tm+DTm9DdrQsLBX++s8q/vZzmvv281mDh9AHr1GSTS+zkpI+NTCjlcq4/t7cq2ra41RLt+eZ+nByUkGprJl/8P9Tce8elR97xMJ5oqQeX51KtoH8UfdA/7Eo1D5Lux8Pe/c5mn7n+Wx9UnBhLg9J0TrUcS3Uv9lY0eW4rsWkZZGJoAQAt4OgBPQbqya13nhDYdaQ4AHdKh9S+bS7JTtGtX348NTXLYUTY9m6pcZj9yu4OKfCqycV2ln5oNnUSFhQyYLj3uKADUCbOt1c03biXe18PVLliQ8rHBnNQlJ4beOGdOMH5J2v4P94+bqkvb0c5L3ydmleOjt7tYK5Lo0cgqyBw4I9RxNteIEPAPoWQQnoM2mjqdq3/yifeqcndatiG1T5NDRfr7ND24cHpYpVQ1qHd6t1zx4tewey0xc19L//K0XNlgWlliarFXvVLOux8qjeaK5uu6DkIalw8JCGf/qLKt57b15JspCUNDansubjff9K/rvyZ/eHrQKzp1eDkqcXD5gnzkkvHc+ne/qGxusQktzluKmzzZpVPtlDCQBuF0EJ6DNpq6nGiy+oYGf747kFBdVBG1VG+UDsHXSaOXg1qWFD0vM2kNuzTuslekYYZgNw/5EH3/+AkiNLWq3XFT37mgp2VBZWFFpg+hODO/XNtVn9oD6fTcGL+3wwGpRKqnzoCZXuP6rqk09aQHpUhakpC+WtzSgiXeGPsk+522dhYr/9ku4Jg96dGrpiIfvifBaU0uPn8o1512mTWe/UeN5C/KnGqgAAt4+gBPSbVkvx2bOKL11SsrqmsFxR4NPwbvKkvw9GvaLkU+/q2n46a7VK+2cUz+zQ0uqqolpdyZtnVVq0oGQVuwdLIzrVWlXRPtoXyvf7SiVfj1Q84hWkx1T99GdUGBux24pK1ja/7bQH+RE79ltA8l2werbq6Q0c5haVXl608s9CHpLWLfSlWkma2RolAMDt8/HALwpA/0gSpcvLCgcGFE1MqLh/r6LBwXdt2dxpkFdrX075Why7cm8PL5S/E1lgsoA5MG1D8WOH1frk+9Uol1TfN6M9b16ws0xB9jG+R81s3FC/CUdHFU3PaOTnfi6bajf2V/+qyu97n90+nM/PbG3uwhcf8vuZvUl7Xv6wPSe/WAi075oKYM85eU76/e9L33pGgW82m7Wjv7OKkndmbKV5SPr1pdN6ubmi4y2qSgBwu6goAX3Ip98lK8tqnTopLa9IvuC+c7b6JudK2Wdlg1M/g9+zg9E70Pl5IwtHhR3DiqtlJQ8eVjo9rui1UxpeGtR9J2p6Ll3Vyeaa1vqgA14Q5WtkopmdKuzZkx3lYw+oeN+9Cscn5ZWKIGsdH7Q3NN0cna/kjTS8gcNuC0pTvbpvkmvF+dS7MxfszES76rMe1SS7D8+wq0mcdbtjo1kAuDMEJaBPxWfPqfb1r2vgU59ROLNb8jUQ2QLydx7Qeyjygamd49aiHd6uYKB9+3ZVsbP9fqx+4clsmt3yrgntfOE1ffb3hvTSi2s6s7qk1/rgzH1glcdweFgDX/iCqk982I6PqLhrSkG5osQrkhaObnYD4/WStA+PET7V7qeiUA9ZUNrVy00cVmtKT5xX+k2rJq1aUCoVdefymrAH9otxXSfs+fh6c1kAgNtHUAL6VLy0pOZrr6p15nQ2Ba+wf+9NFZM6k3+W7IOX0kCLqZ/J395BqcNfMLOOa/ftVzA2JE2M6eHvDat1/DW98ZXfUWpn8tNaTb3CK0gegsLJCXuOTGZT66IdO7KGDYV9+xSNjWTb7WYVkCTd9B2IO63qPZwetWB01L4VD0kzvVzebNlP9PIJyYKSvLOi7zu1HnsntdXTRHNxQ6sWmBp0vAOAO0JQAvpUurSoxqureVCanlbh4D4FXhF4l8/rjEGX7AM9JHlTh+3UJvyd+Atm9vjdf0CFe/aq8N5jenj3kEZfeU3/9I++lu21FPdQUFJoQWlgQMV9B1S8/36NfPFnss1kve13R1pvvev6to3SaQfuE8jutaD0oIWkh3t9zVyzHZROnlcwv5xtZKx1/JkaSR6U1iy01wlKAHBHCEpAn0r9THXDBkzf+Ibic+dU+eD7b+rz/EXBh1dnLFSdtONNO2ZskDog+Hn/TtAMrQpQqJb1wSc/qvc98X49f99hHT93Vr/11a+o8fTTalpATS/NKo1b2gqCYlFBpaJoasrC0aAGf/RHFY1PqPTe96q4c0bRrp2Khofz7tKNpL0B6t3bqdQDkk/7PGDPvTHLEf9lMdTuXl8oV2tIlxeV/O4f2V+wiwp8Gqzvd3anTRx0df3h5bim79ZmtZJsjecdAPQyghLQr9qD3GRuTvGFi0r9THbq672DfLB/g0Fwp/udD7N8mflK1v56e3a+u54rj4Q9jr5Mplwpq1wuaf++fUqsOjP4+mtWKZhXEkXZ45zUbXDsYckGxZ3w6rLrG/H9+TflA287fP+jjF2GlarC4SFFO3fa5agKBw4oHBm1atI+RRPj2fTM7GfLglJ7HdtdCkr+VbOug/bHsB077WcZt8uxXl2X1LFWz4+5JQUemvzHWdeHOFXNKkkL9nxriWoSANwpghLQ59a++Q3Vvvtdjf6V/1bh6IgKO6cVWGi6UZO2TlByF22g/HwS6H2Bt2UWrscH73b87INH9bI9Xuef+JCeXljUyVpNwR/8vhKr5jWeey7b1yq+dFHNl19SWq8rXVrSuvPvxUJRMGSBaHJKpSP3ZtfLjz6qwq5dKh07psKefQp37FA4WL7ye/apdV5F2qjwdqu8LUYlyPdK8uYNHwkD3WfX16PlwV319CvSqQsK/NKn25VL67TJbC5NE6soNfSd2rwWt0glEwB6GUEJ6HPpqg07rarReOF5FffvU9GC0s2sU/LmDd4zy6fg1e1I2u2YcX2dPX4+YQPgulWZmmGkyw89pOTQQZXuOax4YUHJ/IJaJ44rrdUVz122wNRQsmo1u5WVrOLkH5NN1fOqkzdaCG7wiBcKecWoWs2m04V+WCDyjWHDsdFs3VE0Np41ZMjWIO2aUTCchye/zNqAN+OrzwO/chen2XXE7W+lLO9wF+jTYd7AYSpQbz/32o9t+urJLChlDRyCddxgNsh7bfjaJN9k9nLSUJOKEgDcMYIS0Oc8KPkwrfHiCwp9PUTwnpv6PB+YrqQelPIpeHd/GL21+YvphB2ftArIG+WKLhVTLT38YBYwK3Z7srKqeGUtqzB5Ral1/ryS5SW1Ll5UcvFCFp6aJ05k7/M9sEKvDEU36DVYqWZhKRzfYYFozCqFYxaGdluVaDBbaxT4NLuRUUUzeWvvsH032e/QRtS+xj+birnF+Hfkw/shG/jP2BPwU/ZY3mfXp3t9yp3zsHRtUAqD9QtKlpRi5dUkD0mzFpaaWyD4AkCvIygB28Tqf/ptpWurKn/oCYXtSkTauPFg2V8cfH3SORvTnbfLGRt3zfTDgHUD+dSwKTs+HQV60MLJP2glOmdvz9tjFxVKKowUFVXLvkBJxcMHlbZa2ebAab2Z3Zas1fK1THYE7zQlKypkLaUDC0vZUSxk65Hy68Wsm51XpLKPs/tN68lbq0dbTKezXaldOforhShrAf6ohYkh9YELc3Zclp5+VTp3yZ4oxXVtCZ4HpUAv1pf0RmNV80lLMUEJAO4YQQnYJpqnTqp0/oKSy3MKpiOFA9Ubjpk9DvkwrmUfsGZvLGRtwlOC0rvwx8ynjR2wAf6oPWa7LaR4s/CFbKZVmHUnCEuFK4vAusPLlW7OybsMctvtpK/MzAvecnFlFl3q95NVkLbuoDnV1eYNk/Znwa48Yj/fsF0fUx/wX8bSatblTnOL+XUPSev2VymvTMX2ZS5ZJWnJQlKTtuAAsC58QsYvCkDf8+53gQ1A00JRBd9XaWb6XffH8TP9Pu3ugHx9UqD7e30Pm00yony62L32eB2y4wULKrENXpfiRAU75M0TWvlldsTtw91MJaDTutsDUHz1ftLO/XbuL7m7Lb7fjf/Evg7Oe/NN2eP15wqhPm/HJ+0x29kPTzV/7P138vWnpN/8fem5N7P1glkTh3U56dBuDG73tWwB6VcWj+u15opetwMAcOdYmw1sI/HiopovvZi1C0+WVxR4/+UbhJ9O52IPS3N2XBZu1ag8ZEoftFfawzaY9bU3Hg5uOOGxE4Bu5ehB/l232pfj9rgctOfgE6FX4qQ96iPeCvzMJemsHWdmlf32b7Tu7HbZ4+cVpDULShetorQQNwUAWB9MvQO2kfj0Ga19+cuqvO/9Khy6R8WD+xT41KzrrFXyoNSpKJ22AfkwSx5u2T4bxO6wo2THl2JfbC+dSNPscfUNfK9txZ7ZButKkvbhzyuPDEfssXmfBaWfKuQtwPtiTVKH75X0wuvS8+2jYD9xaR3PT7afPPW4paVWXa82ljUbNwQAWB8EJWAbSWtrap09q9q3vmHXa9rx1/6K0my03lk089aBug/p/EXijB0le9dF5WtwRoSbVbXDA0AUhnogSPXLcapZe5xfsYDqQcEbQPjj3O+TGrPOi7q6JukxC0e77fK/KobZNMU9Qf5Y9Y2GVXbOzSr5j9+QXj6hILZ4XCzcsIJ7e4JsodrZuKY3Wit6o7mi2o02SAMA3DKCErCNeJc12RFfvKjWmdPZbdkUOw9K16lmdCoeNXvXqg3yO1UA3Dx/vLxKsivwF9xAI/Y4rmZdytIr0xu3C68kdYKSN2rYY6HhATs8fPdVJcl5C/BaPQtLWl7N/35tUBr2cLSStLIjoZE/AKyb7fbvNADjm5B6G+k9/+l3FY4Mq3TsaL4BaVdzh86g1lc9+FqS/7kUabe9ajxE97vb5uu9vF34P2zFes0Gz9+wClPncfbA8LbpeD2sM83OO/951Wy3PW/eH+bHD0dh1gK8X4N3+q+/LD37mvTP/n0+5c473YXrvCzYqkm+KfH/OvuSvleb0z9beFMAgPVDMwdgO/Kz3XGs1vHjis+dy0azqd6+AWb3oP2yDeyXOLVyRwrt45A91oft0fU1OmM+7SzI14T50QlOvajzvXd+Dv9HxkP2TjsetDcOtTvaeae7vozbFoC9s106O2+peOHq7et9csHuzyN2K020kDSzzWYBAOuLqXfANuTrk3wQu/TPf1mlBx9S5aMfy9/hZ719LcU1o/RO2XnFQtJ3rPrhe/c8QZvw2zbshz18P1cI9aY9pu9NUv16nOi0PcgvpPm6JX9h9rVLvfgoewXJQ5JXkXzNUcV+iI/b88WrR3/WfmafcrejnyuSiyvSqv30X/6O0lPnr7TvXu+g5I3B60msWtLSs2tzero2JwDA+iIoAdtY/dlnlDQbqn396yoc2K/SgQNK4s5Kkqt88O7DvJdsUD8d5K3CvaEDLyB3xpsYPG4homqXXq37bQuiF+3ypD38jfSta8I6l1spYvizpBOMOm+XA19/FGhvkG+8u99+tg/ZMRrkeyWV1OdeOSG9dkqBhSQtLFvprLjODRza7IzFmdaKXm8s6VRc0yXaggPAumOcA2xjrdOnFQ4MqvHaqwpHhqRDB677cT59ygfE5+y4ZMeqHYPiBeROeYvwg0G+NqlmIeJNSxpVO87HeUjqNG33YfZW7IzXPc3Oj6yKpHxqoa9le8hCwnvsqGib8D2TXjlpZxMWpTWrLA1uRC+/fFLsglWTTjRXs5bgK2lLAID15Scpf1EAtqckUbK0pNYbr1tgGlJh/yELTIMKvI1x/PbGDnZ+PBsI+8ape20QPMAMvHUxGHg3PAsUdnzAQsXHo0C7w7xl9iUbEPsLtQ27s0Diw+HOdMhrH/6N+lVcW1vsbJbr0+o6rb59at0e+77fG+XVsT9XjPSn7PpPRqEeDUPt3S4hyatHz76m9Ne/Kn35j/OQVCisewOHoP2bji0Y/cHqBf3W8lm90lzWckJQAoD1xglhYDvzlsVxnDV0aJ44rsbLL6kyOqxgaPAteyt1BuE+UF+1Tzmb5pdJQEeY9RC2D2/qULRH29cnzdn1EQsZ8xZP1tIgm47nVSY/mvY76XSUc53QdKfBKX2H2zr3Vwp8nVUe3nb492zf+F57+0Dobwe6vx36xrWNNC2krFgwevVkXlFaWskD0kak1yCPyQutpi7FdZ1urWk1Ye8kANgIBCVgm0sbdbXOntHa739V8aVLKj34gIKBwbyxQ5K1w7sy3vOB+QU7vpuk+lSYalrbaErVJvEpjV5h2hPlj/qTFpLmLRg9Yw/+83Z5xn4fz9rjn1V1Ur0lMLnOFL1bma7XWWvUuZ9r76+zPs0vvYI42p5S52vUPhTl3eyOWaDz73vbPhe8gcObZ5T+y9+Vjp+1apLF2YHK+ne6c3afdXsevNBY1DP1hawteDOlFSUAbASCEoBMfOF8Np2q/v3vq7Brt8oPP+Q70Sq9ps7glQ7vl3fKRtKn7HLQ3nWEPZU2lFdmBuwx9ty6034fi/a4PxCEWrPbz1pg8il5i2k+Nc+X8zfav7E4zafJddYQdf+WOlWoTjXLg1DUrhCWlDdd8GMiyKdbztj34FMuJ+xyX5Cvr9rbvs3fv63/Mfn+S9IbZ6QzF7PW4FkDhw3USBN9b21Op5tr2cbFKdshAsCGICgByMQXLmSHB6V4bk6Vxx5Wek1pwQfV/oJRS/OQ5GFpKPSgJGyg8XYQ9Y1+PQjF9ps4FeYNNZ6LE6swpdlUyFP2ttU1sn2uWj5NL/CPSbOQlKRvn5qXtN+O2s0kPBwNtDeAHbav6W3Mh+w4HObT6B4M8851M+1q0sZGgR7zg5ftF2C11tMWlKoWL4sb+09rI8mD0pnWmv2uCUkAsFEISgDeYvEf/UOrKO1S+YEHVJyZVrRzRkk9ztYqebXBqxReefqGlSy8S9vH2VNp03Q2qz3QfsjvsTJT3A5DfniQOq98St5aml6pMtVvcH/++/TA49Uhrwp5QCrafU+qXWG6cgTZ2qRO5YnfeC71VuCXFqRf/U/5DRULSWGkDRFE2Uy+1+vLOtFc0X9au0ADBwDYYAQlAG+RzM4qLpUUnzurcKCqcHo622TWOzek15y9XrIBuu/907Lhc2f6FjZWJ6B0qjnF4Npbr3bE83DkU/O8KtRov32j+/N/BDwo+fqioTBvJDGht1egcA1fu+dlusUVpecuKfA1Sv5obVQDhysCXY4b2bGcNLO9tgAAG4egBOAt4oV5JbU1zf7Nv6nhL/6Mhn7mv1A0NqKgZC8X9VZWUfC1Ky/bGO01O960wZpPxZpmrdJd5y/oO/1KlnL4fWyYWiPfJ+k3/kD6w+9bGm3lzU9KGz8h8beWz+i4VZSW6XQHABuOoATg7eJYrZMnVf/BDxRNTmngE59QND2VDwa9XbidTV9rn83+vl0/aIPyacbl2A58f7Ezl5T+0TN5O/DZhXxN0kY9/4O8trdoFaRaGuu5xkK2ySwAYOMRlAC8TdpqWVA6YUHp+9lArfzoowonJy0oRdm0o8DOZvvULj+n/QMLSr5M6f2sVcJ2YM/31PdK+v3vWUn1lIJL89LokDZSEIRasqA016rrmdq8TrdqAgBsPJ9F84sCgOtIl5fVOnFcwcBAtnap4nss2e1eUXJ+3QOTL/Q/EuZrlcrkJfSzf/170td+IH31u/n+SV5NijZwhZ6dqPD/vrxyTv9x5ay+unZJq2lMQ3AA2ARUlADcULK8lB2N555VUCwqXVuVwoICO8JsM9pUF2zE5sd5u15tt5UG+s5qu4rzwpvSyfPS3GK+JqmwQV3unP19atlJiTiI9UZzRS82lhTb37OEJg4AsCmoKAF4V81XX1HjhedVPHK/0kZdxX27FcaJIhuvzSnvquabnu4Lfb8fSkroP+k3n5GeflX6u/9COn0hD0h+bODzPQiLWrLq0R9bFelXFk/od1bOZ+uUAACbg4oSgHcXx9k0vNo3v6FkYU6FXTsVjk8oiCIV4jTbp8c3oT2XBrpo13eIFxf0idU1pV5NeuGNbG1S0KnmhBvZED/I/o+V6HJc11P1Bc3FDSUCAGwmKkoA3p0NDtNmU82XXrKKUlPR/oMqTE8qHBqUWkm2V4+dY9d+Gzz6svYZO8tOUEI/SC7MKT1xXvrV35GsqhSsrCnbWKy4gdWk9rqkRpJPufvf5l/VK81lLcRNAQA2D0EJwM3zvVtqNcUXL6qwd69SqzQVJsbtzLcP6lIN2Lhx3qpKj/jGpUH+AgP0JF+Dd3E+C0f60tcVvPCmAl+X5J0fo2Bj96myIOad7r62elFP1+b1a0unNZc01WJtEgBsqo2cOwCgn3hVyUJS6+zZbApe8403FF+aVegdv2zg6NPvTtrY8kX7uBWlagnoYd7ZcXlVeuOMgm8/byXTWTtJUM873IUb/U+n33+g1xvLetMqSmdba6qxwSwAbDo/JcYpKgC3rLBrt4JKRbv+3W8q2jGmwr49ajRaasWp/rtCqGNWVfqTEedi0IPOWSg6f1np3/j/5td936SBysa2AXc+5S6IdKlV07JVkD765n9WI010Ma4LALD5WEYA4LZ49zvXfPFFJbt3KpqasBvzs+2X7ByMtwy38/Eqtg9gy2tZHbRllZvjZyVfl+TrkZqtDe9u120+buhUazULSQ3OZQLAXcMaJQC3JV1by/ZYar7xejYlqXTsISWVslI78362lWjFPuYRC03+IjNAx3D0goXlbF1S+r/8svQH35dePi7FiVQubU5Qypo4SL+2eFK/uXha36hdVp124ABw1xCUANwZqywly8uKL88qsGBUKJTUGhlSy6+nqco28ttlA8B81QWwBTWsarSwovQ7L0i/8y3pj57NGzm4aHOqSb6J84W4rmdr8/p3S2f0tdolXU7ocgcAdxNT7wDckXh2tt0JLFJx334F0zOq757Rgr39jFWW9qfKuuLxYoMtK02y/ZL05hnpj5/P1yX5lLvBqjZPoJUkzho4vNZa1qvNFQEA7i6aOQC4Y0HBYpAdxT17FU5Oavxv/i2Fhw+pbMeT9grzMassfd4qTCOUlLDVnLkkvfiG0l/6knTiXL4+yYN/GGxOJSmIsn+J36wv6T+vXtTfnX1JZ+OaZuOGAAB3Fyd5AdyxNFsE31J8+bKS1VW1XnxBYW1N6Y4dOlup6KVyWTYczVqGjwvYArxpQxznVaTX7ThuIcn3SfI1ScXCJoSkIPs/ab/1fGNRL9UXdT6uazmluT4AbAWsUQKwbtJa3uCh/uxzit88rvKBQ7psg86XJsZ1r1WV6lZdOhBQVsIWML+cNW9I/+4/l772VLtxgwWnymY2bgjUTBO1kkS/cP4pfb8+rzeaK4rZWBYAtgSCEoD1F3j78IbSlRWl9bqvVNfQ2JjmwlBH7bq/n5bhuCsaTen8nPTt55TaoW8+I11ezNckZVPuNmnvr/aeSd9fu6yXGkv65cXjWfOGlYRqEgBsFUy9A7DukoWFLCQtXzivZHHBBqAFffPgIe0sFPV5G4tOprQMx11Sb2YbyKbfeFr63ovSG2ftCWuVpFJxU/dKypcIB3qmvqA3G8t6xQ4AwNZCMwcAG8bbhQfVanbs+Et/WdUDB/WRP/Nn9dkoyI5hcbYGmyf16tEbp5X+89/OOtsFl5estLl5jRtyVkkKI51trunZ2pz+1uwLerG+mLUGBwBsLYxRAGyYNEmyypLsqJ84bmPRQGcuXtS5oQFdtKMaRdn+Sps02QnblU+3syM9fVG6ZBXOC3MKllbzNUnlwuaFpPbXaaSp5pKGTrZWtZQ0Nc9+SQCwJVFRArBpwsFBDXzux3XvD/+w7v2RH9HPT+zQ/aWSdgjYOOkf/kB69aTSv/PPs3AULK9ZQCrZqcJIm8k3lfWQ9JJVkn539bz+zuzLumSVpHqaCACw9dDMAcAm8n7INiis17V2+bIGBwa0ZLceGB7Kzths7rAVfcu7xq3VJasgpb6BrAelH7yc7ZMUJGnesMEbN2xmJSkItZq0dNmC0a8sntAP1ub1XGNRdSWcrQSALYqpdwA2TdpsqPHsMzq/sKDZV1/VVycmdcZGiR/ftVNle39JwDpoB6XUN4/9vW9nHe70xplszVy2Hqm42f/0eYe7UCtJTZdaa/qNpdPZhrKLTLkDgC2NihKATZfWa0rmLmvu9dd19nvf06lCQecWF3Vg794sLFFZwm07ecEqR2eV/OPflL76XQXf8PbfC3kVyafaReGmVpK8cUPLglsjifW/z72qLy2f09fWLmXrkmJqSQCwpVFRArDpfG8lP+Zee1U1C0jPnzql8ZERed8vVmvgjqzV8oYNL5+Qzl+2Y1aq+nqkQl5N2nRBFofiNNFLjWWdaK5oib2SAKAn0MwBwN3lZ91LJe2+/6geePJT+kt/5r/UPQf265GpKQHvyv8Fa1lt5ulXJDvSX/9qvhbJq0i+DqnU7moXbG5I8ql2Hvq9kvTvl87YcVr/duWMlglJANAzmHoH4K7ztSMF3/AzTVW06xfPn9e+mZ1qtloaqFQEXNfyqrSwJD1lIempl6VnX7OQdD67PYiTfJrdZk61y+ShzP+bixt6vr6ob9Vm9Z3anE601phuBwA9hKl3AO66tNnU5ePHs+P866+qNDSkew8c1OToqCbHHhZwXT61bnZB6f//P0ivnbbjVN6wwYNRuai7IshaN2RXfR3SbyyfztYkfc3CEgCgt1BRArCltCw0NVZWdPbceZ187XVNFMsqR4WslbjCcNOnUGEL8W52zZbS41Y1evZVpf/2K0q/9YwCryYtLEve+vuuVJGUV5GC8EpI+u3ls/ra6kX9q+VTOtFY00rKlDsA6DVUlABsKY3lZTXs8j9/+fd05tBhffSeo5qZnNK0r1nyBfnkpO3Lg1Irli7NSa+ekr71rJVtFvPKkrf89q52Hqa3gBfqi3qqNq9nagsCAPQmmjkA0FYV2ln6or1M/dSRR/Teqb36c7/432vkwB7pvv3CNvOdF6TXTymxKpJOnVdw8nzerMGDUenunvPzSlLHry+e0g9qc/pf517Npt4BAHoXFSUAW5edxkntdM5cfU1vLl7W2VdeU7yyph0+MB4asKNqg+TilqkiYB15M4bVmrRix+pq3u775DlpcUVBo9meYhfd5QpjcOXr19JEZ1r2PG2u6HhrVTXFAgD0NipKALa8ahCpYNWl/2nyIR3bd0Cf/rHPSo/cKz1qx/6ZfEoe+stSHo7Sbz8rvXlW+r1v513u1upbZ5pdu7ude90C0j+ce03/YeWsnma6HQD0BZo5ANjysg077c+FpKX51WXtnW9Ipy9q8LWzClbr2XWNjeSnfghNvWtuMQtI6Ve+K33vRaVf+rr0nRcVvHIiD07XNmu4myHJA1IYZfsk+Uay/2TudX197ZL+3coZnWisqp6ybTIA9ANGFAC2PA9JsY2Rf1CfUytu6fTzL6l6aVHTJ2at3FSWpnZI9x+wVzQbPFfKQo9aswBcs+D7zKtKL85J33g672bnU/AGKnk48krSlhBYUErseZlm3e3Ox3UaNwBAn2HqHYCe0WnucLhQ1aeHdupTw7v0qZFdGiyUpIO7pUM7FRywy8eP5eGJpg9bm6818ul1FywUvfim9K1nlM4tKXj9dN7eu9bIq0eusxbpLreHD8KCammsxVZd/2bxlJ6qz+tfLJ7I3rec0AIcAPoJFSUAPSOxs/exDZTPJg291FjW6Mqs7kvKGi2WtetM0T4gyasS3uxhajx/2ysQ3vShYhWJqgWqckm4S/z34eGobseiVYqW16SnX5XOz2abxaYnL+S3ewXJA1Fnel24BXrCtzvbrSax5qx69FJ9Qc83FvRifYmABAB9iooSgJ72t6ce1sHioH5qYJcUx9k+O+nYcDZVK/CK0q4J6egh6cHDCnZPSXunhbvA90DyRgxnL0nnZpV+/Snp9AWlX7PLtZqCeQtIpVIeispFbTVeSfJ/Ml+pzembtVn904XjerGxqLPNmgAA/YmKEoCe9nurF7QzKmsqLOpAVNWBYlWBByYflHu3tEsLNjC/LL1+WunEaB6YfF3TTgtQ4/b2YCVvMR5sgapFv6k3supReuJcXiV684x0xoLSmYvSG2eyVt8+vS7wJg2VUrvd91b6PQTt78eqmK011aya9KuLJ/WqVTO9DfhSTAtwAOhnBCUAPe13V85rzELSIasqfWxgSvsqQ4qsqhQ0W3kXtY6JMQtF1ayi4RWn4D33S0eCfGqet5smKK2/bIqdhaFnXpPm7XfxzWeyKpJOXcjfZ1WmwMORr0PaglMig86fQahzzTXNx3X9SwtKvpHsaQtOAID+xtQ7AH3Bw9KjlTE9Uh7VXxg7bJWlQQ1FpXxdTJrY//ZSF7R3sPVwND6cr2MaGVDw0D15hemBw3ZHQ3bY+3aMXG0kgHfn3emsipc+/4bUac5w/nI2zS7bKNbCa772qP3x3cF0CwXVoL0eyetF36/N6Qdrc/rlxeM6ZeHoRHM168Lo6+UAAP2NihKAvuBn+c+1ahqNCtnmn6Ug0v6omHUMj9JQQWLDW+8xXq/nTQJ8oOtj3aWVPBx5W+rRwWy9TFbtcB6UfFpetndPu/IEqdluXuBT6+IkD6Oz8/ZYruUVo1mrHp26aIHpch6aPER5UPLH3ENqYatNsXPBlRDnLb/9qXEpbuiMVZKOt1Y1a9fPW1BqskcSAGwbVJQA9J37SsM6WBzQ35p8SBOFig6XrTrkL3VeWfKBbraDbXx1kO+HD9w9DPk6Jj+OHZSGrNp07FDeEGLXZN4IorOfz3bWXnOU+lQ6D0HeoOHVk1ZBslB05kL+uF4bhEqFt3ax23KCPCN5JcmOCxa0L1no/p8vvainGgv6QZ39kQBgO+L0KIC+s2Bn/08r1H9aPa99FpjWLBztLlY0EhazvZgyWTAK8y5rSZifNvLbvJrkg//j5/IKkjeFmLTgNDkmzUzkLcbHRvJKk7cd9+DkH+e3h+1qSRhujZbWt8OrPv4YtDsIamnVKkj+mKzkrb2XV/Ng5I/Ls69JK1aBm1vKq0hejct+7vCtoSgIr06522qC4MpapEWrSi5Z5fEbqxd1oVXXaxaYLsdNAQC2JypKAPpSaC9vgxZcHqvs0OeHduuTgzM6apWmSuStp1MrLl2nY5lXlrwa4gGhM73MQlBqlSUPRYGvXfJQ9IBVmXaMKtg/k69tGh2yEDVuIamQrXnKQpQHpl7Tqa55KFpZy6tG3jlwfknBS8eVXrbKyonzSmcXstAU+PojX/vVsseq2J6imAXFoGeaY2Trkdqd7V5pLOqV+qL+n1ZJumAVpZebywIAbF8EJQB9Katr2ADYmzyMRSU9boFpf2FAf3HHEVUtQO0qVvPqiZRPx+vI1i6leQDo6Az8w/agerBdRcoqSZUsHKT7prOAFHjladjCUqWchSkNWKVpxIJUtZy3JfdQ5YHK10P5/fm0tI2aktb5WZwHP2+msFrPW3YvLOUVosuLeXXIj4uX82qSV4gsHKUekPx6rZGvR2q08s+J2+uNPFRm/4Rssc1h31Fnml3ezW7eAtGZ1pp+b+WCnqrP66navF5qLKllP18tpf03AGxnTL0D0JeyZUg22PVF+H4MBpEW46ZWkmZ7Glh78X5397KgE4rab2dVlvRqOPDDqy2d6529f3xKmre4nl7Mu+ZlezXV81DlAcNbk/tUPf+YoletKhv/Cnztz+ahptEOSx585tsByKtC/r0v28906pzdloen1AOUV5D8Z/UK27VhrnO9GLWn1fXiNEP/GQI1LCT78+IVC0cvWjXp2fpCdhtnEAEAVJQAbCtTVl3aWxzQTw3v06cHZ3SsNKyBqJwXQrwzXvZRN/GyeG21xjU7VZY4D1ZJu0rlQapSUtrp9tZpBpFtsBoq8OrSjvaUvs6mqz6NbWJEgYWrtDMF8GZ4GPIuc/49NK1q5OuHfE+phWWl/v34fa018jVHWWUoUeDByT8vboehoP09R+11RlGvBqG38s7witrJ1ILQ99bmdLK5ov/l8ks6ZVUl30AWAIBrUVECsK3UlOhiXNf3anMqWQA42VzVQ9UdGg9LmgwLWSZIFV4Tgm4QmrrDQ2fPpewOvLNelN9He9pedlbKA4lXcfxjPMCE7SlrHmA6G9+G7VbkXs2pFNvT226SB7TF1fZaqzifRudrsVbrCpI0D0u+nihur8XKKmLh1cYWQbvK1pli2OsBqf39B+3ZgZft9+4NG45bKPru2mW7XNXZVt2qjLcQRgEA2wYVJQDb1pHikKatmvQXdtyje0qD+kh18kqL6CxgeNOHO3mJTK5d+6T22qd2e/LkLu3Hc+0eRp1g1A+h6Ho8oAZXm2o80w5H/2LxuP7Irr9OFQkA8A4ISgC2rdGwqLINpI+Vh7SnMKAPVSZ0xK7fUxrS4eKgCp31N+1pdncUmjoVqrTr7U2QeGBI/QU/vRqOOvooIGWVozDvYOdht2aVomU7Xm4sZQ0b/s3iSa1aAH6usaDzVJIAAO+CqXcAtq0Fb+ygpubXGpqMlm1gHaumWMNhpP3FgfYLZCdI3GGwuVLFuXKDNkvqgc++/yDdDufFgiuXHoOW7XfsQenl+qK+tHxWvgptNaGbHQDg3VFRAoBrFCzQRPbS+CNDOzUTlfVnRg9km9Z6a/Eg9OjkFaY4ry5ti+CxdXW2is02+m2btcrRrFWL/vnCcb3eWNE31y7pYtLQItUjAMAtoqIEANfIZtnZ+HsubmSb1j5dX9B83NRCsalJC0slG5SPBVE2jS1sV2ryT5Q477QZgrdV5Xx63aofFmBfry/pvIWl461VnYnXVEsTqxnyewEA3DoqSgBwAx6UBtvT8Lyi9GNDu7W7UNHHB6YsMBU0EJWUvYSmydXNa3lJ3UCdzWLDK90Ffc+jl+qLej47FvSllXM6ZUHpXKsmAADuBEEJAG7AXyB9Kt5QUNSABabdxaqGg4I+Wp3UVKGsg6VhHSxUs+szFqDyasc1L6tJcvP7MqFLJxS1H1NvGGhhNLZg5FPpLsY1fbc2l20W+621WV1q1XXJbj9rIWkxblkliXVIAIA7w9Q7ALgBjzdNG5zPpQ3NWdHotA3CnTd98E1rl5KWKlWpbAP5LCjlI3tdPQcVZFP0iEl3ovN45hex/T4W4oZON1f1zdVLuhTX9eWVC1llqZ7epZbrAIC+REUJAG5RJQiz1uFFewndEZU0ZNWmjw9OayIq67HSmPaXqtoRlrS3NJS3GHfZ1Ly3NoCg2tSuG10bMNvX84erpZMWTuctGH3Dqkanmmt6qj6vc1ZN8vbevo7MP2zNm2ukTHsEAKwvKkoAcItq2ZqkvHrhjQIWkkDHmyvZgH5HkL+srkSxSpFP2SvYC60FK/s4bwHRedENguD6Z6r6uSnEdfds8lBkESdIlcWeNH98W0lqR9MqR97FrqHjjVULSGvZhrFeRZq1x7qZJkQjAMCGoaIEAOts2qpMvpbp0eoO7SxU9L7yjqwhxAE7dhUGVLQqUzlqtxrPdDrnJX3ddjzoNGG4djqdVYNa9vP65rCvNpezfY9+d/l8Nq3xxcaSXrHbzrdqWkliEYsAAJuJoAQA62zQQlJn3dKQVZR2F6oat/A0YcfB4pCqYaRDpSENBJFGPVR51ck+fiIsZZWm8C2b0aZdl9d5143ev2GCd3zzrTfk/8z4fysWfurZWqI0q76t2fUL3nzBwtG5Zk3HWyvZx7zcWFbDAtQl+xivHPltDapHAIBNRlACgE1QtmpKyY6jxRGNWDD6yMBEtqYpqzIVq6paaLq3NKzI1z6F186Kvlptepu3rHfavJfy4NogdL3pdN1VI6VZE4YLzZVs41fvVPe6Xfc1Rs81FrNW3i/UF3U6XtOaVY5oygAA2AoISgCwCbxK5PlhKPA1S4GGo0IWnEoWkKYtMHmQOlgctGpTQWNRMatGjVmFaY9d+vt8Ct9AaB+vKJu655Wnot9xttbprY0QNlbWpzu7bFmg8UgTtytGfvPlpJFtAHvGKkReKVrwdUatPACdscvLFo788Nu9CYPf7q28a1mlKc7ug9oRAGArICgBwF3mnfPKFqX2FKyyFEUat6C0rzCY3b7fb/NNbwsD2TS+igUrD1PeS8+Dk4ckr0KFod9i15V32fMX9/BKV+1bD09pu0bVKVr5RdK+tZXE2S11C0S+vqhp72zZez04nWvVtZw2dbyxYqGpmVWN3mysatVC0Pm4lr09n+TT7uI+XYsFAOgPBCUA2OJ8/ZJPzRsJCllr8snIqkwWjPYUq9k0Pr99yEKVh6hJu4yyalNgtxWvfO7N6myyu5pcrfZ4GPLpcB5uvEo0G9ezt88017Kq0ELczEKQv2/ZPqelNOtIBwBAL6M9OABscR45vA35iuJsA1wldUVJmLXTrlpwqmRHIZuSN9SuNnlYKlslyi8rnb2cbkJWibI/6+0NXD3wJFnVKM0aKnhwWklb2dvzFpD8tjWrLPl0u5pXlXwKngAA6H1UlACgz5VvISh1xNkaJP55AABsXwQlAOhz4R2sUQIAYLsiKAEAAABAl1ufjwEAAAAAfY6gBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAAAAABdCEoAAAAA0IWgBAD4P9qvYwEAAACAQf7W+8dQFgEAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAI0oAAAAjSgAAACNKAAAAE66La9ksQ6vKAAAAAElFTkSuQmCC";
  function JS(t10, e, r) {
    let n = false;
    return new Promise((i, o) => {
      let s;
      const l = `wss://live-api.joinplayroom.com/?service=tiktok&username=${t10}`;
      s = new WebSocket(l), s.onmessage = function(c) {
        if (n)
          e(c.data ? JSON.parse(c.data) : null);
        else
          try {
            JSON.parse(c.data).type === "streamStart" && (n = true, i(s));
          } catch {
          }
      }, s.onopen = function(c) {
      }, s.onerror = function(c) {
        o();
      }, s.onclose = function(c) {
        n ? r() : o();
      };
    });
  }
  function QS({ options: t10 = {}, onStart: e }) {
    const { width: r, height: n } = Wm(), [i, o] = reactExports.useState(false), s = Ie();
    return reactExports.useEffect(() => {
      const a = document.createElement("style");
      a.innerHTML = [lg, cg, ug].join(`
`), document.head.appendChild(a), s.createRoom(null, true, true);
    }, []), i ? null : /* @__PURE__ */ K.createElement("div", { className: "bootstrap-wrapper" }, /* @__PURE__ */ K.createElement("div", { className: "playroom" }, /* @__PURE__ */ K.createElement("div", { className: "modal-container fullscreen " }, /* @__PURE__ */ K.createElement("div", { "data-pop": "slide-up", id: "popup", className: "show" }, /* @__PURE__ */ K.createElement("div", { className: "popupcontrols" }), /* @__PURE__ */ K.createElement(
      "div",
      {
        className: "popupcontent",
        style: { transform: `scale(${Math.min(1, n / 844)})` }
      },
      /* @__PURE__ */ K.createElement(
        GS,
        {
          options: t10,
          onStart: () => {
            o(true), s.setState("__launched", true), e();
          },
          onMessage: (a) => {
            s.emit("live:tiktok:msg", a);
          }
        }
      )
    )), /* @__PURE__ */ K.createElement("div", { id: "overlay", className: "show" }))));
  }
  function GS({ options: t10 = {}, onStart: e, onMessage: r }) {
    const [n, i] = reactExports.useState(false), [o, s] = reactExports.useState(""), [a, l] = reactExports.useState(null), [c, u] = reactExports.useState(null);
    async function f() {
      try {
        const d = await JS(
          o,
          (h) => {
            r(h);
          },
          () => {
            i(false);
          }
        );
        u(d), e(d);
      } catch (d) {
        console.log(d), l(setTimeout(f, 5e3));
      }
    }
    return /* @__PURE__ */ K.createElement("div", { className: "main-menu" }, /* @__PURE__ */ K.createElement("div", { className: "platform" }, /* @__PURE__ */ K.createElement("div", { className: "profilecontainer" }, /* @__PURE__ */ K.createElement("div", { className: "steps-container" }, /* @__PURE__ */ K.createElement("div", { className: "step-item active" }), /* @__PURE__ */ K.createElement("div", { className: "step-item " + (n ? " loading" : "") }, /* @__PURE__ */ K.createElement("span", null))), !n && /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          textAlign: "left",
          color: "#fff",
          padding: "1rem 0rem"
        }
      },
      /* @__PURE__ */ K.createElement("b", { className: "title" }, "Connect to TikTok"),
      /* @__PURE__ */ K.createElement("p", { className: "subtitle" }, "Enter your TikTok username which you will live stream from.")
    ), /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          position: "relative",
          zIndex: 1,
          display: "inline-block"
        }
      },
      /* @__PURE__ */ K.createElement(
        "div",
        {
          className: "avatar-photo ",
          style: {
            border: "none",
            // tiktok style double shadow
            boxShadow: "2px 2px 0px 0px rgba(254,40,84,1), -2px -2px 0px -0px rgba(36,246,250,1)",
            backgroundImage: `url(${XS})`
          }
        }
      )
    ), /* @__PURE__ */ K.createElement(
      "input",
      {
        type: "text",
        placeholder: "username",
        value: o,
        onChange: (d) => {
          s(d.target.value);
        },
        autoCapitalize: "none",
        autoCorrect: "off",
        className: "input-name"
      }
    )), n && /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(
      "div",
      {
        style: {
          textAlign: "left",
          color: "#fff",
          padding: "1rem 0rem"
        }
      },
      /* @__PURE__ */ K.createElement("b", { className: "title" }, "Waiting for stream..."),
      /* @__PURE__ */ K.createElement("p", { className: "subtitle" }, "Open TikTok and go live from ", /* @__PURE__ */ K.createElement("b", null, "@", o), ' in "Mobile gaming" mode.')
    ))), /* @__PURE__ */ K.createElement(
      "section",
      {
        style: { width: "100%", display: "flex", marginBottom: "1rem" }
      },
      /* @__PURE__ */ K.createElement(
        "button",
        {
          id: "btn-launchjoin",
          className: "button-black launch-btn",
          disabled: !o,
          onClick: async () => {
            if (n) {
              i(false), a && clearTimeout(a), l(null), c && c.close();
              return;
            }
            i(true), f();
          }
        },
        n ? "Cancel" : "Launch"
      )
    ), /* @__PURE__ */ K.createElement("p", { className: "sdk-version" }, "Multiplayer by Playroom v.", Gu.version)));
  }
  function ZS(t10 = {}, e) {
    if (!window.__playroomjs_mounted) {
      var r = document.createElement("div");
      document.body.appendChild(r), window.__playroomjs_mounted = true, $S(/* @__PURE__ */ K.createElement(QS, { options: t10, onStart: e }), r);
    }
  }
  function $S(t10, e) {
    Wt.createRoot ? Wt.createRoot(e).render(t10) : Wt.render(t10, e);
  }
  typeof window < "u" && (window._PLAYROOM_CONFIG = {
    ...window._PLAYROOM_CONFIG || {},
    sessionStorage: true,
    sdkMode: true,
    sdkVersion: Gu.version
  }, mi.track("SDK: Loaded", {
    cdn: !!window.Playroom
  }));
  function RE(t10 = {
    streamMode: false,
    baseUrl: "",
    allowGamepads: false,
    enableBots: false,
    botOptions: {},
    avatars: [],
    roomCode: void 0,
    skipLobby: false,
    liveMode: void 0,
    maxPlayersPerRoom: void 0,
    defaultStates: {},
    defaultPlayerStates: {},
    matchmaking: void 0,
    gameId: "",
    persistentMode: void 0,
    turnBased: void 0,
    discord: void 0
  }, e = void 0, r = void 0) {
    if (typeof t10 != "object")
      throw new Error("options must be an object");
    if (!t10.streamMode && t10.allowGamepads)
      throw new Error("allowGamepads only works in stream mode");
    return t10.matchmaking && (typeof t10.matchmaking != "object" ? t10.matchmaking = { waitBeforeCreatingNewRoom: 5e3 } : t10.matchmaking = {
      waitBeforeCreatingNewRoom: 5e3,
      ...t10.matchmaking
    }), t10.turnBased && (t10.persistentMode = true), t10.turnBased && t10.turnBased.challengeId && (t10.roomCode = t10.turnBased.challengeId), t10.persistentMode && (window._PLAYROOM_CONFIG.sessionStorage = false), new Promise((n, i) => {
      const o = () => {
        e && e(), n();
      }, s = (a) => {
        r && r(a), i(a);
      };
      t10.liveMode ? ZS(t10, o) : t10.discord ? e3(
        t10,
        (a) => {
          d0(a, o, s);
        },
        s
      ) : d0(t10, o, s);
    });
  }
  const Playroom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Analytics: mi,
    Bot: sg,
    DQNBaseBot: D5,
    DQNBotJoystick: CE,
    Joystick: Pc,
    Multiplayer: Ie,
    RPC: xE,
    addBot: F5,
    clearTurns: IE,
    getAllTurns: OE,
    getChallengeId: AE,
    getDiscordAccessToken: aE,
    getDiscordAuth: lE,
    getDiscordClient: l3,
    getDiscordSDK: c3,
    getDiscordServerData: a1,
    getMyTurnData: PE,
    getPersistentData: a1,
    getRoomCode: AE,
    getState: mE,
    handlePlayerKeyDown: bE,
    handlePlayerKeyRelease: vE,
    insertCoin: RE,
    insertDiscordServerData: A3,
    insertPersistentData: A3,
    isHost: yE,
    isStreamScreen: p3,
    me: Hn,
    myPlayer: Hn,
    onDisconnect: wE,
    onPlayerJoin: hE,
    onTikTokLiveEvent: pE,
    openDiscordInviteDialog: sE,
    resetPlayersStates: dE,
    resetStates: fE,
    saveMyTurnData: TE,
    setDiscordServerData: v3,
    setPersistentData: v3,
    setState: gE,
    startMatchmaking: _E,
    transferHost: SE,
    useIsHost: Mu,
    useMultiplayerState: yi,
    usePlayerState: uE,
    usePlayersList: Va,
    usePlayersState: cE,
    waitForPlayerState: oE,
    waitForState: iE
  }, Symbol.toStringTag, { value: "Module" }));
  window.Playroom = Playroom;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var eventemitter3 = { exports: {} };
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events2() {
    }
    if (Object.create) {
      Events2.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events2().__proto__)
        prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events2();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a12, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a12), true;
          case 3:
            return listeners.fn.call(listeners.context, a12, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a12, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a12, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a12, a22, a32, a42, a52), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a12);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a12, a22);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a12, a22, a32);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x2) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el2 = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el2] = curr[el2] || { _errors: [] };
              } else {
                curr[el2] = curr[el2] || { _errors: [] };
                curr[el2]._errors.push(mapper(issue));
              }
              curr = curr[el2];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform2) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform: transform2 }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[a-z][a-z0-9]*$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  const datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip2, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip2)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip2)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch2) => ch2.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch2) => ch2.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    var _a2;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
          return true;
        } else if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        } else if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    var _a2;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min)
            min = ch2.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max)
            max = ch2.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn2 = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn2, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn2, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum.create(values);
    }
    exclude(values) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if (isValid(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  const custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a2, _b2;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a2 = p.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
          const p22 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var BigInteger = { exports: {} };
  (function(module) {
    var bigInt2 = function(undefined$1) {
      var BASE2 = 1e7, LOG_BASE2 = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined")
          return Integer[0];
        if (typeof radix !== "undefined")
          return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }
      function BigInteger2(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }
      BigInteger2.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
      }
      function smallToArray(n) {
        if (n < 1e7)
          return [n];
        if (n < 1e14)
          return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE2;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE2) * BASE2;
          }
        }
        return arr;
      }
      function trim(v) {
        var i10 = v.length;
        while (v[--i10] === 0)
          ;
        v.length = i10 + 1;
      }
      function createArray(length) {
        var x = new Array(length);
        var i10 = -1;
        while (++i10 < length) {
          x[i10] = 0;
        }
        return x;
      }
      function truncate2(n) {
        if (n > 0)
          return Math.floor(n);
        return Math.ceil(n);
      }
      function add2(a, b) {
        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE2, sum, i10;
        for (i10 = 0; i10 < l_b; i10++) {
          sum = a[i10] + b[i10] + carry;
          carry = sum >= base ? 1 : 0;
          r[i10] = sum - carry * base;
        }
        while (i10 < l_a) {
          sum = a[i10] + carry;
          carry = sum === base ? 1 : 0;
          r[i10++] = sum - carry * base;
        }
        if (carry > 0)
          r.push(carry);
        return r;
      }
      function addAny(a, b) {
        if (a.length >= b.length)
          return add2(a, b);
        return add2(b, a);
      }
      function addSmall(a, carry) {
        var l = a.length, r = new Array(l), base = BASE2, sum, i10;
        for (i10 = 0; i10 < l; i10++) {
          sum = a[i10] - base + carry;
          carry = Math.floor(sum / base);
          r[i10] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r[i10++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      BigInteger2.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
          return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger2(addAny(a, b), this.sign);
      };
      BigInteger2.prototype.plus = BigInteger2.prototype.add;
      SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          if (isPrecise(a + b))
            return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }
        return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract2(a, b) {
        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE2, i10, difference;
        for (i10 = 0; i10 < b_l; i10++) {
          difference = a[i10] - borrow - b[i10];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else
            borrow = 0;
          r[i10] = difference;
        }
        for (i10 = b_l; i10 < a_l; i10++) {
          difference = a[i10] - borrow;
          if (difference < 0)
            difference += base;
          else {
            r[i10++] = difference;
            break;
          }
          r[i10] = difference;
        }
        for (; i10 < a_l; i10++) {
          r[i10] = a[i10];
        }
        trim(r);
        return r;
      }
      function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
          value = subtract2(a, b);
        } else {
          value = subtract2(b, a);
          sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign)
            value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger2(value, sign);
      }
      function subtractSmall(a, b, sign) {
        var l = a.length, r = new Array(l), carry = -b, base = BASE2, i10, difference;
        for (i10 = 0; i10 < l; i10++) {
          difference = a[i10] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r[i10] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
          if (sign)
            r = -r;
          return new SmallInteger(r);
        }
        return new BigInteger2(r, sign);
      }
      BigInteger2.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
          return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };
      BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
      SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger2.prototype.negate = function() {
        return new BigInteger2(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger2.prototype.abs = function() {
        return new BigInteger2(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE2, product, carry, i10, a_i, b_j;
        for (i10 = 0; i10 < a_l; ++i10) {
          a_i = a[i10];
          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r[i10 + j];
            carry = Math.floor(product / base);
            r[i10 + j] = product - carry * base;
            r[i10 + j + 1] += carry;
          }
        }
        trim(r);
        return r;
      }
      function multiplySmall(a, b) {
        var l = a.length, r = new Array(l), base = BASE2, carry = 0, product, i10;
        for (i10 = 0; i10 < l; i10++) {
          product = a[i10] * b + carry;
          carry = Math.floor(product / base);
          r[i10] = product - carry * base;
        }
        while (carry > 0) {
          r[i10++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0)
          r.push(0);
        return r.concat(x);
      }
      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30)
          return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac2 = multiplyKaratsuba(a, c), bd2 = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac2, shiftLeft(subtract2(subtract2(abcd, ac2), bd2), n)), shiftLeft(bd2, 2 * n));
        trim(product);
        return product;
      }
      function useKaratsuba(l12, l22) {
        return -0.012 * l12 - 0.012 * l22 + 15e-6 * l12 * l22 > 0;
      }
      BigInteger2.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
        if (n.isSmall) {
          if (b === 0)
            return Integer[0];
          if (b === 1)
            return this;
          if (b === -1)
            return this.negate();
          abs = Math.abs(b);
          if (abs < BASE2) {
            return new BigInteger2(multiplySmall(a, abs), sign);
          }
          b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length))
          return new BigInteger2(multiplyKaratsuba(a, b), sign);
        return new BigInteger2(multiplyLong(a, b), sign);
      };
      BigInteger2.prototype.times = BigInteger2.prototype.multiply;
      function multiplySmallAndArray(a, b, sign) {
        if (a < BASE2) {
          return new BigInteger2(multiplySmall(b, a), sign);
        }
        return new BigInteger2(multiplyLong(b, smallToArray(a)), sign);
      }
      SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };
      BigInteger2.prototype._multiplyBySmall = function(a) {
        if (a.value === 0)
          return Integer[0];
        if (a.value === 1)
          return this;
        if (a.value === -1)
          return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };
      SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a) {
        var l = a.length, r = createArray(l + l), base = BASE2, product, carry, i10, a_i, a_j;
        for (i10 = 0; i10 < l; i10++) {
          a_i = a[i10];
          carry = 0 - a_i * a_i;
          for (var j = i10; j < l; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r[i10 + j] + carry;
            carry = Math.floor(product / base);
            r[i10 + j] = product - carry * base;
          }
          r[i10 + l] = carry;
        }
        trim(r);
        return r;
      }
      BigInteger2.prototype.square = function() {
        return new BigInteger2(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value))
          return new SmallInteger(value);
        return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE2, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i10, l, q;
        if (remainder.length <= a_l)
          remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base - 1;
          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l = divisor.length;
          for (i10 = 0; i10 < l; i10++) {
            carry += quotientDigit * divisor[i10];
            q = Math.floor(carry / base);
            borrow += remainder[shift + i10] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift + i10] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift + i10] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i10 = 0; i10 < l; i10++) {
              carry += remainder[shift + i10] - base + divisor[i10];
              if (carry < 0) {
                remainder[shift + i10] = carry + base;
                carry = 0;
              } else {
                remainder[shift + i10] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a, b) {
        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE2, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a[--a_l]);
          trim(part);
          if (compareAbs(part, b) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b, guess);
            if (compareAbs(check, part) <= 0)
              break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract2(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE2, i10, q, remainder, divisor;
        remainder = 0;
        for (i10 = length - 1; i10 >= 0; --i10) {
          divisor = remainder * base + value[i10];
          q = truncate2(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i10] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
        }
        var a = self2.value, b = n.value;
        var quotient;
        if (b === 0)
          throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate2(a / b)), new SmallInteger(a % b)];
          }
          return [Integer[0], self2];
        }
        if (n.isSmall) {
          if (b === 1)
            return [self2, Integer[0]];
          if (b == -1)
            return [self2.negate(), Integer[0]];
          var abs = Math.abs(b);
          if (abs < BASE2) {
            value = divModSmall(a, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign)
              remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n.sign)
                quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger2(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
          }
          b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1)
          return [Integer[0], self2];
        if (comparison === 0)
          return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
        if (a.length + b.length <= 200)
          value = divMod1(a, b);
        else
          value = divMod2(a, b);
        quotient = value[0];
        var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign)
            quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else
          quotient = new BigInteger2(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign)
            mod = -mod;
          mod = new SmallInteger(mod);
        } else
          mod = new BigInteger2(mod, mSign);
        return [quotient, mod];
      }
      BigInteger2.prototype.divmod = function(v) {
        var result = divModAny(this, v);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
      BigInteger2.prototype.divide = function(v) {
        return divModAny(this, v)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
      BigInteger2.prototype.mod = function(v) {
        return divModAny(this, v)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
      BigInteger2.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0)
          return Integer[1];
        if (a === 0)
          return Integer[0];
        if (a === 1)
          return Integer[1];
        if (a === -1)
          return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
          return Integer[0];
        }
        if (!n.isSmall)
          throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b)))
            return new SmallInteger(truncate2(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
          if (b & true) {
            y = y.times(x);
            --b;
          }
          if (b === 0)
            break;
          b /= 2;
          x = x.square();
        }
        return y;
      };
      SmallInteger.prototype.pow = BigInteger2.prototype.pow;
      NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _02 = BigInt(0), _12 = BigInt(1), _22 = BigInt(2);
        if (b === _02)
          return Integer[1];
        if (a === _02)
          return Integer[0];
        if (a === _12)
          return Integer[1];
        if (a === BigInt(-1))
          return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative())
          return new NativeBigInt(_02);
        var x = this;
        var y = Integer[1];
        while (true) {
          if ((b & _12) === _12) {
            y = y.times(x);
            --b;
          }
          if (b === _02)
            break;
          b /= _22;
          x = x.square();
        }
        return y;
      };
      BigInteger2.prototype.modPow = function(exp2, mod) {
        exp2 = parseValue(exp2);
        mod = parseValue(mod);
        if (mod.isZero())
          throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1], base = this.mod(mod);
        if (exp2.isNegative()) {
          exp2 = exp2.multiply(Integer[-1]);
          base = base.modInv(mod);
        }
        while (exp2.isPositive()) {
          if (base.isZero())
            return Integer[0];
          if (exp2.isOdd())
            r = r.multiply(base).mod(mod);
          exp2 = exp2.divide(2);
          base = base.square().mod(mod);
        }
        return r;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }
        for (var i10 = a.length - 1; i10 >= 0; i10--) {
          if (a[i10] !== b[i10])
            return a[i10] > b[i10] ? 1 : -1;
        }
        return 0;
      }
      BigInteger2.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall)
          return 1;
        return compareAbs(a, b);
      };
      SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      BigInteger2.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };
      BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
      SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger2.prototype.equals = function(v) {
        return this.compare(v) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
      BigInteger2.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
      BigInteger2.prototype.greater = function(v) {
        return this.compare(v) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
      BigInteger2.prototype.lesser = function(v) {
        return this.compare(v) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
      BigInteger2.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
      BigInteger2.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
      BigInteger2.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger2.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger2.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger2.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger2.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger2.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger2.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero())
          return false;
        if (n.isUnit())
          return true;
        if (n.compareAbs(2) === 0)
          return this.isEven();
        return this.mod(n).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit())
          return false;
        if (n.equals(2) || n.equals(3) || n.equals(5))
          return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
          return false;
        if (n.lesser(49))
          return true;
      }
      function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r = 0, d, i10, x;
        while (b.isEven())
          b = b.divide(2), r++;
        next:
          for (i10 = 0; i10 < a.length; i10++) {
            if (n.lesser(a[i10]))
              continue;
            x = bigInt2(a[i10]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev))
              continue;
            for (d = r - 1; d != 0; d--) {
              x = x.square().mod(n);
              if (x.isUnit())
                return false;
              if (x.equals(nPrev))
                continue next;
            }
            return false;
          }
        return true;
      }
      BigInteger2.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1)
          return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
          return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a = [], i10 = 0; i10 < t; i10++) {
          a.push(bigInt2(i10 + 2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
      BigInteger2.prototype.isProbablePrime = function(iterations, rng2) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1)
          return isPrime;
        var n = this.abs();
        var t = iterations === undefined$1 ? 5 : iterations;
        for (var a = [], i10 = 0; i10 < t; i10++) {
          a.push(bigInt2.randBetween(2, n.minus(2), rng2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
      BigInteger2.prototype.modInv = function(n) {
        var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r.divide(newR);
          lastT = t;
          lastR = r;
          t = newT;
          r = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit())
          throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
      BigInteger2.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger2(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT)
          return new SmallInteger(value + 1);
        return new BigInteger2(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger2.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger2(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT)
          return new SmallInteger(value - 1);
        return new BigInteger2(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE2)
        powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n) {
        return Math.abs(n) <= BASE2;
      }
      BigInteger2.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0)
          return this.shiftRight(-n);
        var result = this;
        if (result.isZero())
          return result;
        while (n >= powers2Length) {
          result = result.multiply(highestPower2);
          n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
      BigInteger2.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0)
          return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit())
            return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
      function bitwise(x, y, fn2) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn2(xDigit, yDigit));
        }
        var sum = fn2(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
        for (var i10 = result.length - 1; i10 >= 0; i10 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt2(result[i10]));
        }
        return sum;
      }
      BigInteger2.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
      BigInteger2.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
          return a & b;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
      BigInteger2.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
          return a | b;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
      BigInteger2.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
          return a ^ b;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE2 & -BASE2) * (BASE2 & -BASE2) | LOBMASK_I;
      function roughLOB(n) {
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE2 | LOBMASK_BI;
        return x & -x;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p = tmp.p;
          var e = tmp.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
        }
        return { p: bigInt2(1), e: 0 };
      }
      BigInteger2.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt2(0)) < 0) {
          n = n.negate().subtract(bigInt2(1));
        }
        if (n.compareTo(bigInt2(0)) === 0) {
          return bigInt2(0);
        }
        return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
      function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }
      function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }
      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b))
          return a;
        if (a.isZero())
          return b;
        if (b.isZero())
          return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
          d = min(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }
        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }
        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }
          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }
          b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
      }
      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }
      function randBetween(a, b, rng2) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng2 || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall)
          return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE2).value;
        var result = [], restricted = true;
        for (var i10 = 0; i10 < digits.length; i10++) {
          var top = restricted ? digits[i10] : BASE2;
          var digit = truncate2(usedRNG() * top);
          result.push(digit);
          if (digit < top)
            restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE2, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i10;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i10 = 0; i10 < alphabet.length; i10++) {
          alphabetValues[alphabet[i10]] = i10;
        }
        for (i10 = 0; i10 < length; i10++) {
          var c = text[i10];
          if (c === "-")
            continue;
          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1)
                continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i10 = isNegative ? 1 : 0; i10 < text.length; i10++) {
          var c = text[i10];
          if (c in alphabetValues)
            digits.push(parseValue(alphabetValues[c]));
          else if (c === "<") {
            var start = i10;
            do {
              i10++;
            } while (text[i10] !== ">" && i10 < text.length);
            digits.push(parseValue(text.slice(start + 1, i10)));
          } else
            throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
      };
      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i10;
        for (i10 = digits.length - 1; i10 >= 0; i10--) {
          val = val.add(digits[i10].times(pow));
          pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n, base) {
        base = bigInt2(base);
        if (base.isZero()) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          if (n.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }
        if (base.isUnit()) {
          if (n.isZero())
            return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
          return stringify(x, alphabet);
        }).join("");
      }
      BigInteger2.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger2.prototype.toString = function(radix, alphabet) {
        if (radix === undefined$1)
          radix = 10;
        if (radix !== 10)
          return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
          digit = String(v[l]);
          str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined$1)
          radix = 10;
        if (radix != 10)
          return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger2.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate2(x))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign)
          v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2)
          throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp2 = split[1];
          if (exp2[0] === "+")
            exp2 = exp2.slice(1);
          exp2 = +exp2;
          if (exp2 !== truncate2(exp2) || !isPrecise(exp2))
            throw new Error("Invalid integer: " + exp2 + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp2 -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp2 < 0)
            throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp2 + 1).join("0");
          v = text;
        }
        var isValid2 = /^([0-9][0-9]*)$/.test(v);
        if (!isValid2)
          throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max2 = v.length, l = LOG_BASE2, min2 = max2 - l;
        while (max2 > 0) {
          r.push(+v.slice(min2, max2));
          min2 -= l;
          if (min2 < 0)
            min2 = 0;
          max2 -= l;
        }
        trim(r);
        return new BigInteger2(r, sign);
      }
      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
          if (v !== truncate2(v))
            throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
      }
      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }
        if (typeof v === "string") {
          return parseStringValue(v);
        }
        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }
        return v;
      }
      for (var i = 0; i < 1e3; i++) {
        Integer[i] = parseValue(i);
        if (i > 0)
          Integer[-i] = parseValue(-i);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max;
      Integer.min = min;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x) {
        return x instanceof BigInteger2 || x instanceof SmallInteger || x instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };
      return Integer;
    }();
    if (module.hasOwnProperty("exports")) {
      module.exports = bigInt2;
    }
  })(BigInteger);
  var BigIntegerExports = BigInteger.exports;
  var bigInt = /* @__PURE__ */ getDefaultExportFromCjs(BigIntegerExports);
  const MAX_BIG_INT = 64;
  const SMALL_INT = 16;
  const PARTS = MAX_BIG_INT / SMALL_INT;
  function checkBrowserSupportsBigInt() {
    try {
      BigInt;
      return true;
    } catch (e) {
      return false;
    }
  }
  function fromHexReverseArray(hexValues, start, size) {
    let value = 0;
    for (let i = 0; i < size; i++) {
      const byte = hexValues[start + i];
      if (byte === void 0) {
        break;
      }
      value += byte * 16 ** i;
    }
    return value;
  }
  function toHexReverseArray(value) {
    const sum = [];
    for (let i = 0; i < value.length; i++) {
      let s = Number(value[i]);
      for (let j = 0; s || j < sum.length; j++) {
        s += (sum[j] || 0) * 10;
        sum[j] = s % 16;
        s = (s - sum[j]) / 16;
      }
    }
    return sum;
  }
  function splitBigInt(value) {
    const sum = toHexReverseArray(value);
    const parts = Array(PARTS);
    for (let i = 0; i < PARTS; i++) {
      parts[PARTS - 1 - i] = fromHexReverseArray(sum, i * PARTS, PARTS);
    }
    return parts;
  }
  class HighLow {
    static fromString(value) {
      return new HighLow(splitBigInt(value), value);
    }
    static fromBit(index2) {
      const parts = Array(PARTS);
      const offset = Math.floor(index2 / SMALL_INT);
      for (let i = 0; i < PARTS; i++) {
        parts[PARTS - 1 - i] = i === offset ? 1 << index2 - offset * SMALL_INT : 0;
      }
      return new HighLow(parts);
    }
    constructor(parts, str) {
      this.parts = parts;
      this.str = str;
    }
    and({ parts }) {
      return new HighLow(this.parts.map((v, i) => v & parts[i]));
    }
    or({ parts }) {
      return new HighLow(this.parts.map((v, i) => v | parts[i]));
    }
    xor({ parts }) {
      return new HighLow(this.parts.map((v, i) => v ^ parts[i]));
    }
    not() {
      return new HighLow(this.parts.map((v) => ~v));
    }
    equals({ parts }) {
      return this.parts.every((v, i) => v === parts[i]);
    }
    /**
     * For the average case the string representation is provided, but
     * when we need to convert high and low to string we just let the
     * slower big-integer library do it.
     */
    toString() {
      if (this.str != null) {
        return this.str;
      }
      const array = new Array(MAX_BIG_INT / 4);
      this.parts.forEach((value, offset) => {
        const hex = toHexReverseArray(value.toString());
        for (let i = 0; i < 4; i++) {
          array[i + offset * 4] = hex[4 - 1 - i] || 0;
        }
      });
      return this.str = bigInt.fromArray(array, 16).toString();
    }
    toJSON() {
      return this.toString();
    }
  }
  const SUPPORTS_BIGINT = checkBrowserSupportsBigInt();
  if (SUPPORTS_BIGINT && BigInt.prototype.toJSON == null) {
    BigInt.prototype.toJSON = function() {
      return this.toString();
    };
  }
  const HIGH_LOW_CACHE = {};
  const convertToBigFlag = SUPPORTS_BIGINT ? function convertToBigFlagBigInt(value) {
    return BigInt(value);
  } : function convertToBigFlagHighLow(value) {
    if (value instanceof HighLow) {
      return value;
    }
    if (typeof value === "number") {
      value = value.toString();
    }
    if (HIGH_LOW_CACHE[value] != null) {
      return HIGH_LOW_CACHE[value];
    }
    HIGH_LOW_CACHE[value] = HighLow.fromString(value);
    return HIGH_LOW_CACHE[value];
  };
  const EMPTY_FLAG = convertToBigFlag(0);
  const flagAnd = SUPPORTS_BIGINT ? function flagAndBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first & second;
  } : function flagAndHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.and(second);
  };
  const flagOr = SUPPORTS_BIGINT ? function flagOrBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first | second;
  } : function flagOrHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.or(second);
  };
  const flagXor = SUPPORTS_BIGINT ? function flagXorBigInt(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first ^ second;
  } : function flagXorHighLow(first = EMPTY_FLAG, second = EMPTY_FLAG) {
    return first.xor(second);
  };
  const flagNot = SUPPORTS_BIGINT ? function flagNotBigInt(first = EMPTY_FLAG) {
    return ~first;
  } : function flagNotHighLow(first = EMPTY_FLAG) {
    return first.not();
  };
  const flagEquals = SUPPORTS_BIGINT ? function flagEqualsBigInt(first, second) {
    return first === second;
  } : function flagEqualsHighLow(first, second) {
    if (first == null || second == null) {
      return first == second;
    }
    return first.equals(second);
  };
  function flagOrMultiple(...flags) {
    let result = flags[0];
    for (let i = 1; i < flags.length; i++) {
      result = flagOr(result, flags[i]);
    }
    return result;
  }
  function flagHas(base, flag) {
    return flagEquals(flagAnd(base, flag), flag);
  }
  function flagHasAny(base, flag) {
    return !flagEquals(flagAnd(base, flag), EMPTY_FLAG);
  }
  function flagAdd(base, flag) {
    return flag === EMPTY_FLAG ? base : flagOr(base, flag);
  }
  function flagRemove(base, flag) {
    return flag === EMPTY_FLAG ? base : flagXor(base, flagAnd(base, flag));
  }
  const getFlag = SUPPORTS_BIGINT ? function getFlagBigInt(index2) {
    return BigInt(1) << BigInt(index2);
  } : function getFlagHighLow(index2) {
    return HighLow.fromBit(index2);
  };
  var BigFlagUtils = {
    combine: flagOrMultiple,
    add: flagAdd,
    remove: flagRemove,
    filter: flagAnd,
    invert: flagNot,
    has: flagHas,
    hasAny: flagHasAny,
    equals: flagEquals,
    deserialize: convertToBigFlag,
    getFlag
  };
  var RPCCloseCodes;
  (function(RPCCloseCodes2) {
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_NORMAL"] = 1e3] = "CLOSE_NORMAL";
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_UNSUPPORTED"] = 1003] = "CLOSE_UNSUPPORTED";
    RPCCloseCodes2[RPCCloseCodes2["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_CLIENTID"] = 4e3] = "INVALID_CLIENTID";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_ORIGIN"] = 4001] = "INVALID_ORIGIN";
    RPCCloseCodes2[RPCCloseCodes2["RATELIMITED"] = 4002] = "RATELIMITED";
    RPCCloseCodes2[RPCCloseCodes2["TOKEN_REVOKED"] = 4003] = "TOKEN_REVOKED";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_VERSION"] = 4004] = "INVALID_VERSION";
    RPCCloseCodes2[RPCCloseCodes2["INVALID_ENCODING"] = 4005] = "INVALID_ENCODING";
  })(RPCCloseCodes || (RPCCloseCodes = {}));
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["INVALID_PAYLOAD"] = 4e3] = "INVALID_PAYLOAD";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_COMMAND"] = 4002] = "INVALID_COMMAND";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_EVENT"] = 4004] = "INVALID_EVENT";
    RPCErrorCodes2[RPCErrorCodes2["INVALID_PERMISSIONS"] = 4006] = "INVALID_PERMISSIONS";
  })(RPCErrorCodes || (RPCErrorCodes = {}));
  var Orientation$1;
  (function(Orientation2) {
    Orientation2["LANDSCAPE"] = "landscape";
    Orientation2["PORTRAIT"] = "portrait";
  })(Orientation$1 || (Orientation$1 = {}));
  var Platform;
  (function(Platform2) {
    Platform2["MOBILE"] = "mobile";
    Platform2["DESKTOP"] = "desktop";
  })(Platform || (Platform = {}));
  const Permissions = Object.freeze({
    CREATE_INSTANT_INVITE: BigFlagUtils.getFlag(0),
    ADMINISTRATOR: BigFlagUtils.getFlag(3)
  });
  function zodCoerceUnhandledValue(inputObject) {
    return preprocessType((arg) => {
      var _a2;
      const [objectKey] = (_a2 = Object.entries(inputObject).find(([, value]) => value === arg)) !== null && _a2 !== void 0 ? _a2 : [];
      if (arg != null && objectKey === void 0) {
        return inputObject.UNHANDLED;
      }
      return arg;
    }, stringType().or(numberType()));
  }
  function fallbackToDefault(schema) {
    const transform2 = custom().transform((data) => {
      const res = schema.safeParse(data);
      if (res.success) {
        return res.data;
      }
      return schema._def.defaultValue();
    });
    transform2.overlayType = schema;
    return transform2;
  }
  const InitiateImageUploadResponseSchema = z.object({ image_url: z.string() });
  const OpenShareMomentDialogRequestSchema = z.object({ mediaUrl: z.string().max(1024) });
  const AuthenticateRequestSchema = z.object({ access_token: z.union([z.string(), z.null()]).optional() });
  const AuthenticateResponseSchema = z.object({
    access_token: z.string(),
    user: z.object({
      username: z.string(),
      discriminator: z.string(),
      id: z.string(),
      avatar: z.union([z.string(), z.null()]).optional(),
      public_flags: z.number(),
      global_name: z.union([z.string(), z.null()]).optional()
    }),
    scopes: z.array(fallbackToDefault(z.enum([
      "identify",
      "email",
      "connections",
      "guilds",
      "guilds.join",
      "guilds.members.read",
      "gdm.join",
      "rpc",
      "rpc.notifications.read",
      "rpc.voice.read",
      "rpc.voice.write",
      "rpc.video.read",
      "rpc.video.write",
      "rpc.screenshare.read",
      "rpc.screenshare.write",
      "rpc.activities.write",
      "bot",
      "webhook.incoming",
      "messages.read",
      "applications.builds.upload",
      "applications.builds.read",
      "applications.commands",
      "applications.commands.update",
      "applications.commands.permissions.update",
      "applications.store.update",
      "applications.entitlements",
      "activities.read",
      "activities.write",
      "relationships.read",
      "voice",
      "dm_channels.read",
      "role_connections.write"
    ]).or(z.literal(-1)).default(-1))),
    expires: z.string(),
    application: z.object({
      description: z.string(),
      icon: z.union([z.string(), z.null()]).optional(),
      id: z.string(),
      rpc_origins: z.array(z.string()).optional(),
      name: z.string()
    })
  });
  const GetActivityInstanceConnectedParticipantsResponseSchema = z.object({
    participants: z.array(z.object({
      id: z.string(),
      username: z.string(),
      global_name: z.union([z.string(), z.null()]).optional(),
      discriminator: z.string(),
      avatar: z.union([z.string(), z.null()]).optional(),
      flags: z.number(),
      bot: z.boolean(),
      avatar_decoration_data: z.union([z.object({ asset: z.string(), skuId: z.string().optional() }), z.null()]).optional(),
      premium_type: z.union([z.number(), z.null()]).optional(),
      nickname: z.string().optional()
    }))
  });
  var Command;
  (function(Command2) {
    Command2["INITIATE_IMAGE_UPLOAD"] = "INITIATE_IMAGE_UPLOAD";
    Command2["OPEN_SHARE_MOMENT_DIALOG"] = "OPEN_SHARE_MOMENT_DIALOG";
    Command2["AUTHENTICATE"] = "AUTHENTICATE";
    Command2["GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS"] = "GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS";
  })(Command || (Command = {}));
  const emptyResponseSchema = z.object({}).optional().nullable();
  const emptyRequestSchema = z.void();
  const Schemas = {
    [Command.INITIATE_IMAGE_UPLOAD]: {
      request: emptyRequestSchema,
      response: InitiateImageUploadResponseSchema
    },
    [Command.OPEN_SHARE_MOMENT_DIALOG]: {
      request: OpenShareMomentDialogRequestSchema,
      response: emptyResponseSchema
    },
    [Command.AUTHENTICATE]: {
      request: AuthenticateRequestSchema,
      response: AuthenticateResponseSchema
    },
    [Command.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS]: {
      request: emptyRequestSchema,
      response: GetActivityInstanceConnectedParticipantsResponseSchema
    }
  };
  const DISPATCH = "DISPATCH";
  var Commands$1;
  (function(Commands2) {
    Commands2["AUTHORIZE"] = "AUTHORIZE";
    Commands2["AUTHENTICATE"] = "AUTHENTICATE";
    Commands2["GET_GUILDS"] = "GET_GUILDS";
    Commands2["GET_GUILD"] = "GET_GUILD";
    Commands2["GET_CHANNEL"] = "GET_CHANNEL";
    Commands2["GET_CHANNELS"] = "GET_CHANNELS";
    Commands2["SELECT_VOICE_CHANNEL"] = "SELECT_VOICE_CHANNEL";
    Commands2["SELECT_TEXT_CHANNEL"] = "SELECT_TEXT_CHANNEL";
    Commands2["SUBSCRIBE"] = "SUBSCRIBE";
    Commands2["UNSUBSCRIBE"] = "UNSUBSCRIBE";
    Commands2["CAPTURE_SHORTCUT"] = "CAPTURE_SHORTCUT";
    Commands2["SET_CERTIFIED_DEVICES"] = "SET_CERTIFIED_DEVICES";
    Commands2["SET_ACTIVITY"] = "SET_ACTIVITY";
    Commands2["GET_SKUS"] = "GET_SKUS";
    Commands2["GET_ENTITLEMENTS"] = "GET_ENTITLEMENTS";
    Commands2["GET_SKUS_EMBEDDED"] = "GET_SKUS_EMBEDDED";
    Commands2["GET_ENTITLEMENTS_EMBEDDED"] = "GET_ENTITLEMENTS_EMBEDDED";
    Commands2["START_PURCHASE"] = "START_PURCHASE";
    Commands2["SET_CONFIG"] = "SET_CONFIG";
    Commands2["SEND_ANALYTICS_EVENT"] = "SEND_ANALYTICS_EVENT";
    Commands2["USER_SETTINGS_GET_LOCALE"] = "USER_SETTINGS_GET_LOCALE";
    Commands2["OPEN_EXTERNAL_LINK"] = "OPEN_EXTERNAL_LINK";
    Commands2["ENCOURAGE_HW_ACCELERATION"] = "ENCOURAGE_HW_ACCELERATION";
    Commands2["CAPTURE_LOG"] = "CAPTURE_LOG";
    Commands2["SET_ORIENTATION_LOCK_STATE"] = "SET_ORIENTATION_LOCK_STATE";
    Commands2["OPEN_INVITE_DIALOG"] = "OPEN_INVITE_DIALOG";
    Commands2["GET_PLATFORM_BEHAVIORS"] = "GET_PLATFORM_BEHAVIORS";
    Commands2["GET_CHANNEL_PERMISSIONS"] = "GET_CHANNEL_PERMISSIONS";
    Commands2["OPEN_SHARE_MOMENT_DIALOG"] = "OPEN_SHARE_MOMENT_DIALOG";
    Commands2["INITIATE_IMAGE_UPLOAD"] = "INITIATE_IMAGE_UPLOAD";
    Commands2["GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS"] = "GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS";
  })(Commands$1 || (Commands$1 = {}));
  const ReceiveFramePayload = objectType({
    cmd: stringType(),
    data: unknownType(),
    evt: nullType(),
    nonce: stringType()
  }).passthrough();
  const ScopesObject = Object.assign(Object.assign({}, AuthenticateResponseSchema.shape.scopes.element.overlayType._def.innerType.options[0].Values), { UNHANDLED: -1 });
  const Scopes = zodCoerceUnhandledValue(ScopesObject);
  const User = objectType({
    id: stringType(),
    username: stringType(),
    discriminator: stringType(),
    global_name: stringType().optional().nullable(),
    avatar: stringType().optional().nullable(),
    avatar_decoration_data: objectType({
      asset: stringType(),
      sku_id: stringType().optional()
    }).nullable(),
    bot: booleanType(),
    flags: numberType().optional().nullable(),
    premium_type: numberType().optional().nullable()
  });
  const GuildMember = objectType({
    user: User,
    nick: stringType().optional().nullable(),
    roles: arrayType(stringType()),
    joined_at: stringType(),
    deaf: booleanType(),
    mute: booleanType()
  });
  const Emoji = objectType({
    id: stringType(),
    name: stringType().optional().nullable(),
    roles: arrayType(stringType()).optional().nullable(),
    user: User.optional().nullable(),
    require_colons: booleanType().optional().nullable(),
    managed: booleanType().optional().nullable(),
    animated: booleanType().optional().nullable(),
    available: booleanType().optional().nullable()
  });
  const VoiceState = objectType({
    mute: booleanType(),
    deaf: booleanType(),
    self_mute: booleanType(),
    self_deaf: booleanType(),
    suppress: booleanType()
  });
  const UserVoiceState = objectType({
    mute: booleanType(),
    nick: stringType(),
    user: User,
    voice_state: VoiceState,
    volume: numberType()
  });
  const StatusObject = {
    UNHANDLED: -1,
    IDLE: "idle",
    DND: "dnd",
    ONLINE: "online",
    OFFLINE: "offline"
  };
  const Status = zodCoerceUnhandledValue(StatusObject);
  const Activity = objectType({
    name: stringType(),
    type: numberType(),
    url: stringType().optional().nullable(),
    created_at: numberType().optional().nullable(),
    timestamps: objectType({
      start: numberType(),
      end: numberType()
    }).partial().optional().nullable(),
    application_id: stringType().optional().nullable(),
    details: stringType().optional().nullable(),
    state: stringType().optional().nullable(),
    emoji: Emoji.optional().nullable(),
    party: objectType({
      id: stringType().optional().nullable(),
      size: arrayType(numberType()).optional().nullable()
    }).optional().nullable(),
    assets: objectType({
      large_image: stringType().nullable(),
      large_text: stringType().nullable(),
      small_image: stringType().nullable(),
      small_text: stringType().nullable()
    }).partial().optional().nullable(),
    secrets: objectType({
      join: stringType(),
      match: stringType()
    }).partial().optional().nullable(),
    instance: booleanType().optional().nullable(),
    flags: numberType().optional().nullable()
  });
  const PermissionOverwriteTypeObject = {
    UNHANDLED: -1,
    ROLE: 0,
    MEMBER: 1
  };
  const PermissionOverwrite = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(PermissionOverwriteTypeObject),
    allow: stringType(),
    deny: stringType()
  });
  const ChannelTypesObject = {
    UNHANDLED: -1,
    DM: 1,
    GROUP_DM: 3,
    GUILD_TEXT: 0,
    GUILD_VOICE: 2,
    GUILD_CATEGORY: 4,
    GUILD_ANNOUNCEMENT: 5,
    GUILD_STORE: 6,
    ANNOUNCEMENT_THREAD: 10,
    PUBLIC_THREAD: 11,
    PRIVATE_THREAD: 12,
    GUILD_STAGE_VOICE: 13,
    GUILD_DIRECTORY: 14,
    GUILD_FORUM: 15
  };
  const Channel = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(ChannelTypesObject),
    guild_id: stringType().optional().nullable(),
    position: numberType().optional().nullable(),
    permission_overwrites: arrayType(PermissionOverwrite).optional().nullable(),
    name: stringType().optional().nullable(),
    topic: stringType().optional().nullable(),
    nsfw: booleanType().optional().nullable(),
    last_message_id: stringType().optional().nullable(),
    bitrate: numberType().optional().nullable(),
    user_limit: numberType().optional().nullable(),
    rate_limit_per_user: numberType().optional().nullable(),
    recipients: arrayType(User).optional().nullable(),
    icon: stringType().optional().nullable(),
    owner_id: stringType().optional().nullable(),
    application_id: stringType().optional().nullable(),
    parent_id: stringType().optional().nullable(),
    last_pin_timestamp: stringType().optional().nullable()
  });
  const PresenceUpdate = objectType({
    user: User,
    guild_id: stringType(),
    status: Status,
    activities: arrayType(Activity),
    client_status: objectType({
      desktop: Status,
      mobile: Status,
      web: Status
    }).partial()
  });
  const Role = objectType({
    id: stringType(),
    name: stringType(),
    color: numberType(),
    hoist: booleanType(),
    position: numberType(),
    permissions: stringType(),
    managed: booleanType(),
    mentionable: booleanType()
  });
  const Guild = objectType({
    id: stringType(),
    name: stringType(),
    owner_id: stringType(),
    icon: stringType().nullable(),
    icon_hash: stringType().optional().nullable(),
    splash: stringType().nullable(),
    discovery_splash: stringType().nullable(),
    owner: booleanType().optional().nullable(),
    permissions: stringType().optional().nullable(),
    region: stringType(),
    afk_channel_id: stringType().nullable(),
    afk_timeout: numberType(),
    widget_enabled: booleanType().optional().nullable(),
    widget_channel_id: stringType().optional().nullable(),
    verification_level: numberType(),
    default_message_notifications: numberType(),
    explicit_content_filter: numberType(),
    roles: arrayType(Role),
    emojis: arrayType(Emoji),
    features: arrayType(stringType()),
    mfa_level: numberType(),
    application_id: stringType().nullable(),
    system_channel_id: stringType().nullable(),
    system_channel_flags: numberType(),
    rules_channel_id: stringType().nullable(),
    joined_at: stringType().optional().nullable(),
    large: booleanType().optional().nullable(),
    unavailable: booleanType().optional().nullable(),
    member_count: numberType().optional().nullable(),
    voice_states: arrayType(VoiceState).optional().nullable(),
    members: arrayType(GuildMember).optional().nullable(),
    channels: arrayType(Channel).optional().nullable(),
    presences: arrayType(PresenceUpdate).optional().nullable(),
    max_presences: numberType().optional().nullable(),
    max_members: numberType().optional().nullable(),
    vanity_url_code: stringType().nullable(),
    description: stringType().nullable(),
    banner: stringType().nullable(),
    premium_tier: numberType(),
    premium_subscription_count: numberType().optional().nullable(),
    preferred_locale: stringType(),
    public_updates_channel_id: stringType().nullable(),
    max_video_channel_users: numberType().optional().nullable(),
    approximate_member_count: numberType().optional().nullable(),
    approximate_presence_count: numberType().optional().nullable()
  });
  const ChannelMention = objectType({
    id: stringType(),
    guild_id: stringType(),
    type: numberType(),
    name: stringType()
  });
  const Attachment = objectType({
    id: stringType(),
    filename: stringType(),
    size: numberType(),
    url: stringType(),
    proxy_url: stringType(),
    height: numberType().optional().nullable(),
    width: numberType().optional().nullable()
  });
  const EmbedFooter = objectType({
    text: stringType(),
    icon_url: stringType().optional().nullable(),
    proxy_icon_url: stringType().optional().nullable()
  });
  const Image = objectType({
    url: stringType().optional().nullable(),
    proxy_url: stringType().optional().nullable(),
    height: numberType().optional().nullable(),
    width: numberType().optional().nullable()
  });
  const Video = Image.omit({ proxy_url: true });
  const EmbedProvider = objectType({
    name: stringType().optional().nullable(),
    url: stringType().optional().nullable()
  });
  const EmbedAuthor = objectType({
    name: stringType().optional().nullable(),
    url: stringType().optional().nullable(),
    icon_url: stringType().optional().nullable(),
    proxy_icon_url: stringType().optional().nullable()
  });
  const EmbedField = objectType({
    name: stringType(),
    value: stringType(),
    inline: booleanType()
  });
  const Embed = objectType({
    title: stringType().optional().nullable(),
    type: stringType().optional().nullable(),
    description: stringType().optional().nullable(),
    url: stringType().optional().nullable(),
    timestamp: stringType().optional().nullable(),
    color: numberType().optional().nullable(),
    footer: EmbedFooter.optional().nullable(),
    image: Image.optional().nullable(),
    thumbnail: Image.optional().nullable(),
    video: Video.optional().nullable(),
    provider: EmbedProvider.optional().nullable(),
    author: EmbedAuthor.optional().nullable(),
    fields: arrayType(EmbedField).optional().nullable()
  });
  const Reaction = objectType({
    count: numberType(),
    me: booleanType(),
    emoji: Emoji
  });
  const MessageActivity = objectType({
    type: numberType(),
    party_id: stringType().optional().nullable()
  });
  const MessageApplication = objectType({
    id: stringType(),
    cover_image: stringType().optional().nullable(),
    description: stringType(),
    icon: stringType().optional().nullable(),
    name: stringType()
  });
  const MessageReference = objectType({
    message_id: stringType().optional().nullable(),
    channel_id: stringType().optional().nullable(),
    guild_id: stringType().optional().nullable()
  });
  const Message = objectType({
    id: stringType(),
    channel_id: stringType(),
    guild_id: stringType().optional().nullable(),
    author: User.optional().nullable(),
    member: GuildMember.optional().nullable(),
    content: stringType(),
    timestamp: stringType(),
    edited_timestamp: stringType().optional().nullable(),
    tts: booleanType(),
    mention_everyone: booleanType(),
    mentions: arrayType(User),
    mention_roles: arrayType(stringType()),
    mention_channels: arrayType(ChannelMention),
    attachments: arrayType(Attachment),
    embeds: arrayType(Embed),
    reactions: arrayType(Reaction).optional().nullable(),
    nonce: unionType([stringType(), numberType()]).optional().nullable(),
    pinned: booleanType(),
    webhook_id: stringType().optional().nullable(),
    type: numberType(),
    activity: MessageActivity.optional().nullable(),
    application: MessageApplication.optional().nullable(),
    message_reference: MessageReference.optional().nullable(),
    flags: numberType().optional().nullable(),
    stickers: arrayType(unknownType()).optional().nullable(),
    // Cannot self reference, but this is possibly a Message
    referenced_message: unknownType().optional().nullable()
  });
  const VoiceDevice = objectType({
    id: stringType(),
    name: stringType()
  });
  const KeyTypesObject = {
    UNHANDLED: -1,
    KEYBOARD_KEY: 0,
    MOUSE_BUTTON: 1,
    KEYBOARD_MODIFIER_KEY: 2,
    GAMEPAD_BUTTON: 3
  };
  const ShortcutKey = objectType({
    type: zodCoerceUnhandledValue(KeyTypesObject),
    code: numberType(),
    name: stringType()
  });
  const VoiceSettingModeTypeObject = {
    UNHANDLED: -1,
    PUSH_TO_TALK: "PUSH_TO_TALK",
    VOICE_ACTIVITY: "VOICE_ACTIVITY"
  };
  const VoiceSettingsMode = objectType({
    type: zodCoerceUnhandledValue(VoiceSettingModeTypeObject),
    auto_threshold: booleanType(),
    threshold: numberType(),
    shortcut: arrayType(ShortcutKey),
    delay: numberType()
  });
  const VoiceSettingsIO = objectType({
    device_id: stringType(),
    volume: numberType(),
    available_devices: arrayType(VoiceDevice)
  });
  const CertifiedDeviceTypeObject = {
    UNHANDLED: -1,
    AUDIO_INPUT: "AUDIO_INPUT",
    AUDIO_OUTPUT: "AUDIO_OUTPUT",
    VIDEO_INPUT: "VIDEO_INPUT"
  };
  const CertifiedDevice = objectType({
    type: zodCoerceUnhandledValue(CertifiedDeviceTypeObject),
    id: stringType(),
    vendor: objectType({
      name: stringType(),
      url: stringType()
    }),
    model: objectType({
      name: stringType(),
      url: stringType()
    }),
    related: arrayType(stringType()),
    echo_cancellation: booleanType().optional().nullable(),
    noise_suppression: booleanType().optional().nullable(),
    automatic_gain_control: booleanType().optional().nullable(),
    hardware_mute: booleanType().optional().nullable()
  });
  const SkuTypeObject = {
    UNHANDLED: -1,
    APPLICATION: 1,
    DLC: 2,
    CONSUMABLE: 3,
    BUNDLE: 4,
    SUBSCRIPTION: 5
  };
  const Sku = objectType({
    id: stringType(),
    name: stringType(),
    type: zodCoerceUnhandledValue(SkuTypeObject),
    price: objectType({
      amount: numberType(),
      currency: stringType()
    }),
    application_id: stringType(),
    flags: numberType(),
    release_date: stringType().nullable()
  });
  const EntitlementTypesObject = {
    UNHANDLED: -1,
    PURCHASE: 1,
    PREMIUM_SUBSCRIPTION: 2,
    DEVELOPER_GIFT: 3,
    TEST_MODE_PURCHASE: 4,
    FREE_PURCHASE: 5,
    USER_GIFT: 6,
    PREMIUM_PURCHASE: 7
  };
  const Entitlement = objectType({
    id: stringType(),
    sku_id: stringType(),
    application_id: stringType(),
    user_id: stringType(),
    gift_code_flags: numberType(),
    type: zodCoerceUnhandledValue(EntitlementTypesObject),
    gifter_user_id: stringType().optional().nullable(),
    branches: arrayType(stringType()).optional().nullable(),
    starts_at: stringType().optional().nullable(),
    ends_at: stringType().optional().nullable(),
    parent_id: stringType().optional().nullable(),
    consumed: booleanType().optional().nullable(),
    deleted: booleanType().optional().nullable(),
    gift_code_batch_id: stringType().optional().nullable()
  });
  const OrientationLockStateTypeObject = {
    UNHANDLED: -1,
    UNLOCKED: 1,
    PORTRAIT: 2,
    LANDSCAPE: 3
  };
  const OrientationLockState = zodCoerceUnhandledValue(OrientationLockStateTypeObject);
  const ThermalStateTypeObject = {
    UNHANDLED: -1,
    NOMINAL: 0,
    FAIR: 1,
    SERIOUS: 2,
    CRITICAL: 3
  };
  const ThermalState = zodCoerceUnhandledValue(ThermalStateTypeObject);
  const OrientationTypeObject = {
    UNHANDLED: -1,
    PORTRAIT: 0,
    LANDSCAPE: 1
  };
  const Orientation = zodCoerceUnhandledValue(OrientationTypeObject);
  const LayoutModeTypeObject = {
    UNHANDLED: -1,
    FOCUSED: 0,
    PIP: 1,
    GRID: 2
  };
  const LayoutMode = zodCoerceUnhandledValue(LayoutModeTypeObject);
  const common = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Activity,
    Attachment,
    CertifiedDevice,
    CertifiedDeviceTypeObject,
    Channel,
    ChannelMention,
    ChannelTypesObject,
    get Commands() {
      return Commands$1;
    },
    DISPATCH,
    Embed,
    EmbedAuthor,
    EmbedField,
    EmbedFooter,
    EmbedProvider,
    Emoji,
    Entitlement,
    EntitlementTypesObject,
    Guild,
    GuildMember,
    Image,
    KeyTypesObject,
    LayoutMode,
    LayoutModeTypeObject,
    Message,
    MessageActivity,
    MessageApplication,
    MessageReference,
    Orientation,
    OrientationLockState,
    OrientationLockStateTypeObject,
    OrientationTypeObject,
    PermissionOverwrite,
    PermissionOverwriteTypeObject,
    PresenceUpdate,
    Reaction,
    ReceiveFramePayload,
    Role,
    Scopes,
    ScopesObject,
    ShortcutKey,
    Sku,
    SkuTypeObject,
    Status,
    StatusObject,
    ThermalState,
    ThermalStateTypeObject,
    User,
    UserVoiceState,
    Video,
    VoiceDevice,
    VoiceSettingModeTypeObject,
    VoiceSettingsIO,
    VoiceSettingsMode,
    VoiceState
  }, Symbol.toStringTag, { value: "Module" }));
  const ERROR = "ERROR";
  var Events;
  (function(Events2) {
    Events2["READY"] = "READY";
    Events2["VOICE_STATE_UPDATE"] = "VOICE_STATE_UPDATE";
    Events2["SPEAKING_START"] = "SPEAKING_START";
    Events2["SPEAKING_STOP"] = "SPEAKING_STOP";
    Events2["ACTIVITY_LAYOUT_MODE_UPDATE"] = "ACTIVITY_LAYOUT_MODE_UPDATE";
    Events2["ORIENTATION_UPDATE"] = "ORIENTATION_UPDATE";
    Events2["CURRENT_USER_UPDATE"] = "CURRENT_USER_UPDATE";
    Events2["ENTITLEMENT_CREATE"] = "ENTITLEMENT_CREATE";
    Events2["THERMAL_STATE_UPDATE"] = "THERMAL_STATE_UPDATE";
    Events2["ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE"] = "ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE";
  })(Events || (Events = {}));
  const DispatchEventFrame = ReceiveFramePayload.extend({
    evt: nativeEnumType(Events),
    nonce: stringType().nullable(),
    cmd: literalType(DISPATCH),
    data: objectType({}).passthrough()
  });
  const ErrorEvent = ReceiveFramePayload.extend({
    evt: literalType(ERROR),
    data: objectType({
      code: numberType(),
      message: stringType().optional()
    }).passthrough(),
    cmd: nativeEnumType(Commands$1),
    nonce: stringType().nullable()
  });
  const OtherEvent = DispatchEventFrame.extend({
    evt: stringType()
  });
  const EventFrame = unionType([DispatchEventFrame, OtherEvent, ErrorEvent]);
  function parseEventPayload(data) {
    const event = data.evt;
    if (!(event in Events)) {
      throw new Error(`Unrecognized event type ${data.evt}`);
    }
    const eventSchema = EventSchema[event];
    return eventSchema.payload.parse(data);
  }
  const EventSchema = {
    /**
     * @description
     * The READY event is emitted by Discord's RPC server in reply to a client
     * initiating the RPC handshake. The event includes information about
     * - the rpc server version
     * - the discord client configuration
     * - the (basic) user object
     *
     * Unlike other events, READY will only be omitted once, immediately after the
     * Embedded App SDK is initialized
     *
     * # Supported Platforms
     * | Web | iOS | Android |
     * |-----|-----|---------|
     * |   |   |       |
     *
     * Required scopes: []
     *
     */
    [Events.READY]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.READY),
        data: objectType({
          v: numberType(),
          config: objectType({
            cdn_host: stringType().optional(),
            api_endpoint: stringType(),
            environment: stringType()
          }),
          user: objectType({
            id: stringType(),
            username: stringType(),
            discriminator: stringType(),
            avatar: stringType().optional()
          }).optional()
        })
      })
    },
    [Events.VOICE_STATE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.VOICE_STATE_UPDATE),
        data: UserVoiceState
      }),
      subscribeArgs: objectType({
        channel_id: stringType()
      })
    },
    [Events.SPEAKING_START]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.SPEAKING_START),
        data: objectType({
          lobby_id: stringType().optional(),
          channel_id: stringType().optional(),
          user_id: stringType()
        })
      }),
      subscribeArgs: objectType({
        lobby_id: stringType().nullable().optional(),
        channel_id: stringType().nullable().optional()
      })
    },
    [Events.SPEAKING_STOP]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.SPEAKING_STOP),
        data: objectType({
          lobby_id: stringType().optional(),
          channel_id: stringType().optional(),
          user_id: stringType()
        })
      }),
      subscribeArgs: objectType({
        lobby_id: stringType().nullable().optional(),
        channel_id: stringType().nullable().optional()
      })
    },
    [Events.ACTIVITY_LAYOUT_MODE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ACTIVITY_LAYOUT_MODE_UPDATE),
        data: objectType({
          layout_mode: zodCoerceUnhandledValue(LayoutModeTypeObject)
        })
      })
    },
    [Events.ORIENTATION_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ORIENTATION_UPDATE),
        data: objectType({
          screen_orientation: zodCoerceUnhandledValue(OrientationTypeObject),
          /**
           * @deprecated use screen_orientation instead
           */
          orientation: nativeEnumType(Orientation$1)
        })
      })
    },
    [Events.CURRENT_USER_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.CURRENT_USER_UPDATE),
        data: User
      })
    },
    [Events.ENTITLEMENT_CREATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ENTITLEMENT_CREATE),
        data: objectType({ entitlement: Entitlement })
      })
    },
    [Events.THERMAL_STATE_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.THERMAL_STATE_UPDATE),
        data: objectType({ thermal_state: ThermalState })
      })
    },
    [Events.ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE]: {
      payload: DispatchEventFrame.extend({
        evt: literalType(Events.ACTIVITY_INSTANCE_PARTICIPANTS_UPDATE),
        data: objectType({
          participants: GetActivityInstanceConnectedParticipantsResponseSchema.shape.participants
        })
      })
    }
  };
  function assertUnreachable(_x2, runtimeError) {
    throw runtimeError;
  }
  const EmptyResponse = objectType({}).nullable();
  const AuthorizeResponse = objectType({
    code: stringType()
  });
  const GetGuildsResponse = objectType({
    guilds: arrayType(objectType({
      id: stringType(),
      name: stringType()
    }))
  });
  const GetGuildResponse = objectType({
    id: stringType(),
    name: stringType(),
    icon_url: stringType().optional(),
    members: arrayType(GuildMember)
  });
  const GetChannelResponse = objectType({
    id: stringType(),
    type: zodCoerceUnhandledValue(ChannelTypesObject),
    guild_id: stringType().optional().nullable(),
    name: stringType().optional().nullable(),
    topic: stringType().optional().nullable(),
    bitrate: numberType().optional().nullable(),
    user_limit: numberType().optional().nullable(),
    position: numberType().optional().nullable(),
    voice_states: arrayType(UserVoiceState),
    messages: arrayType(Message)
  });
  const GetChannelsResponse = objectType({
    channels: arrayType(Channel)
  });
  const NullableChannelResponse = GetChannelResponse.nullable();
  const SelectVoiceChannelResponse = GetChannelResponse.nullable();
  const SelectTextChannelResponse = GetChannelResponse.nullable();
  const VoiceSettingsResponse = objectType({
    input: VoiceSettingsIO,
    output: VoiceSettingsIO,
    mode: VoiceSettingsMode,
    automatic_gain_control: booleanType(),
    echo_cancellation: booleanType(),
    noise_suppression: booleanType(),
    qos: booleanType(),
    silence_warning: booleanType(),
    deaf: booleanType(),
    mute: booleanType()
  });
  const SubscribeResponse = objectType({
    evt: stringType()
  });
  const CaptureShortcutResponse = objectType({ shortcut: ShortcutKey });
  const SetActivityResponse = Activity;
  const GetSkusResponse = objectType({ skus: arrayType(Sku) });
  const GetEntitlementsResponse = objectType({ entitlements: arrayType(Entitlement) });
  const StartPurchaseResponse = arrayType(Entitlement).nullable();
  const SetConfigResponse = objectType({
    use_interactive_pip: booleanType()
  });
  const UserSettingsGetLocaleResponse = objectType({
    locale: stringType()
  });
  const EncourageHardwareAccelerationResponse = objectType({
    enabled: booleanType()
  });
  const GetChannelPermissionsResponse = objectType({
    permissions: bigIntType().or(stringType())
  });
  const GetPlatformBehaviorsResponse = objectType({
    iosKeyboardResizesView: optionalType(booleanType())
  });
  const ResponseFrame = ReceiveFramePayload.extend({
    cmd: nativeEnumType(Commands$1),
    evt: nullType()
  });
  function parseResponseData({ cmd, data }) {
    switch (cmd) {
      case Commands$1.AUTHORIZE:
        return AuthorizeResponse.parse(data);
      case Commands$1.CAPTURE_SHORTCUT:
        return CaptureShortcutResponse.parse(data);
      case Commands$1.ENCOURAGE_HW_ACCELERATION:
        return EncourageHardwareAccelerationResponse.parse(data);
      case Commands$1.GET_CHANNEL:
        return GetChannelResponse.parse(data);
      case Commands$1.GET_CHANNELS:
        return GetChannelsResponse.parse(data);
      case Commands$1.GET_CHANNEL_PERMISSIONS:
        return GetChannelPermissionsResponse.parse(data);
      case Commands$1.GET_GUILD:
        return GetGuildResponse.parse(data);
      case Commands$1.GET_GUILDS:
        return GetGuildsResponse.parse(data);
      case Commands$1.GET_PLATFORM_BEHAVIORS:
        return GetPlatformBehaviorsResponse.parse(data);
      case Commands$1.GET_CHANNEL:
        return GetChannelResponse.parse(data);
      case Commands$1.SELECT_TEXT_CHANNEL:
        return SelectTextChannelResponse.parse(data);
      case Commands$1.SELECT_VOICE_CHANNEL:
        return SelectVoiceChannelResponse.parse(data);
      case Commands$1.SET_ACTIVITY:
        return SetActivityResponse.parse(data);
      case Commands$1.GET_SKUS_EMBEDDED:
        return GetSkusResponse.parse(data);
      case Commands$1.GET_ENTITLEMENTS_EMBEDDED:
        return GetEntitlementsResponse.parse(data);
      case Commands$1.SET_CONFIG:
        return SetConfigResponse.parse(data);
      case Commands$1.START_PURCHASE:
        return StartPurchaseResponse.parse(data);
      case Commands$1.SUBSCRIBE:
      case Commands$1.UNSUBSCRIBE:
        return SubscribeResponse.parse(data);
      case Commands$1.USER_SETTINGS_GET_LOCALE:
        return UserSettingsGetLocaleResponse.parse(data);
      case Commands$1.OPEN_EXTERNAL_LINK:
      case Commands$1.SET_ORIENTATION_LOCK_STATE:
      case Commands$1.SET_CERTIFIED_DEVICES:
      case Commands$1.SEND_ANALYTICS_EVENT:
      case Commands$1.OPEN_INVITE_DIALOG:
      case Commands$1.CAPTURE_LOG:
      case Commands$1.GET_SKUS:
      case Commands$1.GET_ENTITLEMENTS:
        return EmptyResponse.parse(data);
      case Commands$1.AUTHENTICATE:
      case Commands$1.INITIATE_IMAGE_UPLOAD:
      case Commands$1.OPEN_SHARE_MOMENT_DIALOG:
      case Commands$1.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS:
        const { response } = Schemas[cmd];
        return response.parse(data);
      default:
        assertUnreachable(cmd, new Error(`Unrecognized command ${cmd}`));
    }
  }
  function parseResponsePayload(payload) {
    return Object.assign(Object.assign({}, payload), { data: parseResponseData(payload) });
  }
  const responses = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AuthenticateResponse: AuthenticateResponseSchema,
    AuthorizeResponse,
    CaptureShortcutResponse,
    EmptyResponse,
    EncourageHardwareAccelerationResponse,
    GetChannelPermissionsResponse,
    GetChannelResponse,
    GetChannelsResponse,
    GetEntitlementsResponse,
    GetGuildResponse,
    GetGuildsResponse,
    GetPlatformBehaviorsResponse,
    GetSkusResponse,
    InitiateImageUploadResponse: InitiateImageUploadResponseSchema,
    NullableChannelResponse,
    ResponseFrame,
    SelectTextChannelResponse,
    SelectVoiceChannelResponse,
    SetActivityResponse,
    SetConfigResponse,
    StartPurchaseResponse,
    SubscribeResponse,
    UserSettingsGetLocaleResponse,
    VoiceSettingsResponse,
    parseResponsePayload
  }, Symbol.toStringTag, { value: "Module" }));
  objectType({
    frame_id: stringType(),
    platform: nativeEnumType(Platform).optional().nullable()
  });
  objectType({
    v: literalType(1),
    encoding: literalType("json").optional(),
    client_id: stringType(),
    frame_id: stringType()
  });
  const ClosePayload = objectType({
    code: numberType(),
    message: stringType().optional()
  });
  const IncomingPayload = objectType({
    evt: stringType().nullable(),
    nonce: stringType().nullable(),
    data: unknownType().nullable(),
    cmd: stringType()
  }).passthrough();
  function parseIncomingPayload(payload) {
    const incoming = IncomingPayload.parse(payload);
    if (incoming.evt != null) {
      if (incoming.evt === ERROR) {
        return ErrorEvent.parse(incoming);
      }
      return parseEventPayload(EventFrame.parse(incoming));
    } else {
      return parseResponsePayload(ResponseFrame.passthrough().parse(incoming));
    }
  }
  function commandFactory(sendCommand, cmd, response, transferTransform = () => void 0) {
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return async (args) => {
      const reply = await sendCommand({ cmd, args, transfer: transferTransform(args) });
      const parsed = payload.parse(reply);
      return parsed.data;
    };
  }
  function schemaCommandFactory(cmd, transferTransform = () => void 0) {
    const response = Schemas[cmd].response;
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return (sendCommand) => async (args) => {
      const reply = await sendCommand({
        // @ts-expect-error - Merge commands
        cmd,
        args,
        transfer: transferTransform(args)
      });
      const parsed = payload.parse(reply);
      return parsed.data;
    };
  }
  const authenticate = schemaCommandFactory(Command.AUTHENTICATE);
  const authorize = (sendCommand) => commandFactory(sendCommand, Commands$1.AUTHORIZE, AuthorizeResponse);
  const captureLog = (sendCommand) => commandFactory(sendCommand, Commands$1.CAPTURE_LOG, EmptyResponse);
  const encourageHardwareAcceleration = (sendCommand) => commandFactory(sendCommand, Commands$1.ENCOURAGE_HW_ACCELERATION, EncourageHardwareAccelerationResponse);
  const getEntitlements = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_ENTITLEMENTS_EMBEDDED, GetEntitlementsResponse);
  const getSkus = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_SKUS_EMBEDDED, GetSkusResponse);
  const getChannelPermissions = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_CHANNEL_PERMISSIONS, GetChannelPermissionsResponse);
  const getPlatformBehaviors = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_PLATFORM_BEHAVIORS, GetPlatformBehaviorsResponse);
  const openExternalLink = (sendCommand) => commandFactory(sendCommand, Commands$1.OPEN_EXTERNAL_LINK, EmptyResponse);
  const openInviteDialog = (sendCommand) => commandFactory(sendCommand, Commands$1.OPEN_INVITE_DIALOG, EmptyResponse);
  const openShareMomentDialog = schemaCommandFactory(Command.OPEN_SHARE_MOMENT_DIALOG);
  Activity.pick({
    state: true,
    details: true,
    timestamps: true,
    assets: true,
    party: true,
    secrets: true,
    buttons: true,
    instance: true,
    supported_platforms: true,
    type: true
  }).extend({
    type: Activity.shape.type.optional(),
    instance: Activity.shape.instance.optional()
  }).nullable();
  const setActivity = (sendCommand) => commandFactory(sendCommand, Commands$1.SET_ACTIVITY, SetActivityResponse);
  const setConfig = (sendCommand) => commandFactory(sendCommand, Commands$1.SET_CONFIG, SetConfigResponse);
  function compatCommandFactory({ sendCommand, cmd, response, fallbackTransform: fallbackTransform2, transferTransform = () => void 0 }) {
    const payload = ReceiveFramePayload.extend({
      cmd: literalType(cmd),
      data: response
    });
    return async (args) => {
      try {
        const reply = await sendCommand({ cmd, args, transfer: transferTransform(args) });
        const parsed = payload.parse(reply);
        return parsed.data;
      } catch (error) {
        if (error.code === RPCErrorCodes.INVALID_PAYLOAD) {
          const fallbackArgs = fallbackTransform2(args);
          const reply = await sendCommand({ cmd, args: fallbackArgs, transfer: transferTransform(fallbackArgs) });
          const parsed = payload.parse(reply);
          return parsed.data;
        } else {
          throw error;
        }
      }
    };
  }
  const fallbackTransform = (args) => {
    return {
      lock_state: args.lock_state,
      picture_in_picture_lock_state: args.picture_in_picture_lock_state
    };
  };
  const setOrientationLockState = (sendCommand) => compatCommandFactory({
    sendCommand,
    cmd: Commands$1.SET_ORIENTATION_LOCK_STATE,
    response: EmptyResponse,
    fallbackTransform
  });
  const startPurchase = (sendCommand) => commandFactory(sendCommand, Commands$1.START_PURCHASE, StartPurchaseResponse);
  const userSettingsGetLocale = (sendCommand) => commandFactory(sendCommand, Commands$1.USER_SETTINGS_GET_LOCALE, UserSettingsGetLocaleResponse);
  const initiateImageUpload = schemaCommandFactory(Command.INITIATE_IMAGE_UPLOAD);
  const getChannel = (sendCommand) => commandFactory(sendCommand, Commands$1.GET_CHANNEL, GetChannelResponse);
  const getInstanceConnectedParticipants = schemaCommandFactory(Command.GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS);
  function commands(sendCommand) {
    return {
      authenticate: authenticate(sendCommand),
      authorize: authorize(sendCommand),
      captureLog: captureLog(sendCommand),
      encourageHardwareAcceleration: encourageHardwareAcceleration(sendCommand),
      getChannel: getChannel(sendCommand),
      getChannelPermissions: getChannelPermissions(sendCommand),
      getEntitlements: getEntitlements(sendCommand),
      getPlatformBehaviors: getPlatformBehaviors(sendCommand),
      getSkus: getSkus(sendCommand),
      openExternalLink: openExternalLink(sendCommand),
      openInviteDialog: openInviteDialog(sendCommand),
      openShareMomentDialog: openShareMomentDialog(sendCommand),
      setActivity: setActivity(sendCommand),
      setConfig: setConfig(sendCommand),
      setOrientationLockState: setOrientationLockState(sendCommand),
      startPurchase: startPurchase(sendCommand),
      userSettingsGetLocale: userSettingsGetLocale(sendCommand),
      initiateImageUpload: initiateImageUpload(sendCommand),
      getInstanceConnectedParticipants: getInstanceConnectedParticipants(sendCommand)
    };
  }
  class SDKError extends Error {
    constructor(code, message = "") {
      super(message);
      this.code = code;
      this.message = message;
      this.name = "Discord SDK Error";
    }
  }
  function getDefaultSdkConfiguration() {
    return {
      disableConsoleLogOverride: false
    };
  }
  const consoleLevels = ["log", "warn", "debug", "info", "error"];
  function wrapConsoleMethod(console2, level, callback) {
    const _consoleMethod = console2[level];
    const _console = console2;
    if (!_consoleMethod) {
      return;
    }
    console2[level] = function() {
      const args = [].slice.call(arguments);
      const message = "" + args.join(" ");
      callback(level, message);
      _consoleMethod.apply(_console, args);
    };
  }
  const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native = {
    randomUUID
  };
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
  }
  var Opcodes;
  (function(Opcodes2) {
    Opcodes2[Opcodes2["HANDSHAKE"] = 0] = "HANDSHAKE";
    Opcodes2[Opcodes2["FRAME"] = 1] = "FRAME";
    Opcodes2[Opcodes2["CLOSE"] = 2] = "CLOSE";
    Opcodes2[Opcodes2["HELLO"] = 3] = "HELLO";
  })(Opcodes || (Opcodes = {}));
  const ALLOWED_ORIGINS = new Set(getAllowedOrigins());
  function getAllowedOrigins() {
    if (typeof window === "undefined")
      return [];
    return [
      window.location.origin,
      "https://discord.com",
      "https://discordapp.com",
      "https://ptb.discord.com",
      "https://ptb.discordapp.com",
      "https://canary.discord.com",
      "https://canary.discordapp.com",
      "https://staging.discord.co",
      "http://localhost:3333",
      "https://pax.discord.com",
      "null"
    ];
  }
  function getRPCServerSource() {
    var _a2;
    return [(_a2 = window.parent.opener) !== null && _a2 !== void 0 ? _a2 : window.parent, !!document.referrer ? document.referrer : "*"];
  }
  class DiscordSDK {
    getTransfer(payload) {
      var _a2;
      switch (payload.cmd) {
        case Commands$1.SUBSCRIBE:
        case Commands$1.UNSUBSCRIBE:
          return void 0;
        default:
          return (_a2 = payload.transfer) !== null && _a2 !== void 0 ? _a2 : void 0;
      }
    }
    constructor(clientId, configuration) {
      this.source = null;
      this.sourceOrigin = "";
      this.eventBus = new EventEmitter();
      this.pendingCommands = /* @__PURE__ */ new Map();
      this.sendCommand = (payload) => {
        var _a2;
        if (this.source == null)
          throw new Error("Attempting to send message before initialization");
        const nonce = v4();
        (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([Opcodes.FRAME, Object.assign(Object.assign({}, payload), { nonce })], this.sourceOrigin, this.getTransfer(payload));
        const promise = new Promise((resolve, reject) => {
          this.pendingCommands.set(nonce, { resolve, reject });
        });
        return promise;
      };
      this.commands = commands(this.sendCommand);
      this.handleMessage = (event) => {
        if (!ALLOWED_ORIGINS.has(event.origin))
          return;
        const tuple = event.data;
        if (!Array.isArray(tuple)) {
          return;
        }
        const [opcode, data] = tuple;
        switch (opcode) {
          case Opcodes.HELLO:
            return;
          case Opcodes.CLOSE:
            return this.handleClose(data);
          case Opcodes.HANDSHAKE:
            return this.handleHandshake();
          case Opcodes.FRAME:
            return this.handleFrame(data);
          default:
            throw new Error("Invalid message format");
        }
      };
      this.isReady = false;
      this.clientId = clientId;
      this.configuration = configuration !== null && configuration !== void 0 ? configuration : getDefaultSdkConfiguration();
      if (typeof window !== "undefined") {
        window.addEventListener("message", this.handleMessage);
      }
      if (typeof window === "undefined") {
        this.frameId = "";
        this.instanceId = "";
        this.platform = Platform.DESKTOP;
        this.guildId = null;
        this.channelId = null;
        return;
      }
      const urlParams = new URLSearchParams(this._getSearch());
      const frameId = urlParams.get("frame_id");
      if (!frameId) {
        throw new Error("frame_id query param is not defined");
      }
      this.frameId = frameId;
      const instanceId = urlParams.get("instance_id");
      if (!instanceId) {
        throw new Error("instance_id query param is not defined");
      }
      this.instanceId = instanceId;
      const platform = urlParams.get("platform");
      if (!platform) {
        throw new Error("platform query param is not defined");
      } else if (platform !== Platform.DESKTOP && platform !== Platform.MOBILE) {
        throw new Error(`Invalid query param "platform" of "${platform}". Valid values are "${Platform.DESKTOP}" or "${Platform.MOBILE}"`);
      }
      this.platform = platform;
      this.guildId = urlParams.get("guild_id");
      this.channelId = urlParams.get("channel_id");
      [this.source, this.sourceOrigin] = getRPCServerSource();
      this.addOnReadyListener();
      this.handshake();
    }
    close(code, message) {
      var _a2;
      window.removeEventListener("message", this.handleMessage);
      const nonce = v4();
      (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([Opcodes.CLOSE, { code, message, nonce }], this.sourceOrigin);
    }
    async subscribe(event, listener, ...rest) {
      const [subscribeArgs] = rest;
      const listenerCount = this.eventBus.listenerCount(event);
      const emitter = this.eventBus.on(event, listener);
      if (Object.values(Events).includes(event) && event !== Events.READY && listenerCount === 0) {
        await this.sendCommand({
          cmd: Commands$1.SUBSCRIBE,
          args: subscribeArgs,
          evt: event
        });
      }
      return emitter;
    }
    async unsubscribe(event, listener, ...rest) {
      const [unsubscribeArgs] = rest;
      if (event !== Events.READY && this.eventBus.listenerCount(event) === 1) {
        await this.sendCommand({
          cmd: Commands$1.UNSUBSCRIBE,
          evt: event,
          args: unsubscribeArgs
        });
      }
      return this.eventBus.off(event, listener);
    }
    async ready() {
      if (this.isReady) {
        return;
      } else {
        await new Promise((resolve) => {
          this.eventBus.once(Events.READY, resolve);
        });
      }
    }
    handshake() {
      var _a2;
      (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.postMessage([
        Opcodes.HANDSHAKE,
        {
          v: 1,
          encoding: "json",
          client_id: this.clientId,
          frame_id: this.frameId
        }
      ], this.sourceOrigin);
    }
    addOnReadyListener() {
      this.eventBus.once(Events.READY, () => {
        this.overrideConsoleLogging();
        this.isReady = true;
      });
    }
    overrideConsoleLogging() {
      if (this.configuration.disableConsoleLogOverride)
        return;
      const sendCaptureLogCommand = (level, message) => {
        this.commands.captureLog({
          level,
          message
        });
      };
      consoleLevels.forEach((level) => {
        wrapConsoleMethod(console, level, sendCaptureLogCommand);
      });
    }
    handleClose(data) {
      ClosePayload.parse(data);
    }
    handleHandshake() {
    }
    handleFrame(payload) {
      var _a2, _b2;
      let parsed;
      try {
        parsed = parseIncomingPayload(payload);
      } catch (e) {
        console.error("Failed to parse", payload);
        console.error(e);
        return;
      }
      if (parsed.cmd === "DISPATCH") {
        this.eventBus.emit(parsed.evt, parsed.data);
      } else {
        if (parsed.evt === ERROR) {
          if (parsed.nonce != null) {
            (_a2 = this.pendingCommands.get(parsed.nonce)) === null || _a2 === void 0 ? void 0 : _a2.reject(parsed.data);
            this.pendingCommands.delete(parsed.nonce);
            return;
          }
          this.eventBus.emit("error", new SDKError(parsed.data.code, parsed.data.message));
        }
        if (parsed.nonce == null) {
          console.error("Missing nonce", payload);
          return;
        }
        (_b2 = this.pendingCommands.get(parsed.nonce)) === null || _b2 === void 0 ? void 0 : _b2.resolve(parsed);
        this.pendingCommands.delete(parsed.nonce);
      }
    }
    _getSearch() {
      return typeof window === "undefined" ? "" : window.location.search;
    }
  }
  function can(permission, permissions) {
    return BigFlagUtils.has(BigFlagUtils.deserialize(permissions), permission);
  }
  var PermissionUtils = {
    can
  };
  var MAX_DIGITS = 1e9, defaults = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed during run-time using `Decimal.config`.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
    // `toFixed`, `toPrecision` and `toSignificantDigits`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -MAX_E
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to MAX_E
    // The natural logarithm of 10.
    // 115 digits
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
  }, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s)
      x.s = 1;
    return x;
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this;
    y = new x.constructor(y);
    if (x.s !== y.s)
      return x.s || -y.s;
    if (x.e !== y.e)
      return x.e > y.e ^ x.s < 0 ? 1 : -1;
    xdL = x.d.length;
    ydL = y.d.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (x.d[i] !== y.d[i])
        return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
  };
  P.decimalPlaces = P.dp = function() {
    var x = this, w = x.d.length - 1, dp2 = (w - x.e) * LOG_BASE;
    w = x.d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        dp2--;
    return dp2 < 0 ? 0 : dp2;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.idiv = function(y) {
    var x = this, Ctor = x.constructor;
    return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
  };
  P.equals = P.eq = function(y) {
    return !this.cmp(y);
  };
  P.exponent = function() {
    return getBase10Exponent(this);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    return this.cmp(y) >= 0;
  };
  P.isInteger = P.isint = function() {
    return this.e > this.d.length - 2;
  };
  P.isNegative = P.isneg = function() {
    return this.s < 0;
  };
  P.isPositive = P.ispos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return this.s === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var r, x = this, Ctor = x.constructor, pr2 = Ctor.precision, wpr = pr2 + 5;
    if (base === void 0) {
      base = new Ctor(10);
    } else {
      base = new Ctor(base);
      if (base.s < 1 || base.eq(ONE))
        throw Error(decimalError + "NaN");
    }
    if (x.s < 1)
      throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
    if (x.eq(ONE))
      return new Ctor(0);
    external = false;
    r = divide(ln(x, wpr), ln(base, wpr), wpr);
    external = true;
    return round(r, pr2);
  };
  P.minus = P.sub = function(y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor, pr2 = Ctor.precision;
    y = new Ctor(y);
    if (!y.s)
      throw Error(decimalError + "NaN");
    if (!x.s)
      return round(new Ctor(x), pr2);
    external = false;
    q = divide(x, y, 0, 1).times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return exp(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return ln(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s || 0;
    return x;
  };
  P.plus = P.add = function(y) {
    var x = this;
    y = new x.constructor(y);
    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
  };
  P.precision = P.sd = function(z10) {
    var e, sd2, w, x = this;
    if (z10 !== void 0 && z10 !== !!z10 && z10 !== 1 && z10 !== 0)
      throw Error(invalidArgument + z10);
    e = getBase10Exponent(x) + 1;
    w = x.d.length - 1;
    sd2 = w * LOG_BASE + 1;
    w = x.d[w];
    if (w) {
      for (; w % 10 == 0; w /= 10)
        sd2--;
      for (w = x.d[0]; w >= 10; w /= 10)
        sd2++;
    }
    return z10 && e > sd2 ? e : sd2;
  };
  P.squareRoot = P.sqrt = function() {
    var e, n, pr2, r, s, t, wpr, x = this, Ctor = x.constructor;
    if (x.s < 1) {
      if (!x.s)
        return new Ctor(0);
      throw Error(decimalError + "NaN");
    }
    e = getBase10Exponent(x);
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(x.d);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "1e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    pr2 = Ctor.precision;
    s = wpr = pr2 + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, wpr + 2)).times(0.5);
      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
        n = n.slice(wpr - 3, wpr + 1);
        if (s == wpr && n == "4999") {
          round(t, pr2 + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        } else if (n != "9999") {
          break;
        }
        wpr += 4;
      }
    }
    external = true;
    return round(r, pr2);
  };
  P.times = P.mul = function(y) {
    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd2 = x.d, yd2 = (y = new Ctor(y)).d;
    if (!x.s || !y.s)
      return new Ctor(0);
    y.s *= x.s;
    e = x.e + y.e;
    xdL = xd2.length;
    ydL = yd2.length;
    if (xdL < ydL) {
      r = xd2;
      xd2 = yd2;
      yd2 = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; )
      r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd2[i] * xd2[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; )
      r.pop();
    if (carry)
      ++e;
    else
      r.shift();
    y.d = r;
    y.e = e;
    return external ? round(y, Ctor.precision) : y;
  };
  P.toDecimalPlaces = P.todp = function(dp2, rm2) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp2 === void 0)
      return x;
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm2 === void 0)
      rm2 = Ctor.rounding;
    else
      checkInt32(rm2, 0, 8);
    return round(x, dp2 + getBase10Exponent(x) + 1, rm2);
  };
  P.toExponential = function(dp2, rm2) {
    var str, x = this, Ctor = x.constructor;
    if (dp2 === void 0) {
      str = toString(x, true);
    } else {
      checkInt32(dp2, 0, MAX_DIGITS);
      if (rm2 === void 0)
        rm2 = Ctor.rounding;
      else
        checkInt32(rm2, 0, 8);
      x = round(new Ctor(x), dp2 + 1, rm2);
      str = toString(x, true, dp2 + 1);
    }
    return str;
  };
  P.toFixed = function(dp2, rm2) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp2 === void 0)
      return toString(x);
    checkInt32(dp2, 0, MAX_DIGITS);
    if (rm2 === void 0)
      rm2 = Ctor.rounding;
    else
      checkInt32(rm2, 0, 8);
    y = round(new Ctor(x), dp2 + getBase10Exponent(x) + 1, rm2);
    str = toString(y.abs(), false, dp2 + getBase10Exponent(y) + 1);
    return x.isneg() && !x.isZero() ? "-" + str : str;
  };
  P.toInteger = P.toint = function() {
    var x = this, Ctor = x.constructor;
    return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
  };
  P.toNumber = function() {
    return +this;
  };
  P.toPower = P.pow = function(y) {
    var e, k, pr2, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn2 = +(y = new Ctor(y));
    if (!y.s)
      return new Ctor(ONE);
    x = new Ctor(x);
    if (!x.s) {
      if (y.s < 1)
        throw Error(decimalError + "Infinity");
      return x;
    }
    if (x.eq(ONE))
      return x;
    pr2 = Ctor.precision;
    if (y.eq(ONE))
      return round(x, pr2);
    e = y.e;
    k = y.d.length - 1;
    yIsInt = e >= k;
    sign = x.s;
    if (!yIsInt) {
      if (sign < 0)
        throw Error(decimalError + "NaN");
    } else if ((k = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER) {
      r = new Ctor(ONE);
      e = Math.ceil(pr2 / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (k % 2) {
          r = r.times(x);
          truncate(r.d, e);
        }
        k = mathfloor(k / 2);
        if (k === 0)
          break;
        x = x.times(x);
        truncate(x.d, e);
      }
      external = true;
      return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr2);
    }
    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
    x.s = 1;
    external = false;
    r = y.times(ln(x, pr2 + guard));
    external = true;
    r = exp(r);
    r.s = sign;
    return r;
  };
  P.toPrecision = function(sd2, rm2) {
    var e, str, x = this, Ctor = x.constructor;
    if (sd2 === void 0) {
      e = getBase10Exponent(x);
      str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    } else {
      checkInt32(sd2, 1, MAX_DIGITS);
      if (rm2 === void 0)
        rm2 = Ctor.rounding;
      else
        checkInt32(rm2, 0, 8);
      x = round(new Ctor(x), sd2, rm2);
      e = getBase10Exponent(x);
      str = toString(x, sd2 <= e || e <= Ctor.toExpNeg, sd2);
    }
    return str;
  };
  P.toSignificantDigits = P.tosd = function(sd2, rm2) {
    var x = this, Ctor = x.constructor;
    if (sd2 === void 0) {
      sd2 = Ctor.precision;
      rm2 = Ctor.rounding;
    } else {
      checkInt32(sd2, 1, MAX_DIGITS);
      if (rm2 === void 0)
        rm2 = Ctor.rounding;
      else
        checkInt32(rm2, 0, 8);
    }
    return round(new Ctor(x), sd2, rm2);
  };
  P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
    var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  };
  function add(x, y) {
    var carry, d, e, i, k, len, xd2, yd2, Ctor = x.constructor, pr2 = Ctor.precision;
    if (!x.s || !y.s) {
      if (!y.s)
        y = new Ctor(x);
      return external ? round(y, pr2) : y;
    }
    xd2 = x.d;
    yd2 = y.d;
    k = x.e;
    e = y.e;
    xd2 = xd2.slice();
    i = k - e;
    if (i) {
      if (i < 0) {
        d = xd2;
        i = -i;
        len = yd2.length;
      } else {
        d = yd2;
        e = k;
        len = xd2.length;
      }
      k = Math.ceil(pr2 / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; )
        d.push(0);
      d.reverse();
    }
    len = xd2.length;
    i = yd2.length;
    if (len - i < 0) {
      i = len;
      d = yd2;
      yd2 = xd2;
      xd2 = d;
    }
    for (carry = 0; i; ) {
      carry = (xd2[--i] = xd2[i] + yd2[i] + carry) / BASE | 0;
      xd2[i] %= BASE;
    }
    if (carry) {
      xd2.unshift(carry);
      ++e;
    }
    for (len = xd2.length; xd2[--len] == 0; )
      xd2.pop();
    y.d = xd2;
    y.e = e;
    return external ? round(y, pr2) : y;
  }
  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }
  function digitsToString(d) {
    var i, k, ws2, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws2 = d[i] + "";
        k = LOG_BASE - ws2.length;
        if (k)
          str += getZeroString(k);
        str += ws2;
      }
      w = d[i];
      ws2 = w + "";
      k = LOG_BASE - ws2.length;
      if (k)
        str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; )
      w /= 10;
    return str + w;
  }
  var divide = /* @__PURE__ */ function() {
    function multiplyInteger(x, k) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % BASE | 0;
        carry = temp / BASE | 0;
      }
      if (carry)
        x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract2(a, b, aL) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * BASE + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; )
        a.shift();
    }
    return function(x, y, pr2, dp2) {
      var cmp, e, i, k, prod, prodL, q, qd2, rem, remL, rem0, sd2, t, xi2, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd2 = x.d, yd2 = y.d;
      if (!x.s)
        return new Ctor(x);
      if (!y.s)
        throw Error(decimalError + "Division by zero");
      e = x.e - y.e;
      yL = yd2.length;
      xL = xd2.length;
      q = new Ctor(sign);
      qd2 = q.d = [];
      for (i = 0; yd2[i] == (xd2[i] || 0); )
        ++i;
      if (yd2[i] > (xd2[i] || 0))
        --e;
      if (pr2 == null) {
        sd2 = pr2 = Ctor.precision;
      } else if (dp2) {
        sd2 = pr2 + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
      } else {
        sd2 = pr2;
      }
      if (sd2 < 0)
        return new Ctor(0);
      sd2 = sd2 / LOG_BASE + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd2 = yd2[0];
        sd2++;
        for (; (i < xL || k) && sd2--; i++) {
          t = k * BASE + (xd2[i] || 0);
          qd2[i] = t / yd2 | 0;
          k = t % yd2 | 0;
        }
      } else {
        k = BASE / (yd2[0] + 1) | 0;
        if (k > 1) {
          yd2 = multiplyInteger(yd2, k);
          xd2 = multiplyInteger(xd2, k);
          yL = yd2.length;
          xL = xd2.length;
        }
        xi2 = yL;
        rem = xd2.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd2.slice();
        yz.unshift(0);
        yd0 = yd2[0];
        if (yd2[1] >= BASE / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd2, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * BASE + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= BASE)
                k = BASE - 1;
              prod = multiplyInteger(yd2, k);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod, yL < prodL ? yz : yd2, prodL);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd2.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract2(rem, prod, remL);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd2, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd2, remL);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd2[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd2[xi2] || 0;
          } else {
            rem = [xd2[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] !== void 0) && sd2--);
      }
      if (!qd2[0])
        qd2.shift();
      q.e = e;
      return round(q, dp2 ? pr2 + getBase10Exponent(q) + 1 : pr2);
    };
  }();
  function exp(x, sd2) {
    var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr2 = Ctor.precision;
    if (getBase10Exponent(x) > 16)
      throw Error(exponentOutOfRange + getBase10Exponent(x));
    if (!x.s)
      return new Ctor(ONE);
    if (sd2 == null) {
      external = false;
      wpr = pr2;
    } else {
      wpr = sd2;
    }
    t = new Ctor(0.03125);
    while (x.abs().gte(0.1)) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(ONE);
    Ctor.precision = wpr;
    for (; ; ) {
      pow = round(pow.times(x), wpr);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        while (k--)
          sum = round(sum.times(sum), wpr);
        Ctor.precision = pr2;
        return sd2 == null ? (external = true, round(sum, pr2)) : sum;
      }
      sum = t;
    }
  }
  function getBase10Exponent(x) {
    var e = x.e * LOG_BASE, w = x.d[0];
    for (; w >= 10; w /= 10)
      e++;
    return e;
  }
  function getLn10(Ctor, sd2, pr2) {
    if (sd2 > Ctor.LN10.sd()) {
      external = true;
      if (pr2)
        Ctor.precision = pr2;
      throw Error(decimalError + "LN10 precision limit exceeded");
    }
    return round(new Ctor(Ctor.LN10), sd2);
  }
  function getZeroString(k) {
    var zs2 = "";
    for (; k--; )
      zs2 += "0";
    return zs2;
  }
  function ln(y, sd2) {
    var c, c02, denominator, e, numerator, sum, t, wpr, x22, n = 1, guard = 10, x = y, xd2 = x.d, Ctor = x.constructor, pr2 = Ctor.precision;
    if (x.s < 1)
      throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
    if (x.eq(ONE))
      return new Ctor(0);
    if (sd2 == null) {
      external = false;
      wpr = pr2;
    } else {
      wpr = sd2;
    }
    if (x.eq(10)) {
      if (sd2 == null)
        external = true;
      return getLn10(Ctor, wpr);
    }
    wpr += guard;
    Ctor.precision = wpr;
    c = digitsToString(xd2);
    c02 = c.charAt(0);
    e = getBase10Exponent(x);
    if (Math.abs(e) < 15e14) {
      while (c02 < 7 && c02 != 1 || c02 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c02 = c.charAt(0);
        n++;
      }
      e = getBase10Exponent(x);
      if (c02 > 1) {
        x = new Ctor("0." + c);
        e++;
      } else {
        x = new Ctor(c02 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr2).times(e + "");
      x = ln(new Ctor(c02 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr2;
      return sd2 == null ? (external = true, round(x, pr2)) : x;
    }
    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
    x22 = round(x.times(x), wpr);
    denominator = 3;
    for (; ; ) {
      numerator = round(numerator.times(x22), wpr);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);
        if (e !== 0)
          sum = sum.plus(getLn10(Ctor, wpr + 2, pr2).times(e + ""));
        sum = divide(sum, new Ctor(n), wpr);
        Ctor.precision = pr2;
        return sd2 == null ? (external = true, round(sum, pr2)) : sum;
      }
      sum = t;
      denominator += 2;
    }
  }
  function parseDecimal(x, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0)
        e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; )
      ++i;
    for (len = str.length; str.charCodeAt(len - 1) === 48; )
      --len;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      e = e - i - 1;
      x.e = mathfloor(e / LOG_BASE);
      x.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0)
        i += LOG_BASE;
      if (i < len) {
        if (i)
          x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; )
          x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; )
        str += "0";
      x.d.push(+str);
      if (external && (x.e > MAX_E || x.e < -MAX_E))
        throw Error(exponentOutOfRange + e);
    } else {
      x.s = 0;
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function round(x, sd2, rm2) {
    var i, j, k, n, rd2, doRound, w, xdi, xd2 = x.d;
    for (n = 1, k = xd2[0]; k >= 10; k /= 10)
      n++;
    i = sd2 - n;
    if (i < 0) {
      i += LOG_BASE;
      j = sd2;
      w = xd2[xdi = 0];
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd2.length;
      if (xdi >= k)
        return x;
      w = k = xd2[xdi];
      for (n = 1; k >= 10; k /= 10)
        n++;
      i %= LOG_BASE;
      j = i - LOG_BASE + n;
    }
    if (rm2 !== void 0) {
      k = mathpow(10, n - j - 1);
      rd2 = w / k % 10 | 0;
      doRound = sd2 < 0 || xd2[xdi + 1] !== void 0 || w % k;
      doRound = rm2 < 4 ? (rd2 || doRound) && (rm2 == 0 || rm2 == (x.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm2 == 4 || doRound || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd2[xdi - 1]) % 10 & 1 || rm2 == (x.s < 0 ? 8 : 7));
    }
    if (sd2 < 1 || !xd2[0]) {
      if (doRound) {
        k = getBase10Exponent(x);
        xd2.length = 1;
        sd2 = sd2 - k - 1;
        xd2[0] = mathpow(10, (LOG_BASE - sd2 % LOG_BASE) % LOG_BASE);
        x.e = mathfloor(-sd2 / LOG_BASE) || 0;
      } else {
        xd2.length = 1;
        xd2[0] = x.e = x.s = 0;
      }
      return x;
    }
    if (i == 0) {
      xd2.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd2.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd2[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (doRound) {
      for (; ; ) {
        if (xdi == 0) {
          if ((xd2[0] += k) == BASE) {
            xd2[0] = 1;
            ++x.e;
          }
          break;
        } else {
          xd2[xdi] += k;
          if (xd2[xdi] != BASE)
            break;
          xd2[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd2.length; xd2[--i] === 0; )
      xd2.pop();
    if (external && (x.e > MAX_E || x.e < -MAX_E)) {
      throw Error(exponentOutOfRange + getBase10Exponent(x));
    }
    return x;
  }
  function subtract(x, y) {
    var d, e, i, j, k, len, xd2, xe, xLTy, yd2, Ctor = x.constructor, pr2 = Ctor.precision;
    if (!x.s || !y.s) {
      if (y.s)
        y.s = -y.s;
      else
        y = new Ctor(x);
      return external ? round(y, pr2) : y;
    }
    xd2 = x.d;
    yd2 = y.d;
    e = y.e;
    xe = x.e;
    xd2 = xd2.slice();
    k = xe - e;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd2;
        k = -k;
        len = yd2.length;
      } else {
        d = yd2;
        e = xe;
        len = xd2.length;
      }
      i = Math.max(Math.ceil(pr2 / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; )
        d.push(0);
      d.reverse();
    } else {
      i = xd2.length;
      len = yd2.length;
      xLTy = i < len;
      if (xLTy)
        len = i;
      for (i = 0; i < len; i++) {
        if (xd2[i] != yd2[i]) {
          xLTy = xd2[i] < yd2[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd2;
      xd2 = yd2;
      yd2 = d;
      y.s = -y.s;
    }
    len = xd2.length;
    for (i = yd2.length - len; i > 0; --i)
      xd2[len++] = 0;
    for (i = yd2.length; i > k; ) {
      if (xd2[--i] < yd2[i]) {
        for (j = i; j && xd2[--j] === 0; )
          xd2[j] = BASE - 1;
        --xd2[j];
        xd2[i] += BASE;
      }
      xd2[i] -= yd2[i];
    }
    for (; xd2[--len] === 0; )
      xd2.pop();
    for (; xd2[0] === 0; xd2.shift())
      --e;
    if (!xd2[0])
      return new Ctor(0);
    y.d = xd2;
    y.e = e;
    return external ? round(y, pr2) : y;
  }
  function toString(x, isExp, sd2) {
    var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd2 && (k = sd2 - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (e < 0 ? "e" : "e+") + e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd2 && (k = sd2 - len) > 0)
        str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd2 && (k = sd2 - e - 1) > 0)
        str = str + "." + getZeroString(k);
    } else {
      if ((k = e + 1) < len)
        str = str.slice(0, k) + "." + str.slice(k);
      if (sd2 && (k = sd2 - len) > 0) {
        if (e + 1 === len)
          str += ".";
        str += getZeroString(k);
      }
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function clone(obj) {
    var i, p, ps2;
    function Decimal2(value) {
      var x = this;
      if (!(x instanceof Decimal2))
        return new Decimal2(value);
      x.constructor = Decimal2;
      if (value instanceof Decimal2) {
        x.s = value.s;
        x.e = value.e;
        x.d = (value = value.d) ? value.slice() : value;
        return;
      }
      if (typeof value === "number") {
        if (value * 0 !== 0) {
          throw Error(invalidArgument + value);
        }
        if (value > 0) {
          x.s = 1;
        } else if (value < 0) {
          value = -value;
          x.s = -1;
        } else {
          x.s = 0;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (value === ~~value && value < 1e7) {
          x.e = 0;
          x.d = [value];
          return;
        }
        return parseDecimal(x, value.toString());
      } else if (typeof value !== "string") {
        throw Error(invalidArgument + value);
      }
      if (value.charCodeAt(0) === 45) {
        value = value.slice(1);
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (isDecimal.test(value))
        parseDecimal(x, value);
      else
        throw Error(invalidArgument + value);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.clone = clone;
    Decimal2.config = Decimal2.set = config;
    if (obj === void 0)
      obj = {};
    if (obj) {
      ps2 = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
      for (i = 0; i < ps2.length; )
        if (!obj.hasOwnProperty(p = ps2[i++]))
          obj[p] = this[p];
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function config(obj) {
    if (!obj || typeof obj !== "object") {
      throw Error(decimalError + "Object expected");
    }
    var i, p, v, ps2 = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -1 / 0,
      0,
      "toExpPos",
      0,
      1 / 0
    ];
    for (i = 0; i < ps2.length; i += 3) {
      if ((v = obj[p = ps2[i]]) !== void 0) {
        if (mathfloor(v) === v && v >= ps2[i + 1] && v <= ps2[i + 2])
          this[p] = v;
        else
          throw Error(invalidArgument + p + ": " + v);
      }
    }
    if ((v = obj[p = "LN10"]) !== void 0) {
      if (v == Math.LN10)
        this[p] = new this(v);
      else
        throw Error(invalidArgument + p + ": " + v);
    }
    return this;
  }
  var Decimal = clone(defaults);
  ONE = new Decimal(1);
  var Decimal$1 = Decimal;
  var CurrencyCodes;
  (function(CurrencyCodes2) {
    CurrencyCodes2["AED"] = "aed";
    CurrencyCodes2["AFN"] = "afn";
    CurrencyCodes2["ALL"] = "all";
    CurrencyCodes2["AMD"] = "amd";
    CurrencyCodes2["ANG"] = "ang";
    CurrencyCodes2["AOA"] = "aoa";
    CurrencyCodes2["ARS"] = "ars";
    CurrencyCodes2["AUD"] = "aud";
    CurrencyCodes2["AWG"] = "awg";
    CurrencyCodes2["AZN"] = "azn";
    CurrencyCodes2["BAM"] = "bam";
    CurrencyCodes2["BBD"] = "bbd";
    CurrencyCodes2["BDT"] = "bdt";
    CurrencyCodes2["BGN"] = "bgn";
    CurrencyCodes2["BHD"] = "bhd";
    CurrencyCodes2["BIF"] = "bif";
    CurrencyCodes2["BMD"] = "bmd";
    CurrencyCodes2["BND"] = "bnd";
    CurrencyCodes2["BOB"] = "bob";
    CurrencyCodes2["BOV"] = "bov";
    CurrencyCodes2["BRL"] = "brl";
    CurrencyCodes2["BSD"] = "bsd";
    CurrencyCodes2["BTN"] = "btn";
    CurrencyCodes2["BWP"] = "bwp";
    CurrencyCodes2["BYN"] = "byn";
    CurrencyCodes2["BYR"] = "byr";
    CurrencyCodes2["BZD"] = "bzd";
    CurrencyCodes2["CAD"] = "cad";
    CurrencyCodes2["CDF"] = "cdf";
    CurrencyCodes2["CHE"] = "che";
    CurrencyCodes2["CHF"] = "chf";
    CurrencyCodes2["CHW"] = "chw";
    CurrencyCodes2["CLF"] = "clf";
    CurrencyCodes2["CLP"] = "clp";
    CurrencyCodes2["CNY"] = "cny";
    CurrencyCodes2["COP"] = "cop";
    CurrencyCodes2["COU"] = "cou";
    CurrencyCodes2["CRC"] = "crc";
    CurrencyCodes2["CUC"] = "cuc";
    CurrencyCodes2["CUP"] = "cup";
    CurrencyCodes2["CVE"] = "cve";
    CurrencyCodes2["CZK"] = "czk";
    CurrencyCodes2["DJF"] = "djf";
    CurrencyCodes2["DKK"] = "dkk";
    CurrencyCodes2["DOP"] = "dop";
    CurrencyCodes2["DZD"] = "dzd";
    CurrencyCodes2["EGP"] = "egp";
    CurrencyCodes2["ERN"] = "ern";
    CurrencyCodes2["ETB"] = "etb";
    CurrencyCodes2["EUR"] = "eur";
    CurrencyCodes2["FJD"] = "fjd";
    CurrencyCodes2["FKP"] = "fkp";
    CurrencyCodes2["GBP"] = "gbp";
    CurrencyCodes2["GEL"] = "gel";
    CurrencyCodes2["GHS"] = "ghs";
    CurrencyCodes2["GIP"] = "gip";
    CurrencyCodes2["GMD"] = "gmd";
    CurrencyCodes2["GNF"] = "gnf";
    CurrencyCodes2["GTQ"] = "gtq";
    CurrencyCodes2["GYD"] = "gyd";
    CurrencyCodes2["HKD"] = "hkd";
    CurrencyCodes2["HNL"] = "hnl";
    CurrencyCodes2["HRK"] = "hrk";
    CurrencyCodes2["HTG"] = "htg";
    CurrencyCodes2["HUF"] = "huf";
    CurrencyCodes2["IDR"] = "idr";
    CurrencyCodes2["ILS"] = "ils";
    CurrencyCodes2["INR"] = "inr";
    CurrencyCodes2["IQD"] = "iqd";
    CurrencyCodes2["IRR"] = "irr";
    CurrencyCodes2["ISK"] = "isk";
    CurrencyCodes2["JMD"] = "jmd";
    CurrencyCodes2["JOD"] = "jod";
    CurrencyCodes2["JPY"] = "jpy";
    CurrencyCodes2["KES"] = "kes";
    CurrencyCodes2["KGS"] = "kgs";
    CurrencyCodes2["KHR"] = "khr";
    CurrencyCodes2["KMF"] = "kmf";
    CurrencyCodes2["KPW"] = "kpw";
    CurrencyCodes2["KRW"] = "krw";
    CurrencyCodes2["KWD"] = "kwd";
    CurrencyCodes2["KYD"] = "kyd";
    CurrencyCodes2["KZT"] = "kzt";
    CurrencyCodes2["LAK"] = "lak";
    CurrencyCodes2["LBP"] = "lbp";
    CurrencyCodes2["LKR"] = "lkr";
    CurrencyCodes2["LRD"] = "lrd";
    CurrencyCodes2["LSL"] = "lsl";
    CurrencyCodes2["LTL"] = "ltl";
    CurrencyCodes2["LVL"] = "lvl";
    CurrencyCodes2["LYD"] = "lyd";
    CurrencyCodes2["MAD"] = "mad";
    CurrencyCodes2["MDL"] = "mdl";
    CurrencyCodes2["MGA"] = "mga";
    CurrencyCodes2["MKD"] = "mkd";
    CurrencyCodes2["MMK"] = "mmk";
    CurrencyCodes2["MNT"] = "mnt";
    CurrencyCodes2["MOP"] = "mop";
    CurrencyCodes2["MRO"] = "mro";
    CurrencyCodes2["MUR"] = "mur";
    CurrencyCodes2["MVR"] = "mvr";
    CurrencyCodes2["MWK"] = "mwk";
    CurrencyCodes2["MXN"] = "mxn";
    CurrencyCodes2["MXV"] = "mxv";
    CurrencyCodes2["MYR"] = "myr";
    CurrencyCodes2["MZN"] = "mzn";
    CurrencyCodes2["NAD"] = "nad";
    CurrencyCodes2["NGN"] = "ngn";
    CurrencyCodes2["NIO"] = "nio";
    CurrencyCodes2["NOK"] = "nok";
    CurrencyCodes2["NPR"] = "npr";
    CurrencyCodes2["NZD"] = "nzd";
    CurrencyCodes2["OMR"] = "omr";
    CurrencyCodes2["PAB"] = "pab";
    CurrencyCodes2["PEN"] = "pen";
    CurrencyCodes2["PGK"] = "pgk";
    CurrencyCodes2["PHP"] = "php";
    CurrencyCodes2["PKR"] = "pkr";
    CurrencyCodes2["PLN"] = "pln";
    CurrencyCodes2["PYG"] = "pyg";
    CurrencyCodes2["QAR"] = "qar";
    CurrencyCodes2["RON"] = "ron";
    CurrencyCodes2["RSD"] = "rsd";
    CurrencyCodes2["RUB"] = "rub";
    CurrencyCodes2["RWF"] = "rwf";
    CurrencyCodes2["SAR"] = "sar";
    CurrencyCodes2["SBD"] = "sbd";
    CurrencyCodes2["SCR"] = "scr";
    CurrencyCodes2["SDG"] = "sdg";
    CurrencyCodes2["SEK"] = "sek";
    CurrencyCodes2["SGD"] = "sgd";
    CurrencyCodes2["SHP"] = "shp";
    CurrencyCodes2["SLL"] = "sll";
    CurrencyCodes2["SOS"] = "sos";
    CurrencyCodes2["SRD"] = "srd";
    CurrencyCodes2["SSP"] = "ssp";
    CurrencyCodes2["STD"] = "std";
    CurrencyCodes2["SVC"] = "svc";
    CurrencyCodes2["SYP"] = "syp";
    CurrencyCodes2["SZL"] = "szl";
    CurrencyCodes2["THB"] = "thb";
    CurrencyCodes2["TJS"] = "tjs";
    CurrencyCodes2["TMT"] = "tmt";
    CurrencyCodes2["TND"] = "tnd";
    CurrencyCodes2["TOP"] = "top";
    CurrencyCodes2["TRY"] = "try";
    CurrencyCodes2["TTD"] = "ttd";
    CurrencyCodes2["TWD"] = "twd";
    CurrencyCodes2["TZS"] = "tzs";
    CurrencyCodes2["UAH"] = "uah";
    CurrencyCodes2["UGX"] = "ugx";
    CurrencyCodes2["USD"] = "usd";
    CurrencyCodes2["USN"] = "usn";
    CurrencyCodes2["USS"] = "uss";
    CurrencyCodes2["UYI"] = "uyi";
    CurrencyCodes2["UYU"] = "uyu";
    CurrencyCodes2["UZS"] = "uzs";
    CurrencyCodes2["VEF"] = "vef";
    CurrencyCodes2["VND"] = "vnd";
    CurrencyCodes2["VUV"] = "vuv";
    CurrencyCodes2["WST"] = "wst";
    CurrencyCodes2["XAF"] = "xaf";
    CurrencyCodes2["XAG"] = "xag";
    CurrencyCodes2["XAU"] = "xau";
    CurrencyCodes2["XBA"] = "xba";
    CurrencyCodes2["XBB"] = "xbb";
    CurrencyCodes2["XBC"] = "xbc";
    CurrencyCodes2["XBD"] = "xbd";
    CurrencyCodes2["XCD"] = "xcd";
    CurrencyCodes2["XDR"] = "xdr";
    CurrencyCodes2["XFU"] = "xfu";
    CurrencyCodes2["XOF"] = "xof";
    CurrencyCodes2["XPD"] = "xpd";
    CurrencyCodes2["XPF"] = "xpf";
    CurrencyCodes2["XPT"] = "xpt";
    CurrencyCodes2["XSU"] = "xsu";
    CurrencyCodes2["XTS"] = "xts";
    CurrencyCodes2["XUA"] = "xua";
    CurrencyCodes2["YER"] = "yer";
    CurrencyCodes2["ZAR"] = "zar";
    CurrencyCodes2["ZMW"] = "zmw";
    CurrencyCodes2["ZWL"] = "zwl";
  })(CurrencyCodes || (CurrencyCodes = {}));
  const CurrencyExponents = {
    [CurrencyCodes.AED]: 2,
    [CurrencyCodes.AFN]: 2,
    [CurrencyCodes.ALL]: 2,
    [CurrencyCodes.AMD]: 2,
    [CurrencyCodes.ANG]: 2,
    [CurrencyCodes.AOA]: 2,
    [CurrencyCodes.ARS]: 2,
    [CurrencyCodes.AUD]: 2,
    [CurrencyCodes.AWG]: 2,
    [CurrencyCodes.AZN]: 2,
    [CurrencyCodes.BAM]: 2,
    [CurrencyCodes.BBD]: 2,
    [CurrencyCodes.BDT]: 2,
    [CurrencyCodes.BGN]: 2,
    [CurrencyCodes.BHD]: 3,
    [CurrencyCodes.BIF]: 0,
    [CurrencyCodes.BMD]: 2,
    [CurrencyCodes.BND]: 2,
    [CurrencyCodes.BOB]: 2,
    [CurrencyCodes.BOV]: 2,
    [CurrencyCodes.BRL]: 2,
    [CurrencyCodes.BSD]: 2,
    [CurrencyCodes.BTN]: 2,
    [CurrencyCodes.BWP]: 2,
    [CurrencyCodes.BYR]: 0,
    [CurrencyCodes.BYN]: 2,
    [CurrencyCodes.BZD]: 2,
    [CurrencyCodes.CAD]: 2,
    [CurrencyCodes.CDF]: 2,
    [CurrencyCodes.CHE]: 2,
    [CurrencyCodes.CHF]: 2,
    [CurrencyCodes.CHW]: 2,
    [CurrencyCodes.CLF]: 0,
    [CurrencyCodes.CLP]: 0,
    [CurrencyCodes.CNY]: 2,
    [CurrencyCodes.COP]: 2,
    [CurrencyCodes.COU]: 2,
    [CurrencyCodes.CRC]: 2,
    [CurrencyCodes.CUC]: 2,
    [CurrencyCodes.CUP]: 2,
    [CurrencyCodes.CVE]: 2,
    [CurrencyCodes.CZK]: 2,
    [CurrencyCodes.DJF]: 0,
    [CurrencyCodes.DKK]: 2,
    [CurrencyCodes.DOP]: 2,
    [CurrencyCodes.DZD]: 2,
    [CurrencyCodes.EGP]: 2,
    [CurrencyCodes.ERN]: 2,
    [CurrencyCodes.ETB]: 2,
    [CurrencyCodes.EUR]: 2,
    [CurrencyCodes.FJD]: 2,
    [CurrencyCodes.FKP]: 2,
    [CurrencyCodes.GBP]: 2,
    [CurrencyCodes.GEL]: 2,
    [CurrencyCodes.GHS]: 2,
    [CurrencyCodes.GIP]: 2,
    [CurrencyCodes.GMD]: 2,
    [CurrencyCodes.GNF]: 0,
    [CurrencyCodes.GTQ]: 2,
    [CurrencyCodes.GYD]: 2,
    [CurrencyCodes.HKD]: 2,
    [CurrencyCodes.HNL]: 2,
    [CurrencyCodes.HRK]: 2,
    [CurrencyCodes.HTG]: 2,
    [CurrencyCodes.HUF]: 2,
    [CurrencyCodes.IDR]: 2,
    [CurrencyCodes.ILS]: 2,
    [CurrencyCodes.INR]: 2,
    [CurrencyCodes.IQD]: 3,
    [CurrencyCodes.IRR]: 2,
    [CurrencyCodes.ISK]: 0,
    [CurrencyCodes.JMD]: 2,
    [CurrencyCodes.JOD]: 3,
    [CurrencyCodes.JPY]: 0,
    [CurrencyCodes.KES]: 2,
    [CurrencyCodes.KGS]: 2,
    [CurrencyCodes.KHR]: 2,
    [CurrencyCodes.KMF]: 0,
    [CurrencyCodes.KPW]: 2,
    [CurrencyCodes.KRW]: 0,
    [CurrencyCodes.KWD]: 3,
    [CurrencyCodes.KYD]: 2,
    [CurrencyCodes.KZT]: 2,
    [CurrencyCodes.LAK]: 2,
    [CurrencyCodes.LBP]: 2,
    [CurrencyCodes.LKR]: 2,
    [CurrencyCodes.LRD]: 2,
    [CurrencyCodes.LSL]: 2,
    [CurrencyCodes.LTL]: 2,
    [CurrencyCodes.LVL]: 2,
    [CurrencyCodes.LYD]: 3,
    [CurrencyCodes.MAD]: 2,
    [CurrencyCodes.MDL]: 2,
    [CurrencyCodes.MGA]: 2,
    [CurrencyCodes.MKD]: 2,
    [CurrencyCodes.MMK]: 2,
    [CurrencyCodes.MNT]: 2,
    [CurrencyCodes.MOP]: 2,
    [CurrencyCodes.MRO]: 2,
    [CurrencyCodes.MUR]: 2,
    [CurrencyCodes.MVR]: 2,
    [CurrencyCodes.MWK]: 2,
    [CurrencyCodes.MXN]: 2,
    [CurrencyCodes.MXV]: 2,
    [CurrencyCodes.MYR]: 2,
    [CurrencyCodes.MZN]: 2,
    [CurrencyCodes.NAD]: 2,
    [CurrencyCodes.NGN]: 2,
    [CurrencyCodes.NIO]: 2,
    [CurrencyCodes.NOK]: 2,
    [CurrencyCodes.NPR]: 2,
    [CurrencyCodes.NZD]: 2,
    [CurrencyCodes.OMR]: 3,
    [CurrencyCodes.PAB]: 2,
    [CurrencyCodes.PEN]: 2,
    [CurrencyCodes.PGK]: 2,
    [CurrencyCodes.PHP]: 2,
    [CurrencyCodes.PKR]: 2,
    [CurrencyCodes.PLN]: 2,
    [CurrencyCodes.PYG]: 0,
    [CurrencyCodes.QAR]: 2,
    [CurrencyCodes.RON]: 2,
    [CurrencyCodes.RSD]: 2,
    [CurrencyCodes.RUB]: 2,
    [CurrencyCodes.RWF]: 0,
    [CurrencyCodes.SAR]: 2,
    [CurrencyCodes.SBD]: 2,
    [CurrencyCodes.SCR]: 2,
    [CurrencyCodes.SDG]: 2,
    [CurrencyCodes.SEK]: 2,
    [CurrencyCodes.SGD]: 2,
    [CurrencyCodes.SHP]: 2,
    [CurrencyCodes.SLL]: 2,
    [CurrencyCodes.SOS]: 2,
    [CurrencyCodes.SRD]: 2,
    [CurrencyCodes.SSP]: 2,
    [CurrencyCodes.STD]: 2,
    [CurrencyCodes.SVC]: 2,
    [CurrencyCodes.SYP]: 2,
    [CurrencyCodes.SZL]: 2,
    [CurrencyCodes.THB]: 2,
    [CurrencyCodes.TJS]: 2,
    [CurrencyCodes.TMT]: 2,
    [CurrencyCodes.TND]: 3,
    [CurrencyCodes.TOP]: 2,
    [CurrencyCodes.TRY]: 2,
    [CurrencyCodes.TTD]: 2,
    [CurrencyCodes.TWD]: 2,
    [CurrencyCodes.TZS]: 2,
    [CurrencyCodes.UAH]: 2,
    [CurrencyCodes.UGX]: 0,
    [CurrencyCodes.USD]: 2,
    [CurrencyCodes.USN]: 2,
    [CurrencyCodes.USS]: 2,
    [CurrencyCodes.UYI]: 0,
    [CurrencyCodes.UYU]: 2,
    [CurrencyCodes.UZS]: 2,
    [CurrencyCodes.VEF]: 2,
    [CurrencyCodes.VND]: 0,
    [CurrencyCodes.VUV]: 0,
    [CurrencyCodes.WST]: 2,
    [CurrencyCodes.XAF]: 0,
    [CurrencyCodes.XAG]: 0,
    [CurrencyCodes.XAU]: 0,
    [CurrencyCodes.XBA]: 0,
    [CurrencyCodes.XBB]: 0,
    [CurrencyCodes.XBC]: 0,
    [CurrencyCodes.XBD]: 0,
    [CurrencyCodes.XCD]: 2,
    [CurrencyCodes.XDR]: 0,
    [CurrencyCodes.XFU]: 0,
    [CurrencyCodes.XOF]: 0,
    [CurrencyCodes.XPD]: 0,
    [CurrencyCodes.XPF]: 0,
    [CurrencyCodes.XPT]: 0,
    [CurrencyCodes.XSU]: 0,
    [CurrencyCodes.XTS]: 0,
    [CurrencyCodes.XUA]: 0,
    [CurrencyCodes.YER]: 2,
    [CurrencyCodes.ZAR]: 2,
    [CurrencyCodes.ZMW]: 2,
    [CurrencyCodes.ZWL]: 2
  };
  function formatPrice(price, locale = "en-US") {
    const { amount, currency } = price;
    const formatter = Intl.NumberFormat(locale, { style: "currency", currency });
    return formatter.format(convertToMajorCurrencyUnits(amount, currency));
  }
  function convertToMajorCurrencyUnits(minorUnitValue, currency) {
    const exponent = CurrencyExponents[currency];
    if (exponent == null) {
      console.warn(`Unexpected currency ${currency}`);
      return minorUnitValue;
    }
    const minorUnit = new Decimal$1(minorUnitValue);
    return minorUnit.dividedBy(10 ** exponent).toNumber();
  }
  var PriceUtils = {
    formatPrice
  };
  var lodash_transform = { exports: {} };
  lodash_transform.exports;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array ? array.length : 0;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array ? array.length : 0;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform3) {
      return function(arg) {
        return func(transform3(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if (hasOwnProperty.call(value, key) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index2 = 0, length = path.length;
      while (object != null && index2 < length) {
        object = object[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index2 = matchData.length, length = index2;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index2--) {
        var data = matchData[index2];
        if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index2 = -1, length = path.length;
      while (++index2 < length) {
        var key = toKey(path[index2]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString2(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function transform2(object, iteratee, accumulator) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee);
      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor() : [];
          } else {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
        return iteratee(accumulator, value, index2, object2);
      });
      return accumulator;
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = transform2;
  })(lodash_transform, lodash_transform.exports);
  var lodash_transformExports = lodash_transform.exports;
  var transform = /* @__PURE__ */ getDefaultExportFromCjs(lodash_transformExports);
  class DiscordSDKMock {
    constructor(clientId, guildId, channelId) {
      this.platform = Platform.DESKTOP;
      this.instanceId = "123456789012345678";
      this.configuration = getDefaultSdkConfiguration();
      this.source = null;
      this.sourceOrigin = "";
      this.frameId = "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa";
      this.eventBus = new EventEmitter();
      this.clientId = clientId;
      this.commands = this._updateCommandMocks({});
      this.guildId = guildId;
      this.channelId = channelId;
    }
    _updateCommandMocks(newCommands) {
      this.commands = transform(Object.assign({}, commandsMockDefault, newCommands), (mock, func, name) => {
        mock[name] = async (...args) => {
          console.info(`DiscordSDKMock: ${String(name)}(${JSON.stringify(args)})`);
          return await func(...args);
        };
      });
      return this.commands;
    }
    emitReady() {
      this.emitEvent("READY", void 0);
    }
    close(...args) {
      console.info(`DiscordSDKMock: close(${JSON.stringify(args)})`);
    }
    ready() {
      return Promise.resolve();
    }
    async subscribe(event, listener, ..._subscribeArgs) {
      return await this.eventBus.on(event, listener);
    }
    async unsubscribe(event, listener, ..._unsubscribeArgs) {
      return await this.eventBus.off(event, listener);
    }
    emitEvent(event, data) {
      this.eventBus.emit(event, data);
    }
  }
  const commandsMockDefault = {
    authorize: () => Promise.resolve({ code: "mock_code" }),
    authenticate: () => Promise.resolve({
      access_token: "mock_token",
      user: {
        username: "mock_user_username",
        discriminator: "mock_user_discriminator",
        id: "mock_user_id",
        avatar: null,
        public_flags: 1
      },
      scopes: [],
      expires: new Date(2121, 1, 1).toString(),
      application: {
        description: "mock_app_description",
        icon: "mock_app_icon",
        id: "mock_app_id",
        name: "mock_app_name"
      }
    }),
    setActivity: () => Promise.resolve({
      name: "mock_activity_name",
      type: 0
    }),
    getChannel: () => Promise.resolve({
      id: "mock_channel_id",
      name: "mock_channel_name",
      type: ChannelTypesObject.GUILD_TEXT,
      voice_states: [],
      messages: []
    }),
    getSkus: () => Promise.resolve({ skus: [] }),
    getEntitlements: () => Promise.resolve({ entitlements: [] }),
    startPurchase: () => Promise.resolve([]),
    setConfig: () => Promise.resolve({ use_interactive_pip: false }),
    userSettingsGetLocale: () => Promise.resolve({ locale: "" }),
    openExternalLink: () => Promise.resolve(null),
    encourageHardwareAcceleration: () => Promise.resolve({ enabled: true }),
    captureLog: () => Promise.resolve(null),
    setOrientationLockState: () => Promise.resolve(null),
    openInviteDialog: () => Promise.resolve(null),
    getPlatformBehaviors: () => Promise.resolve({
      iosKeyboardResizesView: true
    }),
    getChannelPermissions: () => Promise.resolve({ permissions: bigInt(1234567890) }),
    openShareMomentDialog: () => Promise.resolve(null),
    initiateImageUpload: () => Promise.resolve({
      image_url: "https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0b52aa9e99b832574a53_full_logo_blurple_RGB.png"
    }),
    getInstanceConnectedParticipants: () => Promise.resolve({ participants: [] })
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  const SUBSTITUTION_REGEX = /\{([a-z]+)\}/g;
  function regexFromTarget(target) {
    const regexString = target.replace(SUBSTITUTION_REGEX, (match, name) => `(?<${name}>[\\w-]+)`);
    return new RegExp(`${regexString}(/|$)`);
  }
  function matchAndRewriteURL({ originalURL, prefix, prefixHost, target }) {
    const targetURL = new URL(`https://${target}`);
    const targetRegEx = regexFromTarget(targetURL.host.replace(/%7B/g, "{").replace(/%7D/g, "}"));
    const match = originalURL.toString().match(targetRegEx);
    if (match == null)
      return originalURL;
    const newURL = new URL(originalURL.toString());
    newURL.host = prefixHost;
    newURL.pathname = prefix.replace(SUBSTITUTION_REGEX, (_, matchName) => {
      var _a2;
      const replaceValue = (_a2 = match.groups) === null || _a2 === void 0 ? void 0 : _a2[matchName];
      if (replaceValue == null)
        throw new Error("Misconfigured route.");
      return replaceValue;
    });
    newURL.pathname += newURL.pathname === "/" ? originalURL.pathname.slice(1) : originalURL.pathname;
    newURL.pathname = newURL.pathname.replace(targetURL.pathname, "");
    if (originalURL.pathname.endsWith("/") && !newURL.pathname.endsWith("/")) {
      newURL.pathname += "/";
    }
    return newURL;
  }
  function absoluteURL(url, protocol = window.location.protocol, host = window.location.host) {
    return new URL(url, `${protocol}//${host}`);
  }
  function patchUrlMappings(mappings, { patchFetch = true, patchWebSocket = true, patchXhr = true, patchSrcAttributes = false } = {}) {
    if (typeof window === "undefined")
      return;
    if (patchFetch) {
      const fetchImpl = window.fetch;
      window.fetch = function(input, init) {
        if (input instanceof Request) {
          const newUrl = attemptRemap({ url: absoluteURL(input.url), mappings });
          const _a2 = init !== null && init !== void 0 ? init : {}, newInit = __rest(_a2, ["url"]);
          Object.keys(Request.prototype).forEach((value) => {
            if (value === "url")
              return;
            try {
              newInit[value] = input[value];
            } catch (ex2) {
              console.warn(`Remapping fetch request key "${value}" failed`, ex2);
            }
          });
          return new Promise((resolve, reject) => {
            try {
              input.blob().then((blob) => {
                if (input.method.toUpperCase() !== "HEAD" && input.method.toUpperCase() !== "GET" && blob.size > 0) {
                  newInit.body = blob;
                }
                resolve(fetchImpl(new Request(newUrl, newInit)));
              });
            } catch (ex2) {
              reject(ex2);
            }
          });
        }
        const remapped = attemptRemap({ url: input instanceof URL ? input : absoluteURL(input), mappings });
        return fetchImpl(remapped, init);
      };
    }
    if (patchWebSocket) {
      class WebSocketProxy extends WebSocket {
        constructor(url, protocols) {
          const remapped = attemptRemap({ url: url instanceof URL ? url : absoluteURL(url), mappings });
          super(remapped, protocols);
        }
      }
      window.WebSocket = WebSocketProxy;
    }
    if (patchXhr) {
      const openImpl = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, async, username, password) {
        const remapped = attemptRemap({ url: absoluteURL(url), mappings });
        openImpl.apply(this, [method, remapped, async, username, password]);
      };
    }
    if (patchSrcAttributes) {
      const callback = function(mutationsList) {
        for (const mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "src") {
            attemptSetNodeSrc(mutation.target, mappings);
          } else if (mutation.type === "childList") {
            mutation.addedNodes.forEach((node) => recursivelyRemapChildNodes(node, mappings));
          }
        }
      };
      const observer = new MutationObserver(callback);
      const config2 = {
        attributeFilter: ["src"],
        childList: true,
        subtree: true
      };
      observer.observe(window.document, config2);
      window.document.querySelectorAll("[src]").forEach((node) => {
        attemptSetNodeSrc(node, mappings);
      });
    }
  }
  function recursivelyRemapChildNodes(node, mappings) {
    if (node.hasChildNodes()) {
      node.childNodes.forEach((child) => {
        attemptSetNodeSrc(child, mappings);
        recursivelyRemapChildNodes(child, mappings);
      });
    }
  }
  function attemptSetNodeSrc(node, mappings) {
    var _a2;
    if (node instanceof HTMLElement && node.hasAttribute("src")) {
      const url = absoluteURL((_a2 = node.getAttribute("src")) !== null && _a2 !== void 0 ? _a2 : "");
      if (url.host === window.location.host)
        return;
      node.setAttribute("src", attemptRemap({ url, mappings }).toString());
    }
  }
  function attemptRemap({ url, mappings }) {
    for (const mapping of mappings) {
      const mapped = matchAndRewriteURL({
        originalURL: url,
        prefix: mapping.prefix,
        target: mapping.target,
        prefixHost: window.location.host
      });
      if (mapped != null && (mapped === null || mapped === void 0 ? void 0 : mapped.toString()) !== url.toString()) {
        return mapped;
      }
    }
    return url;
  }
  const { Commands } = common;
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Commands,
    Common: common,
    DiscordSDK,
    DiscordSDKMock,
    get Events() {
      return Events;
    },
    get Orientation() {
      return Orientation$1;
    },
    PermissionUtils,
    Permissions,
    get Platform() {
      return Platform;
    },
    PriceUtils,
    get RPCCloseCodes() {
      return RPCCloseCodes;
    },
    get RPCErrorCodes() {
      return RPCErrorCodes;
    },
    Responses: responses,
    attemptRemap,
    patchUrlMappings
  }, Symbol.toStringTag, { value: "Module" }));
})


// Emscripten 1.x had a function Pointer_stringify() to marshal C strings to JS strings. That has been obsoleted by the new UTF8/16/32ToString() API family.
function Pointer_stringify(s, len) {
	warnOnce("The JavaScript function 'Pointer_stringify(ptrToSomeCString)' is obsoleted and will be removed in a future Unity version. Please call 'UTF8ToString(ptrToSomeCString)' instead.");
	return UTF8ToString(s, len);
}
Module['Pointer_stringify'] = Pointer_stringify;
var stackTraceReference = "(^|\\n)(\\s+at\\s+|)jsStackTrace(\\s+\\(|@)([^\\n]+):\\d+:\\d+(\\)|)(\\n|$)";
var stackTraceReferenceMatch = jsStackTrace().match(new RegExp(stackTraceReference));
if (stackTraceReferenceMatch)
  Module.stackTraceRegExp = new RegExp(stackTraceReference.replace("([^\\n]+)", stackTraceReferenceMatch[4].replace(/[\\^${}[\]().*+?|]/g,"\\$&")).replace("jsStackTrace", "[^\\n]+"));

var abort = function (what) {
  if (ABORT)
    return;
  ABORT = true;
  EXITSTATUS = 1;
  if (typeof ENVIRONMENT_IS_PTHREAD !== "undefined" && ENVIRONMENT_IS_PTHREAD)
    console.error("Pthread aborting at " + new Error().stack);
  if (what !== undefined) {
    out(what);
    err(what);
    what = JSON.stringify(what)
  } else {
    what = "";
  }
  var message = "abort(" + what + ") at " + stackTrace();
  if (Module.abortHandler && Module.abortHandler(message))
    return;
  throw message;
}

Module["SetFullscreen"] = function (fullscreen) {
  if (typeof runtimeInitialized === 'undefined' || !runtimeInitialized) {
    console.log ("Runtime not initialized yet.");
  } else if (typeof JSEvents === 'undefined') {
    console.log ("Player not loaded yet.");
  } else {
    var tmp = JSEvents.canPerformEventHandlerRequests;
    JSEvents.canPerformEventHandlerRequests = function () { return 1; };
    Module.ccall("SetFullscreen", null, ["number"], [fullscreen]);
    JSEvents.canPerformEventHandlerRequests = tmp;
  }
};
if (!Module['ENVIRONMENT_IS_PTHREAD']) {
  Module['preRun'].push(function () {
    // Initialize the IndexedDB based file system. Module['unityFileSystemInit'] allows
    // developers to override this with their own function, when they want to do cloud storage
    // instead.
    var unityFileSystemInit = Module['unityFileSystemInit'] || function () {
      FS.mkdir('/idbfs');
      FS.mount(IDBFS, {}, '/idbfs');
      Module.addRunDependency('JS_FileSystem_Mount');
      FS.syncfs(true, function (err) {
        if (err)
          console.log('IndexedDB is not available. Data will not persist in cache and PlayerPrefs will not be saved.');
        Module.removeRunDependency('JS_FileSystem_Mount');
      });
    };
    unityFileSystemInit();
  });
}

var videoInputDevices = []; // Set to null to disable video input devices altogether.
var videoInputDevicesEnumerated = false;
var removeEnumerateMediaDevicesRunDependency;
var enumerateWatchdog = null;

// Bug/limitation: Chrome does not specify deviceIds for any MediaDeviceInfo input devices at least in Chrome 85 on Windows 10
// This means that we need to use an awkward heuristic way of matching old video input connections to new ones.
function matchToOldDevice(newDevice) {
	var oldDevices = Object.keys(videoInputDevices);
	// First match by deviceId
	for(var i = 0; i < oldDevices.length; ++i) {
		var old = videoInputDevices[oldDevices[i]];
		if (old.deviceId && old.deviceId == newDevice.deviceId) return old;
	}
	// Then by object identity, in case that is supported.
	for(var i = 0; i < oldDevices.length; ++i) {
		var old = videoInputDevices[oldDevices[i]];
		if (old == newDevice) return old;
	}
	// Then by label
	for(var i = 0; i < oldDevices.length; ++i) {
		var old = videoInputDevices[oldDevices[i]];
		if (old.label && old.label == newDevice.label) return old;
	}
	// Last, by groupId + kind combination
	for(var i = 0; i < oldDevices.length; ++i) {
		var old = videoInputDevices[oldDevices[i]];
		if (old.groupId && old.kind && old.groupId == newDevice.groupId && old.kind == newDevice.kind) return old;
	}
}

function assignNewVideoInputId() {
	for(var i = 0;; ++i) {
		if (!videoInputDevices[i]) return i;
	}
}

function updateVideoInputDevices(devices) {
	removeEnumerateMediaDevicesRunDependency();
	// we're going to clear the list of videoInputDevices and regenerate it to get more accurate info after being granted camera access
	videoInputDevices = [];
	var retainedDevices = {};
	var newDevices = [];

	// Find devices that still exist
	devices.forEach(function (device) {
		if (device.kind === 'videoinput') { // Only interested in WebCam inputs
			var oldDevice = matchToOldDevice(device);
			if (oldDevice) {
				retainedDevices[oldDevice.id] = oldDevice;
			} else {
				newDevices.push(device);
			}
		}
	});
	videoInputDevices = retainedDevices;

	// Assign IDs to video input devices that are new
	newDevices.forEach(function (device) {
		if (!device.id) {
			device.id = assignNewVideoInputId();
			// Attempt to name the device. In both Firefox and Chrome, label is null.
			// In Chrome, deviceId is null. (could use it here, but human-readable
			// name is probably better than a long hash)
			device.name = device.label || ("Video input #" + (device.id + 1));

			// Chrome 85 on Android labels camera provides devices with labels like
			// "camera2 0, facing back" and "camera2 1, facing front", use that to
			// determine whether the device is front facing or not.
			// some labels don't provide that info, like the camera on a 2019 MacbookPro: FaceTime HD Camera (Built-in)
			// so if there's no "front" or "back" in the label or name, we're going to assume it's front facing


			device.isFrontFacing = device.name.toLowerCase().includes('front') || (!(device.name.toLowerCase().includes('front')) && !(device.name.toLowerCase().includes('back')));

			videoInputDevices[device.id] = device;
		}
	});
}

function enumerateMediaDeviceList() {
	if (!videoInputDevices) return;
	// Bug/limitation: If there are multiple video or audio devices connected,
	// Chrome only lists one of each category (audioinput/videoinput/audioutput) (tested Chrome 85 on Windows 10)
	navigator.mediaDevices.enumerateDevices().then(function(devices) {
		updateVideoInputDevices(devices);
		videoInputDevicesEnumerated = true;
	}).catch(function(e) {
		console.warn('Unable to enumerate media devices: ' + e + '\nWebcams will not be available.');
		disableAccessToMediaDevices();
	});

	// Work around Firefox 81 bug on Windows:
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1397977, devicechange
	// events do not fire, so resort to polling for device changes once every
	// 60 seconds.
	if (/Firefox/.test(navigator.userAgent)) {
		setTimeout(enumerateMediaDeviceList, 60000);
		warnOnce('Applying workaround to Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=1397977');
	}
}

function disableAccessToMediaDevices() {
	// Safari 11 has navigator.mediaDevices, but navigator.mediaDevices.add/removeEventListener is undefined
	if (navigator.mediaDevices && navigator.mediaDevices.removeEventListener) {
		navigator.mediaDevices.removeEventListener('devicechange', enumerateMediaDeviceList);
	}
	videoInputDevices = null;
}
Module['disableAccessToMediaDevices'] = disableAccessToMediaDevices;

if (!navigator.mediaDevices) {
	console.warn('navigator.mediaDevices not supported by this browser. Webcam access will not be available.' + (location.protocol == 'https:' ? '' : ' Try hosting the page over HTTPS, because some browsers disable webcam access when insecure HTTP is being used.'));
	disableAccessToMediaDevices();
} else if (typeof ENVIRONMENT_IS_PTHREAD === "undefined" || !ENVIRONMENT_IS_PTHREAD) setTimeout(function() {
	try {
		// Do not start engine main() until we have completed enumeration.
		addRunDependency('enumerateMediaDevices');
		removeEnumerateMediaDevicesRunDependency = function() {
			if (enumerateWatchdog !== null) clearTimeout(enumerateWatchdog);
			removeRunDependency('enumerateMediaDevices');
			if (navigator.mediaDevices) console.log('navigator.mediaDevices support available');
			removeEnumerateMediaDevicesRunDependency = function(){};
		}
		// Enumerate media devices now at startup..
		enumerateMediaDeviceList();
		// Firefox won't complete device enumeration if the window isn't in focus causing the startup to hang, so we
		// wait a second before removing the dependency and starting with an empty list of devices. Moving forward it's
		// likely more browsers will assume this standard.
		// See https://w3c.github.io/mediacapture-main/#dom-mediadevices-enumeratedevices
		enumerateWatchdog = setTimeout(removeEnumerateMediaDevicesRunDependency, 1000);

		// .. and whenever the connected devices list changes.
		navigator.mediaDevices.addEventListener('devicechange', enumerateMediaDeviceList);
	} catch(e) {
		console.warn('Unable to enumerate media devices: ' + e);
		disableAccessToMediaDevices();
	}
}, 0);

function SendMessage(gameObject, func, param) {
    var func_cstr = stringToNewUTF8(func);
    var gameObject_cstr = stringToNewUTF8(gameObject);
    var param_cstr = 0;

    try {
        if (param === undefined)
            _SendMessage(gameObject_cstr, func_cstr);
        else if (typeof param === "string") {
            param_cstr = stringToNewUTF8(param);
            _SendMessageString(gameObject_cstr, func_cstr, param_cstr);
        }
        else if (typeof param === "number")
            _SendMessageFloat(gameObject_cstr, func_cstr, param);
        else
            throw "" + param + " is does not have a type which is supported by SendMessage.";

    } finally {
        _free(param_cstr);
        _free(gameObject_cstr);
        _free(func_cstr);
    }
}
Module["SendMessage"] = SendMessage; // to avoid emscripten stripping

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Normally we don't log exceptions but instead let them bubble out the top
// level where the embedding environment (e.g. the browser) can handle
// them.
// However under v8 and node we sometimes exit the process direcly in which case
// its up to use us to log the exception before exiting.
// If we fix https://github.com/emscripten-core/emscripten/issues/15080
// this may no longer be needed under node.
function logExceptionOnExit(e) {
  if (e instanceof ExitStatus) return;
  let toLog = e;
  if (e && typeof e == 'object' && e.stack) {
    toLog = [e, e.stack];
  }
  err('exiting due to exception: ' + toLog);
}

var fs;
var nodePath;
var requireNodeFS;

if (ENVIRONMENT_IS_NODE) {
  if (!(typeof process == 'object' && typeof require == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


requireNodeFS = () => {
  // Use nodePath as the indicator for these not being initialized,
  // since in some environments a global fs may have already been
  // created.
  if (!nodePath) {
    fs = require('fs');
    nodePath = require('path');
  }
};

read_ = function shell_read(filename, binary) {
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  return fs.readFileSync(filename, binary ? undefined : 'utf8');
};

readBinary = (filename) => {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

readAsync = (filename, onload, onerror) => {
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  fs.readFile(filename, function(err, data) {
    if (err) onerror(err);
    else onload(data.buffer);
  });
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  // MODULARIZE will export the module in the proper place outside, we don't need to export here

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  // Without this older versions of node (< v15) will log unhandled rejections
  // but return 0, which is not normally the desired behaviour.  This is
  // not be needed with node v15 and about because it is now the default
  // behaviour:
  // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode
  process['on']('unhandledRejection', function(reason) { throw reason; });

  quit_ = (status, toThrow) => {
    if (keepRuntimeAlive()) {
      process['exitCode'] = status;
      throw toThrow;
    }
    logExceptionOnExit(toThrow);
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else
if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    let data;
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = function readAsync(f, onload, onerror) {
    setTimeout(() => onload(readBinary(f)), 0);
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      logExceptionOnExit(toThrow);
      quit(status);
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');

var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';


assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.");




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function == "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {
  assert(typeof func != 'undefined');

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


function legacyModuleProp(prop, newName) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get: function() {
        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
  }
}

function unexportedMessage(sym, isFSSybol) {
  var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
  if (isFSSybol) {
    msg += '. Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you';
  }
  return msg;
}

function unexportedRuntimeSymbol(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get: function() {
        abort(unexportedMessage(sym, isFSSybol));
      }
    });
  }
}

function unexportedRuntimeFunction(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Module[sym] = () => abort(unexportedMessage(sym, isFSSybol));
  }
}

// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');
var noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return Number(HEAPF64[((ptr)>>3)]);
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;
  assert(typeof allocator == 'number', 'allocate no longer takes a type argument')
  assert(typeof slab != 'number', 'allocate no longer takes a number as arg0')

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  ;
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 33554432;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');

assert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// If memory is defined in wasm, the user can't provide it.
assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -s IMPORTED_MEMORY to define wasmMemory externally');
assert(INITIAL_MEMORY == 33554432, 'Detected runtime INITIAL_MEMORY setting.  Use -s IMPORTED_MEMORY to define wasmMemory dynamically');

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAP32[((max)>>2)] = 0x2135467;
  HEAP32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

// end include: runtime_stack_check.js
// include: runtime_assertions.js


// Endianness check
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
SOCKFS.root = FS.mount(SOCKFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.

  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
/** @param {boolean=} fixedasm */
function createExportWrapper(name, fixedasm) {
  return function() {
    var displayName = name;
    var asm = fixedasm;
    if (!fixedasm) {
      asm = Module['asm'];
    }
    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
    if (!asm[name]) {
      assert(asm[name], 'exported native function `' + displayName + '` not found');
    }
    return asm[name].apply(null, arguments);
  };
}

var wasmBinaryFile;
  wasmBinaryFile = 'build.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmMemory = Module['asm']['memory'];
    assert(wasmMemory, "memory not found in wasm exports");
    // This assertion doesn't hold when emscripten is run in --post-link
    // mode.
    // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
    //assert(wasmMemory.buffer.byteLength === 33554432);
    updateGlobalBufferAndViews(wasmMemory.buffer);

    wasmTable = Module['asm']['__indirect_function_table'];
    assert(wasmTable, "table not found in wasm exports");

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      // Warn on some common problems.
      if (isFileURI(wasmBinaryFile)) {
        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
      }
      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // If instantiation fails, reject the module ready promise.
  instantiateAsync().catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  3224048: function() {return Module.webglContextAttributes.premultipliedAlpha;},  
 3224109: function() {return Module.webglContextAttributes.preserveDrawingBuffer;},  
 3224173: function() {return Module.webglContextAttributes.powerPreference;},  
 3224231: function() {Module['emscripten_get_now_backup'] = performance.now;},  
 3224286: function($0) {performance.now = function() { return $0; };},  
 3224334: function($0) {performance.now = function() { return $0; };},  
 3224382: function() {performance.now = Module['emscripten_get_now_backup'];}
};






  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            (function() {  dynCall_v.call(null, func); })();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            (function(a1) {  dynCall_vi.apply(null, [func, a1]); })(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      // If demangle has failed before, stop demangling any further function names
      // This avoids an infinite recursion with malloc()->abort()->stackTrace()->demangle()->malloc()->...
      demangle.recursionGuard = (demangle.recursionGuard|0)+1;
      if (demangle.recursionGuard > 1) return func;
      var __cxa_demangle_func = Module['___cxa_demangle'] || Module['__cxa_demangle'];
      assert(__cxa_demangle_func);
      return withStackSave(function() {
        try {
          var s = func;
          if (s.startsWith('__Z'))
            s = s.substr(1);
          var len = lengthBytesUTF8(s)+1;
          var buf = stackAlloc(len);
          stringToUTF8(s, buf, len);
          var status = stackAlloc(4);
          var ret = __cxa_demangle_func(buf, 0, 0, status);
          if (HEAP32[((status)>>2)] === 0 && ret) {
            return UTF8ToString(ret);
          }
          // otherwise, libcxxabi failed
        } catch(e) {
        } finally {
          _free(ret);
          if (demangle.recursionGuard < 2) --demangle.recursionGuard;
        }
        // failure when using libcxxabi, don't demangle
        return func;
      });
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function dynCallLegacy(sig, ptr, args) {
      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      if (args && args.length) {
        // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
        assert(args.length === sig.substring(1).replace(/j/g, '--').length);
      } else {
        assert(sig.length == 1);
      }
      var f = Module["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
  
  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    }
  /** @param {Object=} args */
  function dynCall(sig, ptr, args) {
      return dynCallLegacy(sig, ptr, args);
    }


  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
      wasmTableMirror[idx] = func;
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function _ClearTurnsInternal(callback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }    
  
      Playroom.clearTurns().then(() => {
        (function() {  dynCall_v.call(null, callback); });
      }).catch((error) => {
        console.error("[JS]: Failed to clear all turns:", error);
      });
    }

  function _ConvertString(str) {
      var bufferSize = lengthBytesUTF8(str) + 1;
      var buffer = _malloc(bufferSize);
      stringToUTF8(str, buffer, bufferSize);
      return buffer;
    }

  function _CreateJoystickInternal(JoystickOptions) {
      const options = JoystickOptions
        ? JSON.parse(UTF8ToString(JoystickOptions))
        : {};
  
      this.leftStick = new Playroom.Joystick(Playroom.myPlayer(), {
        type: options.type,
        buttons: options.buttons,
        zones: options.zones,
      });
    }

  function _DpadJoystickInternal() {
      const dpad = this.leftStick.dpad();
  
      var jsonString = JSON.stringify(dpad);
      var bufferSize = lengthBytesUTF8(jsonString) + 1;
      var buffer = _malloc(bufferSize);
      stringToUTF8(jsonString, buffer, bufferSize);
      return buffer;
    }

  function _GetAllTurnsInternal(callback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.getAllTurns().then((data) => {
        dataJson = JSON.stringify(data);
        (function(a1) {  dynCall_vi.apply(null, [callback, a1]); })(stringToNewUTF8(dataJson));
  
      }).catch((error) => {
        console.error("[JS]: Failed to get turns:", error);
      });
    }

  function _GetChallengeIdInternal() {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      const challengeId =  Playroom.getChallengeId();
      return _ConvertString(challengeId);
    }

  function _GetJSMemoryInfo(totalJSptr, usedJSptr) {
      if (performance.memory) {
        HEAPF64[totalJSptr >> 3] = performance.memory.totalJSHeapSize;
        HEAPF64[usedJSptr >> 3] = performance.memory.usedJSHeapSize;
      } else {
        HEAPF64[totalJSptr >> 3] = NaN;
        HEAPF64[usedJSptr >> 3] = NaN;
      }
    }

  function _GetMyTurnDataInternal(callback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.getMyTurnData().then((data) => {
        if (data == undefined) {
          return;
        }
  
        dataJson = JSON.stringify(data);
        (function(a1) {  dynCall_vi.apply(null, [callback, a1]); })(stringToNewUTF8(dataJson));
      }).catch((error) => {
        console.error("[JS]: Failed to get my turn data:", error);
      });
    }

  function _GetPersistentDataInternal(key, onGetPersistentDataCallback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var dataKey = UTF8ToString(key);
  
      Playroom.getPersistentData(dataKey).then(data => {
        if (data === undefined) {
          return null;
        }
  
        data = JSON.stringify(data);
        var key = _ConvertString(dataKey);
        (function(a1, a2) {  dynCall_vii.apply(null, [onGetPersistentDataCallback, a1, a2]); })(key, stringToNewUTF8(data))
      }).catch((error) => {
        console.error("Error getting persistent data:", error);
      });
    
    }

  function _GetPlayerStateDictionary(playerId, key) {
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.getState === "function") {
        var obj = playerState.getState(UTF8ToString(key));
        var jsonString = JSON.stringify(obj);
        var bufferSize = lengthBytesUTF8(jsonString) + 1;
        var buffer = _malloc(bufferSize);
        stringToUTF8(jsonString, buffer, bufferSize);
        return buffer;
      } else {
        console.error(
          'The player state object does not have a "setState" method.'
        );
        return null;
      }
    }

  function _GetPlayerStateFloatById(playerId, key) {
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.getState === "function") {
        var stateVal = playerState.getState(UTF8ToString(key));
        return stateVal;
      } else {
        console.error(
          'The player state object does not have a "getState" method.'
        );
        return null;
      }
    }

  function _GetPlayerStateIntById(playerId, key) {
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.getState === "function") {
        var stateVal = playerState.getState(UTF8ToString(key));
        return stateVal;
      } else {
        console.error(
          'The player state object does not have a "getState" method.'
        );
        return null;
      }
    }

  function _GetPlayerStateStringById(playerId, key) {
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.getState === "function") {
        try {
          var stateVal = playerState.getState(UTF8ToString(key));
  
          if (stateVal === undefined) {
            return null;
          }
  
          var bufferSize = lengthBytesUTF8(stateVal) + 1;
          var buffer = _malloc(bufferSize);
          stringToUTF8(stateVal, buffer, bufferSize);
          return buffer;
        } catch (error) {
          console.log("There was an error: " + error);
        }
      } else {
        console.error(
          'The player state object does not have a "getState" method.'
        );
        return null;
      }
    }

  function _GetProfileByPlayerId(playerId) {
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.getProfile === "function") {
        const profile = playerState.getProfile();
  
        var returnStr = JSON.stringify(profile);
  
        var bufferSize = lengthBytesUTF8(returnStr) + 1;
        var buffer = _malloc(bufferSize);
        stringToUTF8(returnStr, buffer, bufferSize);
        return buffer;
      } else {
        console.error(
          'The player state object does not have a "getProfile" method.'
        );
        return null;
      }
    }

  function _GetRoomCodeInternal() {
      var roomCode = Playroom.getRoomCode();
      var bufferSize = lengthBytesUTF8(roomCode) + 1;
      var buffer = _malloc(bufferSize);
      stringToUTF8(roomCode, buffer, bufferSize);
      return buffer;
    }

  function _GetStateDictionaryInternal(key) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      var obj = Playroom.getState(UTF8ToString(key));
      var jsonString = JSON.stringify(obj);
      var bufferSize = lengthBytesUTF8(jsonString) + 1;
      var buffer = _malloc(bufferSize);
      stringToUTF8(jsonString, buffer, bufferSize);
      return buffer;
    }

  function _GetStateFloatInternal(key) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      return Playroom.getState(UTF8ToString(key));
    }

  function _GetStateIntInternal(key) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      return Playroom.getState(UTF8ToString(key));
    }

  function _GetStateStringInternal(key) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
      }
  
      try {
        var returnStr = Playroom.getState(UTF8ToString(key));
  
        if (returnStr == null) {
          return "";
        }
  
        if (typeof returnStr !== "string") {
          return "";
        }
  
        var bufferSize = lengthBytesUTF8(returnStr) + 1;
        var buffer = _malloc(bufferSize);
        stringToUTF8(returnStr, buffer, bufferSize);
        return buffer;
      } catch (error) {
        console.error(
          "JavaScript Library: An error occurred in GetStateStringInternal: \n\n",
          error
        );
      }
    }

  function _InsertCoinInternal(
      optionsJson,
      onLaunchCallBack,
      onQuitInternalCallback,
      onDisconnectCallback,
      onError,
      onLaunchCallBackKey,
      onQuitInternalCallbackKey
    ) {
      onLaunchCallBackKey = UTF8ToString(onLaunchCallBackKey);
      onQuitInternalCallbackKey = UTF8ToString(onQuitInternalCallbackKey);
  
      function OnLaunchCallBack() {
        var key = _ConvertString(onLaunchCallBackKey);
        (function(a1) {  dynCall_vi.apply(null, [onLaunchCallBack, a1]); })(key)
      }
  
      function OnDisconnectCallback() {
        var key = _ConvertString(onQuitInternalCallbackKey);
        (function(a1) {  dynCall_vi.apply(null, [onDisconnectCallback, a1]); })(key)
      }
      this.onPlayerJoinCallBacks = {};
      var options = optionsJson ? JSON.parse(UTF8ToString(optionsJson)) : {};
  
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.insertCoin(options, OnLaunchCallBack, OnDisconnectCallback)
        .then(() => {
          Playroom.onPlayerJoin((player) => {
            var id = player.id;
            var bufferSize = lengthBytesUTF8(id) + 1;
            var buffer = _malloc(bufferSize);
            stringToUTF8(id, buffer, bufferSize);
  
            player.onQuit(() => {
              (function(a1) {  dynCall_vi.apply(null, [onQuitInternalCallback, a1]); })(buffer)
            });
          });
        })
        .catch((error) => {
          var jsonString = JSON.stringify(error);
          var bufferSize = lengthBytesUTF8(jsonString) + 1;
          var buffer = _malloc(bufferSize);
          stringToUTF8(jsonString, buffer, bufferSize);
          (function(a1) {  dynCall_vi.apply(null, [onError, a1]); })(buffer)
        });
    }

  function _InsertPersistentDataInternal(key, value) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      
      Playroom.insertPersistentData(UTF8ToString(key), UTF8ToString(value)).then(() => {
        console.log("Data has been set successfully.");
      }).catch((error) => {
        console.error("Failed to set data:", error);
      });
    }

  function _IsHostInternal() {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      return Playroom.isHost();
    }

  function _IsStreamScreenInternal() {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      return Playroom.isStreamScreen();
    }

  var JS_Accelerometer = null;
  
  var JS_Accelerometer_callback = 0;
  function _JS_Accelerometer_IsRunning() {
          // Sensor is running if there is an activated new JS_Accelerometer; or the JS_Accelerometer_callback is hooked up
          return (JS_Accelerometer && JS_Accelerometer.activated) || (JS_Accelerometer_callback != 0);
      }

  var JS_Accelerometer_multiplier = 1;
  
  var JS_Accelerometer_lastValue = {x:0,y:0,z:0};
  function JS_Accelerometer_eventHandler() {
          // Record the last value for gravity computation
          JS_Accelerometer_lastValue = {
              x: JS_Accelerometer.x * JS_Accelerometer_multiplier,
              y: JS_Accelerometer.y * JS_Accelerometer_multiplier,
              z: JS_Accelerometer.z * JS_Accelerometer_multiplier
          };
          if (JS_Accelerometer_callback != 0)
              dynCall_vfff(JS_Accelerometer_callback, JS_Accelerometer_lastValue.x, JS_Accelerometer_lastValue.y, JS_Accelerometer_lastValue.z);
      }
  
  var JS_Accelerometer_frequencyRequest = 0;
  
  var JS_Accelerometer_frequency = 0;
  
  var JS_LinearAccelerationSensor_callback = 0;
  
  var JS_GravitySensor_callback = 0;
  
  var JS_Gyroscope_callback = 0;
  
  function JS_ComputeGravity(accelerometerValue, linearAccelerationValue) {
          // On some Android devices, the linear acceleration direction is reversed compared to its accelerometer
          // So, compute both the difference and sum (difference of the negative) and return the one that's the smallest in magnitude
          var difference = {
              x: accelerometerValue.x - linearAccelerationValue.x,
              y: accelerometerValue.y - linearAccelerationValue.y,
              z: accelerometerValue.z - linearAccelerationValue.z
          };
          var differenceMagnitudeSq = difference.x*difference.x + difference.y*difference.y + difference.z*difference.z;
  
          var sum = {
              x: accelerometerValue.x + linearAccelerationValue.x,
              y: accelerometerValue.y + linearAccelerationValue.y,
              z: accelerometerValue.z + linearAccelerationValue.z
          };
          var sumMagnitudeSq = sum.x*sum.x + sum.y*sum.y + sum.z*sum.z;
  
          return (differenceMagnitudeSq <= sumMagnitudeSq) ? difference : sum;
      }
  function JS_DeviceMotion_eventHandler(event) {
          // The accelerationIncludingGravity property is the amount of acceleration recorded by the device, in meters per second squared (m/s2).
          // Its value is the sum of the acceleration of the device as induced by the user and the acceleration caused by gravity.
          // Apply the JS_Accelerometer_multiplier to convert to g
          var accelerometerValue = {
              x: event.accelerationIncludingGravity.x * JS_Accelerometer_multiplier,
              y: event.accelerationIncludingGravity.y * JS_Accelerometer_multiplier,
              z: event.accelerationIncludingGravity.z * JS_Accelerometer_multiplier
          };
          if (JS_Accelerometer_callback != 0)
              dynCall_vfff(JS_Accelerometer_callback, accelerometerValue.x, accelerometerValue.y, accelerometerValue.z);
  
          // The acceleration property is the amount of acceleration recorded by the device, in meters per second squared (m/s2), compensated for gravity.
          // Apply the JS_Accelerometer_multiplier to convert to g
          var linearAccelerationValue = {
              x: event.acceleration.x * JS_Accelerometer_multiplier,
              y: event.acceleration.y * JS_Accelerometer_multiplier,
              z: event.acceleration.z * JS_Accelerometer_multiplier
          };
          if (JS_LinearAccelerationSensor_callback != 0)
              dynCall_vfff(JS_LinearAccelerationSensor_callback, linearAccelerationValue.x, linearAccelerationValue.y, linearAccelerationValue.z);
  
          // Compute and raise the gravity sensor vector
          if (JS_GravitySensor_callback != 0) {
              assert(typeof GravitySensor === 'undefined');
              var gravityValue = JS_ComputeGravity(accelerometerValue, linearAccelerationValue);
              dynCall_vfff(JS_GravitySensor_callback, gravityValue.x, gravityValue.y, gravityValue.z);
          }
  
          // The rotationRate property describes the rotation rates of the device around each of its axes (deg/s), but we want in radians/s so must scale
          // Note that the spec here has been updated so x,y,z axes are alpha,beta,gamma.
          // Therefore the order of axes at https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/rotationRate is incorrect
          //
          // There is a bug in Chrome < M66 where rotationRate values are not in deg/s https://bugs.chromium.org/p/chromium/issues/detail?id=541607
          // But that version is too old to include a check here
          if (JS_Gyroscope_callback != 0) {
              var degToRad = Math.PI / 180;
              dynCall_vfff(JS_Gyroscope_callback, event.rotationRate.alpha * degToRad, event.rotationRate.beta * degToRad, event.rotationRate.gamma * degToRad);
          }
      }
  
  var JS_DeviceSensorPermissions = 0;
  function JS_RequestDeviceSensorPermissions(permissions) {
          // iOS requires that we request permissions before using device sensor events
          if (permissions & 1/*DeviceOrientationEvent permission*/) {
              if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                  DeviceOrientationEvent.requestPermission()
                      .then(function(permissionState) {
                          if (permissionState === 'granted') {
                              JS_DeviceSensorPermissions &= ~1; // Remove DeviceOrientationEvent permission bit
                          } else {
                              warnOnce("DeviceOrientationEvent permission not granted");
                          }
                      })
                      .catch(function(err) {
                          // Permissions cannot be requested unless on a user interaction (a touch event)
                          // So in this case set JS_DeviceSensorPermissions and we will try again on a touch event
                          warnOnce(err);
                          JS_DeviceSensorPermissions |= 1/*DeviceOrientationEvent permission*/;
                      });
              }
          }
          if (permissions & 2/*DeviceMotionEvent permission*/) {
              if (typeof DeviceMotionEvent.requestPermission === 'function') {
                  DeviceMotionEvent.requestPermission()
                      .then(function(permissionState) {
                          if (permissionState === 'granted') {
                              JS_DeviceSensorPermissions &= ~2; // Remove DeviceMotionEvent permission bit
                          } else {
                              warnOnce("DeviceMotionEvent permission not granted");
                          }
                      })
                      .catch(function(err) {
                          // Permissions cannot be requested unless on a user interaction (a touch event)
                          // So in this case set JS_DeviceSensorPermissions and we will try again on a touch event
                          warnOnce(err);
                          JS_DeviceSensorPermissions |= 2/*DeviceMotionEvent permission*/;
                      });
              }
          }
      }
  function JS_DeviceMotion_add() {
          // Only add the event listener if we don't yet have any of the motion callbacks set
          if (JS_Accelerometer_callback == 0 &&
              JS_LinearAccelerationSensor_callback == 0 &&
              JS_GravitySensor_callback == 0 &&
              JS_Gyroscope_callback == 0) {
              JS_RequestDeviceSensorPermissions(2/*DeviceMotionEvent permission*/);
              window.addEventListener('devicemotion', JS_DeviceMotion_eventHandler);
          }
      }
  
  function JS_DefineAccelerometerMultiplier() {
          // Earth's gravity in m/s^2, same as ASENSOR_STANDARD_GRAVITY
          var g = 9.80665;
  
          // Multiplier is 1/g to normalize acceleration
          // iOS has its direction opposite to Android and Windows (tested Surface Pro tablet)
          // We include Macintosh in the test to capture Safari on iOS viewing in Desktop mode (the default now on iPads)
          JS_Accelerometer_multiplier = (/(iPhone|iPad|Macintosh)/i.test(navigator.userAgent)) ? 1/g : -1/g;
      }
  function _JS_Accelerometer_Start(callback, frequency) {
          // callback can be zero here when called via JS_GravitySensor_Start
  
          JS_DefineAccelerometerMultiplier();
  
          // If we don't have new sensor API, fallback to old DeviceMotionEvent
          if (typeof Accelerometer === 'undefined') {
              JS_DeviceMotion_add(); // Must call before we set the callback
              if (callback != 0) JS_Accelerometer_callback = callback;
              return;
          }
  
          if (callback != 0) JS_Accelerometer_callback = callback;
  
          function InitializeAccelerometer(frequency) {
              // Use device referenceFrame, since New Input System package does its own compensation
              JS_Accelerometer = new Accelerometer({ frequency: frequency, referenceFrame: 'device' });
              JS_Accelerometer.addEventListener('reading', JS_Accelerometer_eventHandler);
              JS_Accelerometer.addEventListener('error', function(e) {
                  // e.error could be DOMException: Could not connect to a sensor
                  warnOnce((e.error) ? e.error : e);
              });
              JS_Accelerometer.start();
              JS_Accelerometer_frequency = frequency;
          }
  
          // If the sensor is already created, stop and re-create it with new frequency
          if (JS_Accelerometer) {
              if (JS_Accelerometer_frequency != frequency) {
                  JS_Accelerometer.stop();
                  JS_Accelerometer.removeEventListener('reading', JS_Accelerometer_eventHandler);
                  InitializeAccelerometer(frequency);
              }
          }
          else if (JS_Accelerometer_frequencyRequest != 0) {
              // If the permissions promise is currently in progress, then note new frequency only
              JS_Accelerometer_frequencyRequest = frequency;
          }
          else {
              JS_Accelerometer_frequencyRequest = frequency;
  
              // Request required permission for the Accelerometer
              navigator.permissions.query({name: 'accelerometer'})
                  .then(function(result) {
                      if (result.state === "granted") {
                          InitializeAccelerometer(JS_Accelerometer_frequencyRequest);
                      } else {
                          warnOnce("No permission to use Accelerometer.");
                      }
                      JS_Accelerometer_frequencyRequest = 0;
              });
          }
      }

  function JS_DeviceMotion_remove() {
          // If we've removed the last callback, remove the devicemotion event listener
          if (JS_Accelerometer_callback == 0 &&
              JS_LinearAccelerationSensor_callback == 0 &&
              JS_GravitySensor_callback == 0 &&
              JS_Gyroscope_callback == 0 ) {
              window.removeEventListener('devicemotion', JS_DeviceOrientation_eventHandler);
          }
      }
  function _JS_Accelerometer_Stop() {
          if (JS_Accelerometer) {
              // Only actually stop the accelerometer if we don't need it to compute gravity values
              if (typeof GravitySensor !== 'undefined' || JS_GravitySensor_callback == 0) {
                  JS_Accelerometer.stop();
                  JS_Accelerometer.removeEventListener('reading', JS_Accelerometer_eventHandler);
                  JS_Accelerometer = null;
              }
              JS_Accelerometer_callback = 0;
              JS_Accelerometer_frequency = 0;
          }
          else if (JS_Accelerometer_callback != 0) {
              JS_Accelerometer_callback = 0;
              JS_DeviceMotion_remove();
          }
      }

  var ExceptionsSeen = 0;
  function _JS_CallAsLongAsNoExceptionsSeen(cb) {
  		if (!ExceptionsSeen) {
  			try {
  				(function() {  dynCall_v.call(null, cb); })();
  			} catch(e) {
  				ExceptionsSeen = 1;
  				console.error('Uncaught exception from main loop:');
  				console.error(e);
  				console.error('Halting program.');
  				if (Module.errorHandler) Module.errorHandler(e);
  				throw e;
  			}
  		}
  	}

  function _JS_Cursor_SetImage(ptr, length) {
      var binary = "";
      for (var i = 0; i < length; i++)
        binary += String.fromCharCode(HEAPU8[ptr + i]);
      Module.canvas.style.cursor = "url(data:image/cur;base64," + btoa(binary) + "),default";
    }

  function _JS_Cursor_SetShow(show) {
      Module.canvas.style.cursor = show ? "default" : "none";
    }

  function jsDomCssEscapeId(id) {
  		// Use CSS Object Model to escape ID if feature is present
  		if (typeof window.CSS !== "undefined" && typeof window.CSS.escape !== "undefined") {
  			return window.CSS.escape(id);
  		}
  
  		// Fallback: Escape special characters with RegExp. This handles most cases but not all!
  		return id.replace(/(#|\.|\+|\[|\]|\(|\)|\{|\})/g, "\\$1");
  	}
  function jsCanvasSelector() {
  		// This lookup specifies the target canvas that different DOM
  		// events are registered to, like keyboard and mouse events.
  		// This requires that Module['canvas'] must have a CSS ID associated
  		// with it, it cannot be empty. Override Module['canvas'] to specify
  		// some other target to use, e.g. if the page contains multiple Unity
  		// game instances.
  		if (Module['canvas'] && !Module['canvas'].id) throw 'Module["canvas"] must have a CSS ID associated with it!';
  		var canvasId = Module['canvas'] ? Module['canvas'].id : 'unity-canvas';
  		return '#' + jsDomCssEscapeId(canvasId);
  	}
  function _JS_DOM_MapViewportCoordinateToElementLocalCoordinate(viewportX, viewportY, targetX, targetY) {
  		var canvas = document.querySelector(jsCanvasSelector());
  		var rect = canvas && canvas.getBoundingClientRect();
  		HEAPU32[targetX >> 2] = viewportX - (rect ? rect.left : 0);
  		HEAPU32[targetY >> 2] = viewportY - (rect ? rect.top : 0);
  	}

  function stringToNewUTF8(jsString) {
      var length = lengthBytesUTF8(jsString)+1;
      var cString = _malloc(length);
      stringToUTF8(jsString, cString, length);
      return cString;
    }
  function _JS_DOM_UnityCanvasSelector() {
  		var canvasSelector = jsCanvasSelector();
  		if (_JS_DOM_UnityCanvasSelector.selector != canvasSelector) {
  			_free(_JS_DOM_UnityCanvasSelector.ptr);
  			_JS_DOM_UnityCanvasSelector.ptr = stringToNewUTF8(canvasSelector);
  			_JS_DOM_UnityCanvasSelector.selector = canvasSelector;
  		}
  		return _JS_DOM_UnityCanvasSelector.ptr;
  	}

  function _JS_Eval_OpenURL(ptr)
  {
  	var str = UTF8ToString(ptr);
  	window.open(str, '_blank', '');
  }

  var fs = {numPendingSync:0,syncInternal:1000,syncInProgress:false,sync:function(onlyPendingSync)
  	{
  		if (onlyPendingSync) {
  			if (fs.numPendingSync == 0)
  				return;
  		}
  		else if (fs.syncInProgress) {
  			// this is to avoid indexedDB memory leak when FS.syncfs is executed before the previous one completed.
  			fs.numPendingSync++;
  			return;
  		}
  
  		fs.syncInProgress = true;
  		FS.syncfs(false, (function(err) {
  			fs.syncInProgress = false;
  		}));
  		fs.numPendingSync = 0;
  	}};
  function _JS_FileSystem_Initialize()
  {
  	Module.setInterval(function(){
  		fs.sync(true);
  	}, fs.syncInternal);
  }

  function _JS_FileSystem_Sync()
  {
  	fs.sync(false);
  }

  var JS_GravitySensor = null;
  function _JS_GravitySensor_IsRunning() {
          return (typeof GravitySensor !== 'undefined') ? (JS_GravitySensor && JS_GravitySensor.activated) : JS_GravitySensor_callback != 0;
      }

  function JS_GravitySensor_eventHandler() {
          if (JS_GravitySensor_callback != 0)
              dynCall_vfff(JS_GravitySensor_callback,
                  JS_GravitySensor.x * JS_Accelerometer_multiplier,
                  JS_GravitySensor.y * JS_Accelerometer_multiplier,
                  JS_GravitySensor.z * JS_Accelerometer_multiplier);
      }
  
  var JS_GravitySensor_frequencyRequest = 0;
  
  var JS_LinearAccelerationSensor = null;
  
  function JS_LinearAccelerationSensor_eventHandler() {
          var linearAccelerationValue = {
              x: JS_LinearAccelerationSensor.x * JS_Accelerometer_multiplier,
              y: JS_LinearAccelerationSensor.y * JS_Accelerometer_multiplier,
              z: JS_LinearAccelerationSensor.z * JS_Accelerometer_multiplier
          };
          if (JS_LinearAccelerationSensor_callback != 0)
              dynCall_vfff(JS_LinearAccelerationSensor_callback, linearAccelerationValue.x, linearAccelerationValue.y, linearAccelerationValue.z);
  
          // Calculate and call the Gravity callback if the Gravity Sensor API isn't present
          if (JS_GravitySensor_callback != 0 && typeof GravitySensor === 'undefined') {
              var gravityValue = JS_ComputeGravity(JS_Accelerometer_lastValue, linearAccelerationValue);
              dynCall_vfff(JS_GravitySensor_callback, gravityValue.x, gravityValue.y, gravityValue.z);
          }
      }
  
  var JS_LinearAccelerationSensor_frequencyRequest = 0;
  
  var JS_LinearAccelerationSensor_frequency = 0;
  function _JS_LinearAccelerationSensor_Start(callback, frequency) {
          // callback can be zero here when called via JS_GravitySensor_Start
  
          JS_DefineAccelerometerMultiplier();
  
          // If we don't have new sensor API, fallback to old DeviceMotionEvent
          if (typeof LinearAccelerationSensor === 'undefined') {
              JS_DeviceMotion_add(); // Must call before we set the callback
              if (callback != 0) JS_LinearAccelerationSensor_callback = callback;
              return;
          }
  
          if (callback != 0) JS_LinearAccelerationSensor_callback = callback;
  
          function InitializeLinearAccelerationSensor(frequency) {
              // Use device referenceFrame, since New Input System package does its own compensation
              JS_LinearAccelerationSensor = new LinearAccelerationSensor({ frequency: frequency, referenceFrame: 'device' });
              JS_LinearAccelerationSensor.addEventListener('reading', JS_LinearAccelerationSensor_eventHandler);
              JS_LinearAccelerationSensor.addEventListener('error', function(e) {
                  // e.error could be DOMException: Could not connect to a sensor
                  warnOnce((e.error) ? e.error : e);
              });
              JS_LinearAccelerationSensor.start();
              JS_LinearAccelerationSensor_frequency = frequency;
          }
  
          // If the sensor is already created, stop and re-create it with new frequency
          if (JS_LinearAccelerationSensor) {
              if (JS_LinearAccelerationSensor_frequency != frequency) {
                  JS_LinearAccelerationSensor.stop();
                  JS_LinearAccelerationSensor.removeEventListener('reading', JS_LinearAccelerationSensor_eventHandler);
                  InitializeLinearAccelerationSensor(frequency);
              }
          }
          else if (JS_LinearAccelerationSensor_frequencyRequest != 0) {
              // If the permissions promise is currently in progress, then note new frequency only
              JS_LinearAccelerationSensor_frequencyRequest = frequency;
          }
          else {
              JS_LinearAccelerationSensor_frequencyRequest = frequency;
  
              // Request required permission for the LinearAccelerationSensor
              navigator.permissions.query({name: 'accelerometer'})
                  .then(function(result) {
                      if (result.state === "granted") {
                          InitializeLinearAccelerationSensor(JS_LinearAccelerationSensor_frequencyRequest);
                      } else {
                          warnOnce("No permission to use LinearAccelerationSensor.");
                      }
                      JS_LinearAccelerationSensor_frequencyRequest = 0;
              });
          }
      }
  function _JS_GravitySensor_Start(callback, frequency) {
          assert(callback != 0, 'Invalid callback passed to JS_GravitySensor_Start');
  
          // If we don't have explicit new Gravity Sensor API, start the Accelerometer and LinearAccelerationSensor
          // and we will compute the gravity value from those readings
          if (typeof GravitySensor === 'undefined') {
              // Start both Accelerometer and LinearAccelerationSensor
              _JS_Accelerometer_Start(0, Math.max(frequency, JS_Accelerometer_frequency));
              _JS_LinearAccelerationSensor_Start(0, Math.max(frequency, JS_LinearAccelerationSensor_frequency));
  
              // Add the gravity sensor callback (must be after Accelerometer and LinearAccelerationSensor start)
              JS_GravitySensor_callback = callback;
              return;
          }
  
          JS_DefineAccelerometerMultiplier();
  
          JS_GravitySensor_callback = callback;
  
          function InitializeGravitySensor(frequency) {
              // Use device referenceFrame, since New Input System package does its own compensation
              JS_GravitySensor = new GravitySensor({ frequency: frequency, referenceFrame: 'device' });
              JS_GravitySensor.addEventListener('reading', JS_GravitySensor_eventHandler);
              JS_GravitySensor.addEventListener('error', function(e) {
                  // e.error could be DOMException: Could not connect to a sensor
                  warnOnce((e.error) ? e.error : e);
              });
              JS_GravitySensor.start();
          }
  
          // If the sensor is already created, stop and re-create it with new frequency
          if (JS_GravitySensor) {
              JS_GravitySensor.stop();
              JS_GravitySensor.removeEventListener('reading', JS_GravitySensor_eventHandler);
              InitializeGravitySensor(frequency);
          }
          else if (JS_GravitySensor_frequencyRequest != 0) {
              // If the permissions promise is currently in progress, then note new frequency only
              JS_GravitySensor_frequencyRequest = frequency;
          }
          else {
              JS_GravitySensor_frequencyRequest = frequency;
  
              // Request required permission for the GravitySensor
              navigator.permissions.query({name: 'accelerometer'})
                  .then(function(result) {
                      if (result.state === "granted") {
                          InitializeGravitySensor(JS_GravitySensor_frequencyRequest);
                      } else {
                          warnOnce("No permission to use GravitySensor.");
                      }
                      JS_GravitySensor_frequencyRequest = 0;
              });
          }
      }

  function _JS_LinearAccelerationSensor_Stop() {
          if (JS_LinearAccelerationSensor) {
              // Only actually stop the Linear Acceleration Sensor if we don't need it to compute gravity values
              if (typeof GravitySensor !== 'undefined' || JS_GravitySensor_callback == 0) {
                  JS_LinearAccelerationSensor.stop();
                  JS_LinearAccelerationSensor.removeEventListener('reading', JS_LinearAccelerationSensor_eventHandler);
                  JS_LinearAccelerationSensor = null;
              }
              JS_LinearAccelerationSensor_callback = 0;
              JS_LinearAccelerationSensor_frequency = 0;
          }
          else if (JS_LinearAccelerationSensor_callback != 0) {
              JS_LinearAccelerationSensor_callback = 0;
              JS_DeviceMotion_remove();
          }
      }
  function _JS_GravitySensor_Stop() {
          JS_GravitySensor_callback = 0;
  
          // If we don't have Gravity Sensor API, stop the Accelerometer and LinearAccelerationSensor
          if (typeof GravitySensor === 'undefined') {
              // Stop the source sensors if they're not used explicitly by Unity
              if (JS_Accelerometer_callback == 0) _JS_Accelerometer_Stop();
              if (JS_LinearAccelerationSensor_callback == 0) _JS_LinearAccelerationSensor_Stop();
              return;
          }
  
          if (JS_GravitySensor) {
              JS_GravitySensor.stop();
              JS_GravitySensor.removeEventListener('reading', JS_GravitySensor_eventHandler);
              JS_GravitySensor = null;
          }
      }

  function _JS_GuardAgainstJsExceptions(cb) {
  		try {
  			(function() {  dynCall_v.call(null, cb); })();
  		} catch(e) {
  			console.warn(e);
  		}
  	}

  var JS_Gyroscope = null;
  function _JS_Gyroscope_IsRunning() {
          // Sensor is running if there is an activated new JS_Gyroscope; or the JS_Gyroscope_callback is hooked up
          return (JS_Gyroscope && JS_Gyroscope.activated) || (JS_Gyroscope_callback != 0);
      }

  function JS_Gyroscope_eventHandler() {
          // Radians per second
          if (JS_Gyroscope_callback != 0)
              dynCall_vfff(JS_Gyroscope_callback, JS_Gyroscope.x, JS_Gyroscope.y, JS_Gyroscope.z);
      }
  
  var JS_Gyroscope_frequencyRequest = 0;
  function _JS_Gyroscope_Start(callback, frequency) {
          assert(callback != 0, 'Invalid callback passed to JS_Gyroscope_Start');
  
          // If we don't have new sensor API, fallback to old DeviceMotionEvent
          if (typeof Gyroscope === 'undefined') {
              JS_DeviceMotion_add(); // Must call before we set the callback
              JS_Gyroscope_callback = callback;
              return;
          }
  
          JS_Gyroscope_callback = callback;
  
          function InitializeGyroscope(frequency) {
              // Use device referenceFrame, since New Input System package does its own compensation
              JS_Gyroscope = new Gyroscope({ frequency: frequency, referenceFrame: 'device' });
              JS_Gyroscope.addEventListener('reading', JS_Gyroscope_eventHandler);
              JS_Gyroscope.addEventListener('error', function(e) {
                  // e.error could be DOMException: Could not connect to a sensor
                  warnOnce((e.error) ? e.error : e);
              });
              JS_Gyroscope.start();
          }
  
          // If the sensor is already created, stop and re-create it with new frequency
          if (JS_Gyroscope) {
              JS_Gyroscope.stop();
              JS_Gyroscope.removeEventListener('reading', JS_Gyroscope_eventHandler);
              InitializeGyroscope(frequency);
          }
          else if (JS_Gyroscope_frequencyRequest != 0) {
              // If the permissions promise is currently in progress, then note new frequency only
              JS_Gyroscope_frequencyRequest = frequency;
          }
          else {
              JS_Gyroscope_frequencyRequest = frequency;
  
              // Request required permission for the Gyroscope
              navigator.permissions.query({name: 'gyroscope'})
                  .then(function(result) {
                      if (result.state === "granted") {
                          InitializeGyroscope(JS_Gyroscope_frequencyRequest);
                      } else {
                          warnOnce("No permission to use Gyroscope.");
                      }
                      JS_Gyroscope_frequencyRequest = 0;
              });
          }
      }

  function _JS_Gyroscope_Stop() {
          if (JS_Gyroscope) {
              JS_Gyroscope.stop();
              JS_Gyroscope.removeEventListener('reading', JS_Gyroscope_eventHandler);
              JS_Gyroscope = null;
              JS_Gyroscope_callback = 0;
          }
          else if (JS_Gyroscope_callback != 0) {
              JS_Gyroscope_callback = 0;
              JS_DeviceMotion_remove();
          }
      }

  function _JS_Init_ContextMenuHandler() {
          const _handleContextMenu = function (event){
              if(event.target.localName !== "canvas")
                  _ReleaseKeys();
          }
  
          document.addEventListener("contextmenu", _handleContextMenu);
  
          Module.deinitializers.push(function() {
              document.removeEventListener("contextmenu", _handleContextMenu);
          });
      }

  function _JS_LinearAccelerationSensor_IsRunning() {
          // Sensor is running if there is an activated new JS_LinearAccelerationSensor; or the JS_LinearAccelerationSensor_callback is hooked up
          return (JS_LinearAccelerationSensor && JS_LinearAccelerationSensor.activated) || (JS_LinearAccelerationSensor_callback != 0);
      }



  function _JS_Log_Dump(ptr, type)
  {
  	var str = UTF8ToString(ptr);
  	if (typeof dump == 'function')
  		dump (str);
  	switch (type)
  	{
  		case 0: //LogType_Error
  		case 1: //LogType_Assert
  		case 4: //LogType_Exception
  			console.error (str);
  			return;
  
  		case 2: //LogType_Warning
  			console.warn (str);
  			return;
  
  		case 3: //LogType_Log
  		case 5: //LogType_Debug
  			console.log (str);
  			return;			
  
  		default:
  			console.error ("Unknown console message type!")
  			console.error (str);
  	}
  }

  function _JS_Log_StackTrace(buffer, bufferSize)
  {
  	var trace = stackTrace();
  	if (buffer)
  		stringToUTF8(trace, buffer, bufferSize);
  	return lengthBytesUTF8(trace);	
  }

  var mobile_input_hide_delay = null;
  var mobile_input_text = null;
  var mobile_input = null;
  var mobile_input_ignore_blur_event = false;
  function _JS_MobileKeybard_GetIgnoreBlurEvent() {
      // On some platforms, such as iOS15, a blur event is sent to the window after the keyboard
      // is closed. This causes the game to be paused in the blur event handler in ScreenManagerWebGL.
      // It checks this return value to see if it should ignore the blur event.
      return mobile_input_ignore_blur_event;
  }

  function _JS_MobileKeyboard_GetKeyboardStatus()
  {
      var kKeyboardStatusVisible = 0;
      var kKeyboardStatusDone = 1;
      //var kKeyboardStatusCanceled = 2;
      //var kKeyboardStatusLostFocus = 3;
      if (!mobile_input) return kKeyboardStatusDone;
      return kKeyboardStatusVisible;
  }

  function _JS_MobileKeyboard_GetText(buffer, bufferSize)
  {
      // If the keyboard was closed, use the cached version of the input's text so that Unity can
      // still ask for it.
      var text = mobile_input && mobile_input.input ? mobile_input.input.value :
          mobile_input_text ? mobile_input_text :
          "";
      if (buffer) stringToUTF8(text, buffer, bufferSize);
      return lengthBytesUTF8(text);
  }

  function _JS_MobileKeyboard_GetTextSelection(outStart, outLength)
  {
      if (!mobile_input) {
          HEAP32[outStart >> 2] = 0;
          HEAP32[outLength >> 2] = 0;
          return;
      }
      HEAP32[outStart >> 2] = mobile_input.input.selectionStart;
      HEAP32[outLength >> 2] = mobile_input.input.selectionEnd - mobile_input.input.selectionStart;
  }

  function _JS_MobileKeyboard_Hide(delay)
  {
      if (mobile_input_hide_delay) return;
      mobile_input_ignore_blur_event = true;
  
      function hideMobileKeyboard() {
          if (mobile_input && mobile_input.input) {
              mobile_input_text = mobile_input.input.value;
              mobile_input.input = null;
              if (mobile_input.parentNode && mobile_input.parentNode) {
                  mobile_input.parentNode.removeChild(mobile_input);
              }
          }
          mobile_input = null;
          mobile_input_hide_delay = null;
  
          // mobile_input_ignore_blur_event was set to true so that ScreenManagerWebGL will ignore
          // the blur event it might get from the closing of the keyboard. But it might not get that
          // blur event, too, depending on the browser. So we want to clear the flag, as soon as we
          // can, but some time after the blur event has been potentially fired.
          setTimeout(function() {
              mobile_input_ignore_blur_event = false;
          }, 100);
      }
  
      if (delay) {
          // Delaying the hide of the input/keyboard allows a new input to be selected and re-use the
          // existing control. This fixes a problem where a quick tap select of a new element would
          // cause it to not be displayed because it tried to be focused before the old keyboard finished
          // sliding away.
          var hideDelay = 200;
          mobile_input_hide_delay = setTimeout(hideMobileKeyboard, hideDelay);
      } else {
          hideMobileKeyboard();
      }
  }

  function _JS_MobileKeyboard_SetCharacterLimit(limit)
  {
      if (!mobile_input) return;
      mobile_input.input.maxLength = limit;
  }

  function _JS_MobileKeyboard_SetText(text)
  {
      if (!mobile_input) return;
      text = UTF8ToString(text);
      mobile_input.input.value = text;
  }

  function _JS_MobileKeyboard_SetTextSelection(start, length)
  {
      if (!mobile_input) return;
      if(mobile_input.input.type === "number"){ // The type of input field has to be changed to use setSelectionRange
          mobile_input.input.type = "text";
          mobile_input.input.setSelectionRange(start, start + length);
          mobile_input.input.type = "number";
      } else {
          mobile_input.input.setSelectionRange(start, start + length);
      }
  }

  function _JS_MobileKeyboard_Show(text, keyboardType, autocorrection, multiline, secure, alert,
                                   placeholder, characterLimit)
  {
      if (mobile_input_hide_delay) {
          clearTimeout(mobile_input_hide_delay);
          mobile_input_hide_delay = null;
      }
  
      text = UTF8ToString(text);
      mobile_input_text = text;
  
      placeholder = UTF8ToString(placeholder);
  
      var container = document.body;
  
      var hasExistingMobileInput = !!mobile_input;
  
      // From KeyboardOnScreen::KeyboardTypes
      var input_type;
      var KEYBOARD_TYPE_NUMBERS_AND_PUNCTUATION = 2;
      var KEYBOARD_TYPE_URL = 3;
      var KEYBOARD_TYPE_NUMBER_PAD = 4;
      var KEYBOARD_TYPE_PHONE_PAD = 5;
      var KEYBOARD_TYPE_EMAIL_ADDRESS = 7;
      if (!secure) {
          switch (keyboardType) {
              case KEYBOARD_TYPE_EMAIL_ADDRESS:
                  input_type = "email";
                  break;
              case KEYBOARD_TYPE_URL:
                  input_type = "url";
                  break;
              case KEYBOARD_TYPE_NUMBERS_AND_PUNCTUATION:
              case KEYBOARD_TYPE_NUMBER_PAD:
              case KEYBOARD_TYPE_PHONE_PAD:
                  input_type = "number";
                  break;
              default:
                  input_type = "text";
                  break;
          }
      } else {
          input_type = "password";
      }
  
      if (hasExistingMobileInput) {
          if (mobile_input.multiline != multiline) {
              _JS_MobileKeyboard_Hide(false);
              return;
          }
      }
  
      var inputContainer = mobile_input || document.createElement("div");
      if (!hasExistingMobileInput) {
          inputContainer.style = "width:100%; position:fixed; bottom:0px; margin:0px; padding:0px; left:0px; border: 1px solid #000; border-radius: 5px; background-color:#fff; font-size:14pt;";
          container.appendChild(inputContainer);
          mobile_input = inputContainer;
      }
  
      var input = hasExistingMobileInput ?
          mobile_input.input :
          document.createElement(multiline ? "textarea" : "input");
  
      mobile_input.multiline = multiline;
      mobile_input.secure = secure;
      mobile_input.keyboardType = keyboardType;
      mobile_input.inputType = input_type;
  
      input.type = input_type;
      input.style = "width:calc(100% - 85px); " + (multiline ? "height:100px;" : "") + "vertical-align:top; border-radius: 5px; outline:none; cursor:default; resize:none; border:0px; padding:10px 0px 10px 10px;";
  
      input.spellcheck = autocorrection ? true : false;
      input.maxLength = characterLimit > 0 ? characterLimit : 524288;
      input.value = text;
      input.placeholder = placeholder;
  
      if (!hasExistingMobileInput) {
          inputContainer.appendChild(input);
          inputContainer.input = input;
      }
  
      if (!hasExistingMobileInput) {
          var okButton = document.createElement("button");
          okButton.innerText = "OK";
          okButton.style = "border:0; position:absolute; left:calc(100% - 75px); top:0px; width:75px; height:100%; margin:0; padding:0; border-radius: 5px; background-color:#fff";
          okButton.addEventListener("touchend", function() {
              _JS_MobileKeyboard_Hide(true);
          });
  
          inputContainer.appendChild(okButton);
          inputContainer.okButton = okButton;
  
          // For single-line text input, enter key will close the keyboard.
          input.addEventListener('keyup', function(e) {
              if (input.parentNode.multiline) return;
              if (e.code == 'Enter' || e.which == 13 || e.keyCode == 13) {
                  _JS_MobileKeyboard_Hide(true);
              }
          });
  
          // On iOS, the keyboard has a done button that hides the keyboard. The only way to detect
          // when this happens seems to be when the HTML input looses focus, so we watch for the blur
          // event on the input element and close the element/keybaord when it's gotten.
          input.addEventListener("blur", function(e) {
              _JS_MobileKeyboard_Hide(true);
              e.stopPropagation();
              e.preventDefault();
          });
  
          input.select();
          input.focus();
      } else {
          input.select();
      }
  }

  var JS_OrientationSensor = null;
  
  var JS_OrientationSensor_callback = 0;
  function _JS_OrientationSensor_IsRunning() {
          // Sensor is running if there is an activated new JS_OrientationSensor; or the DeviceOrientation handler is hooked up
          return (JS_OrientationSensor && JS_OrientationSensor.activated) || (JS_OrientationSensor_callback != 0);
      }

  function JS_OrientationSensor_eventHandler() {
          if (JS_OrientationSensor_callback != 0)
              dynCall_vffff(JS_OrientationSensor_callback, JS_OrientationSensor.quaternion[0], JS_OrientationSensor.quaternion[1], JS_OrientationSensor.quaternion[2], JS_OrientationSensor.quaternion[3]);
      }
  
  var JS_OrientationSensor_frequencyRequest = 0;
  
  function JS_DeviceOrientation_eventHandler(event) {
          if (JS_OrientationSensor_callback) {
              // OBSERVATION: On Android Firefox, absolute = false, webkitCompassHeading = null
              // OBSERVATION: On iOS Safari, absolute is undefined, webkitCompassHeading and webkitCompassAccuracy are set
  
              // Convert alpha, beta, gamma Euler angles to a quaternion
              var degToRad = Math.PI / 180;
              var x = event.beta * degToRad;
              var y = event.gamma * degToRad;
              var z = event.alpha * degToRad;
  
              var cx = Math.cos(x/2);
              var sx = Math.sin(x/2);
              var cy = Math.cos(y/2);
              var sy = Math.sin(y/2);
              var cz = Math.cos(z/2);
              var sz = Math.sin(z/2);
  
              var qx = sx * cy * cz - cx * sy * sz;
              var qy = cx * sy * cz + sx * cy * sz;
              var qz = cx * cy * sz + sx * sy * cz;
              var qw = cx * cy * cz - sx * sy * sz;
  
              dynCall_vffff(JS_OrientationSensor_callback, qx, qy, qz, qw);
          }
      }
  function _JS_OrientationSensor_Start(callback, frequency) {
          assert(callback != 0, 'Invalid callback passed to JS_OrientationSensor_Start');
  
          // If we don't have new sensor API, fallback to old DeviceOrientationEvent
          if (typeof RelativeOrientationSensor === 'undefined') {
              if (JS_OrientationSensor_callback == 0) {
                  JS_OrientationSensor_callback = callback;
                  JS_RequestDeviceSensorPermissions(1/*DeviceOrientationEvent permission*/);
                  window.addEventListener('deviceorientation', JS_DeviceOrientation_eventHandler);
              }
              return;
          }
  
          JS_OrientationSensor_callback = callback;
  
          function InitializeOrientationSensor(frequency) {
              // Use device referenceFrame, since New Input System package does its own compensation
              // Use relative orientation to match native players
              JS_OrientationSensor = new RelativeOrientationSensor({ frequency: frequency, referenceFrame: 'device' });
              JS_OrientationSensor.addEventListener('reading', JS_OrientationSensor_eventHandler);
              JS_OrientationSensor.addEventListener('error', function(e) {
                  // e.error could be DOMException: Could not connect to a sensor
                  warnOnce((e.error) ? e.error : e);
              });
              JS_OrientationSensor.start();
          }
  
          // If the sensor is already created, stop and re-create it with new frequency
          if (JS_OrientationSensor) {
              JS_OrientationSensor.stop();
              JS_OrientationSensor.removeEventListener('reading', JS_OrientationSensor_eventHandler);
              InitializeOrientationSensor(frequency);
          }
          else if (JS_OrientationSensor_frequencyRequest != 0) {
              // If the permissions promise is currently in progress, then note new frequency only
              JS_OrientationSensor_frequencyRequest = frequency;
          }
          else {
              JS_OrientationSensor_frequencyRequest = frequency;
  
              // Request required permissions for the RelativeOrientationSensor
              Promise.all([navigator.permissions.query({ name: "accelerometer" }),
                           navigator.permissions.query({ name: "gyroscope" })])
                  .then(function(results) {
                      if (results.every(function(result) {return(result.state === "granted");})) {
                          InitializeOrientationSensor(JS_OrientationSensor_frequencyRequest);
                      } else {
                          warnOnce("No permissions to use RelativeOrientationSensor.");
                      }
                      JS_OrientationSensor_frequencyRequest = 0;
              });
          }
      }

  function _JS_OrientationSensor_Stop() {
          if (JS_OrientationSensor) {
              JS_OrientationSensor.stop();
              JS_OrientationSensor.removeEventListener('reading', JS_OrientationSensor_eventHandler);
              JS_OrientationSensor = null;
          }
          else if (JS_OrientationSensor_callback != 0) {
              window.removeEventListener('deviceorientation', JS_DeviceOrientation_eventHandler);
          }
          JS_OrientationSensor_callback = 0;
      }

  function _JS_Profiler_InjectJobs()
  {
    for (var jobname in Module["Jobs"])
    {
      var job = Module["Jobs"][jobname];
      if (typeof job["endtime"] != "undefined")
         Module.ccall("InjectProfilerSample", null, ["string", "number", "number"], [jobname, job.starttime, job.endtime]);
     }
  }

  function _JS_RequestDeviceSensorPermissionsOnTouch() {
          if (JS_DeviceSensorPermissions == 0) return;
  
          // Re-request any required device sensor permissions (iOS requires that permissions are requested on a user interaction event)
          JS_RequestDeviceSensorPermissions(JS_DeviceSensorPermissions);
      }

  function _JS_RunQuitCallbacks() {
  	Module.QuitCleanup();
  }

  var JS_ScreenOrientation_callback = 0;
  function JS_ScreenOrientation_eventHandler() {
  		if (JS_ScreenOrientation_callback) dynCall_viii(JS_ScreenOrientation_callback, window.innerWidth, window.innerHeight, screen.orientation ? screen.orientation.angle : window.orientation);
  	}
  function _JS_ScreenOrientation_DeInit() {
  		JS_ScreenOrientation_callback = 0;
  		window.removeEventListener('resize', JS_ScreenOrientation_eventHandler);
  		if (screen.orientation) {
  			screen.orientation.removeEventListener('change', JS_ScreenOrientation_eventHandler);
  		}
  	}

  function _JS_ScreenOrientation_Init(callback) {
  		// Only register if not yet registered
  		if (!JS_ScreenOrientation_callback) {
  			if (screen.orientation) {
  				// Use Screen Orientation API if available:
  				// - https://www.w3.org/TR/screen-orientation/
  				// - https://caniuse.com/screen-orientation
  				// - https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
  				// (Firefox, Chrome, Chrome for Android, Firefox for Android)
  				screen.orientation.addEventListener('change', JS_ScreenOrientation_eventHandler);
  			}
  
  			// As a fallback, use deprecated DOM window.orientation field if available:
  			// - https://compat.spec.whatwg.org/#dom-window-orientation
  			// - https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation
  			// (Safari for iOS)
  			// Listening to resize event also helps emulate landscape/portrait transitions on desktop
  			// browsers when the browser window is scaled to narrow/wide configurations.
  			window.addEventListener('resize', JS_ScreenOrientation_eventHandler);
  
  			JS_ScreenOrientation_callback = callback;
  
  			// Trigger the event handler immediately after the engine initialization is done to start up
  			// ScreenManager with the initial state.
  			setTimeout(JS_ScreenOrientation_eventHandler, 0);
  		}
  	}

  var JS_ScreenOrientation_requestedLockType = -1;
  
  var JS_ScreenOrientation_appliedLockType = -1;
  
  var JS_ScreenOrientation_timeoutID = -1;
  function _JS_ScreenOrientation_Lock(orientationLockType) {
  		// We will use the Screen Orientation API if available, and silently return if not available
  		// - https://www.w3.org/TR/screen-orientation/
  		// - https://caniuse.com/screen-orientation
  		// - https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
  		if (!screen.orientation || !screen.orientation.lock) {
  			// As of writing, this is only not implemented on Safari
  			return;
  		}
  
  		// Callback to apply the lock
  		function applyLock() {
  			JS_ScreenOrientation_appliedLockType = JS_ScreenOrientation_requestedLockType;
  
  			// Index must match enum class OrientationLockType in ScreenOrientation.h
  			var screenOrientations = ['any', 0/*natural*/, 'landscape', 'portrait', 'portrait-primary', 'portrait-secondary', 'landscape-primary', 'landscape-secondary' ];
  			var type = screenOrientations[JS_ScreenOrientation_appliedLockType];
  
  			assert(type, 'Invalid orientationLockType passed to JS_ScreenOrientation_Lock');
  
  			// Apply the lock, which is done asynchronously and returns a Promise
  			screen.orientation.lock(type).then(function() {
  				// Upon success, see if the JS_ScreenOrientation_requestedLockType value has changed, in which case, we will now need to queue another applyLock
  				if (JS_ScreenOrientation_requestedLockType != JS_ScreenOrientation_appliedLockType) {
  					JS_ScreenOrientation_timeoutID = setTimeout(applyLock, 0);
  				}
  				else {
  					JS_ScreenOrientation_timeoutID = -1;
  				}
  			}).catch(function(err) {
  				// When screen.orientation.lock() is called on a desktop browser, a DOMException is thrown by the promise
  				warnOnce(err);
  				JS_ScreenOrientation_timeoutID = -1;
  			});
  
  			// Note, there is also an screen.orientation.unlock() which unlocks auto rotate to default orientation.
  			// On my Google Pixel 5, this allows 'portrait-primary' AND 'landscape', but will differ depending on device.
  		}
  
  		// Request this orientationLockType be applied on the callback
  		JS_ScreenOrientation_requestedLockType = orientationLockType;
  
  		// Queue applyLock callback if there is not already a callback or a screen.orientation.lock call in progress
  		if (JS_ScreenOrientation_timeoutID == -1 && orientationLockType != JS_ScreenOrientation_appliedLockType) {
  			JS_ScreenOrientation_timeoutID = setTimeout(applyLock, 0);
  		}
  	}

  var WEBAudio = {audioInstanceIdCounter:0,audioInstances:{},audioContext:null,audioWebEnabled:0,audioCache:[],pendingAudioSources:{}};
  function jsAudioMixinSetPitch(source) {
  	// Add a helper to AudioBufferSourceNode which gives the current playback position of the clip in seconds.
  	source.estimatePlaybackPosition = function () {
  		var t = (WEBAudio.audioContext.currentTime - source.playbackStartTime) * source.playbackRate.value;
  		// Collapse extra times that the audio clip has looped through.
  		if (source.loop && t >= source.loopStart) {
  			t = (t - source.loopStart) % (source.loopEnd - source.loopStart) + source.loopStart;
  		}
  		return t;
  	}
  
  	// Add a helper to AudioBufferSourceNode to allow adjusting pitch in a way that keeps playback position estimation functioning.
  	source.setPitch = function (newPitch) {
  		var curPosition = source.estimatePlaybackPosition();
  		if (curPosition >= 0) { // If negative, the clip has not begun to play yet (that delay is not scaled by pitch)
  			source.playbackStartTime = WEBAudio.audioContext.currentTime - curPosition / newPitch;
  		}
  		if (source.playbackRate.value !== newPitch) source.playbackRate.value = newPitch;
  	}
  }
  function jsAudioCreateUncompressedSoundClip(buffer, error) {
  	var soundClip = {
  		buffer: buffer,
  		error: error
  	};
  
  	/**
  	 * Release resources of a sound clip
  	 */
  	soundClip.release = function () { };
  
  	/**
  	 * Get length of sound clip in number of samples
  	 * @returns {number}
  	 */
  	soundClip.getLength = function () {
  		if (!this.buffer) {
  			console.log ("Trying to get length of sound which is not loaded.");
  			return 0;
  		}
  
  		// Fakemod assumes sample rate is 44100, though that's not necessarily the case,
  		// depending on OS, if the audio file was not imported by our pipeline.
  		// Therefore we need to recalculate the length based on the actual samplerate.
  		var sampleRateRatio = 44100 / this.buffer.sampleRate;
  		return this.buffer.length * sampleRateRatio;
  	}
  
  	/**
  	 * Gets uncompressed audio data from sound clip.
  	 * If output buffer is smaller than the sound data only the first portion
  	 * of the sound data is read.
  	 * Sound clips with multiple channels will be stored one after the other.
  	 *
  	 * @param {number} ptr Pointer to the output buffer
  	 * @param {number} length Size of output buffer in bytes
  	 * @returns Size of data in bytes written to output buffer
  	 */
  	soundClip.getData = function (ptr, length) {
  		if (!this.buffer) {
  			console.log ("Trying to get data of sound which is not loaded.");
  			return 0;
  		}
  
  		// Get output buffer
  		var startOutputBuffer = ptr >> 2;
  		var output = HEAPF32.subarray(startOutputBuffer, startOutputBuffer + (length >> 2));
  		var numMaxSamples = Math.floor((length >> 2) / this.buffer.numberOfChannels);
  		var numReadSamples = Math.min(this.buffer.length, numMaxSamples);
  
  		// Copy audio data to outputbuffer
  		for (var i = 0; i < this.buffer.numberOfChannels; i++) {
  			var channelData = this.buffer.getChannelData(i).subarray(0, numReadSamples);
  			output.set(channelData, i * numReadSamples);
  		}
  
  		return numReadSamples * this.buffer.numberOfChannels * 4;
  	}
  
  	/**
  	 * Gets number of channels of soundclip
  	 * @returns {number}
  	 */
  	soundClip.getNumberOfChannels = function () {
  		if (!this.buffer) {
  			console.log ("Trying to get metadata of sound which is not loaded.");
  			return 0;
  		}
  
  		return this.buffer.numberOfChannels;
  	}
  
  	/**
  	 * Gets sampling rate in Hz
  	 * @returns {number}
  	 */
  	soundClip.getFrequency = function () {
  		if (!this.buffer) {
  			console.log ("Trying to get metadata of sound which is not loaded.");
  			return 0;
  		}
  
  		return this.buffer.sampleRate;
  	}
  
  	/**
  	 * Create an audio source node.
  	 * @returns {AudioBufferSourceNode}
  	 */
  	soundClip.createSourceNode = function () {
  		if (!this.buffer) {
  			console.log ("Trying to play sound which is not loaded.");
  		}
  
  		var source = WEBAudio.audioContext.createBufferSource();
  		source.buffer = this.buffer;
  		jsAudioMixinSetPitch(source);
  
  		return source;
  	};
  
  	return soundClip;
  }
  function jsAudioCreateChannel(callback, userData) {
  	var channel = {
  		callback: callback,
  		userData: userData,
  		source: null,
  		gain: WEBAudio.audioContext.createGain(),
  		panner: WEBAudio.audioContext.createPanner(),
  		threeD: false,
  		loop: false,
  		loopStart: 0,
  		loopEnd: 0,
  		pitch: 1.0
  	};
  
  	channel.panner.rolloffFactor = 0; // We calculate rolloff ourselves.
  
  	/**
  	 * Release internal resources.
  	 */
  	channel.release = function () {
  		// Explicitly disconnect audio nodes related to this audio channel when the channel should be
  		// GCd to work around Safari audio performance bug that resulted in crackling audio; as suggested
  		// in https://bugs.webkit.org/show_bug.cgi?id=222098#c23
  		this.disconnectSource();
  		this.gain.disconnect();
  		this.panner.disconnect();
  	}
  
  	/**
  	 * Play a sound clip on the channel
  	 * @param {UncompressedSoundClip|CompressedSoundClip} soundClip
  	 * @param {number} startTime Scheduled start time in seconds
  	 * @param {number} startOffset Start offset in seconds
  	 */
  	channel.playSoundClip = function (soundClip, startTime, startOffset) {
  		try {
  			var self = this;
  			this.source = soundClip.createSourceNode();
  			this.setupPanning();
  
  			// Setup on ended callback
  			this.source.onended = function () {
  				self.source.isStopped = true;
  				self.disconnectSource();
  				if (self.callback) {
  					dynCall("vi", self.callback, [self.userData]);
  				}
  			};
  
  			this.source.loop = this.loop;
  			this.source.loopStart = this.loopStart;
  			this.source.loopEnd = this.loopEnd;
  			this.source.start(startTime, startOffset);
  			this.source.playbackStartTime = startTime - startOffset / this.source.playbackRate.value;
  			this.source.setPitch(this.pitch);
  		} catch (e) {
  			// Need to catch exception, otherwise execution will stop on Safari if audio output is missing/broken
  			console.error("Channel.playSoundClip error. Exception: " + e);
  		}
  	};
  
  	/**
  	 * Stop playback on channel
  	 */
  	channel.stop = function (delay) {
  		if (!this.source) {
  			return;
  		}
  
  		// stop source currently playing.
  		try {
  			channel.source.stop(WEBAudio.audioContext.currentTime + delay);
  		} catch (e) {
  			// when stop() is used more than once for the same source in Safari it causes the following exception:
  			// InvalidStateError: DOM Exception 11: An attempt was made to use an object that is not, or is no longer, usable.
  			// Ignore that exception.
  		}
  
  		if (delay == 0) {
  			this.disconnectSource();
  		}
  	};
  
  	/**
  	 * Return wether the channel is currently paused
  	 * @returns {boolean}
  	 */
  	channel.isPaused = function () {
  		if (!this.source) {
  			return true;
  		}
  
  		if (this.source.isPausedMockNode) {
  			return true;
  		}
  
  		if (this.source.mediaElement) {
  			return this.source.mediaElement.paused || this.source.pauseRequested;
  		}
  
  		return false;
  	};
  
  	/**
  	 * Pause playback of channel
  	 */
  	channel.pause = function () {
  		if (!this.source || this.source.isPausedMockNode) {
  			return;
  		}
  
  		if (this.source.mediaElement) {
  			this.source._pauseMediaElement();
  			return;
  		}
  
  		// WebAudio does not have support for pausing and resuming AudioBufferSourceNodes (they are a fire-once abstraction)
  		// When we want to pause a node, create a mocked object in its place that represents the needed state that is required
  		// for resuming the clip.
  		var pausedSource = {
  			isPausedMockNode: true,
  			buffer: this.source.buffer,
  			loop: this.source.loop,
  			loopStart: this.source.loopStart,
  			loopEnd: this.source.loopEnd,
  			playbackRate: this.source.playbackRate.value,
  			scheduledStopTime: undefined,
  			// Specifies in seconds the time at the clip where the playback was paused at.
  			// Can be negative if the audio clip has not started yet.
  			playbackPausedAtPosition: this.source.estimatePlaybackPosition(),
  			setPitch: function (v) { this.playbackRate = v; },
  			stop: function(when) { this.scheduledStopTime = when; }
  		};
  		// Stop and clear the real audio source...
  		this.stop(0);
  		this.disconnectSource();
  		// .. and replace the source with a paused mock version.
  		this.source = pausedSource;
  	};
  
  	/**
  	 * Resume playback on channel.
  	 */
  	channel.resume = function () {
  		// If the source is a compressed audio MediaElement, it was directly paused so we can
  		// directly play it again.
  		if (this.source && this.source.mediaElement) {
  			this.source.start(undefined, this.source.currentTime);
  			return;
  		}
  
  		// N.B. We only resume a source that has been previously paused. That is, resume() cannot be used to start playback if
  		// channel was not playing an audio clip before, but playSoundClip() is to be used.
  		if (!this.source || !this.source.isPausedMockNode) {
  			return;
  		}
  
  		var pausedSource = this.source;
  		var soundClip = jsAudioCreateUncompressedSoundClip(pausedSource.buffer, false);
  		this.playSoundClip(soundClip, WEBAudio.audioContext.currentTime, Math.max(0, pausedSource.playbackPausedAtPosition));
  		this.source.loop = pausedSource.loop;
  		this.source.loopStart = pausedSource.loopStart;
  		this.source.loopEnd = pausedSource.loopEnd;
  		this.source.setPitch(pausedSource.playbackRate);
  
  		// Apply scheduled stop of source if present
  		if (typeof pausedSource.scheduledStopTime !== "undefined") {
  			var delay = Math.max(pausedSource.scheduledStopTime - WEBAudio.audioContext.currentTime, 0);
  			this.stop(delay);
  		}
  	};
  
  	/**
  	 * Set loop mode
  	 * @param {boolean} loop If true audio will be looped.
  	 */
  	channel.setLoop = function (loop) {
  		this.loop = loop;
  		if (!this.source || this.source.loop == loop) {
  			return;
  		}
  
  		this.source.loop = loop;
  	}
  
  	/**
  	 * Set loop start and end
  	 * @param {number} loopStart Start of the loop in seconds.
  	 * @param {number} loopEnd End of the loop in seconds.
  	 */
  	channel.setLoopPoints = function (loopStart, loopEnd) {
  		this.loopStart = loopStart;
  		this.loopEnd = loopEnd;
  		if (!this.source) {
  			return;
  		}
  
  		if (this.source.loopStart !== loopStart) {
  			this.source.loopStart = loopStart;
  		}
  
  		if (this.source.loopEnd !== loopEnd) {
  			this.source.loopEnd = loopEnd;
  		}
  	}
  
  	/**
  	 * Set channel 3D mode
  	 * @param {boolean} threeD If true the channel will be played back as 3D audio
  	 */
  	channel.set3D = function (threeD) {
  		if (this.threeD == threeD) {
  			return;
  		}
  		this.threeD = threeD;
  
  		// Only update node graph is source is initialized
  		if (!this.source) {
  			return;
  		}
  
  		this.setupPanning();
  	}
  
  	/**
  	 * Set the pitch of the channel
  	 * @param {number} pitch Pitch of the channel
  	 */
  	channel.setPitch = function (pitch) {
  		this.pitch = pitch;
  
  		// Only update pitch if source is initialized
  		if (!this.source) {
  			return;
  		}
  
  		this.source.setPitch(pitch);
  	}
  
  	/**
  	 * Set volume of channel
  	 * @param {number} volume Volume of channel
  	 */
  	channel.setVolume = function (volume) {
  		// Work around WebKit bug https://bugs.webkit.org/show_bug.cgi?id=222098
  		// Updating volume only if it changes reduces sound distortion over time.
  		// See case 1350204, 1348348 and 1352665
  		if (this.gain.gain.value == volume) {
  			return;
  		}
  
  		this.gain.gain.value = volume;
  	}
  
  	/**
  	 * Set the 3D position of the audio channel
  	 * @param {number} x
  	 * @param {number} y
  	 * @param {number} z
  	 */
  	channel.setPosition = function (x, y, z) {
  		var p = this.panner;
  
  		// Work around Chrome performance bug https://bugs.chromium.org/p/chromium/issues/detail?id=1133233
  		// by only updating the PannerNode position if it has changed.
  		// See case 1270768.
  		if (p.positionX) {
  			// Use new properties if they exist ...
  			if (p.positionX.value !== x) p.positionX.value = x;
  			if (p.positionY.value !== y) p.positionY.value = y;
  			if (p.positionZ.value !== z) p.positionZ.value = z;
  		} else if (p._x !== x || p._y !== y || p._z !== z) {
  			// ... or the deprecated set function if they don't (and shadow cache the set values to avoid re-setting later)
  			p.setPosition(x, y, z);
  			p._x = x;
  			p._y = y;
  			p._z = z;
  		}
  	}
  
  	/**
  	 * Disconnect source node from graph
  	 */
  	channel.disconnectSource = function () {
  		if (!this.source || this.source.isPausedMockNode) {
  			return;
  		}
  
  		if (this.source.mediaElement) {
  			// Pause playback of media element
  			this.source._pauseMediaElement();
  		}
  
  		this.source.onended = null;
  		this.source.disconnect();
  		delete this.source;
  	};
  
  	/**
  	 * Changes this audio channel to either 3D panning or 2D mode (no panning)
  	 */
  	channel.setupPanning = function () {
  		// We have a mocked paused object in effect?
  		if (this.source.isPausedMockNode) return;
  
  		// Configure audio panning options either for 3D or 2D.
  		this.source.disconnect();
  		this.panner.disconnect();
  		this.gain.disconnect();
  		if (this.threeD) {
  			// In 3D: AudioBufferSourceNode/MediaElementSourceNode -> PannerNode -> GainNode -> AudioContext.destination
  			this.source.connect(this.panner);
  			this.panner.connect(this.gain);
  		} else {
  			// In 2D: AudioBufferSourceNode/MediaElementSourceNode -> GainNode -> AudioContext.destination
  			this.source.connect(this.gain);
  		}
  		this.gain.connect(WEBAudio.audioContext.destination);
  	}
  
  	/**
  	 * Returns wether playback on a channel is stopped.
  	 * @returns {boolean} Returns true if playback on channel is stopped.
  	 */
  	 channel.isStopped = function () {
  		if (!this.source) {
  			// Uncompressed audio
  			// No playback source -> channel is stopped
  			return true;
  		}
  
  		if (this.source.mediaElement) {
  			// Compressed audio
  			return this.source.isStopped;
  		} 
  
  		return false;
  	}
  
  	return channel;
  }
  function _JS_Sound_Create_Channel(callback, userData)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter] = jsAudioCreateChannel(callback, userData);
  	return WEBAudio.audioInstanceIdCounter;
  }

  function _JS_Sound_GetLength(bufferInstance)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return 0;
  
  	var soundClip = WEBAudio.audioInstances[bufferInstance];
  
  	if (!soundClip)
  		return 0;
  
  	return soundClip.getLength();
  }

  function _JS_Sound_GetLoadState(bufferInstance)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return 2;
  
  	var sound = WEBAudio.audioInstances[bufferInstance];
  	if (sound.error)
  		return 2;
  	if (sound.buffer || sound.url)
  		return 0;
  	return 1;
  }

  function jsAudioPlayPendingBlockedAudio(soundId) {
  	var pendingAudio = WEBAudio.pendingAudioSources[soundId];
  	pendingAudio.sourceNode._startPlayback(pendingAudio.offset);
  	delete WEBAudio.pendingAudioSources[soundId];
  }
  function jsAudioPlayBlockedAudios() {
  	Object.keys(WEBAudio.pendingAudioSources).forEach(function (audioId) {
  		jsAudioPlayPendingBlockedAudio(audioId);
  	});
  }
  function _JS_Sound_Init() {
  	try {
  		window.AudioContext = window.AudioContext || window.webkitAudioContext;
  		WEBAudio.audioContext = new AudioContext();
  
  		var tryToResumeAudioContext = function () {
  			if (WEBAudio.audioContext.state === 'suspended')
  				WEBAudio.audioContext.resume().catch(function (error) {
  					console.warn("Could not resume audio context. Exception: " + error);
  				});
  			else
  				Module.clearInterval(resumeInterval);
  		};
  		var resumeInterval = Module.setInterval(tryToResumeAudioContext, 400);
  
  		WEBAudio.audioWebEnabled = 1;
  
  		// Safari has the restriction where Audio elements need to be created from a direct user event,
  		// even if the rest of the audio playback requirements is that a user event has happeend
  		// at some point previously. The AudioContext also needs to be resumed, if paused, from a
  		// direct user event. Catch user events here and use them to fill a cache of Audio
  		// elements to be used by the rest of the system.
  		var _userEventCallback = function () {
  			try {
  				// On Safari, resuming the audio context needs to happen from a user event.
  				// The AudioContext is suspended by default, and on iOS if the user switches tabs
  				// and comes back, it will be interrupted. Touching the page will resume audio
  				// playback.
  				if (WEBAudio.audioContext.state !== "running" && WEBAudio.audioContext.state !== "closed") {
  					WEBAudio.audioContext.resume().catch(function (error) {
  						console.warn("Could not resume audio context. Exception: " + error);
  					});
  				}
  
  				// Play blocked audio elements
  				jsAudioPlayBlockedAudios();
  
  				// How many audio elements should we cache? How many compressed audio channels might
  				// be played at a single time?
  				var audioCacheSize = 20;
  				while (WEBAudio.audioCache.length < audioCacheSize) {
  					var audio = new Audio();
  					audio.autoplay = false;
  					WEBAudio.audioCache.push(audio);
  				}
  			} catch (e) {
  				// Audio error, but don't need to notify here, they would have already been
  				// informed of audio errors.
  			}
  		};
  		window.addEventListener("mousedown", _userEventCallback);
  		window.addEventListener("touchstart", _userEventCallback);
  
  		// Make sure we release the event listeners when the app quits to avoid leaking memory.
  		Module.deinitializers.push(function () {
  			window.removeEventListener("mousedown", _userEventCallback);
  			window.removeEventListener("touchstart", _userEventCallback);
  		});
  	}
  	catch (e) {
  		alert('Web Audio API is not supported in this browser');
  	}
  }

  function jsAudioCreateUncompressedSoundClipFromCompressedAudio(audioData) {
  	var soundClip = jsAudioCreateUncompressedSoundClip(null, false);
  
  	WEBAudio.audioContext.decodeAudioData(
  		audioData,
  		function (_buffer) {
  			soundClip.buffer = _buffer;
  		},
  		function (_error) {
  			soundClip.error = true;
  			console.log("Decode error: " + _error);
  		}
  	);
  
  	return soundClip;
  }
  
  function jsAudioAddPendingBlockedAudio(sourceNode, offset) {
  	WEBAudio.pendingAudioSources[sourceNode.mediaElement.src] = {
  		sourceNode: sourceNode,
  		offset: offset
  	};
  }
  
  function jsAudioGetMimeTypeFromType(fmodSoundType) {
  	switch(fmodSoundType)
  	{
  		case 13: // FMOD_SOUND_TYPE_MPEG
  			return "audio/mpeg";
  		case 20: // FMOD_SOUND_TYPE_WAV
  			return "audio/wav";
  		default: // Fallback to mp4 audio file for other types or if not set (works on most browsers)
  			return "audio/mp4";
  	}
  }
  function jsAudioCreateCompressedSoundClip(audioData, fmodSoundType) {
  	var mimeType = jsAudioGetMimeTypeFromType(fmodSoundType);
  	var blob = new Blob([audioData], { type: mimeType });
  
  	var soundClip = {
  		url: URL.createObjectURL(blob),
  		error: false,
  		mediaElement: new Audio()
  	};
  
  	// An Audio element is created for the buffer so that we can access properties like duration
  	// in JS_Sound_GetLength, which knows about the buffer object, but not the channel object.
  	// This Audio element is used for metadata properties only, not for playback. Trying to play
  	// back this Audio element would cause an error on Safari because it's not created in a
  	// direct user event handler.
  	soundClip.mediaElement.preload = "metadata";
  	soundClip.mediaElement.src = soundClip.url;
  
  	/**
  	 * Release resources of a sound clip
  	 */
  	soundClip.release = function () {
  		if (!this.mediaElement) {
  			return;
  		}
  
  		this.mediaElement.src = "";
  		URL.revokeObjectURL(this.url);
  		delete this.mediaElement;
  		delete this.url;
  	}
  
  	/**
  	 * Get length of sound clip in number of samples
  	 * @returns {number}
  	 */
  	soundClip.getLength = function () {
  		// Convert duration (seconds) to number of samples.
  		return this.mediaElement.duration * 44100;
  	}
  	/**
  	 * Gets uncompressed audio data from sound clip.
  	 * If output buffer is smaller than the sound data only the first portion
  	 * of the sound data is read.
  	 * Sound clips with multiple channels will be stored one after the other.
  	 *
  	 * @param {number} ptr Pointer to the output buffer
  	 * @param {number} length Size of output buffer in bytes
  	 * @returns Size of data in bytes written to output buffer
  	 */
  	 soundClip.getData = function (ptr, length) {
  		console.warn("getData() is not supported for compressed sound.");
  
  		return 0;
  	}
  
  	/**
  	 * Gets number of channels of soundclip
  	 * @returns {number}
  	 */
  	soundClip.getNumberOfChannels = function () {
  		console.warn("getNumberOfChannels() is not supported for compressed sound.");
  
  		return 0;
  	}
  
  	/**
  	 * Gets sampling rate in Hz
  	 * @returns {number}
  	 */
  	soundClip.getFrequency = function () {
  		console.warn("getFrequency() is not supported for compressed sound.");
  
  		return 0;
  	}
  
  	/**
  	 * Create an audio source node
  	 * @returns {MediaElementAudioSourceNode}
  	 */
  	soundClip.createSourceNode = function () {
  		var self = this;
  		var mediaElement = WEBAudio.audioCache.length ? WEBAudio.audioCache.pop() : new Audio();;
  		mediaElement.preload = "metadata";
  		mediaElement.src = this.url;
  		var source = WEBAudio.audioContext.createMediaElementSource(mediaElement);
  
  		Object.defineProperty(source, "loop", {
  			get: function () {
  				return source.mediaElement.loop;
  			},
  			set: function (v) {
  				if (source.mediaElement.loop !== v) source.mediaElement.loop = v;
  			}
  		});
  
  		source.playbackRate = {};
  		Object.defineProperty(source.playbackRate, "value", {
  			get: function () {
  				return source.mediaElement.playbackRate;
  			},
  			set: function (v) {
  				if (source.mediaElement.playbackRate !== v) source.mediaElement.playbackRate = v;
  			}
  		});
  		Object.defineProperty(source, "currentTime", {
  			get: function () {
  				return source.mediaElement.currentTime;
  			},
  			set: function (v) {
  				if (source.mediaElement.currentTime !== v) source.mediaElement.currentTime = v;
  			}
  		});
  		Object.defineProperty(source, "mute", {
  			get: function () {
  				return source.mediaElement.mute;
  			},
  			set: function (v) {
  				if (source.mediaElement.mute !== v) source.mediaElement.mute = v;
  			}
  		});
  		Object.defineProperty(source, "onended", {
  			get: function () {
  				return source.mediaElement.onended;
  			},
  			set: function (onended) {
  				source.mediaElement.onended = onended;
  			}
  		});
  
  		source.playPromise = null;
  		source.playTimeout = null;
  		source.pauseRequested = false;
  		source.isStopped = false;
  
  		source._pauseMediaElement = function () {
  			// If there is a play request still pending, then pausing now would cause an
  			// error. Instead, mark that we want the audio paused as soon as it can be,
  			// which will be when the play promise resolves.
  			if (source.playPromise || source.playTimeout) {
  				source.pauseRequested = true;
  			} else {
  				// If there is no play request pending, we can pause immediately.
  				source.mediaElement.pause();
  			}
  		};
  
  		source._startPlayback = function (offset) {
  			if (source.playPromise || source.playTimeout) {
  				source.mediaElement.currentTime = offset;
  				source.pauseRequested = false;
  				return;
  			}
  
  			source.mediaElement.currentTime = offset;
  			source.playPromise = source.mediaElement.play();
  
  			if (source.playPromise) {
  				source.playPromise.then(function () {
  					// If a pause was requested between play() and the MediaElement actually
  					// starting, then pause it now.
  					if (source.pauseRequested) {
  						source.mediaElement.pause();
  						source.pauseRequested = false;
  					}
  					source.playPromise = null;
  				}).catch(function (error) {
  					source.playPromise = null;
  					if (error.name !== 'NotAllowedError')
  						throw error;
  
  					// Playing a media element may fail if there was no previous user interaction
  					// Retry playback when there was a user interaction
  					jsAudioAddPendingBlockedAudio(source, offset);
  				});
  			}
  		};
  
  		source.start = function (startTime, offset) {
  			if (typeof startTime === "undefined") {
  				startTime = WEBAudio.audioContext.currentTime;
  			}
  
  			if (typeof offset === "undefined") {
  				offset = 0.0;
  			}
  
  			// Compare startTime to WEBAudio context currentTime, and if
  			// startTime is more than about 4 msecs in the future, do a setTimeout() wait
  			// for the remaining duration, and only then play. 4 msecs boundary because
  			// setTimeout() is specced to throttle <= 4 msec waits if repeatedly called.
  			var startDelayThresholdMS = 4;
  			// Convert startTime and currentTime to milliseconds
  			var startDelayMS = (startTime - WEBAudio.audioContext.currentTime) * 1000;
  			if (startDelayMS > startDelayThresholdMS) {
  				source.playTimeout = setTimeout(function () {
  					source.playTimeout = null;
  					source._startPlayback(offset);
  				}, startDelayMS);
  			} else {
  				source._startPlayback(offset);
  			}
  		};
  
  		source.stop = function (stopTime) {
  			if (typeof stopTime === "undefined") {
  				stopTime = WEBAudio.audioContext.currentTime;
  			}
  
  			// Compare stopTime to WEBAudio context currentTime, and if
  			// stopTime is more than about 4 msecs in the future, do a setTimeout() wait
  			// for the remaining duration, and only then stop. 4 msecs boundary because
  			// setTimeout() is specced to throttle <= 4 msec waits if repeatedly called.
  			var stopDelayThresholdMS = 4;
  			// Convert startTime and currentTime to milliseconds
  			var stopDelayMS = (stopTime - WEBAudio.audioContext.currentTime) * 1000;
  
  			if (stopDelayMS > stopDelayThresholdMS) {
  				setTimeout(function () {
  					source._pauseMediaElement();
  					source.isStopped = true;
  				}, stopDelayMS);
  			} else {
  				source._pauseMediaElement();
  				source.isStopped = true;
  			}
  		};
  
  		jsAudioMixinSetPitch(source);
  
  		return source;
  	}
  
  	return soundClip;
  }
  function _JS_Sound_Load(ptr, length, decompress, fmodSoundType) {
  	if (WEBAudio.audioWebEnabled == 0)
  		return 0;
  
  	var audioData = HEAPU8.buffer.slice(ptr, ptr + length);
  
  	// We don't ever want to play back really small audio clips as compressed, the compressor has a startup CPU cost,
  	// and replaying the same audio clip multiple times (either individually or when looping) has an unwanted CPU
  	// overhead if the same data will be decompressed on demand again and again. Hence we want to play back small
  	// audio files always as fully uncompressed in memory.
  
  	// However this will be a memory usage tradeoff.
  
  	// Tests with aac audio sizes in a .m4a container shows:
  	// 2.11MB stereo 44.1kHz .m4a file containing 90 seconds of 196kbps aac audio decompresses to 30.3MB of float32 PCM data. (~14.3x size increase)
  	// 721KB stereo 44.1kHz .m4a file 29 seconds of 196kbps aac audio decompresses to 10.0MB of float32 PCM data. (~14x size increase)
  	// 6.07KB mono 44.1kHZ .m4a file containing 1 second of 101kbps aac audio decompresses to 72kB of float32 PCM data. (~11x size increase)
  	// -> overall AAC compression factor is ~10x-15x.
  
  	// Based on above, take 128KB as a cutoff size: if we have a .m4a clip that is smaller than this,
  	// we always uncompress it up front, receiving at most ~1.8MB of raw audio data, which can hold about ~10 seconds of mono audio.
  	// In other words, heuristically all audio clips <= mono ~10 seconds (5 seconds if stereo) in duration will be always fully uncompressed in memory.
  	if (length < 131072) decompress = 1;
  
  	var sound;
  	if (decompress) {
  		sound = jsAudioCreateUncompressedSoundClipFromCompressedAudio(audioData);
  	} else {
  		sound = jsAudioCreateCompressedSoundClip(audioData, fmodSoundType);
  	}
  
  	WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter] = sound;
  
  	return WEBAudio.audioInstanceIdCounter;
  }

  function jsAudioCreateUncompressedSoundClipFromPCM(channels, length, sampleRate, ptr) {
  	var buffer = WEBAudio.audioContext.createBuffer(channels, length, sampleRate);
  
  	// Copy audio data to buffer
  	for (var i = 0; i < channels; i++) {
  		var offs = (ptr >> 2) + length * i;
  		var copyToChannel = buffer['copyToChannel'] || function (source, channelNumber, startInChannel) {
  			// Shim for copyToChannel on browsers which don't support it like Safari.
  			var clipped = source.subarray(0, Math.min(source.length, this.length - (startInChannel | 0)));
  			this.getChannelData(channelNumber | 0).set(clipped, startInChannel | 0);
  		};
  		copyToChannel.apply(buffer, [HEAPF32.subarray(offs, offs + length), i, 0]);
  	}
  
  	return jsAudioCreateUncompressedSoundClip(buffer, false);
  }
  function _JS_Sound_Load_PCM(channels, length, sampleRate, ptr) {
  	if (WEBAudio.audioWebEnabled == 0)
  		return 0;
  
  	var sound = jsAudioCreateUncompressedSoundClipFromPCM(channels, length, sampleRate, ptr);
  
  	WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter] = sound;
  	return WEBAudio.audioInstanceIdCounter;
  }

  function _JS_Sound_Play(bufferInstance, channelInstance, offset, delay)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	// stop sound clip which is currently playing in the channel.
  	_JS_Sound_Stop(channelInstance, 0);
  
  	var soundClip = WEBAudio.audioInstances[bufferInstance];
  	var channel = WEBAudio.audioInstances[channelInstance];
  
  	if (!soundClip) {
  		console.log("Trying to play sound which is not loaded.");
  		return;
  	}
  
  	try {
  		channel.playSoundClip(soundClip, WEBAudio.audioContext.currentTime + delay, offset);
  	} catch (error) {
  		console.error("playSoundClip error. Exception: " + e);
  	}
  }

  function _JS_Sound_ReleaseInstance(instance) {
  	var object = WEBAudio.audioInstances[instance];
  	if (object) {
  		object.release();
  	}
  
  	// Let the GC free up the audio object.
  	delete WEBAudio.audioInstances[instance];
  }

  function _JS_Sound_ResumeIfNeeded()
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	if (WEBAudio.audioContext.state === 'suspended')
  		WEBAudio.audioContext.resume().catch(function (error) {
  			console.warn("Could not resume audio context. Exception: " + error);
  		});
  
  }

  function _JS_Sound_Set3D(channelInstance, threeD)
  {
  	var channel = WEBAudio.audioInstances[channelInstance];
  	channel.set3D(threeD);
  }

  function _JS_Sound_SetListenerOrientation(x, y, z, xUp, yUp, zUp)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	// Web Audio uses a RHS coordinate system, Unity uses LHS, causing orientations to be flipped.
  	// So we pass a negative direction here to compensate, otherwise channels will be flipped.
  	x = -x;
  	y = -y;
  	z = -z;
  
  	var l = WEBAudio.audioContext.listener;
  
  	// Do not re-set same values here if the orientation has not changed. This avoid unpredictable performance issues in Chrome
  	// and Safari Web Audio implementations.
  	if (l.forwardX) {
  		// Use new properties if they exist ...
  		if (l.forwardX.value !== x) l.forwardX.value = x;
  		if (l.forwardY.value !== y) l.forwardY.value = y;
  		if (l.forwardZ.value !== z) l.forwardZ.value = z;
  
  		if (l.upX.value !== xUp) l.upX.value = xUp;
  		if (l.upY.value !== yUp) l.upY.value = yUp;
  		if (l.upZ.value !== zUp) l.upZ.value = zUp;
  	} else if (l._forwardX !== x || l._forwardY !== y || l._forwardZ !== z || l._upX !== xUp || l._upY !== yUp || l._upZ !== zUp) {
  		// ... and old deprecated setOrientation if new properties are not supported.
  		l.setOrientation(x, y, z, xUp, yUp, zUp);
  		l._forwardX = x;
  		l._forwardY = y;
  		l._forwardZ = z;
  		l._upX = xUp;
  		l._upY = yUp;
  		l._upZ = zUp;
  	}
  }

  function _JS_Sound_SetListenerPosition(x, y, z)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	var l = WEBAudio.audioContext.listener;
  
  	// Do not re-set same values here if the orientation has not changed. This avoid unpredictable performance issues in Chrome
  	// and Safari Web Audio implementations.
  	if (l.positionX) {
  		// Use new properties if they exist ...
  		if (l.positionX.value !== x) l.positionX.value = x;
  		if (l.positionY.value !== y) l.positionY.value = y;
  		if (l.positionZ.value !== z) l.positionZ.value = z;
  	} else if (l._positionX !== x || l._positionY !== y || l._positionZ !== z) {
  		// ... and old deprecated setPosition if new properties are not supported.
  		l.setPosition(x, y, z);
  		l._positionX = x;
  		l._positionY = y;
  		l._positionZ = z;
  	}
  }

  function _JS_Sound_SetLoop(channelInstance, loop)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	var channel = WEBAudio.audioInstances[channelInstance];
  	channel.setLoop(loop);
  }

  function _JS_Sound_SetLoopPoints(channelInstance, loopStart, loopEnd)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  	var channel = WEBAudio.audioInstances[channelInstance];
  	channel.setLoopPoints(loopStart, loopEnd);
  }

  function _JS_Sound_SetPaused(channelInstance, paused)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  	var channel = WEBAudio.audioInstances[channelInstance];
  	if (paused != channel.isPaused()) {
  		if (paused) channel.pause();
  		else channel.resume();
  	}
  }

  function _JS_Sound_SetPitch(channelInstance, v)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	try {
  		var channel = WEBAudio.audioInstances[channelInstance];
  		channel.setPitch(v);
  	} catch (e) {
  		console.error('JS_Sound_SetPitch(channel=' + channelInstance + ', pitch=' + v + ') threw an exception: ' + e);
  	}
  }

  function _JS_Sound_SetPosition(channelInstance, x, y, z)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	var channel = WEBAudio.audioInstances[channelInstance];
  	channel.setPosition(x, y, z);
  }

  function _JS_Sound_SetVolume(channelInstance, v)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	try {
  		var channel = WEBAudio.audioInstances[channelInstance];
  		channel.setVolume(v);
  	} catch (e) {
  		console.error('JS_Sound_SetVolume(channel=' + channelInstance + ', volume=' + v + ') threw an exception: ' + e);
  	}
  }

  function _JS_Sound_Stop(channelInstance, delay)
  {
  	if (WEBAudio.audioWebEnabled == 0)
  		return;
  
  	var channel = WEBAudio.audioInstances[channelInstance];
  	channel.stop(delay);
  }

  function _JS_SystemInfo_GetCanvasClientSize(domElementSelector, outWidth, outHeight)
  	{
  		var selector = UTF8ToString(domElementSelector);
  		var canvas = (selector == '#canvas') ? Module['canvas'] : document.querySelector(selector);
  		var w = 0, h = 0;
  		if (canvas) {
  			var size = canvas.getBoundingClientRect();
  			w = size.width;
  			h = size.height;
  		}
  		HEAPF64[outWidth >> 3] = w;
  		HEAPF64[outHeight >> 3] = h;
  	}

  function _JS_SystemInfo_GetDocumentURL(buffer, bufferSize) 
  	{
  		if (buffer)
  			stringToUTF8(document.URL, buffer, bufferSize);
  		return lengthBytesUTF8(document.URL);
  	}

  function _JS_SystemInfo_GetGPUInfo(buffer, bufferSize)
  	{
  		var gpuinfo = Module.SystemInfo.gpu;
  		if (buffer)
  			stringToUTF8(gpuinfo, buffer, bufferSize);
  		return lengthBytesUTF8(gpuinfo);
  	}

  function _JS_SystemInfo_GetMatchWebGLToCanvasSize()
  	{
  		// If matchWebGLToCanvasSize is not present, it is
  		// same as true, to keep backwards compatibility with user page templates
  		// that are not setting this field.
  		return Module.matchWebGLToCanvasSize || Module.matchWebGLToCanvasSize === undefined;
  	}

  function _JS_SystemInfo_GetMemory() 
  	{
  		return HEAPU8.length/(1024*1024);
  	}

  function _JS_SystemInfo_GetOS(buffer, bufferSize) 
  	{
  		var browser = Module.SystemInfo.os + " " + Module.SystemInfo.osVersion;
  		if (buffer)
  			stringToUTF8(browser, buffer, bufferSize);
  		return lengthBytesUTF8(browser);
  	}

  function _JS_SystemInfo_GetPreferredDevicePixelRatio()
  	{
  		return Module.matchWebGLToCanvasSize == false ? 1 : Module.devicePixelRatio || window.devicePixelRatio || 1;
  	}

  function _JS_SystemInfo_GetScreenSize(outWidth, outHeight)
  	{
  		HEAPF64[outWidth >> 3] = Module.SystemInfo.width;
  		HEAPF64[outHeight >> 3] = Module.SystemInfo.height;
  	}

  function _JS_SystemInfo_HasAstcHdr()
      {
        var ext = GLctx.getExtension('WEBGL_compressed_texture_astc');
        if (ext && ext.getSupportedProfiles) {
          return ext.getSupportedProfiles().includes("hdr");
        }
        return false;
      }

  function _JS_SystemInfo_HasCursorLock() 
  	{
  		return Module.SystemInfo.hasCursorLock;
  	}

  function _JS_SystemInfo_HasFullscreen() 
  	{
  		return Module.SystemInfo.hasFullscreen;
  	}

  function _JS_SystemInfo_HasWebGL() 
  	{
  		return Module.SystemInfo.hasWebGL;
  	}

  function _JS_UnityEngineShouldQuit() {
  	return !!Module.shouldQuit;
  }

  function _KickInternal(playerID, onKickCallBack) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        reject("Playroom library not loaded");
        return;
      }
  
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
      const playerState = players[UTF8ToString(playerID)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerID), "not found.");
        return null;
      }
  
      playerState
        .kick()
        .then(() => {
          (function() {  dynCall_v.call(null, onKickCallback); })()
        })
        .catch((error) => {
          console.error("Error kicking player:", error);
        });
    }

  function _MyPlayerInternal() {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var myPlayerID = Playroom.myPlayer().id;
      var bufferSize = lengthBytesUTF8(myPlayerID) + 1;
      var buffer = _malloc(bufferSize);
      stringToUTF8(myPlayerID, buffer, bufferSize);
      return buffer;
    }

  function _OnDisconnectInternal(callback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.onDisconnect((e) => {
        console.log(`Disconnected!`, e.code, e.reason);
        (function() {  dynCall_v.call(null, callback); })()
      });
    }

  function _OnPlayerJoinInternal(functionPtr) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var callbackID = Date.now().toString();
      try {
        var unsubcribePlayerJoin = Playroom.onPlayerJoin((player) => {
          var id = player.id;
          var bufferSize = lengthBytesUTF8(id) + 1;
          var buffer = _malloc(bufferSize);
          stringToUTF8(id, buffer, bufferSize);
          
          (function(a1) {  dynCall_vi.apply(null, [functionPtr, a1]); })(buffer)
        });
      } catch (error) {
        console.log(error);
      }
  
      this.onPlayerJoinCallBacks[callbackID] = unsubcribePlayerJoin;
      var callbackIDbufferSize = lengthBytesUTF8(callbackID) + 1;
      var callbackIDUTF8 = _malloc(callbackIDbufferSize);
      stringToUTF8(callbackID, callbackIDUTF8, callbackIDbufferSize);
      return callbackIDUTF8;
    }

  function _ResetPlayersStatesInternal(keysToExclude, onStatesReset) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var keys = keysToExclude ? JSON.parse(UTF8ToString(keysToExclude)) : [];
      Playroom.resetPlayersStates(keys)
        .then(() => {
          (function() {  dynCall_v.call(null, onStatesReset); })()
        })
        .catch((error) => {
          console.error("Error resetting players states:", error);
          throw error;
        });
    }

  function _ResetStatesInternal(keysToExclude, onStatesReset) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var keys = keysToExclude ? JSON.parse(UTF8ToString(keysToExclude)) : [];
      Playroom.resetStates(keys)
        .then(() => {
          (function() {  dynCall_v.call(null, onStatesReset); })()
        })
        .catch((error) => {
          console.error("Error resetting states:", error);
          throw error;
        });
    }

  function _RpcCallInternal(name, dataJson, mode, callbackOnResponse) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      try {
        var data;
        if (dataJson) {
          try {
            data = JSON.parse(UTF8ToString(dataJson));
          } catch (parseError) {
            data = UTF8ToString(dataJson);
          }
        } else {
          data = {};
        }
  
        function onResponseCallback(responseData) {
          // console.log("Response received: ", responseData);
          (function() {  dynCall_v.call(null, callbackOnResponse); })()
        }
  
        Playroom.RPC.call(UTF8ToString(name), data, mode, onResponseCallback);
      } catch (error) {
        console.error("Error in RpcCallInternal:", error);
      }
    }

  function _RpcRegisterInternal(name, callback, onResponseReturn) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      var n = UTF8ToString(name)
      onResponseReturn = UTF8ToString(onResponseReturn);
  
      function registerCallback(data, sender) {
        var combinedData = {
          data: data,
          senderId: sender.id,
          eventName : n
        };
  
        var dataJson = JSON.stringify(combinedData);
  
        (function(a1) {  dynCall_vi.apply(null, [callback, a1]); })(stringToNewUTF8(dataJson));
  
        return onResponseReturn;
      }
  
      Playroom.RPC.register(UTF8ToString(name), registerCallback);
    }

  function _SaveMyTurnDataInternal(data) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.saveMyTurnData(UTF8ToString(data)).then(() => {
      }).catch((error) => {
        console.error("[JS]: Failed to save turn data:", error);
      });
    }

  function _SetPersistentDataInternal(key, value) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      
      Playroom.setPersistentData(UTF8ToString(key), UTF8ToString(value)).then(() => {
        console.log("Data has been set successfully.");
      }).catch((error) => {
        console.error("Failed to set data:", error);
      });
    }

  function _SetPlayerStateByPlayerId(playerId, key, value, reliable) {
      const players = Playroom.Multiplayer().getPlayers()
  
      reliable = !!reliable;
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.setState === "function") {
        playerState.setState(UTF8ToString(key), value, reliable);
      } else {
        console.error(
          'The player state object does not have a "setState" method.'
        );
        return null;
      }
    }

  function _SetPlayerStateDictionary(playerId, key, jsonValues, reliable) {
      const players = Playroom.Multiplayer().getPlayers()
  
      reliable = !!reliable;
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
  
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.setState === "function") {
        playerState.setState(
          UTF8ToString(key),
          JSON.parse(UTF8ToString(jsonValues)),
          reliable
        );
      } else {
        console.error(
          'The player state object does not have a "setState" method.'
        );
        return null;
      }
    }

  function _SetPlayerStateFloatByPlayerId(playerId, key, value, reliable) {
      const players = Playroom.Multiplayer().getPlayers()
  
      reliable = !!reliable;
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.setState === "function") {
        playerState.setState(
          UTF8ToString(key),
          parseFloat(UTF8ToString(value)),
          reliable
        );
      } else {
        console.error(
          'The player state object does not have a "setState" method.'
        );
        return null;
      }
    }

  function _SetPlayerStateStringById(playerId, key, value, reliable) {
      const players = Playroom.Multiplayer().getPlayers()
  
      reliable = !!reliable;
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      if (typeof playerState.setState === "function") {
        playerState.setState(UTF8ToString(key), UTF8ToString(value), reliable);
      } else {
        console.error(
          'The player state object does not have a "setState" method.'
        );
        return null;
      }
    }

  function _SetStateDictionary(key, jsonValues, reliable) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      reliable = !!reliable;
  
      Playroom.setState(
        UTF8ToString(key),
        JSON.parse(UTF8ToString(jsonValues)),
        reliable
      );
    }

  function _SetStateFloatInternal(key, value, reliable) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      reliable = !!reliable;
  
      Playroom.setState(
        UTF8ToString(key),
        parseFloat(UTF8ToString(value)),
        reliable
      );
    }

  function _SetStateInternal(key, value, reliable) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      reliable = !!reliable;
  
      Playroom.setState(UTF8ToString(key), value, reliable);
    }

  function _SetStateString(key, stringVal, reliable) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      reliable = !!reliable;
  
      Playroom.setState(UTF8ToString(key), UTF8ToString(stringVal), reliable);
    }

  function _StartMatchmakingInternal(callback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
  
      Playroom.startMatchmaking()
        .then(() => {
          console.log(`Player has joined a public room`);
          (function() {  dynCall_v.call(null, callback); })()
        })
        .catch((error) => {
          console.error(`JS: Error starting match making ${error}`);
        });
    }

  function _TransferHostInternal(playerId) {
      if (!window.Playroom) {
        console.error("Playroom library is not loaded. Please make sure to call InsertCoin first.");
        return;
      }
  
      try {
        Playroom.transferHost(playerId)
          .then(() => {
            console.log("Host privileges successfully transferred.");
          })
          .catch((error) => {
            console.error("Failed to transfer host privileges: ", error);
          });
      } catch (error) {
        console.error("Error transferring host: ", error);
      }
    }

  function _UnsubscribeOnPlayerJoinInternal(id) {
      functionId = UTF8ToString(id);
      var unsubscribeFunction = this.onPlayerJoinCallBacks[functionId];
      if (unsubscribeFunction) {
        unsubscribeFunction();
        delete this.onPlayerJoinCallBacks[functionId];
      } else {
        console.error(
          "No player join event handler with ID " + functionId + " to unregister."
        );
      }
    }

  function _UnsubscribeOnQuitInternal() {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        return;
      }
      if (this.unsubscribeOnQuit) {
        this.unsubscribeOnQuit();
      } else {
        console.error("No On Quit event handler to unregister.");
      }
    }

  function _WaitForPlayerStateInternal(
      playerId,
      stateKey,
      onStateSetCallback
    ) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        reject("Playroom library not loaded");
        return;
      }
  
      const players = Playroom.Multiplayer().getPlayers()
  
      if (typeof players !== "object" || players === null) {
        console.error('The "players" variable is not an object:', players);
        return null;
      }
      const playerState = players[UTF8ToString(playerId)];
  
      if (!playerState) {
        console.error("Player with ID", UTF8ToString(playerId), "not found.");
        return null;
      }
  
      stateKey = UTF8ToString(stateKey);
      Playroom.waitForPlayerState(playerState, stateKey)
        .then((stateVal) => {
          (function(a1) {  dynCall_vi.apply(null, [onStateSetCallback, a1]); })(stringToNewUTF8(stateVal))
        })
        .catch((error) => {
          console.error("Error waiting for state:", error);
        });
    }

  function _WaitForStateInternal(stateKey, onStateSetCallback) {
      if (!window.Playroom) {
        console.error(
          "Playroom library is not loaded. Please make sure to call InsertCoin first."
        );
        reject("Playroom library not loaded");
        return;
      }
  
      stateKey = UTF8ToString(stateKey);
      Playroom.waitForState(stateKey)
        .then((stateVal) => {
          stateVal = JSON.stringify(stateVal);
  
          var key = _ConvertString(stateKey);
          
          (function(a1, a2) {  dynCall_vii.apply(null, [onStateSetCallback, a1, a2]); })(key, stringToNewUTF8(stateVal))
        })
        .catch((error) => {
          console.error("Error Waiting for state:", error);
        });
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  function ___cxa_allocate_exception(size) {
      // Thrown object is prepended by exception metadata block
      return _malloc(size + 16) + 16;
    }

  /** @constructor */
  function ExceptionInfo(excPtr) {
      this.excPtr = excPtr;
      this.ptr = excPtr - 16;
  
      this.set_type = function(type) {
        HEAP32[(((this.ptr)+(4))>>2)] = type;
      };
  
      this.get_type = function() {
        return HEAP32[(((this.ptr)+(4))>>2)];
      };
  
      this.set_destructor = function(destructor) {
        HEAP32[(((this.ptr)+(8))>>2)] = destructor;
      };
  
      this.get_destructor = function() {
        return HEAP32[(((this.ptr)+(8))>>2)];
      };
  
      this.set_refcount = function(refcount) {
        HEAP32[((this.ptr)>>2)] = refcount;
      };
  
      this.set_caught = function (caught) {
        caught = caught ? 1 : 0;
        HEAP8[(((this.ptr)+(12))>>0)] = caught;
      };
  
      this.get_caught = function () {
        return HEAP8[(((this.ptr)+(12))>>0)] != 0;
      };
  
      this.set_rethrown = function (rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;
      };
  
      this.get_rethrown = function () {
        return HEAP8[(((this.ptr)+(13))>>0)] != 0;
      };
  
      // Initialize native structure fields. Should be called once after allocated.
      this.init = function(type, destructor) {
        this.set_type(type);
        this.set_destructor(destructor);
        this.set_refcount(0);
        this.set_caught(false);
        this.set_rethrown(false);
      }
  
      this.add_ref = function() {
        var value = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = value + 1;
      };
  
      // Returns true if last reference released.
      this.release_ref = function() {
        var prev = HEAP32[((this.ptr)>>2)];
        HEAP32[((this.ptr)>>2)] = prev - 1;
        assert(prev > 0);
        return prev === 1;
      };
    }
  
    /**
     * @constructor
     * @param {number=} ptr
     */
  function CatchInfo(ptr) {
  
      this.free = function() {
        _free(this.ptr);
        this.ptr = 0;
      };
  
      this.set_base_ptr = function(basePtr) {
        HEAP32[((this.ptr)>>2)] = basePtr;
      };
  
      this.get_base_ptr = function() {
        return HEAP32[((this.ptr)>>2)];
      };
  
      this.set_adjusted_ptr = function(adjustedPtr) {
        HEAP32[(((this.ptr)+(4))>>2)] = adjustedPtr;
      };
  
      this.get_adjusted_ptr_addr = function() {
        return this.ptr + 4;
      }
  
      this.get_adjusted_ptr = function() {
        return HEAP32[(((this.ptr)+(4))>>2)];
      };
  
      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted
      // when the pointer is casted to some of the exception object base classes (e.g. when virtual
      // inheritance is used). When a pointer is thrown this method should return the thrown pointer
      // itself.
      this.get_exception_ptr = function() {
        // Work around a fastcomp bug, this code is still included for some reason in a build without
        // exceptions support.
        var isPointer = ___cxa_is_pointer_type(
          this.get_exception_info().get_type());
        if (isPointer) {
          return HEAP32[((this.get_base_ptr())>>2)];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0) return adjusted;
        return this.get_base_ptr();
      };
  
      this.get_exception_info = function() {
        return new ExceptionInfo(this.get_base_ptr());
      };
  
      if (ptr === undefined) {
        this.ptr = _malloc(8);
        this.set_adjusted_ptr(0);
      } else {
        this.ptr = ptr;
      }
    }
  
  var exceptionCaught =  [];
  
  function exception_addRef(info) {
      info.add_ref();
    }
  
  var uncaughtExceptionCount = 0;
  function ___cxa_begin_catch(ptr) {
      var catchInfo = new CatchInfo(ptr);
      var info = catchInfo.get_exception_info();
      if (!info.get_caught()) {
        info.set_caught(true);
        uncaughtExceptionCount--;
      }
      info.set_rethrown(false);
      exceptionCaught.push(catchInfo);
      exception_addRef(info);
      return catchInfo.get_exception_ptr();
    }

  var exceptionLast = 0;
  
  function ___cxa_free_exception(ptr) {
      try {
        return _free(new ExceptionInfo(ptr).ptr);
      } catch(e) {
        err('exception during cxa_free_exception: ' + e);
      }
    }
  function exception_decRef(info) {
      // A rethrown exception can reach refcount 0; it must not be discarded
      // Its next handler will clear the rethrown flag and addRef it, prior to
      // final decRef and destruction here
      if (info.release_ref() && !info.get_rethrown()) {
        var destructor = info.get_destructor();
        if (destructor) {
          // In Wasm, destructors return 'this' as in ARM
          (function(a1) { return dynCall_ii.apply(null, [destructor, a1]); })(info.excPtr);
        }
        ___cxa_free_exception(info.excPtr);
      }
    }
  function ___cxa_end_catch() {
      // Clear state flag.
      _setThrew(0);
      assert(exceptionCaught.length > 0);
      // Call destructor if one is registered then clear it.
      var catchInfo = exceptionCaught.pop();
  
      exception_decRef(catchInfo.get_exception_info());
      catchInfo.free();
      exceptionLast = 0; // XXX in decRef?
    }

  function ___resumeException(catchInfoPtr) {
      var catchInfo = new CatchInfo(catchInfoPtr);
      var ptr = catchInfo.get_base_ptr();
      if (!exceptionLast) { exceptionLast = ptr; }
      catchInfo.free();
      throw ptr;
    }
  function ___cxa_find_matching_catch_2() {
      var thrown = exceptionLast;
      if (!thrown) {
        // just pass through the null ptr
        setTempRet0(0); return ((0)|0);
      }
      var info = new ExceptionInfo(thrown);
      var thrownType = info.get_type();
      var catchInfo = new CatchInfo();
      catchInfo.set_base_ptr(thrown);
      catchInfo.set_adjusted_ptr(thrown);
      if (!thrownType) {
        // just pass through the thrown ptr
        setTempRet0(0); return ((catchInfo.ptr)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      // can_catch receives a **, add indirection
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        var caughtType = typeArray[i];
        if (caughtType === 0 || caughtType === thrownType) {
          // Catch all clause matched or exactly the same type is caught
          break;
        }
        if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
          setTempRet0(caughtType); return ((catchInfo.ptr)|0);
        }
      }
      setTempRet0(thrownType); return ((catchInfo.ptr)|0);
    }

  function ___cxa_find_matching_catch_3() {
      var thrown = exceptionLast;
      if (!thrown) {
        // just pass through the null ptr
        setTempRet0(0); return ((0)|0);
      }
      var info = new ExceptionInfo(thrown);
      var thrownType = info.get_type();
      var catchInfo = new CatchInfo();
      catchInfo.set_base_ptr(thrown);
      catchInfo.set_adjusted_ptr(thrown);
      if (!thrownType) {
        // just pass through the thrown ptr
        setTempRet0(0); return ((catchInfo.ptr)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      // can_catch receives a **, add indirection
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        var caughtType = typeArray[i];
        if (caughtType === 0 || caughtType === thrownType) {
          // Catch all clause matched or exactly the same type is caught
          break;
        }
        if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
          setTempRet0(caughtType); return ((catchInfo.ptr)|0);
        }
      }
      setTempRet0(thrownType); return ((catchInfo.ptr)|0);
    }

  function ___cxa_find_matching_catch_4() {
      var thrown = exceptionLast;
      if (!thrown) {
        // just pass through the null ptr
        setTempRet0(0); return ((0)|0);
      }
      var info = new ExceptionInfo(thrown);
      var thrownType = info.get_type();
      var catchInfo = new CatchInfo();
      catchInfo.set_base_ptr(thrown);
      catchInfo.set_adjusted_ptr(thrown);
      if (!thrownType) {
        // just pass through the thrown ptr
        setTempRet0(0); return ((catchInfo.ptr)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      // can_catch receives a **, add indirection
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        var caughtType = typeArray[i];
        if (caughtType === 0 || caughtType === thrownType) {
          // Catch all clause matched or exactly the same type is caught
          break;
        }
        if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
          setTempRet0(caughtType); return ((catchInfo.ptr)|0);
        }
      }
      setTempRet0(thrownType); return ((catchInfo.ptr)|0);
    }


  function ___cxa_rethrow() {
      var catchInfo = exceptionCaught.pop();
      if (!catchInfo) {
        abort('no exception to throw');
      }
      var info = catchInfo.get_exception_info();
      var ptr = catchInfo.get_base_ptr();
      if (!info.get_rethrown()) {
        // Only pop if the corresponding push was through rethrow_primary_exception
        exceptionCaught.push(catchInfo);
        info.set_rethrown(true);
        info.set_caught(false);
        uncaughtExceptionCount++;
      } else {
        catchInfo.free();
      }
      exceptionLast = ptr;
      throw ptr;
    }

  function ___cxa_throw(ptr, type, destructor) {
      var info = new ExceptionInfo(ptr);
      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      throw ptr;
    }


  var PATH = {splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          // nodejs has crypto support
          return function() { return crypto_module['randomBytes'](1)[0]; };
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  
  function alignMemory(size, alignment) {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      zeroMemory(ptr, size);
      return ptr;
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            // We don't currently support location hints for the address of the mapping
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var IDBFS = {dbs:{},indexedDB:() => {
        if (typeof indexedDB != 'undefined') return indexedDB;
        var ret = null;
        if (typeof window == 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function(mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:(mount, populate, callback) => {
        IDBFS.getLocalSet(mount, (err, local) => {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, (err, remote) => {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:(name, callback) => {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        if (!req) {
          return callback("Unable to connect to IndexedDB");
        }
        req.onupgradeneeded = (e) => {
          var db = /** @type {IDBDatabase} */ (e.target.result);
          var transaction = e.target.transaction;
  
          var fileStore;
  
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
  
          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = () => {
          db = /** @type {IDBDatabase} */ (req.result);
  
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = (e) => {
          callback(this.error);
          e.preventDefault();
        };
      },getLocalSet:(mount, callback) => {
        var entries = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return (p) => {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
  
          entries[path] = { 'timestamp': stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:(mount, callback) => {
        var entries = {};
  
        IDBFS.getDB(mount.mountpoint, (err, db) => {
          if (err) return callback(err);
  
          try {
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
            transaction.onerror = (e) => {
              callback(this.error);
              e.preventDefault();
            };
  
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            var index = store.index('timestamp');
  
            index.openKeyCursor().onsuccess = (event) => {
              var cursor = event.target.result;
  
              if (!cursor) {
                return callback(null, { type: 'remote', db: db, entries: entries });
              }
  
              entries[cursor.primaryKey] = { 'timestamp': cursor.key };
  
              cursor.continue();
            };
          } catch (e) {
            return callback(e);
          }
        });
      },loadLocalEntry:(path, callback) => {
        var stat, node;
  
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (FS.isDir(stat.mode)) {
          return callback(null, { 'timestamp': stat.mtime, 'mode': stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { 'timestamp': stat.mtime, 'mode': stat.mode, 'contents': node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:(path, entry, callback) => {
        try {
          if (FS.isDir(entry['mode'])) {
            FS.mkdirTree(path, entry['mode']);
          } else if (FS.isFile(entry['mode'])) {
            FS.writeFile(path, entry['contents'], { canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }
  
          FS.chmod(path, entry['mode']);
          FS.utime(path, entry['timestamp'], entry['timestamp']);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removeLocalEntry:(path, callback) => {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
  
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadRemoteEntry:(store, path, callback) => {
        var req = store.get(path);
        req.onsuccess = (event) => { callback(null, event.target.result); };
        req.onerror = (e) => {
          callback(this.error);
          e.preventDefault();
        };
      },storeRemoteEntry:(store, path, entry, callback) => {
        try {
          var req = store.put(entry, path);
        } catch (e) {
          callback(e);
          return;
        }
        req.onsuccess = () => { callback(null); };
        req.onerror = (e) => {
          callback(this.error);
          e.preventDefault();
        };
      },removeRemoteEntry:(store, path, callback) => {
        var req = store.delete(path);
        req.onsuccess = () => { callback(null); };
        req.onerror = (e) => {
          callback(this.error);
          e.preventDefault();
        };
      },reconcile:(src, dst, callback) => {
        var total = 0;
  
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e['timestamp'].getTime() != e2['timestamp'].getTime()) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          if (!src.entries[key]) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        function done(err) {
          if (err && !errored) {
            errored = true;
            return callback(err);
          }
        };
  
        transaction.onerror = (e) => {
          done(this.error);
          e.preventDefault();
        };
  
        transaction.oncomplete = (e) => {
          if (!errored) {
            callback(null);
          }
        };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach((path) => {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, (err, entry) => {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, (err, entry) => {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach((path) => {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};
  
  var ERRNO_MESSAGES = {0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};
  
  var ERRNO_CODES = {};
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        assert(typeof parent == 'object')
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        if (typeof type == 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode, fd_start, fd_end) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, address, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
          'IDBFS': IDBFS,
        };
      },init:(input, output, error) => {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // Call musl-internal function to close all stdio streams, so nothing is
        // left in internal buffers.
        ___stdio_exit();
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },absolutePath:() => {
        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');
      },createFolder:() => {
        abort('FS.createFolder has been removed; use FS.mkdir instead');
      },createLink:() => {
        abort('FS.createLink has been removed; use FS.symlink instead');
      },joinPath:() => {
        abort('FS.joinPath has been removed; use PATH.join instead');
      },mmapAlloc:() => {
        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');
      },standardizePath:() => {
        abort('FS.standardizePath has been removed; use PATH.normalize instead');
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (path[0] === '/') {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      }};
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
  try {
  
      // readfds are supported,
      // writefds checks socket open status
      // exceptfds not supported
      // timeout is always 0 - fully async
      assert(nfds <= 64, 'nfds must be less than or equal to 64');  // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
      assert(!exceptfds, 'exceptfds not supported');
  
      var total = 0;
      
      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;
  
      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var check = function(fd, low, high, val) {
        return (fd < 32 ? (low & val) : (high & val));
      };
  
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }
  
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
  
        var flags = SYSCALLS.DEFAULT_POLLMASK;
  
        if (stream.stream_ops.poll) {
          flags = stream.stream_ops.poll(stream);
        }
  
        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }
  
      if (readfds) {
        HEAP32[((readfds)>>2)] = dstReadLow;
        HEAP32[(((readfds)+(4))>>2)] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)] = dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)] = dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)] = dstExceptHigh;
      }
  
      return total;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var SOCKFS = {mount:function(mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = /** @this{Object} */ function(event, callback) {
          if ('function' === typeof callback) {
            this._callbacks[event] = callback;
          }
          return this;
        };
  
        Module['websocket'].emit = /** @this{Object} */ function(event, param) {
          if ('function' === typeof this._callbacks[event]) {
            this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function(family, type, protocol) {
        type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function(sock, addr, port) {
          var ws;
  
          if (typeof addr == 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The default WebSocket options
              var opts = undefined;
  
              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
                // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
                opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
              }
  
              // some webservers (azure) does not support subprotocol header
              if (runtimeConfig && null === Module['websocket']['subprotocol']) {
                subProtocols = 'null';
                opts = undefined;
              }
  
              // If node we use the ws library.
              var WebSocketConstructor;
              if (ENVIRONMENT_IS_NODE) {
                WebSocketConstructor = /** @type{(typeof WebSocket)} */(require('ws'));
              } else
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport != 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function(sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            if (typeof data == 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              } else {
                data = new Uint8Array(data); // make a typed array view on the array buffer
              }
            }
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)] = bytes;
              return 0;
            default:
              return 28;
          }
        },close:function(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function(sock, addr, port) {
          if (typeof sock.saddr != 'undefined' || typeof sock.sport != 'undefined') {
            throw new FS.ErrnoError(28);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== 138) throw e;
            }
          }
        },connect:function(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr != 'undefined' && typeof sock.dport != 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(26);
        },listen:function(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
          if (sock.server) {
             throw new FS.ErrnoError(28);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = 23; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(53);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(17);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(6);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
  
          var data;
            data = buffer.slice(offset, offset + length);
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },recvmsg:function(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(53);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(53);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(6);
              }
            } else {
              throw new FS.ErrnoError(6);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};
  function getSocketFromFD(fd) {
      var socket = SOCKFS.getSocket(fd);
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    }
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  var Sockets = {BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};
  
  function inetPton4(str) {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    }
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  function inetPton6(str) {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] == 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    }
  /** @param {number=} addrlen */
  function writeSockaddr(sa, family, addr, port, addrlen) {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        case 10:
          addr = inetPton6(addr);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    }
  
  var DNS = {address_map:{id:1,addrs:{},names:{}},lookup_name:function (name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },lookup_addr:function (addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      }};
  function ___syscall_accept4(fd, addr, addrlen, flags) {
  try {
  
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
        assert(!errno);
      }
      return newsock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function inetNtop4(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }
  
  function inetNtop6(ints) {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    }
  function readSockaddr(sa, salen) {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;
  
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = inetNtop4(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = inetNtop6(addr);
          break;
        default:
          return { errno: 5 };
      }
  
      return { family: family, addr: addr, port: port };
    }
  /** @param {boolean=} allowNull */
  function getSocketAddress(addrp, addrlen, allowNull) {
      if (allowNull && addrp === 0) return null;
      var info = readSockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    }
  function ___syscall_connect(fd, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
        /* case 5: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        /* case 6: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 7: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd);
      if (size < cwdLengthInBytes + 1) return -68;
      stringToUTF8(cwd, buf, size);
      return buf;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getdents64(fd, dirp, count) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
  
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
  
      var idx = Math.floor(off / struct_size);
  
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === '.') {
          id = stream.node.id;
          type = 4; // DT_DIR
        }
        else if (name === '..') {
          var lookup = FS.lookupPath(stream.path, { parent: true });
          id = lookup.node.id;
          type = 4; // DT_DIR
        }
        else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        assert(id);
        (tempI64 = [id>>>0,(tempDouble=id,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((dirp + pos)>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(4))>>2)] = tempI64[1]);
        (tempI64 = [(idx + 1) * struct_size>>>0,(tempDouble=(idx + 1) * struct_size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((dirp + pos)+(8))>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(12))>>2)] = tempI64[1]);
        HEAP16[(((dirp + pos)+(16))>>1)] = 280;
        HEAP8[(((dirp + pos)+(18))>>0)] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getsockopt(fd, level, optname, optval, optlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
      // so only supports SOL_SOCKET with SO_ERROR.
      if (level === 1) {
        if (optname === 4) {
          HEAP32[((optval)>>2)] = sock.error;
          HEAP32[((optlen)>>2)] = 4;
          sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
          return 0;
        }
      }
      return -50; // The option is unknown at the level indicated.
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdir(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMkdir(path, mode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~4352);
      assert(!flags, flags);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len);
      if (!msg) return 0; // socket is closed
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
        assert(!errno);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {
  
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
  try {
  
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        // send, no address provided
        return FS.write(sock.stream, HEAP8,message, length);
      } else {
        // sendto an address
        return sock.sock_ops.sendmsg(sock, HEAP8,message, length, dest.addr, dest.port);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_socket(domain, type, protocol) {
  try {
  
      var sock = SOCKFS.createSocket(domain, type, protocol);
      assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
      return sock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_statfs64(path, size, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(size === 64);
      // NOTE: None of the constants here are true. We're just returning safe and
      //       sane values.
      HEAP32[(((buf)+(4))>>2)] = 4096;
      HEAP32[(((buf)+(40))>>2)] = 4096;
      HEAP32[(((buf)+(8))>>2)] = 1000000;
      HEAP32[(((buf)+(12))>>2)] = 500000;
      HEAP32[(((buf)+(16))>>2)] = 500000;
      HEAP32[(((buf)+(20))>>2)] = FS.nextInode;
      HEAP32[(((buf)+(24))>>2)] = 1000000;
      HEAP32[(((buf)+(28))>>2)] = 42;
      HEAP32[(((buf)+(44))>>2)] = 2;  // ST_NOSUID
      HEAP32[(((buf)+(36))>>2)] = 255;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_truncate64(path, low, high) {
  try {
  
      path = SYSCALLS.getStr(path);
      var length = SYSCALLS.get64(low, high);
      FS.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = HEAP32[((times)>>2)];
        var nanoseconds = HEAP32[(((times)+(4))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 8;
        seconds = HEAP32[((times)>>2)];
        nanoseconds = HEAP32[(((times)+(4))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var dlopen_main_init = 0;
  function __dlopen_js(handle) {
  		warnOnce('Unable to open DLL! Dynamic linking is not supported in WebAssembly builds due to limitations to performance and code size. Please statically link in the needed libraries.');
  		// Do not abort here - IL2CPP will throw a managed exception.
  
  		// Return dummy success for the first dlopen since that is the __main__ module (so it gets past its assert checks),
  		// and false otherwise. TODO: After Emscripten is updated to a version newer than 3.1.8-unity, this logic can be
  		// dropped: https://github.com/emscripten-core/emscripten/issues/16790
  		var ret = !dlopen_main_init;
  		dlopen_main_init = 1;
  		return ret;
  	}

  function __dlsym_js(handle, symbol) {
  		return 0;
  	}

  function __emscripten_date_now() {
      return Date.now();
    }

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  function __emscripten_throw_longjmp() { throw Infinity; }

  function __gmtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
    }

  function __localtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }

  function __mktime_js(tmPtr) {
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      // To match expected behavior, update fields from date
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
  
      return (date.getTime() / 1000)|0;
    }

  function __mmap_js(addr, len, prot, flags, fd, off, allocated, builtin) {
  try {
  
      var info = FS.getStream(fd);
      if (!info) return -8;
      var res = FS.mmap(info, addr, len, off, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      return ptr;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function __munmap_js(addr, len, prot, flags, fd, offset) {
  try {
  
      var stream = FS.getStream(fd);
      if (stream) {
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, flags, offset);
        }
        FS.munmap(stream);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function _tzset_impl(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
      // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        HEAP32[((tzname)>>2)] = winterNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAP32[((tzname)>>2)] = summerNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }
  function __tzset_js(timezone, daylight, tzname) {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (__tzset_js.called) return;
      __tzset_js.called = true;
      _tzset_impl(timezone, daylight, tzname);
    }

  function _abort() {
      abort('native code called abort()');
    }

  var readAsmConstArgsArray = [];
  function readAsmConstArgs(sigPtr, buf) {
      ;
      // Nobody should have mutated _readAsmConstArgsArray underneath us to be something else than an array.
      assert(Array.isArray(readAsmConstArgsArray));
      // The input buffer is allocated on the stack, so it must be stack-aligned.
      assert(buf % 16 == 0);
      readAsmConstArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      buf >>= 2;
      while (ch = HEAPU8[sigPtr++]) {
        assert(ch === 100/*'d'*/ || ch === 102/*'f'*/ || ch === 105 /*'i'*/, 'Invalid character ' + ch + '("' + String.fromCharCode(ch) + '") in readAsmConstArgs! Use only "d", "f" or "i", and do not specify "v" for void return argument.');
        // A double takes two 32-bit slots, and must also be aligned - the backend
        // will emit padding to avoid that.
        var readAsmConstArgsDouble = ch < 105;
        if (readAsmConstArgsDouble && (buf & 1)) buf++;
        readAsmConstArgsArray.push(readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]);
        ++buf;
      }
      return readAsmConstArgsArray;
    }
  function _emscripten_asm_const_int(code, sigPtr, argbuf) {
      var args = readAsmConstArgs(sigPtr, argbuf);
      if (!ASM_CONSTS.hasOwnProperty(code)) abort('No EM_ASM constant found at address ' + code);
      return ASM_CONSTS[code].apply(null, args);
    }

  function mainThreadEM_ASM(code, sigPtr, argbuf, sync) {
      var args = readAsmConstArgs(sigPtr, argbuf);
      if (!ASM_CONSTS.hasOwnProperty(code)) abort('No EM_ASM constant found at address ' + code);
      return ASM_CONSTS[code].apply(null, args);
    }
  function _emscripten_asm_const_int_sync_on_main_thread(code, sigPtr, argbuf) {
      return mainThreadEM_ASM(code, sigPtr, argbuf, 1);
    }

  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        err('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (!Browser.mainLoop.running) {
        
        Browser.mainLoop.running = true;
      }
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
        if (typeof setImmediate == 'undefined') {
          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
          var setImmediates = [];
          var emscriptenMainLoopMessageId = 'setimmediate';
          var Browser_setImmediate_messageHandler = function(/** @type {Event} */ event) {
            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
            // so check for both cases.
            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
              event.stopPropagation();
              setImmediates.shift()();
            }
          }
          addEventListener("message", Browser_setImmediate_messageHandler, true);
          setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
            setImmediates.push(func);
            if (ENVIRONMENT_IS_WORKER) {
              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
              Module['setImmediates'].push(func);
              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
          })
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    }
  
  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = () => {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else _emscripten_get_now = () => performance.now();
  ;
  
  function runtimeKeepalivePush() {
    }
  
  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }
  function maybeExit() {
    }
  
    /**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */
  function setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) {
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = browserIterationFunc;
      Browser.mainLoop.arg = arg;
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
      function checkIsRunning() {
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
          
          maybeExit();
          return false;
        }
        return true;
      }
  
      // We create the loop runner here but it is not actually running until
      // _emscripten_set_main_loop_timing is called (which might happen a
      // later time).  This member signifies that the current runner has not
      // yet been started so that we can call runtimeKeepalivePush when it
      // gets it timing set for the first time.
      Browser.mainLoop.running = false;
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          out('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (!checkIsRunning()) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (!checkIsRunning()) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
        GL.newRenderingFrameStarted();
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          warnOnce('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
        checkStackCookie();
  
        // catch pauses from the main loop itself
        if (!checkIsRunning()) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL == 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    }
  
  /** @param {boolean=} synchronous */
  function callUserCallback(func, synchronous) {
      if (ABORT) {
        err('user callback triggered after runtime exited or application aborted.  Ignoring.');
        return;
      }
      // For synchronous calls, let any exceptions propagate, and don't let the runtime exit.
      if (synchronous) {
        func();
        return;
      }
      try {
        func();
      } catch (e) {
        handleException(e);
      }
    }
  
  function runtimeKeepalivePop() {
    }
  /** @param {number=} timeout */
  function safeSetTimeout(func, timeout) {
      
      return setTimeout(function() {
        
        callUserCallback(func);
      }, timeout);
    }
  var Browser = {mainLoop:{running:false,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function() {
          Browser.mainLoop.scheduler = null;
          // Incrementing this signals the previous main loop that it's now become old, and it must return.
          Browser.mainLoop.currentlyRunningMainloop++;
        },resume:function() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          // do not set timing and call scheduler, we will do it on the next lines
          setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          callUserCallback(func);
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function() {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          out("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? out("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject == 'undefined') {
          out("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = () => {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = (event) => {
            out('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              out('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },handledByPreloadPlugin:function(byteArray, fullname, finish, onerror) {
        // Ensure plugins are ready.
        Browser.init();
  
        var handled = false;
        Module['preloadPlugins'].forEach(function(plugin) {
          if (handled) return;
          if (plugin['canHandle'](fullname)) {
            plugin['handle'](byteArray, fullname, finish, onerror);
            handled = true;
          }
        });
        return handled;
      },createContext:function(/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: (typeof WebGL2RenderingContext != 'undefined') ? 2 : 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL != 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx == 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function(canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        canvasContainer.requestFullscreen();
      },requestFullScreen:function() {
        abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');
      },exitFullscreen:function() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (function() {});
        CFS.apply(document, []);
        return true;
      },nextRAF:0,fakeRequestAnimationFrame:function(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function(func) {
        if (typeof requestAnimationFrame == 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },safeSetTimeout:function(func) {
        // Legacy function, this is used by the SDL2 port so we need to keep it
        // around at least until that is updated.
        return safeSetTimeout(func);
      },safeRequestAnimationFrame:function(func) {
        
        return Browser.requestAnimationFrame(function() {
          
          callUserCallback(func);
        });
      },getMimetype:function(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function(func) {
        if (!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch (event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
          // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
          // and we have no viable fallback.
          assert((typeof scrollX != 'undefined') && (typeof scrollY != 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },resizeListeners:[],updateResizeListeners:function() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      }};
  function _emscripten_cancel_main_loop() {
      Browser.mainLoop.pause();
      Browser.mainLoop.func = null;
    }

  function _emscripten_clear_interval(id) {
      
      clearInterval(id);
    }

  function _emscripten_console_error(str) {
      assert(typeof str == 'number');
      console.error(UTF8ToString(str));
    }

  var JSEvents = {inEventHandler:0,removeAllEventListeners:function() {
        for (var i = JSEvents.eventHandlers.length-1; i >= 0; --i) {
          JSEvents._removeHandler(i);
        }
        JSEvents.eventHandlers = [];
        JSEvents.deferredCalls = [];
      },registerRemoveEventListeners:function() {
        if (!JSEvents.removeEventListenersRegistered) {
          __ATEXIT__.push(JSEvents.removeAllEventListeners);
          JSEvents.removeEventListenersRegistered = true;
        }
      },deferredCalls:[],deferCall:function(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length) return false;
  
          for (var i in arrA) {
            if (arrA[i] != arrB[i]) return false;
          }
          return true;
        }
        // Test if the given call was already queued, and if so, don't add it again.
        for (var i in JSEvents.deferredCalls) {
          var call = JSEvents.deferredCalls[i];
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({
          targetFunction: targetFunction,
          precedence: precedence,
          argsList: argsList
        });
  
        JSEvents.deferredCalls.sort(function(x,y) { return x.precedence < y.precedence; });
      },removeDeferredCalls:function(targetFunction) {
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
            JSEvents.deferredCalls.splice(i, 1);
            --i;
          }
        }
      },canPerformEventHandlerRequests:function() {
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      },runDeferredCalls:function() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          var call = JSEvents.deferredCalls[i];
          JSEvents.deferredCalls.splice(i, 1);
          --i;
          call.targetFunction.apply(null, call.argsList);
        }
      },eventHandlers:[],removeAllHandlersOnTarget:function(target, eventTypeString) {
        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target && 
            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
             JSEvents._removeHandler(i--);
           }
        }
      },_removeHandler:function(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      },registerOrRemoveHandler:function(eventHandler) {
        var jsEventHandler = function jsEventHandler(event) {
          // Increment nesting count for the event handler.
          ++JSEvents.inEventHandler;
          JSEvents.currentEventHandler = eventHandler;
          // Process any old deferred calls the user has placed.
          JSEvents.runDeferredCalls();
          // Process the actual event, calls back to user C code handler.
          eventHandler.handlerFunc(event);
          // Process any new deferred calls that were placed right now from this event handler.
          JSEvents.runDeferredCalls();
          // Out of event handler - restore nesting count.
          --JSEvents.inEventHandler;
        };
        
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = jsEventHandler;
          eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
          JSEvents.registerRemoveEventListeners();
        } else {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target
             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
               JSEvents._removeHandler(i--);
             }
          }
        }
      },getNodeNameForTarget:function(target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == screen) return '#screen';
        return (target && target.nodeName) ? target.nodeName : '';
      },fullscreenEnabled:function() {
        return document.fullscreenEnabled
        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
        // TODO: If Safari at some point ships with unprefixed version, update the version check above.
        || document.webkitFullscreenEnabled
         ;
      }};
  
  var currentFullscreenStrategy = {};
  
  function maybeCStringToJsString(cString) {
      // "cString > 2" checks if the input is a number, and isn't of the special
      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
      // In other words, if cString > 2 then it's a pointer to a valid place in
      // memory, and points to a C string.
      return cString > 2 ? UTF8ToString(cString) : cString;
    }
  
  var specialHTMLTargets = [0, typeof document != 'undefined' ? document : 0, typeof window != 'undefined' ? window : 0];
  function findEventTarget(target) {
      target = maybeCStringToJsString(target);
      var domElement = specialHTMLTargets[target] || (typeof document != 'undefined' ? document.querySelector(target) : undefined);
      return domElement;
    }
  function findCanvasEventTarget(target) { return findEventTarget(target); }
  function _emscripten_get_canvas_element_size(target, width, height) {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      HEAP32[((width)>>2)] = canvas.width;
      HEAP32[((height)>>2)] = canvas.height;
    }
  function getCanvasElementSize(target) {
      return withStackSave(function() {
        var w = stackAlloc(8);
        var h = w + 4;
  
        var targetInt = stackAlloc(target.id.length+1);
        stringToUTF8(target.id, targetInt, target.id.length+1);
        var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
        var size = [HEAP32[((w)>>2)], HEAP32[((h)>>2)]];
        return size;
      });
    }
  
  function _emscripten_set_canvas_element_size(target, width, height) {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      canvas.width = width;
      canvas.height = height;
      return 0;
    }
  function setCanvasElementSize(target, width, height) {
      if (!target.controlTransferredOffscreen) {
        target.width = width;
        target.height = height;
      } else {
        // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
        // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
        withStackSave(function() {
          var targetInt = stackAlloc(target.id.length+1);
          stringToUTF8(target.id, targetInt, target.id.length+1);
          _emscripten_set_canvas_element_size(targetInt, width, height);
        });
      }
    }
  function registerRestoreOldStyle(canvas) {
      var canvasSize = getCanvasElementSize(canvas);
      var oldWidth = canvasSize[0];
      var oldHeight = canvasSize[1];
      var oldCssWidth = canvas.style.width;
      var oldCssHeight = canvas.style.height;
      var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
      var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
      // Firefox always has black background color.
      var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
      var oldPaddingRight = canvas.style.paddingRight;
      var oldPaddingTop = canvas.style.paddingTop;
      var oldPaddingBottom = canvas.style.paddingBottom;
      var oldMarginLeft = canvas.style.marginLeft; // IE11
      var oldMarginRight = canvas.style.marginRight;
      var oldMarginTop = canvas.style.marginTop;
      var oldMarginBottom = canvas.style.marginBottom;
      var oldDocumentBodyMargin = document.body.style.margin;
      var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
      var oldDocumentScroll = document.body.scroll; // IE
      var oldImageRendering = canvas.style.imageRendering;
  
      function restoreOldStyle() {
        var fullscreenElement = document.fullscreenElement
          || document.webkitFullscreenElement
          || document.msFullscreenElement
          ;
        if (!fullscreenElement) {
          document.removeEventListener('fullscreenchange', restoreOldStyle);
  
          // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
          // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
          document.removeEventListener('webkitfullscreenchange', restoreOldStyle);
  
          setCanvasElementSize(canvas, oldWidth, oldHeight);
  
          canvas.style.width = oldCssWidth;
          canvas.style.height = oldCssHeight;
          canvas.style.backgroundColor = oldBackgroundColor; // Chrome
          // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
          // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
          // had explicitly set so subsequent fullscreen transitions would not set background color properly.
          if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = 'white';
          document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
          canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
          canvas.style.paddingRight = oldPaddingRight;
          canvas.style.paddingTop = oldPaddingTop;
          canvas.style.paddingBottom = oldPaddingBottom;
          canvas.style.marginLeft = oldMarginLeft; // IE11
          canvas.style.marginRight = oldMarginRight;
          canvas.style.marginTop = oldMarginTop;
          canvas.style.marginBottom = oldMarginBottom;
          document.body.style.margin = oldDocumentBodyMargin;
          document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
          document.body.scroll = oldDocumentScroll; // IE
          canvas.style.imageRendering = oldImageRendering;
          if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
  
          if (currentFullscreenStrategy.canvasResizedCallback) {
            (function(a1, a2, a3) { return dynCall_iiii.apply(null, [currentFullscreenStrategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        }
      }
      document.addEventListener('fullscreenchange', restoreOldStyle);
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      document.addEventListener('webkitfullscreenchange', restoreOldStyle);
      return restoreOldStyle;
    }
  
  function setLetterbox(element, topBottom, leftRight) {
        // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
        element.style.paddingLeft = element.style.paddingRight = leftRight + 'px';
        element.style.paddingTop = element.style.paddingBottom = topBottom + 'px';
    }
  
  function getBoundingClientRect(e) {
      return specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};
    }
  function _JSEvents_resizeCanvasForFullscreen(target, strategy) {
      var restoreOldStyle = registerRestoreOldStyle(target);
      var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
      var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
      var rect = getBoundingClientRect(target);
      var windowedCssWidth = rect.width;
      var windowedCssHeight = rect.height;
      var canvasSize = getCanvasElementSize(target);
      var windowedRttWidth = canvasSize[0];
      var windowedRttHeight = canvasSize[1];
  
      if (strategy.scaleMode == 3) {
        setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
        cssWidth = windowedCssWidth;
        cssHeight = windowedCssHeight;
      } else if (strategy.scaleMode == 2) {
        if (cssWidth*windowedRttHeight < windowedRttWidth*cssHeight) {
          var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
          setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
          cssHeight = desiredCssHeight;
        } else {
          var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
          setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
          cssWidth = desiredCssWidth;
        }
      }
  
      // If we are adding padding, must choose a background color or otherwise Chrome will give the
      // padding a default white color. Do it only if user has not customized their own background color.
      if (!target.style.backgroundColor) target.style.backgroundColor = 'black';
      // IE11 does the same, but requires the color to be set in the document body.
      if (!document.body.style.backgroundColor) document.body.style.backgroundColor = 'black'; // IE11
      // Firefox always shows black letterboxes independent of style color.
  
      target.style.width = cssWidth + 'px';
      target.style.height = cssHeight + 'px';
  
      if (strategy.filteringMode == 1) {
        target.style.imageRendering = 'optimizeSpeed';
        target.style.imageRendering = '-moz-crisp-edges';
        target.style.imageRendering = '-o-crisp-edges';
        target.style.imageRendering = '-webkit-optimize-contrast';
        target.style.imageRendering = 'optimize-contrast';
        target.style.imageRendering = 'crisp-edges';
        target.style.imageRendering = 'pixelated';
      }
  
      var dpiScale = (strategy.canvasResolutionScaleMode == 2) ? devicePixelRatio : 1;
      if (strategy.canvasResolutionScaleMode != 0) {
        var newWidth = (cssWidth * dpiScale)|0;
        var newHeight = (cssHeight * dpiScale)|0;
        setCanvasElementSize(target, newWidth, newHeight);
        if (target.GLctxObject) target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
      }
      return restoreOldStyle;
    }
  function _JSEvents_requestFullscreen(target, strategy) {
      // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
      if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
        _JSEvents_resizeCanvasForFullscreen(target, strategy);
      }
  
      if (target.requestFullscreen) {
        target.requestFullscreen();
      } else if (target.webkitRequestFullscreen) {
        target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else {
        return JSEvents.fullscreenEnabled() ? -3 : -1;
      }
  
      currentFullscreenStrategy = strategy;
  
      if (strategy.canvasResizedCallback) {
        (function(a1, a2, a3) { return dynCall_iiii.apply(null, [strategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    }
  function _emscripten_exit_fullscreen() {
      if (!JSEvents.fullscreenEnabled()) return -1;
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(_JSEvents_requestFullscreen);
  
      var d = specialHTMLTargets[1];
      if (d.exitFullscreen) {
        d.fullscreenElement && d.exitFullscreen();
      } else if (d.webkitExitFullscreen) {
        d.webkitFullscreenElement && d.webkitExitFullscreen();
      } else {
        return -1;
      }
  
      return 0;
    }

  function requestPointerLock(target) {
      if (target.requestPointerLock) {
        target.requestPointerLock();
      } else if (target.msRequestPointerLock) {
        target.msRequestPointerLock();
      } else {
        // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
        // or if the whole browser just doesn't support the feature.
        if (document.body.requestPointerLock
          || document.body.msRequestPointerLock
          ) {
          return -3;
        } else {
          return -1;
        }
      }
      return 0;
    }
  function _emscripten_exit_pointerlock() {
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(requestPointerLock);
  
      if (document.exitPointerLock) {
        document.exitPointerLock();
      } else if (document.msExitPointerLock) {
        document.msExitPointerLock();
      } else {
        return -1;
      }
      return 0;
    }


  function fillFullscreenChangeEventData(eventStruct) {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      var isFullscreen = !!fullscreenElement;
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP32[((eventStruct)>>2)] = isFullscreen;
      HEAP32[(((eventStruct)+(4))>>2)] = JSEvents.fullscreenEnabled();
      // If transitioning to fullscreen, report info about the element that is now fullscreen.
      // If transitioning to windowed mode, report info about the element that just was fullscreen.
      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
      var id = (reportedElement && reportedElement.id) ? reportedElement.id : '';
      stringToUTF8(nodeName, eventStruct + 8, 128);
      stringToUTF8(id, eventStruct + 136, 128);
      HEAP32[(((eventStruct)+(264))>>2)] = reportedElement ? reportedElement.clientWidth : 0;
      HEAP32[(((eventStruct)+(268))>>2)] = reportedElement ? reportedElement.clientHeight : 0;
      HEAP32[(((eventStruct)+(272))>>2)] = screen.width;
      HEAP32[(((eventStruct)+(276))>>2)] = screen.height;
      if (isFullscreen) {
        JSEvents.previousFullscreenElement = fullscreenElement;
      }
    }
  function _emscripten_get_fullscreen_status(fullscreenStatus) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      fillFullscreenChangeEventData(fullscreenStatus);
      return 0;
    }

  function fillGamepadEventData(eventStruct, e) {
      HEAPF64[((eventStruct)>>3)] = e.timestamp;
      for (var i = 0; i < e.axes.length; ++i) {
        HEAPF64[(((eventStruct+i*8)+(16))>>3)] = e.axes[i];
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i].value;
        } else {
          HEAPF64[(((eventStruct+i*8)+(528))>>3)] = e.buttons[i];
        }
      }
      for (var i = 0; i < e.buttons.length; ++i) {
        if (typeof e.buttons[i] == 'object') {
          HEAP32[(((eventStruct+i*4)+(1040))>>2)] = e.buttons[i].pressed;
        } else {
          // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
          /** @suppress {checkTypes} */
          HEAP32[(((eventStruct+i*4)+(1040))>>2)] = e.buttons[i] == 1;
        }
      }
      HEAP32[(((eventStruct)+(1296))>>2)] = e.connected;
      HEAP32[(((eventStruct)+(1300))>>2)] = e.index;
      HEAP32[(((eventStruct)+(8))>>2)] = e.axes.length;
      HEAP32[(((eventStruct)+(12))>>2)] = e.buttons.length;
      stringToUTF8(e.id, eventStruct + 1304, 64);
      stringToUTF8(e.mapping, eventStruct + 1368, 64);
    }
  function _emscripten_get_gamepad_status(index, gamepadState) {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_gamepad_status() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
  
      // INVALID_PARAM is returned on a Gamepad index that never was there.
      if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;
  
      // NO_DATA is returned on a Gamepad index that was removed.
      // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
      // This is because gamepads must keep their original position in the array.
      // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
      if (!JSEvents.lastGamepadState[index]) return -7;
  
      fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
      return 0;
    }

  function _emscripten_get_heap_max() {
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      return 2147483648;
    }


  function _emscripten_get_now_res() { // return resolution of get_now, in nanoseconds
      if (ENVIRONMENT_IS_NODE) {
        return 1; // nanoseconds
      } else
      // Modern environment where performance.now() is supported:
      return 1000; // microseconds (1/1000 of a millisecond)
    }

  function _emscripten_get_num_gamepads() {
      if (!JSEvents.lastGamepadState) throw 'emscripten_get_num_gamepads() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
      // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
      // Otherwise the following line will throw an exception.
      return JSEvents.lastGamepadState.length;
    }

  function _emscripten_html5_remove_all_event_listeners() {
      JSEvents.removeAllEventListeners();
    }

  function _emscripten_is_webgl_context_lost(contextHandle) {
      return !GL.contexts[contextHandle] || GL.contexts[contextHandle].GLctx.isContextLost(); // No context ~> lost context.
    }

  function reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }
  
  function convertI32PairToI53(lo, hi) {
      // This function should not be getting called with too large unsigned numbers
      // in high part (if hi >= 0x7FFFFFFFF, one should have been calling
      // convertU32PairToI53())
      assert(hi === (hi|0));
      return (lo >>> 0) + hi * 4294967296;
    }
  
  function convertU32PairToI53(lo, hi) {
      return (lo >>> 0) + (hi >>> 0) * 4294967296;
    }
  
  function reSign(value, bits) {
      if (value <= 0) {
        return value;
      }
      var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                            : Math.pow(2, bits-1);
      // for huge values, we can hit the precision limit and always get true here.
      // so don't do that but, in general there is no perfect solution here. With
      // 64-bit ints, we get rounding and errors
      // TODO: In i64 mode 1, resign the two parts separately and safely
      if (value >= half && (bits <= 32 || value > half)) {
        // Cannot bitshift half, as it may be at the limit of the bits JS uses in
        // bitshifts
        value = -2*half + value;
      }
      return value;
    }
  
  function unSign(value, bits) {
      if (value >= 0) {
        return value;
      }
      // Need some trickery, since if bits == 32, we are right at the limit of the
      // bits JS uses in bitshifts
      return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value
                        : Math.pow(2, bits)         + value;
    }
  function formatString(format, varargs) {
      ;
      assert((varargs & 3) === 0);
      var textIndex = format;
      var argIndex = varargs;
      // This must be called before reading a double or i64 vararg. It will bump the pointer properly.
      // It also does an assert on i32 values, so it's nice to call it before all varargs calls.
      function prepVararg(ptr, type) {
        if (type === 'double' || type === 'i64') {
          // move so the load is aligned
          if (ptr & 7) {
            assert((ptr & 7) === 4);
            ptr += 4;
          }
        } else {
          assert((ptr & 3) === 0);
        }
        return ptr;
      }
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        argIndex = prepVararg(argIndex, type);
        if (type === 'double') {
          ret = Number(HEAPF64[((argIndex)>>3)]);
          argIndex += 8;
        } else if (type == 'i64') {
          ret = [HEAP32[((argIndex)>>2)],
                 HEAP32[(((argIndex)+(4))>>2)]];
          argIndex += 8;
        } else {
          assert((argIndex & 3) === 0);
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[((argIndex)>>2)];
          argIndex += 4;
        }
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while (1) {
        var startTextIndex = textIndex;
        curr = HEAP8[((textIndex)>>0)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)>>0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)>>0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while (1) {
                var precisionChr = HEAP8[((textIndex+1)>>0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)>>0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)>>0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              currArg = getNextArg('i' + (argSize * 8));
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = next == 117 ? convertU32PairToI53(currArg[0], currArg[1]) : convertI32PairToI53(currArg[0], currArg[1]);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                argText = reSign(currArg, 8 * argSize).toString(10);
              } else if (next == 117) {
                argText = unSign(currArg, 8 * argSize).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].includes('.') &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)>>0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)] = ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[((i)>>0)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }
  
  function traverseStack(args) {
      if (!args || !args.callee || !args.callee.name) {
        return [null, '', ''];
      }
  
      var funstr = args.callee.toString();
      var funcname = args.callee.name;
      var str = '(';
      var first = true;
      for (var i in args) {
        var a = args[i];
        if (!first) {
          str += ", ";
        }
        first = false;
        if (typeof a == 'number' || typeof a == 'string') {
          str += a;
        } else {
          str += '(' + typeof a + ')';
        }
      }
      str += ')';
      var caller = args.callee.caller;
      args = caller ? caller.arguments : [];
      if (first)
        str = '';
      return [args, funcname, str];
    }
  /** @param {number=} flags */
  function _emscripten_get_callstack_js(flags) {
      var callstack = jsStackTrace();
  
      // Find the symbols in the callstack that corresponds to the functions that report callstack information, and remove everything up to these from the output.
      var iThisFunc = callstack.lastIndexOf('_emscripten_log');
      var iThisFunc2 = callstack.lastIndexOf('_emscripten_get_callstack');
      var iNextLine = callstack.indexOf('\n', Math.max(iThisFunc, iThisFunc2))+1;
      callstack = callstack.slice(iNextLine);
  
      if (flags & 32) {
        warnOnce('EM_LOG_DEMANGLE is deprecated; ignoring');
      }
  
      // If user requested to see the original source stack, but no source map information is available, just fall back to showing the JS stack.
      if (flags & 8 && typeof emscripten_source_map == 'undefined') {
        warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');
        flags ^= 8;
        flags |= 16;
      }
  
      var stack_args = null;
      if (flags & 128) {
        // To get the actual parameters to the functions, traverse the stack via the unfortunately deprecated 'arguments.callee' method, if it works:
        stack_args = traverseStack(arguments);
        while (stack_args[1].includes('_emscripten_'))
          stack_args = traverseStack(stack_args[0]);
      }
  
      // Process all lines:
      var lines = callstack.split('\n');
      callstack = '';
      var newFirefoxRe = new RegExp('\\s*(.*?)@(.*?):([0-9]+):([0-9]+)'); // New FF30 with column info: extract components of form '       Object._main@http://server.com:4324:12'
      var firefoxRe = new RegExp('\\s*(.*?)@(.*):(.*)(:(.*))?'); // Old FF without column info: extract components of form '       Object._main@http://server.com:4324'
      var chromeRe = new RegExp('\\s*at (.*?) \\\((.*):(.*):(.*)\\\)'); // Extract components of form '    at Object._main (http://server.com/file.html:4324:12)'
  
      for (var l in lines) {
        var line = lines[l];
  
        var symbolName = '';
        var file = '';
        var lineno = 0;
        var column = 0;
  
        var parts = chromeRe.exec(line);
        if (parts && parts.length == 5) {
          symbolName = parts[1];
          file = parts[2];
          lineno = parts[3];
          column = parts[4];
        } else {
          parts = newFirefoxRe.exec(line);
          if (!parts) parts = firefoxRe.exec(line);
          if (parts && parts.length >= 4) {
            symbolName = parts[1];
            file = parts[2];
            lineno = parts[3];
            column = parts[4]|0; // Old Firefox doesn't carry column information, but in new FF30, it is present. See https://bugzilla.mozilla.org/show_bug.cgi?id=762556
          } else {
            // Was not able to extract this line for demangling/sourcemapping purposes. Output it as-is.
            callstack += line + '\n';
            continue;
          }
        }
  
        var haveSourceMap = false;
  
        if (flags & 8) {
          var orig = emscripten_source_map.originalPositionFor({line: lineno, column: column});
          haveSourceMap = (orig && orig.source);
          if (haveSourceMap) {
            if (flags & 64) {
              orig.source = orig.source.substring(orig.source.replace(/\\/g, "/").lastIndexOf('/')+1);
            }
            callstack += '    at ' + symbolName + ' (' + orig.source + ':' + orig.line + ':' + orig.column + ')\n';
          }
        }
        if ((flags & 16) || !haveSourceMap) {
          if (flags & 64) {
            file = file.substring(file.replace(/\\/g, "/").lastIndexOf('/')+1);
          }
          callstack += (haveSourceMap ? ('     = ' + symbolName) : ('    at '+ symbolName)) + ' (' + file + ':' + lineno + ':' + column + ')\n';
        }
  
        // If we are still keeping track with the callstack by traversing via 'arguments.callee', print the function parameters as well.
        if (flags & 128 && stack_args[0]) {
          if (stack_args[1] == symbolName && stack_args[2].length > 0) {
            callstack = callstack.replace(/\s+$/, '');
            callstack += ' with values: ' + stack_args[1] + stack_args[2] + '\n';
          }
          stack_args = traverseStack(stack_args[0]);
        }
      }
      // Trim extra whitespace at the end of the output.
      callstack = callstack.replace(/\s+$/, '');
      return callstack;
    }
  function _emscripten_log_js(flags, str) {
      if (flags & 24) {
        str = str.replace(/\s+$/, ''); // Ensure the message and the callstack are joined cleanly with exactly one newline.
        str += (str.length > 0 ? '\n' : '') + _emscripten_get_callstack_js(flags);
      }
  
      if (flags & 1) {
        if (flags & 4) {
          console.error(str);
        } else if (flags & 2) {
          console.warn(str);
        } else if (flags & 512) {
          console.info(str);
        } else if (flags & 256) {
          console.debug(str);
        } else {
          console.log(str);
        }
      } else if (flags & 6) {
        err(str);
      } else {
        out(str);
      }
    }
  function _emscripten_log(flags, format, varargs) {
      var result = formatString(format, varargs);
      var str = UTF8ArrayToString(result, 0);
      _emscripten_log_js(flags, str);
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function doRequestFullscreen(target, strategy) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
  
      if (!target.requestFullscreen
        && !target.webkitRequestFullscreen
        ) {
        return -3;
      }
  
      var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
  
      // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canPerformRequests) {
        if (strategy.deferUntilInEventHandler) {
          JSEvents.deferCall(_JSEvents_requestFullscreen, 1 /* priority over pointer lock */, [target, strategy]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return _JSEvents_requestFullscreen(target, strategy);
    }
  function _emscripten_request_fullscreen(target, deferUntilInEventHandler) {
      var strategy = {
        // These options perform no added logic, but just bare request fullscreen.
        scaleMode: 0,
        canvasResolutionScaleMode: 0,
        filteringMode: 0,
        deferUntilInEventHandler: deferUntilInEventHandler,
        canvasResizedCallbackTargetThread: 2
      };
      return doRequestFullscreen(target, strategy);
    }

  function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
      target = findEventTarget(target);
      if (!target) return -4;
      if (!target.requestPointerLock
        && !target.msRequestPointerLock
        ) {
        return -1;
      }
  
      var canPerformRequests = JSEvents.canPerformEventHandlerRequests();
  
      // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canPerformRequests) {
        if (deferUntilInEventHandler) {
          JSEvents.deferCall(requestPointerLock, 2 /* priority below fullscreen */, [target]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return requestPointerLock(target);
    }

  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
        err('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength  + ' bytes to ' + size + ' bytes, but got error: ' + e);
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
      assert(requestedSize > oldSize);
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = _emscripten_get_heap_max();
      if (requestedSize > maxHeapSize) {
        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + maxHeapSize + ' bytes!');
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');
      return false;
    }

  /** @suppress {checkTypes} */
  function _emscripten_sample_gamepad_data() {
      try {
        if (navigator.getGamepads) return (JSEvents.lastGamepadState = navigator.getGamepads())
          ? 0 /*EMSCRIPTEN_RESULT_SUCCESS*/ : -1 /*EMSCRIPTEN_RESULT_NOT_SUPPORTED*/;
      } catch(e) {
        err(`navigator.getGamepads() exists, but failed to execute with exception ${e}. Disabling Gamepad access.`);
        navigator.getGamepads = null; // Disable getGamepads() so that it won't be attempted to be used again.
      }
      return -1 /*EMSCRIPTEN_RESULT_NOT_SUPPORTED*/;
    }

  function registerFocusEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.focusEvent) JSEvents.focusEvent = _malloc( 256 );
  
      var focusEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var nodeName = JSEvents.getNodeNameForTarget(e.target);
        var id = e.target.id ? e.target.id : '';
  
        var focusEvent = JSEvents.focusEvent;
        stringToUTF8(nodeName, focusEvent + 0, 128);
        stringToUTF8(id, focusEvent + 128, 128);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, focusEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: focusEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
      return 0;
    }


  function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
      return 0;
    }

  function registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc( 280 );
  
      var fullscreenChangeEventhandlerFunc = function(ev) {
        var e = ev || event;
  
        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
  
        fillFullscreenChangeEventData(fullscreenChangeEvent);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: fullscreenChangeEventhandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
  
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
  
      return 0;
    }

  function registerGamepadEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.gamepadEvent) JSEvents.gamepadEvent = _malloc( 1432 );
  
      var gamepadEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var gamepadEvent = JSEvents.gamepadEvent;
        fillGamepadEventData(gamepadEvent, e["gamepad"]);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, gamepadEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: gamepadEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      if (_emscripten_sample_gamepad_data()) return -1 /*EMSCRIPTEN_RESULT_NOT_SUPPORTED*/;
      return registerGamepadEventCallback(2 /*EMSCRIPTEN_EVENT_TARGET_WINDOW*/, userData, useCapture, callbackfunc, 26 /*EMSCRIPTEN_EVENT_GAMEPADCONNECTED*/, "gamepadconnected", targetThread);
    }

  function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
      if (_emscripten_sample_gamepad_data()) return -1 /*EMSCRIPTEN_RESULT_NOT_SUPPORTED*/;
      return registerGamepadEventCallback(2 /*EMSCRIPTEN_EVENT_TARGET_WINDOW*/, userData, useCapture, callbackfunc, 27 /*EMSCRIPTEN_EVENT_GAMEPADDISCONNECTED*/, "gamepaddisconnected", targetThread);
    }

  function _emscripten_set_interval(cb, msecs, userData) {
      
      return setInterval(function() {
        callUserCallback(function() {
          (function(a1) {  dynCall_vi.apply(null, [cb, a1]); })(userData)
        });
      }, msecs);
    }

  function registerKeyEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc( 176 );
  
      var keyEventHandlerFunc = function(e) {
        assert(e);
  
        var keyEventData = JSEvents.keyEvent;
        HEAPF64[((keyEventData)>>3)] = e.timeStamp;
  
        var idx = keyEventData >> 2;
  
        HEAP32[idx + 2] = e.location;
        HEAP32[idx + 3] = e.ctrlKey;
        HEAP32[idx + 4] = e.shiftKey;
        HEAP32[idx + 5] = e.altKey;
        HEAP32[idx + 6] = e.metaKey;
        HEAP32[idx + 7] = e.repeat;
        HEAP32[idx + 8] = e.charCode;
        HEAP32[idx + 9] = e.keyCode;
        HEAP32[idx + 10] = e.which;
        stringToUTF8(e.key || '', keyEventData + 44, 32);
        stringToUTF8(e.code || '', keyEventData + 76, 32);
        stringToUTF8(e.char || '', keyEventData + 108, 32);
        stringToUTF8(e.locale || '', keyEventData + 140, 32);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, keyEventData, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: keyEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
      return 0;
    }

  function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
      return 0;
    }

  function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
      return 0;
    }

  function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop) {
      var browserIterationFunc = (function() {  dynCall_v.call(null, func); });
      setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
    }


  function fillMouseEventData(eventStruct, e, target) {
      assert(eventStruct % 4 == 0);
      HEAPF64[((eventStruct)>>3)] = e.timeStamp;
      var idx = eventStruct >> 2;
      HEAP32[idx + 2] = e.screenX;
      HEAP32[idx + 3] = e.screenY;
      HEAP32[idx + 4] = e.clientX;
      HEAP32[idx + 5] = e.clientY;
      HEAP32[idx + 6] = e.ctrlKey;
      HEAP32[idx + 7] = e.shiftKey;
      HEAP32[idx + 8] = e.altKey;
      HEAP32[idx + 9] = e.metaKey;
      HEAP16[idx*2 + 20] = e.button;
      HEAP16[idx*2 + 21] = e.buttons;
  
      HEAP32[idx + 11] = e["movementX"]
        ;
  
      HEAP32[idx + 12] = e["movementY"]
        ;
  
      var rect = getBoundingClientRect(target);
      HEAP32[idx + 13] = e.clientX - rect.left;
      HEAP32[idx + 14] = e.clientY - rect.top;
  
    }
  function registerMouseEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc( 72 );
      target = findEventTarget(target);
  
      var mouseEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        // TODO: Make this access thread safe, or this could update live while app is reading it.
        fillMouseEventData(JSEvents.mouseEvent, e, target);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: mouseEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
      return 0;
    }

  function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
      return 0;
    }

  function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
      return 0;
    }

  function fillPointerlockChangeEventData(eventStruct) {
      var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
      var isPointerlocked = !!pointerLockElement;
      // Assigning a boolean to HEAP32 with expected type coercion.
      /** @suppress{checkTypes} */
      HEAP32[((eventStruct)>>2)] = isPointerlocked;
      var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
      var id = (pointerLockElement && pointerLockElement.id) ? pointerLockElement.id : '';
      stringToUTF8(nodeName, eventStruct + 4, 128);
      stringToUTF8(id, eventStruct + 132, 128);
    }
  function registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.pointerlockChangeEvent) JSEvents.pointerlockChangeEvent = _malloc( 260 );
  
      var pointerlockChangeEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
        fillPointerlockChangeEventData(pointerlockChangeEvent);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, pointerlockChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: pointerlockChangeEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  /** @suppress {missingProperties} */
  function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
  
      target = findEventTarget(target);
      if (!target) return -4;
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
      return 0;
    }

  function registerTouchEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc( 1696 );
  
      target = findEventTarget(target);
  
      var touchEventHandlerFunc = function(e) {
        assert(e);
        var t, touches = {}, et = e.touches;
        // To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
        // only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
        // each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.
  
        for (var i = 0; i < et.length; ++i) {
          t = et[i];
          // Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
          // changed/target states we may have set from previous frame.
          t.isChanged = t.onTarget = 0;
          touches[t.identifier] = t;
        }
  
        // Mark which touches are part of the changedTouches list.
        for (var i = 0; i < e.changedTouches.length; ++i) {
          t = e.changedTouches[i];
          t.isChanged = 1;
          touches[t.identifier] = t;
        }
        // Mark which touches are part of the targetTouches list.
        for (var i = 0; i < e.targetTouches.length; ++i) {
          touches[e.targetTouches[i].identifier].onTarget = 1;
        }
  
        var touchEvent = JSEvents.touchEvent;
        var idx = touchEvent>>2; // Pre-shift the ptr to index to HEAP32 to save code size
        HEAP32[idx + 3] = e.ctrlKey;
        HEAP32[idx + 4] = e.shiftKey;
        HEAP32[idx + 5] = e.altKey;
        HEAP32[idx + 6] = e.metaKey;
        idx += 7; // Advance to the start of the touch array.
        var targetRect = getBoundingClientRect(target);
        var numTouches = 0;
        for (var i in touches) {
          var t = touches[i];
          HEAP32[idx + 0] = t.identifier;
          HEAP32[idx + 1] = t.screenX;
          HEAP32[idx + 2] = t.screenY;
          HEAP32[idx + 3] = t.clientX;
          HEAP32[idx + 4] = t.clientY;
          HEAP32[idx + 5] = t.pageX;
          HEAP32[idx + 6] = t.pageY;
          HEAP32[idx + 7] = t.isChanged;
          HEAP32[idx + 8] = t.onTarget;
          HEAP32[idx + 9] = t.clientX - targetRect.left;
          HEAP32[idx + 10] = t.clientY - targetRect.top;
  
          idx += 13;
  
          if (++numTouches > 31) {
            break;
          }
        }
        HEAP32[(((touchEvent)+(8))>>2)] = numTouches;
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, touchEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: eventTypeString == 'touchstart' || eventTypeString == 'touchend',
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: touchEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
      return 0;
    }

  function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
      return 0;
    }

  function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
      return 0;
    }

  function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
      return 0;
    }

  function registerWheelEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc( 104 );
  
      // The DOM Level 3 events spec event 'wheel'
      var wheelHandlerFunc = function(ev) {
        var e = ev || event;
        var wheelEvent = JSEvents.wheelEvent;
        fillMouseEventData(wheelEvent, e, target);
        HEAPF64[(((wheelEvent)+(72))>>3)] = e["deltaX"];
        HEAPF64[(((wheelEvent)+(80))>>3)] = e["deltaY"];
        HEAPF64[(((wheelEvent)+(88))>>3)] = e["deltaZ"];
        HEAP32[(((wheelEvent)+(96))>>2)] = e["deltaMode"];
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, wheelEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: wheelHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      target = findEventTarget(target);
      if (typeof target.onwheel != 'undefined') {
        registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
        return 0;
      } else {
        return -1;
      }
    }

  function __webgl_enable_ANGLE_instanced_arrays(ctx) {
      // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('ANGLE_instanced_arrays');
      if (ext) {
        ctx['vertexAttribDivisor'] = function(index, divisor) { ext['vertexAttribDivisorANGLE'](index, divisor); };
        ctx['drawArraysInstanced'] = function(mode, first, count, primcount) { ext['drawArraysInstancedANGLE'](mode, first, count, primcount); };
        ctx['drawElementsInstanced'] = function(mode, count, type, indices, primcount) { ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount); };
        return 1;
      }
    }
  
  function __webgl_enable_OES_vertex_array_object(ctx) {
      // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('OES_vertex_array_object');
      if (ext) {
        ctx['createVertexArray'] = function() { return ext['createVertexArrayOES'](); };
        ctx['deleteVertexArray'] = function(vao) { ext['deleteVertexArrayOES'](vao); };
        ctx['bindVertexArray'] = function(vao) { ext['bindVertexArrayOES'](vao); };
        ctx['isVertexArray'] = function(vao) { return ext['isVertexArrayOES'](vao); };
        return 1;
      }
    }
  
  function __webgl_enable_WEBGL_draw_buffers(ctx) {
      // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ctx['drawBuffers'] = function(n, bufs) { ext['drawBuffersWEBGL'](n, bufs); };
        return 1;
      }
    }
  
  function __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(ctx) {
      // Closure is expected to be allowed to minify the '.dibvbi' property, so not accessing it quoted.
      return !!(ctx.dibvbi = ctx.getExtension('WEBGL_draw_instanced_base_vertex_base_instance'));
    }
  
  function __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(ctx) {
      // Closure is expected to be allowed to minify the '.mdibvbi' property, so not accessing it quoted.
      return !!(ctx.mdibvbi = ctx.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance'));
    }
  
  function __webgl_enable_WEBGL_multi_draw(ctx) {
      // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
      return !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));
    }
  var GL = {counter:1,buffers:[],mappedBuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],samplers:[],transformFeedbacks:[],syncs:[],byteSizeByTypeRoot:5120,byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],stringCache:{},stringiCache:{},unpackAlignment:4,recordError:function recordError(errorCode) {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      },getNewId:function(table) {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },MAX_TEMP_BUFFER_SIZE:2097152,numTempVertexBuffersPerSize:64,log2ceilLookup:function(i) {
        return 32 - Math.clz32(i === 0 ? 0 : i - 1);
      },generateTempBuffers:function(quads, context) {
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        context.tempVertexBufferCounters1 = [];
        context.tempVertexBufferCounters2 = [];
        context.tempVertexBufferCounters1.length = context.tempVertexBufferCounters2.length = largestIndex+1;
        context.tempVertexBuffers1 = [];
        context.tempVertexBuffers2 = [];
        context.tempVertexBuffers1.length = context.tempVertexBuffers2.length = largestIndex+1;
        context.tempIndexBuffers = [];
        context.tempIndexBuffers.length = largestIndex+1;
        for (var i = 0; i <= largestIndex; ++i) {
          context.tempIndexBuffers[i] = null; // Created on-demand
          context.tempVertexBufferCounters1[i] = context.tempVertexBufferCounters2[i] = 0;
          var ringbufferLength = GL.numTempVertexBuffersPerSize;
          context.tempVertexBuffers1[i] = [];
          context.tempVertexBuffers2[i] = [];
          var ringbuffer1 = context.tempVertexBuffers1[i];
          var ringbuffer2 = context.tempVertexBuffers2[i];
          ringbuffer1.length = ringbuffer2.length = ringbufferLength;
          for (var j = 0; j < ringbufferLength; ++j) {
            ringbuffer1[j] = ringbuffer2[j] = null; // Created on-demand
          }
        }
  
        if (quads) {
          // GL_QUAD indexes can be precalculated
          context.tempQuadIndexBuffer = GLctx.createBuffer();
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, context.tempQuadIndexBuffer);
          var numIndexes = GL.MAX_TEMP_BUFFER_SIZE >> 1;
          var quadIndexes = new Uint16Array(numIndexes);
          var i = 0, v = 0;
          while (1) {
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+1;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+3;
            if (i >= numIndexes) break;
            v += 4;
          }
          context.GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, quadIndexes, 0x88E4 /*GL_STATIC_DRAW*/);
          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);
        }
      },getTempVertexBuffer:function getTempVertexBuffer(sizeBytes) {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ringbuffer = GL.currentContext.tempVertexBuffers1[idx];
        var nextFreeBufferIndex = GL.currentContext.tempVertexBufferCounters1[idx];
        GL.currentContext.tempVertexBufferCounters1[idx] = (GL.currentContext.tempVertexBufferCounters1[idx]+1) & (GL.numTempVertexBuffersPerSize-1);
        var vbo = ringbuffer[nextFreeBufferIndex];
        if (vbo) {
          return vbo;
        }
        var prevVBO = GLctx.getParameter(0x8894 /*GL_ARRAY_BUFFER_BINDING*/);
        ringbuffer[nextFreeBufferIndex] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, ringbuffer[nextFreeBufferIndex]);
        GLctx.bufferData(0x8892 /*GL_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, prevVBO);
        return ringbuffer[nextFreeBufferIndex];
      },getTempIndexBuffer:function getTempIndexBuffer(sizeBytes) {
        var idx = GL.log2ceilLookup(sizeBytes);
        var ibo = GL.currentContext.tempIndexBuffers[idx];
        if (ibo) {
          return ibo;
        }
        var prevIBO = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);
        GL.currentContext.tempIndexBuffers[idx] = GLctx.createBuffer();
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, GL.currentContext.tempIndexBuffers[idx]);
        GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, prevIBO);
        return GL.currentContext.tempIndexBuffers[idx];
      },newRenderingFrameStarted:function newRenderingFrameStarted() {
        if (!GL.currentContext) {
          return;
        }
        var vb = GL.currentContext.tempVertexBuffers1;
        GL.currentContext.tempVertexBuffers1 = GL.currentContext.tempVertexBuffers2;
        GL.currentContext.tempVertexBuffers2 = vb;
        vb = GL.currentContext.tempVertexBufferCounters1;
        GL.currentContext.tempVertexBufferCounters1 = GL.currentContext.tempVertexBufferCounters2;
        GL.currentContext.tempVertexBufferCounters2 = vb;
        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
        for (var i = 0; i <= largestIndex; ++i) {
          GL.currentContext.tempVertexBufferCounters1[i] = 0;
        }
      },getSource:function(shader, count, string, length) {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var len = length ? HEAP32[(((length)+(i*4))>>2)] : -1;
          source += UTF8ToString(HEAP32[(((string)+(i*4))>>2)], len < 0 ? undefined : len);
        }
        return source;
      },calcBufLength:function calcBufLength(size, type, stride, count) {
        if (stride > 0) {
          return count * stride;  // XXXvlad this is not exactly correct I don't think
        }
        var typeSize = GL.byteSizeByType[type - GL.byteSizeByTypeRoot];
        return size * typeSize * count;
      },usedTempBuffers:[],preDrawHandleClientVertexAttribBindings:function preDrawHandleClientVertexAttribBindings(count) {
        GL.resetBufferBinding = false;
  
        // TODO: initial pass to detect ranges we need to upload, might not need an upload per attrib
        for (var i = 0; i < GL.currentContext.maxVertexAttribs; ++i) {
          var cb = GL.currentContext.clientBuffers[i];
          if (!cb.clientside || !cb.enabled) continue;
  
          GL.resetBufferBinding = true;
  
          var size = GL.calcBufLength(cb.size, cb.type, cb.stride, count);
          var buf = GL.getTempVertexBuffer(size);
          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, buf);
          GLctx.bufferSubData(0x8892 /*GL_ARRAY_BUFFER*/,
                                   0,
                                   HEAPU8.subarray(cb.ptr, cb.ptr + size));
          cb.vertexAttribPointerAdaptor.call(GLctx, i, cb.size, cb.type, cb.normalized, cb.stride, 0);
        }
      },postDrawHandleClientVertexAttribBindings:function postDrawHandleClientVertexAttribBindings() {
        if (GL.resetBufferBinding) {
          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, GL.buffers[GLctx.currentArrayBufferBinding]);
        }
      },createContext:function(/** @type {HTMLCanvasElement} */ canvas, webGLContextAttributes) {
  
        // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL context on a canvas,
        // calling .getContext() will always return that context independent of which 'webgl' or 'webgl2'
        // context version was passed. See https://bugs.webkit.org/show_bug.cgi?id=222758 and
        // https://github.com/emscripten-core/emscripten/issues/13295.
        // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari version field in above check.
        if (!canvas.getContextSafariWebGL2Fixed) {
          canvas.getContextSafariWebGL2Fixed = canvas.getContext;
          /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */
          function fixedGetContext(ver, attrs) {
            var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
            return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;
          }
          canvas.getContext = fixedGetContext;
        }
  
        var ctx = 
          (webGLContextAttributes.majorVersion > 1)
          ?
            canvas.getContext("webgl2", webGLContextAttributes)
          :
          (canvas.getContext("webgl", webGLContextAttributes)
            // https://caniuse.com/#feat=webgl
            );
  
        if (!ctx) return 0;
  
        var handle = GL.registerContext(ctx, webGLContextAttributes);
  
        return handle;
      },registerContext:function(ctx, webGLContextAttributes) {
        // without pthreads a context is just an integer ID
        var handle = GL.getNewId(GL.contexts);
  
        var context = {
          handle: handle,
          attributes: webGLContextAttributes,
          version: webGLContextAttributes.majorVersion,
          GLctx: ctx
        };
  
        // Store the created context object so that we can access the context given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault == 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
  
        context.maxVertexAttribs = context.GLctx.getParameter(0x8869 /*GL_MAX_VERTEX_ATTRIBS*/);
        context.clientBuffers = [];
        for (var i = 0; i < context.maxVertexAttribs; i++) {
          context.clientBuffers[i] = { enabled: false, clientside: false, size: 0, type: 0, normalized: 0, stride: 0, ptr: 0, vertexAttribPointerAdaptor: null };
        }
  
        GL.generateTempBuffers(false, context);
  
        return handle;
      },makeContextCurrent:function(contextHandle) {
  
        GL.currentContext = GL.contexts[contextHandle]; // Active Emscripten GL layer context object.
        Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx; // Active WebGL context object.
        return !(contextHandle && !GLctx);
      },getContext:function(contextHandle) {
        return GL.contexts[contextHandle];
      },deleteContext:function(contextHandle) {
        if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
        if (typeof JSEvents == 'object') JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas); // Release all JS event handlers on the DOM element that the GL context is associated with since the context is now deleted.
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined; // Make sure the canvas object no longer refers to the context object so there are no GC surprises.
        GL.contexts[contextHandle] = null;
      },initExtensions:function(context) {
        // If this function is called without a specific context object, init the extensions of the currently active context.
        if (!context) context = GL.currentContext;
  
        if (context.initExtensionsDone) return;
        context.initExtensionsDone = true;
  
        var GLctx = context.GLctx;
  
        // Detect the presence of a few extensions manually, this GL interop layer itself will need to know if they exist.
  
        // Extensions that are only available in WebGL 1 (the calls will be no-ops if called on a WebGL 2 context active)
        __webgl_enable_ANGLE_instanced_arrays(GLctx);
        __webgl_enable_OES_vertex_array_object(GLctx);
        __webgl_enable_WEBGL_draw_buffers(GLctx);
        // Extensions that are available from WebGL >= 2 (no-op if called on a WebGL 1 context active)
        __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);
        __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);
  
        // On WebGL 2, EXT_disjoint_timer_query is replaced with an alternative
        // that's based on core APIs, and exposes only the queryCounterEXT()
        // entrypoint.
        if (context.version >= 2) {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query_webgl2");
        }
  
        // However, Firefox exposes the WebGL 1 version on WebGL 2 as well and
        // thus we look for the WebGL 1 version again if the WebGL 2 version
        // isn't present. https://bugzilla.mozilla.org/show_bug.cgi?id=1328882
        if (context.version < 2 || !GLctx.disjointTimerQueryExt)
        {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
        }
  
        __webgl_enable_WEBGL_multi_draw(GLctx);
  
        // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
        var exts = GLctx.getSupportedExtensions() || [];
        exts.forEach(function(ext) {
          // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders are not enabled by default.
          if (!ext.includes('lose_context') && !ext.includes('debug')) {
            // Call .getExtension() to enable that extension permanently.
            GLctx.getExtension(ext);
          }
        });
      }};
  
  var __emscripten_webgl_power_preferences = ['default', 'low-power', 'high-performance'];
  function _emscripten_webgl_do_create_context(target, attributes) {
      assert(attributes);
      var a = attributes >> 2;
      var powerPreference = HEAP32[a + (24>>2)];
      var contextAttributes = {
        'alpha': !!HEAP32[a + (0>>2)],
        'depth': !!HEAP32[a + (4>>2)],
        'stencil': !!HEAP32[a + (8>>2)],
        'antialias': !!HEAP32[a + (12>>2)],
        'premultipliedAlpha': !!HEAP32[a + (16>>2)],
        'preserveDrawingBuffer': !!HEAP32[a + (20>>2)],
        'powerPreference': __emscripten_webgl_power_preferences[powerPreference],
        'failIfMajorPerformanceCaveat': !!HEAP32[a + (28>>2)],
        // The following are not predefined WebGL context attributes in the WebGL specification, so the property names can be minified by Closure.
        majorVersion: HEAP32[a + (32>>2)],
        minorVersion: HEAP32[a + (36>>2)],
        enableExtensionsByDefault: HEAP32[a + (40>>2)],
        explicitSwapControl: HEAP32[a + (44>>2)],
        proxyContextToMainThread: HEAP32[a + (48>>2)],
        renderViaOffscreenBackBuffer: HEAP32[a + (52>>2)]
      };
  
      var canvas = findCanvasEventTarget(target);
  
      if (!canvas) {
        return 0;
      }
  
      if (contextAttributes.explicitSwapControl) {
        return 0;
      }
  
      var contextHandle = GL.createContext(canvas, contextAttributes);
      return contextHandle;
    }
  function _emscripten_webgl_create_context(a0,a1
  ) {
  return _emscripten_webgl_do_create_context(a0,a1);
  }

  function _emscripten_webgl_destroy_context(contextHandle) {
      if (GL.currentContext == contextHandle) GL.currentContext = 0;
      GL.deleteContext(contextHandle);
    }

  function _emscripten_webgl_enable_extension(contextHandle, extension) {
      var context = GL.getContext(contextHandle);
      var extString = UTF8ToString(extension);
      if (extString.startsWith('GL_')) extString = extString.substr(3); // Allow enabling extensions both with "GL_" prefix and without.
  
      // Switch-board that pulls in code for all GL extensions, even if those are not used :/
      // Build with -s GL_SUPPORT_SIMPLE_ENABLE_EXTENSIONS = 0 to avoid this.
  
      // Obtain function entry points to WebGL 1 extension related functions.
      if (extString == 'ANGLE_instanced_arrays') __webgl_enable_ANGLE_instanced_arrays(GLctx);
      if (extString == 'OES_vertex_array_object') __webgl_enable_OES_vertex_array_object(GLctx);
      if (extString == 'WEBGL_draw_buffers') __webgl_enable_WEBGL_draw_buffers(GLctx);
  
      if (extString == 'WEBGL_draw_instanced_base_vertex_base_instance') __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);
      if (extString == 'WEBGL_multi_draw_instanced_base_vertex_base_instance') __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);
  
      if (extString == 'WEBGL_multi_draw') __webgl_enable_WEBGL_multi_draw(GLctx);
  
      var ext = context.GLctx.getExtension(extString);
      return !!ext;
    }

  function _emscripten_webgl_do_get_current_context() {
      return GL.currentContext ? GL.currentContext.handle : 0;
    }
  function _emscripten_webgl_get_current_context(
  ) {
  return _emscripten_webgl_do_get_current_context();
  }

  function _emscripten_webgl_init_context_attributes(attributes) {
      assert(attributes);
      var a = attributes >> 2;
      for (var i = 0; i < (56>>2); ++i) {
        HEAP32[a+i] = 0;
      }
  
      HEAP32[a + (0>>2)] =
      HEAP32[a + (4>>2)] = 
      HEAP32[a + (12>>2)] = 
      HEAP32[a + (16>>2)] = 
      HEAP32[a + (32>>2)] = 
      HEAP32[a + (40>>2)] = 1;
  
    }

  function _emscripten_webgl_make_context_current(contextHandle) {
      var success = GL.makeContextCurrent(contextHandle);
      return success ? 0 : -5;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAP32[(((__environ)+(i * 4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAP32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAP32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }


  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      // TODO HEAP16[(((pbuf)+(2))>>1)] = ?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)] = tempI64[0],HEAP32[(((pbuf)+(12))>>2)] = tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)] = tempI64[0],HEAP32[(((pbuf)+(20))>>2)] = tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      ;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _getTempRet0() {
      return getTempRet0();
    }

  function getHostByName(name) {
      // generate hostent
      var ret = _malloc(20); // XXX possibly leaked, as are others here
      var nameBuf = _malloc(name.length+1);
      stringToUTF8(name, nameBuf, name.length+1);
      HEAP32[((ret)>>2)] = nameBuf;
      var aliasesBuf = _malloc(4);
      HEAP32[((aliasesBuf)>>2)] = 0;
      HEAP32[(((ret)+(4))>>2)] = aliasesBuf;
      var afinet = 2;
      HEAP32[(((ret)+(8))>>2)] = afinet;
      HEAP32[(((ret)+(12))>>2)] = 4;
      var addrListBuf = _malloc(12);
      HEAP32[((addrListBuf)>>2)] = addrListBuf+8;
      HEAP32[(((addrListBuf)+(4))>>2)] = 0;
      HEAP32[(((addrListBuf)+(8))>>2)] = inetPton4(DNS.lookup_name(name));
      HEAP32[(((ret)+(16))>>2)] = addrListBuf;
      return ret;
    }
  function _gethostbyaddr(addr, addrlen, type) {
      if (type !== 2) {
        setErrNo(5);
        // TODO: set h_errno
        return null;
      }
      addr = HEAP32[((addr)>>2)]; // addr is in_addr
      var host = inetNtop4(addr);
      var lookup = DNS.lookup_addr(host);
      if (lookup) {
        host = lookup;
      }
      return getHostByName(host);
    }

  function _gethostbyname(name) {
      return getHostByName(UTF8ToString(name));
    }

  function _glActiveTexture(x0) { GLctx['activeTexture'](x0) }

  function _glAttachShader(program, shader) {
      program = GL.programs[program];
      shader = GL.shaders[shader];
      program[shader.shaderType] = shader;
      GLctx.attachShader(program, shader);
    }

  function _glBeginQuery(target, id) {
      GLctx['beginQuery'](target, GL.queries[id]);
    }

  function _glBindAttribLocation(program, index, name) {
      GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    }

  function _glBindBuffer(target, buffer) {
      if (target == 0x8892 /*GL_ARRAY_BUFFER*/) {
        GLctx.currentArrayBufferBinding = buffer;
      } else if (target == 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/) {
        GLctx.currentElementArrayBufferBinding = buffer;
      }
  
      if (target == 0x88EB /*GL_PIXEL_PACK_BUFFER*/) {
        // In WebGL 2 glReadPixels entry point, we need to use a different WebGL 2 API function call when a buffer is bound to
        // GL_PIXEL_PACK_BUFFER_BINDING point, so must keep track whether that binding point is non-null to know what is
        // the proper API function to call.
        GLctx.currentPixelPackBufferBinding = buffer;
      } else if (target == 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/) {
        // In WebGL 2 gl(Compressed)Tex(Sub)Image[23]D entry points, we need to
        // use a different WebGL 2 API function call when a buffer is bound to
        // GL_PIXEL_UNPACK_BUFFER_BINDING point, so must keep track whether that
        // binding point is non-null to know what is the proper API function to
        // call.
        GLctx.currentPixelUnpackBufferBinding = buffer;
      }
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    }

  function _glBindBufferBase(target, index, buffer) {
      GLctx['bindBufferBase'](target, index, GL.buffers[buffer]);
    }

  function _glBindBufferRange(target, index, buffer, offset, ptrsize) {
      GLctx['bindBufferRange'](target, index, GL.buffers[buffer], offset, ptrsize);
    }

  function _glBindFramebuffer(target, framebuffer) {
  
      GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
  
    }

  function _glBindRenderbuffer(target, renderbuffer) {
      GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    }

  function _glBindSampler(unit, sampler) {
      GLctx['bindSampler'](unit, GL.samplers[sampler]);
    }

  function _glBindTexture(target, texture) {
      GLctx.bindTexture(target, GL.textures[texture]);
    }

  function _glBindVertexArray(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
      var ibo = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);
      GLctx.currentElementArrayBufferBinding = ibo ? (ibo.name | 0) : 0;
    }

  function _glBlendEquation(x0) { GLctx['blendEquation'](x0) }

  function _glBlendEquationSeparate(x0, x1) { GLctx['blendEquationSeparate'](x0, x1) }

  function _glBlendFuncSeparate(x0, x1, x2, x3) { GLctx['blendFuncSeparate'](x0, x1, x2, x3) }

  function _glBlitFramebuffer(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) { GLctx['blitFramebuffer'](x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) }

  function _glBufferData(target, size, data, usage) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (data) {
          GLctx.bufferData(target, HEAPU8, usage, data, size);
        } else {
          GLctx.bufferData(target, size, usage);
        }
      } else {
        // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
        // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
        GLctx.bufferData(target, data ? HEAPU8.subarray(data, data+size) : size, usage);
      }
    }

  function _glBufferSubData(target, offset, size, data) {
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.bufferSubData(target, offset, HEAPU8, data, size);
        return;
      }
      GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data+size));
    }

  function _glCheckFramebufferStatus(x0) { return GLctx['checkFramebufferStatus'](x0) }

  function _glClear(x0) { GLctx['clear'](x0) }

  function _glClearBufferfi(x0, x1, x2, x3) { GLctx['clearBufferfi'](x0, x1, x2, x3) }

  function _glClearBufferfv(buffer, drawbuffer, value) {
  
      GLctx['clearBufferfv'](buffer, drawbuffer, HEAPF32, value>>2);
    }

  function _glClearBufferuiv(buffer, drawbuffer, value) {
  
      GLctx['clearBufferuiv'](buffer, drawbuffer, HEAPU32, value>>2);
    }

  function _glClearColor(x0, x1, x2, x3) { GLctx['clearColor'](x0, x1, x2, x3) }

  function _glClearDepthf(x0) { GLctx['clearDepth'](x0) }

  function _glClearStencil(x0) { GLctx['clearStencil'](x0) }

  function _glClientWaitSync(sync, flags, timeoutLo, timeoutHi) {
      // WebGL2 vs GLES3 differences: in GLES3, the timeout parameter is a uint64, where 0xFFFFFFFFFFFFFFFFULL means GL_TIMEOUT_IGNORED.
      // In JS, there's no 64-bit value types, so instead timeout is taken to be signed, and GL_TIMEOUT_IGNORED is given value -1.
      // Inherently the value accepted in the timeout is lossy, and can't take in arbitrary u64 bit pattern (but most likely doesn't matter)
      // See https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.15
      return GLctx.clientWaitSync(GL.syncs[sync], flags, convertI32PairToI53(timeoutLo, timeoutHi));
    }

  function _glColorMask(red, green, blue, alpha) {
      GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
    }

  function _glCompileShader(shader) {
      GLctx.compileShader(GL.shaders[shader]);
    }

  function _glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data) {
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, imageSize, data);
        } else {
          GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, HEAPU8, data, imageSize);
        }
        return;
      }
      GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, data ? HEAPU8.subarray((data), (data+imageSize)) : null);
    }

  function _glCompressedTexImage3D(target, level, internalFormat, width, height, depth, border, imageSize, data) {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx['compressedTexImage3D'](target, level, internalFormat, width, height, depth, border, imageSize, data);
      } else {
        GLctx['compressedTexImage3D'](target, level, internalFormat, width, height, depth, border, HEAPU8, data, imageSize);
      }
    }

  function _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) {
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } else {
          GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, HEAPU8, data, imageSize);
        }
        return;
      }
      GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, data ? HEAPU8.subarray((data), (data+imageSize)) : null);
    }

  function _glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx['compressedTexSubImage3D'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
      } else {
        GLctx['compressedTexSubImage3D'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, HEAPU8, data, imageSize);
      }
    }

  function _glCopyBufferSubData(x0, x1, x2, x3, x4) { GLctx['copyBufferSubData'](x0, x1, x2, x3, x4) }

  function _glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexSubImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _glCreateProgram() {
      var id = GL.getNewId(GL.programs);
      var program = GLctx.createProgram();
      // Store additional information needed for each shader program:
      program.name = id;
      // Lazy cache results of glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
      program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
      program.uniformIdCounter = 1;
      GL.programs[id] = program;
      return id;
    }

  function _glCreateShader(shaderType) {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
  
      // GL_VERTEX_SHADER = 0x8B31, GL_FRAGMENT_SHADER = 0x8B30
      GL.shaders[id].shaderType = shaderType&1?'vs':'fs';
  
      return id;
    }

  function _glCullFace(x0) { GLctx['cullFace'](x0) }

  function _glDeleteBuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((buffers)+(i*4))>>2)];
        var buffer = GL.buffers[id];
  
        // From spec: "glDeleteBuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        GLctx.deleteBuffer(buffer);
        buffer.name = 0;
        GL.buffers[id] = null;
  
        if (id == GLctx.currentArrayBufferBinding) GLctx.currentArrayBufferBinding = 0;
        if (id == GLctx.currentElementArrayBufferBinding) GLctx.currentElementArrayBufferBinding = 0;
        if (id == GLctx.currentPixelPackBufferBinding) GLctx.currentPixelPackBufferBinding = 0;
        if (id == GLctx.currentPixelUnpackBufferBinding) GLctx.currentPixelUnpackBufferBinding = 0;
      }
    }

  function _glDeleteFramebuffers(n, framebuffers) {
      for (var i = 0; i < n; ++i) {
        var id = HEAP32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = GL.framebuffers[id];
        if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        GLctx.deleteFramebuffer(framebuffer);
        framebuffer.name = 0;
        GL.framebuffers[id] = null;
      }
    }

  function _glDeleteProgram(id) {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) { // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
    }

  function _glDeleteQueries(n, ids) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((ids)+(i*4))>>2)];
        var query = GL.queries[id];
        if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
        GLctx['deleteQuery'](query);
        GL.queries[id] = null;
      }
    }

  function _glDeleteRenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = GL.renderbuffers[id];
        if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        GLctx.deleteRenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        GL.renderbuffers[id] = null;
      }
    }

  function _glDeleteSamplers(n, samplers) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((samplers)+(i*4))>>2)];
        var sampler = GL.samplers[id];
        if (!sampler) continue;
        GLctx['deleteSampler'](sampler);
        sampler.name = 0;
        GL.samplers[id] = null;
      }
    }

  function _glDeleteShader(id) {
      if (!id) return;
      var shader = GL.shaders[id];
      if (!shader) { // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteShader(shader);
      GL.shaders[id] = null;
    }

  function _glDeleteSync(id) {
      if (!id) return;
      var sync = GL.syncs[id];
      if (!sync) { // glDeleteSync signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteSync(sync);
      sync.name = 0;
      GL.syncs[id] = null;
    }

  function _glDeleteTextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
        GLctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    }

  function _glDeleteVertexArrays(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((vaos)+(i*4))>>2)];
        GLctx['deleteVertexArray'](GL.vaos[id]);
        GL.vaos[id] = null;
      }
    }

  function _glDepthFunc(x0) { GLctx['depthFunc'](x0) }

  function _glDepthMask(flag) {
      GLctx.depthMask(!!flag);
    }

  function _glDetachShader(program, shader) {
      GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
    }

  function _glDisable(x0) { GLctx['disable'](x0) }

  function _glDisableVertexAttribArray(index) {
      var cb = GL.currentContext.clientBuffers[index];
      cb.enabled = false;
      GLctx.disableVertexAttribArray(index);
    }

  function _glDrawArrays(mode, first, count) {
      // bind any client-side buffers
      GL.preDrawHandleClientVertexAttribBindings(first + count);
  
      GLctx.drawArrays(mode, first, count);
  
      GL.postDrawHandleClientVertexAttribBindings();
    }

  function _glDrawArraysInstanced(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }

  var tempFixedLengthArray = [];
  function _glDrawBuffers(n, bufs) {
  
      var bufArray = tempFixedLengthArray[n];
      for (var i = 0; i < n; i++) {
        bufArray[i] = HEAP32[(((bufs)+(i*4))>>2)];
      }
  
      GLctx['drawBuffers'](bufArray);
    }

  function _glDrawElements(mode, count, type, indices) {
      var buf;
      if (!GLctx.currentElementArrayBufferBinding) {
        var size = GL.calcBufLength(1, type, 0, count);
        buf = GL.getTempIndexBuffer(size);
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, buf);
        GLctx.bufferSubData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/,
                                 0,
                                 HEAPU8.subarray(indices, indices + size));
        // the index is now 0
        indices = 0;
      }
  
      // bind any client-side buffers
      GL.preDrawHandleClientVertexAttribBindings(count);
  
      GLctx.drawElements(mode, count, type, indices);
  
      GL.postDrawHandleClientVertexAttribBindings(count);
  
      if (!GLctx.currentElementArrayBufferBinding) {
        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);
      }
    }

  function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }

  function _glEnable(x0) { GLctx['enable'](x0) }

  function _glEnableVertexAttribArray(index) {
      var cb = GL.currentContext.clientBuffers[index];
      cb.enabled = true;
      GLctx.enableVertexAttribArray(index);
    }

  function _glEndQuery(x0) { GLctx['endQuery'](x0) }

  function _glFenceSync(condition, flags) {
      var sync = GLctx.fenceSync(condition, flags);
      if (sync) {
        var id = GL.getNewId(GL.syncs);
        sync.name = id;
        GL.syncs[id] = sync;
        return id;
      } else {
        return 0; // Failed to create a sync object
      }
    }

  function _glFinish() { GLctx['finish']() }

  function _glFlush() { GLctx['flush']() }

  function emscriptenWebGLGetBufferBinding(target) {
      switch (target) {
        case 0x8892 /*GL_ARRAY_BUFFER*/: target = 0x8894 /*GL_ARRAY_BUFFER_BINDING*/; break;
        case 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/: target = 0x8895 /*GL_ELEMENT_ARRAY_BUFFER_BINDING*/; break;
        case 0x88EB /*GL_PIXEL_PACK_BUFFER*/: target = 0x88ED /*GL_PIXEL_PACK_BUFFER_BINDING*/; break;
        case 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/: target = 0x88EF /*GL_PIXEL_UNPACK_BUFFER_BINDING*/; break;
        case 0x8C8E /*GL_TRANSFORM_FEEDBACK_BUFFER*/: target = 0x8C8F /*GL_TRANSFORM_FEEDBACK_BUFFER_BINDING*/; break;
        case 0x8F36 /*GL_COPY_READ_BUFFER*/: target = 0x8F36 /*GL_COPY_READ_BUFFER_BINDING*/; break;
        case 0x8F37 /*GL_COPY_WRITE_BUFFER*/: target = 0x8F37 /*GL_COPY_WRITE_BUFFER_BINDING*/; break;
        case 0x8A11 /*GL_UNIFORM_BUFFER*/: target = 0x8A28 /*GL_UNIFORM_BUFFER_BINDING*/; break;
        // In default case, fall through and assume passed one of the _BINDING enums directly.
      }
      var buffer = GLctx.getParameter(target);
      if (buffer) return buffer.name|0;
      else return 0;
    }
  
  function emscriptenWebGLValidateMapBufferTarget(target) {
      switch (target) {
        case 0x8892: // GL_ARRAY_BUFFER
        case 0x8893: // GL_ELEMENT_ARRAY_BUFFER
        case 0x8F36: // GL_COPY_READ_BUFFER
        case 0x8F37: // GL_COPY_WRITE_BUFFER
        case 0x88EB: // GL_PIXEL_PACK_BUFFER
        case 0x88EC: // GL_PIXEL_UNPACK_BUFFER
        case 0x8C2A: // GL_TEXTURE_BUFFER
        case 0x8C8E: // GL_TRANSFORM_FEEDBACK_BUFFER
        case 0x8A11: // GL_UNIFORM_BUFFER
          return true;
        default:
          return false;
      }
    }
  function _glFlushMappedBufferRange(target, offset, length) {
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glFlushMappedBufferRange');
        return;
      }
  
      var mapping = GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)];
      if (!mapping) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was never mapped in glFlushMappedBufferRange');
        return;
      }
  
      if (!(mapping.access & 0x10)) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was not mapped with GL_MAP_FLUSH_EXPLICIT_BIT in glFlushMappedBufferRange');
        return;
      }
      if (offset < 0 || length < 0 || offset + length > mapping.length) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        err('invalid range in glFlushMappedBufferRange');
        return;
      }
  
      GLctx.bufferSubData(
        target,
        mapping.offset,
        HEAPU8.subarray(mapping.mem + offset, mapping.mem + offset + length));
    }

  function _glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
      GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget,
                                         GL.renderbuffers[renderbuffer]);
    }

  function _glFramebufferTexture2D(target, attachment, textarget, texture, level) {
      GLctx.framebufferTexture2D(target, attachment, textarget,
                                      GL.textures[texture], level);
    }

  function _glFramebufferTextureLayer(target, attachment, texture, level, layer) {
      GLctx.framebufferTextureLayer(target, attachment, GL.textures[texture], level, layer);
    }

  function _glFrontFace(x0) { GLctx['frontFace'](x0) }

  function __glGenObject(n, buffers, createFunction, objectTable
      ) {
      for (var i = 0; i < n; i++) {
        var buffer = GLctx[createFunction]();
        var id = buffer && GL.getNewId(objectTable);
        if (buffer) {
          buffer.name = id;
          objectTable[id] = buffer;
        } else {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        }
        HEAP32[(((buffers)+(i*4))>>2)] = id;
      }
    }
  function _glGenBuffers(n, buffers) {
      __glGenObject(n, buffers, 'createBuffer', GL.buffers
        );
    }

  function _glGenFramebuffers(n, ids) {
      __glGenObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    }

  function _glGenQueries(n, ids) {
      __glGenObject(n, ids, 'createQuery', GL.queries
        );
    }

  function _glGenRenderbuffers(n, renderbuffers) {
      __glGenObject(n, renderbuffers, 'createRenderbuffer', GL.renderbuffers
        );
    }

  function _glGenSamplers(n, samplers) {
      __glGenObject(n, samplers, 'createSampler', GL.samplers
        );
    }

  function _glGenTextures(n, textures) {
      __glGenObject(n, textures, 'createTexture', GL.textures
        );
    }

  function _glGenVertexArrays(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }

  function _glGenerateMipmap(x0) { GLctx['generateMipmap'](x0) }

  function __glGetActiveAttribOrUniform(funcName, program, index, bufSize, length, size, type, name) {
      program = GL.programs[program];
      var info = GLctx[funcName](program, index);
      if (info) { // If an error occurs, nothing will be written to length, size and type and name.
        var numBytesWrittenExclNull = name && stringToUTF8(info.name, name, bufSize);
        if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
        if (size) HEAP32[((size)>>2)] = info.size;
        if (type) HEAP32[((type)>>2)] = info.type;
      }
    }
  function _glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
      __glGetActiveAttribOrUniform('getActiveAttrib', program, index, bufSize, length, size, type, name);
    }

  function _glGetActiveUniform(program, index, bufSize, length, size, type, name) {
      __glGetActiveAttribOrUniform('getActiveUniform', program, index, bufSize, length, size, type, name);
    }

  function _glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName) {
      program = GL.programs[program];
  
      var result = GLctx['getActiveUniformBlockName'](program, uniformBlockIndex);
      if (!result) return; // If an error occurs, nothing will be written to uniformBlockName or length.
      if (uniformBlockName && bufSize > 0) {
        var numBytesWrittenExclNull = stringToUTF8(result, uniformBlockName, bufSize);
        if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
      } else {
        if (length) HEAP32[((length)>>2)] = 0;
      }
    }

  function _glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
  
      if (pname == 0x8A41 /* GL_UNIFORM_BLOCK_NAME_LENGTH */) {
        var name = GLctx['getActiveUniformBlockName'](program, uniformBlockIndex);
        HEAP32[((params)>>2)] = name.length+1;
        return;
      }
  
      var result = GLctx['getActiveUniformBlockParameter'](program, uniformBlockIndex, pname);
      if (result === null) return; // If an error occurs, nothing should be written to params.
      if (pname == 0x8A43 /*GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES*/) {
        for (var i = 0; i < result.length; i++) {
          HEAP32[(((params)+(i*4))>>2)] = result[i];
        }
      } else {
        HEAP32[((params)>>2)] = result;
      }
    }

  function _glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (uniformCount > 0 && uniformIndices == 0) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      var ids = [];
      for (var i = 0; i < uniformCount; i++) {
        ids.push(HEAP32[(((uniformIndices)+(i*4))>>2)]);
      }
  
      var result = GLctx['getActiveUniforms'](program, ids, pname);
      if (!result) return; // GL spec: If an error is generated, nothing is written out to params.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        HEAP32[(((params)+(i*4))>>2)] = result[i];
      }
    }

  function _glGetAttribLocation(program, name) {
      return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
    }

  function _glGetBufferSubData(target, offset, size, data) {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx['getBufferSubData'](target, offset, HEAPU8, data, size);
    }

  function _glGetError() {
      var error = GLctx.getError() || GL.lastError;
      GL.lastError = 0/*GL_NO_ERROR*/;
      return error;
    }

  function _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
      var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
      if (result instanceof WebGLRenderbuffer ||
          result instanceof WebGLTexture) {
        result = result.name | 0;
      }
      HEAP32[((params)>>2)] = result;
    }

  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  
  function readI53FromU64(ptr) {
      return HEAPU32[ptr>>2] + HEAPU32[ptr+4>>2] * 4294967296;
    }
  function writeI53ToI64(ptr, num) {
      HEAPU32[ptr>>2] = num;
      HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
      var deserialized = (num >= 0) ? readI53FromU64(ptr) : readI53FromI64(ptr);
      if (deserialized != num) warnOnce('writeI53ToI64() out of range: serialized JS Number ' + num + ' to Wasm heap as bytes lo=0x' + HEAPU32[ptr>>2].toString(16) + ', hi=0x' + HEAPU32[ptr+4>>2].toString(16) + ', which deserializes back to ' + deserialized + ' instead!');
    }
  function emscriptenWebGLGetIndexed(target, index, data, type) {
      if (!data) {
        // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
        // if data == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var result = GLctx['getIndexedParameter'](target, index);
      var ret;
      switch (typeof result) {
        case 'boolean':
          ret = result ? 1 : 0;
          break;
        case 'number':
          ret = result;
          break;
        case 'object':
          if (result === null) {
            switch (target) {
              case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING
              case 0x8A28: // UNIFORM_BUFFER_BINDING
                ret = 0;
                break;
              default: {
                GL.recordError(0x500); // GL_INVALID_ENUM
                return;
              }
            }
          } else if (result instanceof WebGLBuffer) {
            ret = result.name | 0;
          } else {
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          }
          break;
        default:
          GL.recordError(0x500); // GL_INVALID_ENUM
          return;
      }
  
      switch (type) {
        case 1: writeI53ToI64(data, ret); break;
        case 0: HEAP32[((data)>>2)] = ret; break;
        case 2: HEAPF32[((data)>>2)] = ret; break;
        case 4: HEAP8[((data)>>0)] = ret ? 1 : 0; break;
        default: throw 'internal emscriptenWebGLGetIndexed() error, bad type: ' + type;
      }
    }
  function _glGetIntegeri_v(target, index, data) {
      emscriptenWebGLGetIndexed(target, index, data, 0);
    }

  function emscriptenWebGLGet(name_, p, type) {
      // Guard against user passing a null pointer.
      // Note that GLES2 spec does not say anything about how passing a null pointer should be treated.
      // Testing on desktop core GL 3, the application crashes on glGetIntegerv to a null pointer, but
      // better to report an error instead of doing anything random.
      if (!p) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = undefined;
      switch (name_) { // Handle a few trivial GLES values
        case 0x8DFA: // GL_SHADER_COMPILER
          ret = 1;
          break;
        case 0x8DF8: // GL_SHADER_BINARY_FORMATS
          if (type != 0 && type != 1) {
            GL.recordError(0x500); // GL_INVALID_ENUM
          }
          return; // Do not write anything to the out pointer, since no binary formats are supported.
        case 0x87FE: // GL_NUM_PROGRAM_BINARY_FORMATS
        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
          ret = 0;
          break;
        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be queried for length),
          // so implement it ourselves to allow C++ GLES2 code get the length.
          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
          ret = formats ? formats.length : 0;
          break;
        case 0x826E: // GL_MAX_UNIFORM_LOCATIONS
          // This is an arbitrary limit, must be large enough to allow practical
          // use, but small enough to still keep a range for automatic uniform
          // locations, which get assigned numbers larger than this.
          ret = 1048576;
          break;
  
        case 0x821D: // GL_NUM_EXTENSIONS
          if (GL.currentContext.version < 2) {
            GL.recordError(0x502 /* GL_INVALID_OPERATION */); // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context
            return;
          }
          // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
          var exts = GLctx.getSupportedExtensions() || [];
          ret = 2 * exts.length; // each extension is duplicated, first in unprefixed WebGL form, and then a second time with "GL_" prefix.
          break;
        case 0x821B: // GL_MAJOR_VERSION
        case 0x821C: // GL_MINOR_VERSION
          if (GL.currentContext.version < 2) {
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          }
          ret = name_ == 0x821B ? 3 : 0; // return version 3.0
          break;
      }
  
      if (ret === undefined) {
        var result = GLctx.getParameter(name_);
        switch (typeof result) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
              // can mean an invalid name_, which we need to report as an error
              switch (name_) {
                case 0x8894: // ARRAY_BUFFER_BINDING
                case 0x8B8D: // CURRENT_PROGRAM
                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                case 0x8CA7: // RENDERBUFFER_BINDING
                case 0x8069: // TEXTURE_BINDING_2D
                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                case 0x8F36: // COPY_READ_BUFFER_BINDING or COPY_READ_BUFFER
                case 0x8F37: // COPY_WRITE_BUFFER_BINDING or COPY_WRITE_BUFFER
                case 0x88ED: // PIXEL_PACK_BUFFER_BINDING
                case 0x88EF: // PIXEL_UNPACK_BUFFER_BINDING
                case 0x8CAA: // READ_FRAMEBUFFER_BINDING
                case 0x8919: // SAMPLER_BINDING
                case 0x8C1D: // TEXTURE_BINDING_2D_ARRAY
                case 0x806A: // TEXTURE_BINDING_3D
                case 0x8E25: // TRANSFORM_FEEDBACK_BINDING
                case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING
                case 0x8A28: // UNIFORM_BUFFER_BINDING
                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                  ret = 0;
                  break;
                }
                default: {
                  GL.recordError(0x500); // GL_INVALID_ENUM
                  return;
                }
              }
            } else if (result instanceof Float32Array ||
                       result instanceof Uint32Array ||
                       result instanceof Int32Array ||
                       result instanceof Array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 0: HEAP32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 2: HEAPF32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 4: HEAP8[(((p)+(i))>>0)] = result[i] ? 1 : 0; break;
                }
              }
              return;
            } else {
              try {
                ret = result.name | 0;
              } catch(e) {
                GL.recordError(0x500); // GL_INVALID_ENUM
                err('GL_INVALID_ENUM in glGet' + type + 'v: Unknown object returned from WebGL getParameter(' + name_ + ')! (error: ' + e + ')');
                return;
              }
            }
            break;
          default:
            GL.recordError(0x500); // GL_INVALID_ENUM
            err('GL_INVALID_ENUM in glGet' + type + 'v: Native code calling glGet' + type + 'v(' + name_ + ') and it returns ' + result + ' of type ' + typeof(result) + '!');
            return;
        }
      }
  
      switch (type) {
        case 1: writeI53ToI64(p, ret); break;
        case 0: HEAP32[((p)>>2)] = ret; break;
        case 2:   HEAPF32[((p)>>2)] = ret; break;
        case 4: HEAP8[((p)>>0)] = ret ? 1 : 0; break;
      }
    }
  function _glGetIntegerv(name_, p) {
      emscriptenWebGLGet(name_, p, 0);
    }

  function _glGetInternalformativ(target, internalformat, pname, bufSize, params) {
      if (bufSize < 0) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (!params) {
        // GLES3 specification does not specify how to behave if values is a null pointer. Since calling this function does not make sense
        // if values == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = GLctx['getInternalformatParameter'](target, internalformat, pname);
      if (ret === null) return;
      for (var i = 0; i < ret.length && i < bufSize; ++i) {
        HEAP32[(((params)+(i*4))>>2)] = ret[i];
      }
    }

  function _glGetProgramBinary(program, bufSize, length, binaryFormat, binary) {
      GL.recordError(0x502/*GL_INVALID_OPERATION*/);
    }

  function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
      var log = GLctx.getProgramInfoLog(GL.programs[program]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    }

  function _glGetProgramiv(program, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      if (program >= GL.counter) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      program = GL.programs[program];
  
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getProgramInfoLog(program);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)] = log.length + 1;
      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
        if (!program.maxUniformLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
            program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformLength;
      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
        if (!program.maxAttributeLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/); ++i) {
            program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxAttributeLength;
      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
        if (!program.maxUniformBlockNameLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/); ++i) {
            program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformBlockNameLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getProgramParameter(program, pname);
      }
    }

  function _glGetQueryObjectuiv(id, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var query = GL.queries[id];
      var param = GLctx['getQueryParameter'](query, pname);
      var ret;
      if (typeof param == 'boolean') {
        ret = param ? 1 : 0;
      } else {
        ret = param;
      }
      HEAP32[((params)>>2)] = ret;
    }

  function _glGetQueryiv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx['getQuery'](target, pname);
    }

  function _glGetRenderbufferParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getRenderbufferParameter(target, pname);
    }

  function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    }

  function _glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
      var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
      HEAP32[((range)>>2)] = result.rangeMin;
      HEAP32[(((range)+(4))>>2)] = result.rangeMax;
      HEAP32[((precision)>>2)] = result.precision;
    }

  function _glGetShaderSource(shader, bufSize, length, source) {
      var result = GLctx.getShaderSource(GL.shaders[shader]);
      if (!result) return; // If an error occurs, nothing will be written to length or source.
      var numBytesWrittenExclNull = (bufSize > 0 && source) ? stringToUTF8(result, source, bufSize) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    }

  function _glGetShaderiv(shader, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        // The GLES2 specification says that if the shader has an empty info log,
        // a value of 0 is returned. Otherwise the log has a null char appended.
        // (An empty string is falsey, so we can just check that instead of
        // looking at log.length.)
        var logLength = log ? log.length + 1 : 0;
        HEAP32[((p)>>2)] = logLength;
      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
        var source = GLctx.getShaderSource(GL.shaders[shader]);
        // source may be a null, or the empty string, both of which are falsey
        // values that we report a 0 length for.
        var sourceLength = source ? source.length + 1 : 0;
        HEAP32[((p)>>2)] = sourceLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getShaderParameter(GL.shaders[shader], pname);
      }
    }

  function _glGetString(name_) {
      var ret = GL.stringCache[name_];
      if (!ret) {
        switch (name_) {
          case 0x1F03 /* GL_EXTENSIONS */:
            var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
            exts = exts.concat(exts.map(function(e) { return "GL_" + e; }));
            ret = stringToNewUTF8(exts.join(' '));
            break;
          case 0x1F00 /* GL_VENDOR */:
          case 0x1F01 /* GL_RENDERER */:
          case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
          case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
            var s = GLctx.getParameter(name_);
            if (!s) {
              GL.recordError(0x500/*GL_INVALID_ENUM*/);
            }
            ret = s && stringToNewUTF8(s);
            break;
  
          case 0x1F02 /* GL_VERSION */:
            var glVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
            // return GLES version string corresponding to the version of the WebGL context
            if (GL.currentContext.version >= 2) glVersion = 'OpenGL ES 3.0 (' + glVersion + ')';
            else
            {
              glVersion = 'OpenGL ES 2.0 (' + glVersion + ')';
            }
            ret = stringToNewUTF8(glVersion);
            break;
          case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
            var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
            // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
            var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
            var ver_num = glslVersion.match(ver_re);
            if (ver_num !== null) {
              if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
              glslVersion = 'OpenGL ES GLSL ES ' + ver_num[1] + ' (' + glslVersion + ')';
            }
            ret = stringToNewUTF8(glslVersion);
            break;
          default:
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
            // fall through
        }
        GL.stringCache[name_] = ret;
      }
      return ret;
    }

  function _glGetStringi(name, index) {
      if (GL.currentContext.version < 2) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */); // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context
        return 0;
      }
      var stringiCache = GL.stringiCache[name];
      if (stringiCache) {
        if (index < 0 || index >= stringiCache.length) {
          GL.recordError(0x501/*GL_INVALID_VALUE*/);
          return 0;
        }
        return stringiCache[index];
      }
      switch (name) {
        case 0x1F03 /* GL_EXTENSIONS */:
          var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
          exts = exts.concat(exts.map(function(e) { return "GL_" + e; }));
          exts = exts.map(function(e) { return stringToNewUTF8(e); });
  
          stringiCache = GL.stringiCache[name] = exts;
          if (index < 0 || index >= stringiCache.length) {
            GL.recordError(0x501/*GL_INVALID_VALUE*/);
            return 0;
          }
          return stringiCache[index];
        default:
          GL.recordError(0x500/*GL_INVALID_ENUM*/);
          return 0;
      }
    }

  function _glGetTexParameteriv(target, pname, params) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      HEAP32[((params)>>2)] = GLctx.getTexParameter(target, pname);
    }

  function _glGetUniformBlockIndex(program, uniformBlockName) {
      return GLctx['getUniformBlockIndex'](GL.programs[program], UTF8ToString(uniformBlockName));
    }

  function _glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices) {
      if (!uniformIndices) {
        // GLES2 specification does not specify how to behave if uniformIndices is a null pointer. Since calling this function does not make sense
        // if uniformIndices == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (uniformCount > 0 && (uniformNames == 0 || uniformIndices == 0)) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      var names = [];
      for (var i = 0; i < uniformCount; i++)
        names.push(UTF8ToString(HEAP32[(((uniformNames)+(i*4))>>2)]));
  
      var result = GLctx['getUniformIndices'](program, names);
      if (!result) return; // GL spec: If an error is generated, nothing is written out to uniformIndices.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        HEAP32[(((uniformIndices)+(i*4))>>2)] = result[i];
      }
    }

  /** @noinline */
  function webglGetLeftBracePos(name) {
      return name.slice(-1) == ']' && name.lastIndexOf('[');
    }
  function webglPrepareUniformLocationsBeforeFirstUse(program) {
      var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation
        uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]
        i, j;
  
      // On the first time invocation of glGetUniformLocation on this shader program:
      // initialize cache data structures and discover which uniforms are arrays.
      if (!uniformLocsById) {
        // maps GLint integer locations to WebGLUniformLocations
        program.uniformLocsById = uniformLocsById = {};
        // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
        program.uniformArrayNamesById = {};
  
        for (i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
          var u = GLctx.getActiveUniform(program, i);
          var nm = u.name;
          var sz = u.size;
          var lb = webglGetLeftBracePos(nm);
          var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
  
          // Acquire the preset location from the explicit uniform location if one was specified, or
          // programmatically assign a new one if not.
          var id = uniformSizeAndIdsByName[arrayName] ? uniformSizeAndIdsByName[arrayName][1] : program.uniformIdCounter;
          program.uniformIdCounter = Math.max(id + sz, program.uniformIdCounter);
          // Eagerly get the location of the uniformArray[0] base element.
          // The remaining indices >0 will be left for lazy evaluation to
          // improve performance. Those may never be needed to fetch, if the
          // application fills arrays always in full starting from the first
          // element of the array.
          uniformSizeAndIdsByName[arrayName] = [sz, id];
  
          // Store placeholder integers in place that highlight that these
          // >0 index locations are array indices pending population.
          for(j = 0; j < sz; ++j) {
            uniformLocsById[id] = j;
            program.uniformArrayNamesById[id++] = arrayName;
          }
        }
      }
    }
  function _glGetUniformLocation(program, name) {
  
      name = UTF8ToString(name);
  
      if (program = GL.programs[program]) {
        webglPrepareUniformLocationsBeforeFirstUse(program);
        var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
        var arrayIndex = 0;
        var uniformBaseName = name;
  
        // Invariant: when populating integer IDs for uniform locations, we must maintain the precondition that
        // arrays reside in contiguous addresses, i.e. for a 'vec4 colors[10];', colors[4] must be at location colors[0]+4.
        // However, user might call glGetUniformLocation(program, "colors") for an array, so we cannot discover based on the user
        // input arguments whether the uniform we are dealing with is an array. The only way to discover which uniforms are arrays
        // is to enumerate over all the active uniforms in the program.
        var leftBrace = webglGetLeftBracePos(name);
  
        // If user passed an array accessor "[index]", parse the array index off the accessor.
        if (leftBrace > 0) {
          arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
          uniformBaseName = name.slice(0, leftBrace);
        }
  
        // Have we cached the location of this uniform before?
        var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; // A pair [array length, GLint of the uniform location]
  
        // If an uniform with this name exists, and if its index is within the array limits (if it's even an array),
        // query the WebGLlocation, or return an existing cached location.
        if (sizeAndId && arrayIndex < sizeAndId[0]) {
          arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
          if ((uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))) {
            return arrayIndex;
          }
        }
      }
      else {
        // N.b. we are currently unable to distinguish between GL program IDs that never existed vs GL program IDs that have been deleted,
        // so report GL_INVALID_VALUE in both cases.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
      }
      return -1;
    }

  function webglGetUniformLocation(location) {
      var p = GLctx.currentProgram;
  
      if (p) {
        var webglLoc = p.uniformLocsById[location];
        // p.uniformLocsById[location] stores either an integer, or a WebGLUniformLocation.
  
        // If an integer, we have not yet bound the location, so do it now. The integer value specifies the array index
        // we should bind to.
        if (typeof webglLoc == 'number') {
          p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? '[' + webglLoc + ']' : ''));
        }
        // Else an already cached WebGLUniformLocation, return it.
        return webglLoc;
      } else {
        GL.recordError(0x502/*GL_INVALID_OPERATION*/);
      }
    }
  /** @suppress{checkTypes} */
  function emscriptenWebGLGetUniform(program, location, params, type) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      program = GL.programs[program];
      webglPrepareUniformLocationsBeforeFirstUse(program);
      var data = GLctx.getUniform(program, webglGetUniformLocation(location));
      if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)] = data; break;
          case 2: HEAPF32[((params)>>2)] = data; break;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)] = data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)] = data[i]; break;
          }
        }
      }
    }
  function _glGetUniformiv(program, location, params) {
      emscriptenWebGLGetUniform(program, location, params, 0);
    }

  /** @suppress{checkTypes} */
  function emscriptenWebGLGetVertexAttrib(index, pname, params, type) {
      if (!params) {
        // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
        // if params == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (GL.currentContext.clientBuffers[index].enabled) {
        err("glGetVertexAttrib*v on client-side array: not supported, bad data returned");
      }
      var data = GLctx.getVertexAttrib(index, pname);
      if (pname == 0x889F/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/) {
        HEAP32[((params)>>2)] = data && data["name"];
      } else if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 0: HEAP32[((params)>>2)] = data; break;
          case 2: HEAPF32[((params)>>2)] = data; break;
          case 5: HEAP32[((params)>>2)] = Math.fround(data); break;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 0: HEAP32[(((params)+(i*4))>>2)] = data[i]; break;
            case 2: HEAPF32[(((params)+(i*4))>>2)] = data[i]; break;
            case 5: HEAP32[(((params)+(i*4))>>2)] = Math.fround(data[i]); break;
          }
        }
      }
    }
  function _glGetVertexAttribiv(index, pname, params) {
      // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
      // otherwise the results are undefined. (GLES3 spec 6.1.12)
      emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
    }

  function _glInvalidateFramebuffer(target, numAttachments, attachments) {
      var list = tempFixedLengthArray[numAttachments];
      for (var i = 0; i < numAttachments; i++) {
        list[i] = HEAP32[(((attachments)+(i*4))>>2)];
      }
  
      GLctx['invalidateFramebuffer'](target, list);
    }

  function _glIsEnabled(x0) { return GLctx['isEnabled'](x0) }

  function _glIsVertexArray(array) {
  
      var vao = GL.vaos[array];
      if (!vao) return 0;
      return GLctx['isVertexArray'](vao);
    }

  function _glLinkProgram(program) {
      program = GL.programs[program];
      GLctx.linkProgram(program);
      // Invalidate earlier computed uniform->ID mappings, those have now become stale
      program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
      program.uniformSizeAndIdsByName = {};
  
      // Collect explicit uniform locations from the vertex and fragment shaders.
      [program['vs'], program['fs']].forEach(function(s) {
        Object.keys(s.explicitUniformLocations).forEach(function(shaderLocation) {
          var loc = s.explicitUniformLocations[shaderLocation];
          // Record each explicit uniform location temporarily as a non-array uniform
          // with size=1. This is not true, but on the first glGetUniformLocation() call
          // the array sizes will get populated to correct sizes.
          program.uniformSizeAndIdsByName[shaderLocation] = [1, loc];
  
          // Make sure we will never automatically assign locations within the range
          // used for explicit layout(location=x) variables.
          program.uniformIdCounter = Math.max(program.uniformIdCounter, loc + 1);
        });
      });
  
      function copyKeys(dst, src) {
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
      }
      // Collect sampler and ubo binding locations from the vertex and fragment shaders.
      program.explicitUniformBindings = {};
      program.explicitSamplerBindings = {};
      [program['vs'], program['fs']].forEach(function(s) {
        copyKeys(program.explicitUniformBindings, s.explicitUniformBindings);
        copyKeys(program.explicitSamplerBindings, s.explicitSamplerBindings);
      });
      // Record that we need to apply these explicit bindings when glUseProgram() is
      // first called on this program.
      program.explicitProgramBindingsApplied = 0;
    }

  function _glMapBufferRange(target, offset, length, access) {
      if (access != 0x1A && access != 0xA) {
        err("glMapBufferRange is only supported when access is MAP_WRITE|INVALIDATE_BUFFER");
        return 0;
      }
  
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glMapBufferRange');
        return 0;
      }
  
      var mem = _malloc(length);
      if (!mem) return 0;
  
      GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)] = {
        offset: offset,
        length: length,
        mem: mem,
        access: access,
      };
      return mem;
    }

  function _glPixelStorei(pname, param) {
      if (pname == 0xCF5 /* GL_UNPACK_ALIGNMENT */) {
        GL.unpackAlignment = param;
      }
      GLctx.pixelStorei(pname, param);
    }

  function _glPolygonOffset(x0, x1) { GLctx['polygonOffset'](x0, x1) }

  function _glProgramBinary(program, binaryFormat, binary, length) {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    }

  function _glProgramParameteri(program, pname, value) {
      GL.recordError(0x500/*GL_INVALID_ENUM*/);
    }

  function _glReadBuffer(x0) { GLctx['readBuffer'](x0) }

  function computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
      function roundedToNextMultipleOf(x, y) {
        return (x + y - 1) & -y;
      }
      var plainRowSize = width * sizePerPixel;
      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
      return height * alignedRowSize;
    }
  
  function __colorChannelsInGlTextureFormat(format) {
      // Micro-optimizations for size: map format to size by subtracting smallest enum value (0x1902) from all values first.
      // Also omit the most common size value (1) from the list, which is assumed by formats not on the list.
      var colorChannels = {
        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
        5: 3,
        6: 4,
        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
        8: 2,
        29502: 3,
        29504: 4,
        // 0x1903 /* GL_RED */ - 0x1902: 1,
        26917: 2,
        26918: 2,
        // 0x8D94 /* GL_RED_INTEGER */ - 0x1902: 1,
        29846: 3,
        29847: 4
      };
      return colorChannels[format - 0x1902]||1;
    }
  
  function heapObjectForWebGLType(type) {
      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
      // smaller values for the heap, for shorter generated code size.
      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
      // (since most types are HEAPU16)
      type -= 0x1400;
      if (type == 0) return HEAP8;
  
      if (type == 1) return HEAPU8;
  
      if (type == 2) return HEAP16;
  
      if (type == 4) return HEAP32;
  
      if (type == 6) return HEAPF32;
  
      if (type == 5
        || type == 28922
        || type == 28520
        || type == 30779
        || type == 30782
        )
        return HEAPU32;
  
      return HEAPU16;
    }
  
  function heapAccessShiftForWebGLHeap(heap) {
      return 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
    }
  function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
      var heap = heapObjectForWebGLType(type);
      var shift = heapAccessShiftForWebGLHeap(heap);
      var byteSize = 1<<shift;
      var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
      var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
      return heap.subarray(pixels >> shift, pixels + bytes >> shift);
    }
  function _glReadPixels(x, y, width, height, format, type, pixels) {
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelPackBufferBinding) {
          GLctx.readPixels(x, y, width, height, format, type, pixels);
        } else {
          var heap = heapObjectForWebGLType(type);
          GLctx.readPixels(x, y, width, height, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
        }
        return;
      }
      var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
      if (!pixelData) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        return;
      }
      GLctx.readPixels(x, y, width, height, format, type, pixelData);
    }

  function _glRenderbufferStorage(x0, x1, x2, x3) { GLctx['renderbufferStorage'](x0, x1, x2, x3) }

  function _glRenderbufferStorageMultisample(x0, x1, x2, x3, x4) { GLctx['renderbufferStorageMultisample'](x0, x1, x2, x3, x4) }

  function _glSamplerParameteri(sampler, pname, param) {
      GLctx['samplerParameteri'](GL.samplers[sampler], pname, param);
    }

  function _glScissor(x0, x1, x2, x3) { GLctx['scissor'](x0, x1, x2, x3) }

  function find_closing_parens_index(arr, i, opening='(', closing=')') {
      for(var nesting = 0; i < arr.length; ++i) {
        if (arr[i] == opening) ++nesting;
        if (arr[i] == closing && --nesting == 0) {
          return i;
        }
      }
    }
  function preprocess_c_code(code, defs = {}) {
      var i = 0, // iterator over the input string
        len = code.length, // cache input length
        out = '', // generates the preprocessed output string
        stack = [1]; // preprocessing stack (state of active/inactive #ifdef/#else blocks we are currently inside)
      // a mapping 'symbolname' -> function(args) which evaluates the given cpp macro, e.g. #define FOO(x) x+10.
      defs['defined'] = (args) => { // built-in "#if defined(x)"" macro.
        assert(args.length == 1);
        return defs[args[0]] ? 1 : 0;
      };
  
      // Returns true if str[i] is whitespace.
      function isWhitespace(str, i) {
        return !(str.charCodeAt(i) > 32); // Compare as negation to treat end-of-string undefined as whitespace
      }
  
      // Returns index to the next whitespace character starting at str[i].
      function nextWhitespace(str, i) {
        while(!isWhitespace(str, i)) ++i;
        return i;
      }
  
      // Returns an integer ID classification of the character at str[idx], used for tokenization purposes.
      function classifyChar(str, idx) {
        var cc = str.charCodeAt(idx);
        assert(!(cc > 127), "Only 7-bit ASCII can be used in preprocessor #if/#ifdef/#define statements!");
        if (cc > 32) {
          if (cc < 48) return 1; // an operator symbol, any of !"#$%&'()*+,-./
          if (cc < 58) return 2; // a number 0123456789
          if (cc < 65) return 1; // an operator symbol, any of :;<=>?@
          if (cc < 91 || cc == 95/*_*/) return 3; // a character, any of A-Z or _
          if (cc < 97) return 1; // an operator symbol, any of [\]^`
          if (cc < 123) return 3; // a character, any of a-z
          return 1; // an operator symbol, any of {|}~
        }
        return cc < 33 ? 0 : 4; // 0=whitespace, 4=end-of-string
      }
  
      // Returns a tokenized array of the given string expression, i.e. "FOO > BAR && BAZ" -> ["FOO", ">", "BAR", "&&", "BAZ"]
      // Optionally keeps whitespace as tokens to be able to reconstruct the original input string.
      function tokenize(exprString, keepWhitespace) {
        var out = [], len = exprString.length;
        for(var i = 0; i <= len; ++i) {
          var kind = classifyChar(exprString, i);
          if (kind == 2/*0-9*/ || kind == 3/*a-z*/) { // a character or a number
            for(var j = i+1; j <= len; ++j) {
              var kind2 = classifyChar(exprString, j);
              if (kind2 != kind && (kind2 != 2/*0-9*/ || kind != 3/*a-z*/)) { // parse number sequence "423410", and identifier sequence "FOO32BAR"
                out.push(exprString.substring(i, j));
                i = j-1;
                break;
              }
            }
          } else if (kind == 1/*operator symbol*/) {
            // Lookahead for two-character operators.
            var op2 = exprString.substr(i, 2);
            if (['<=', '>=', '==', '!=', '&&', '||'].includes(op2)) {
              out.push(op2);
              ++i;
            } else {
              out.push(exprString[i]);
            }
          }
        }
        return out;
      }
  
      // Expands preprocessing macros on substring str[lineStart...lineEnd]
      function expandMacros(str, lineStart, lineEnd) {
        if (lineEnd === undefined) lineEnd = str.length;
        var len = str.length;
        var out = '';
        for(var i = lineStart; i < lineEnd; ++i) {
          var kind = classifyChar(str, i);
          if (kind == 3/*a-z*/) {
            for(var j = i + 1; j <= lineEnd; ++j) {
              var kind2 = classifyChar(str, j);
              if (kind2 != 2/*0-9*/ && kind2 != 3/*a-z*/) {
                var symbol = str.substring(i, j);
                var pp = defs[symbol];
                if (pp) {
                  var expanded = str.substring(lineStart, i);
                  if (pp.length && str[j] == '(') { // Expanding a macro? (#define FOO(X) ...)
                    var closeParens = find_closing_parens_index(str, j);
                    assert(str[closeParens] == ')');
                    expanded += pp(str.substring(j+1, closeParens).split(',')) + str.substring(closeParens+1, lineEnd);
                  } else { // Expanding a non-macro (#define FOO BAR)
                    expanded += pp() + str.substring(j, lineEnd);
                  }
                  return expandMacros(expanded, 0);
                } else {
                  out += symbol;
                  i = j-1;
                  break;
                }
              }
            }
          } else {
            out += str[i];
          }
        }
        return out;
      }
  
      // Given a token list e.g. ['2', '>', '1'], returns a function that evaluates that token list.
      function buildExprTree(tokens) {
        // Consume tokens array into a function tree until the tokens array is exhausted
        // to a single root node that evaluates it.
        while (tokens.length > 1 || typeof tokens[0] != 'function') {
          tokens = (function(tokens) {
            // Find the index 'i' of the operator we should evaluate next:
            var i, j, p, operatorAndPriority = -2;
            for(j = 0; j < tokens.length; ++j) {
              if ((p = ['*', '/', '+', '-', '!', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '('].indexOf(tokens[j])) > operatorAndPriority) {
                i = j;
                operatorAndPriority = p;
              }
            }
  
            if (operatorAndPriority == 13 /* parens '(' */) {
              // Find the closing parens position
              var j = find_closing_parens_index(tokens, i);
              if (j) {
                tokens.splice(i, j+1-i, buildExprTree(tokens.slice(i+1, j)));
                return tokens;
              }
            }
  
            if (operatorAndPriority == 4 /* unary ! */) {
              // Special case: the unary operator ! needs to evaluate right-to-left.
              i = tokens.lastIndexOf('!');
              var innerExpr = buildExprTree(tokens.slice(i+1, i+2));
              tokens.splice(i, 2, function() { return !innerExpr(); })
              return tokens;
            }
  
            // A binary operator:
            if (operatorAndPriority >= 0) {
              var left = buildExprTree(tokens.slice(0, i));
              var right = buildExprTree(tokens.slice(i+1));
              switch(tokens[i]) {
                case '&&': return [function() { return left() && right(); }];
                case '||': return [function() { return left() || right(); }];
                case '==': return [function() { return left() == right(); }];
                case '!=': return [function() { return left() != right(); }];
                case '<' : return [function() { return left() <  right(); }];
                case '<=': return [function() { return left() <= right(); }];
                case '>' : return [function() { return left() >  right(); }];
                case '>=': return [function() { return left() >= right(); }];
                case  '+': return [function() { return left()  + right(); }];
                case  '-': return [function() { return left()  - right(); }];
                case  '*': return [function() { return left()  * right(); }];
                case  '/': return [function() { return Math.floor(left() / right()); }];
              }
            }
            // else a number:
            if (tokens[i] == ')') throw 'Parsing failure, mismatched parentheses in parsing!' + tokens.toString();
            assert(operatorAndPriority == -1);
            var num = jstoi_q(tokens[i]);
            return [function() { return num; }]
          })(tokens);
        }
        return tokens[0];
      }
  
      // Preprocess the input one line at a time.
      for(; i < len; ++i) {
        // Find the start of the current line.
        var lineStart = i;
  
        // Seek iterator to end of current line.
        i = code.indexOf('\n', i);
        if (i < 0) i = len;
  
        // Find the first non-whitespace character on the line.
        for(var j = lineStart; j < i && isWhitespace(code, j); ++j);
  
        // Is this a non-preprocessor directive line?
        var thisLineIsInActivePreprocessingBlock = stack[stack.length-1];
        if (code[j] != '#') { // non-preprocessor line?
          if (thisLineIsInActivePreprocessingBlock) {
            out += expandMacros(code, lineStart, i) + '\n';
          }
          continue;
        }
        // This is a preprocessor directive line, e.g. #ifdef or #define.
  
        // Parse the line as #<directive> <expression>
        var space = nextWhitespace(code, j);
        var directive = code.substring(j+1, space);
        var expression = code.substring(space, i).trim();
        switch(directive) {
        case 'if':
          var tokens = tokenize(expandMacros(expression, 0));
          var exprTree = buildExprTree(tokens);
          var evaluated = exprTree();
          stack.push(!!evaluated * stack[stack.length-1]);
          break;
        case 'ifdef': stack.push(!!defs[expression] * stack[stack.length-1]); break;
        case 'ifndef': stack.push(!defs[expression] * stack[stack.length-1]); break;
        case 'else': stack[stack.length-1] = 1-stack[stack.length-1]; break;
        case 'endif': stack.pop(); break;
        case 'define':
          if (thisLineIsInActivePreprocessingBlock) {
            // This could either be a macro with input args (#define MACRO(x,y) x+y), or a direct expansion #define FOO 2,
            // figure out which.
            var macroStart = expression.indexOf('(');
            var firstWs = nextWhitespace(expression, 0);
            if (firstWs < macroStart) macroStart = 0;
            if (macroStart > 0) { // #define MACRO( x , y , z ) <statement of x,y and z>
              var macroEnd = expression.indexOf(')', macroStart);
              let params = expression.substring(macroStart+1, macroEnd).split(',').map(x => x.trim());
              let value = tokenize(expression.substring(macroEnd+1).trim())
              defs[expression.substring(0, macroStart)] = (args) => {
                var ret = '';
                value.forEach((x) => {
                  var argIndex = params.indexOf(x);
                  ret += (argIndex >= 0) ? args[argIndex] : x;
                });
                return ret;
              };
            } else { // #define FOO (x + y + z)
              let value = expandMacros(expression.substring(firstWs+1).trim(), 0);
              defs[expression.substring(0, firstWs)] = () => value;
            }
          }
          break;
        case 'undef': if (thisLineIsInActivePreprocessingBlock) delete defs[expression]; break;
        default:
          if (directive != 'version' && directive != 'pragma' && directive != 'extension') { // GLSL shader compiler specific #directives.
            err('Unrecognized preprocessor directive #' + directive + '!');
          }
  
          // Unknown preprocessor macro, just pass through the line to output.
          out += expandMacros(code, lineStart, i) + '\n';
        }
      }
      return out;
    }
  
  function remove_cpp_comments_in_shaders(code) {
      var i = 0, out = '', ch, next, len = code.length;
      for(; i < len; ++i) {
        ch = code[i];
        if (ch == '/') {
          next = code[i+1];
          if (next == '/') {
            while(i < len && code[i+1] != '\n') ++i;
          } else if (next == '*') {
            while(i < len && (code[i-1] != '*' || code[i] != '/')) ++i;
          } else {
            out += ch;
          }
        } else {
          out += ch;
        }
      }
      return out;
    }
  function _glShaderSource(shader, count, string, length) {
      var source = GL.getSource(shader, count, string, length);
  
      // These are not expected to be meaningful in WebGL, but issue a warning if they are present, to give some diagnostics about if they are present.
      if (source.includes('__FILE__')) warnOnce('When compiling shader: ' + source + ': Preprocessor variable __FILE__ is not handled by -sGL_EXPLICIT_UNIFORM_LOCATION/-sGL_EXPLICIT_UNIFORM_BINDING options!');
      if (source.includes('__LINE__')) warnOnce('When compiling shader: ' + source + ': Preprocessor variable __LINE__ is not handled by -sGL_EXPLICIT_UNIFORM_LOCATION/-sGL_EXPLICIT_UNIFORM_BINDING options!');
      // Remove comments and C-preprocess the input shader first, so that we can appropriately
      // parse the layout location directives.
      source = preprocess_c_code(remove_cpp_comments_in_shaders(source), {
        'GL_FRAGMENT_PRECISION_HIGH': () => 1,
        'GL_ES': () => 1,
        '__VERSION__': () => source.includes('#version 300') ? 300 : 100
      });
  
      // Extract the layout(location = x) directives.
      var regex = /layout\s*\(\s*location\s*=\s*(-?\d+)\s*\)\s*(uniform\s+((lowp|mediump|highp)\s+)?\w+\s+(\w+))/g, explicitUniformLocations = {}, match;
      while(match = regex.exec(source)) {
        explicitUniformLocations[match[5]] = jstoi_q(match[1]);
        if (!(explicitUniformLocations[match[5]] >= 0 && explicitUniformLocations[match[5]] < 1048576)) {
          err('Specified an out of range layout(location=x) directive "' + explicitUniformLocations[match[5]] + '"! (' + match[0] + ')');
          GL.recordError(0x501 /* GL_INVALID_VALUE */);
          return;
        }
      }
  
      // Remove all the layout(location = x) directives so that they do not make
      // their way to the actual WebGL shader compiler.
      source = source.replace(regex, '$2');
  
      // Remember all the directives to be handled after glLinkProgram is called.
      GL.shaders[shader].explicitUniformLocations = explicitUniformLocations;
  
      // Extract the layout(binding = x) directives. Four types we need to handle:
      // layout(binding = 3) uniform sampler2D mainTexture;
      // layout(binding = 1, std140) uniform MainBlock { ... };
      // layout(std140, binding = 1) uniform MainBlock { ... };
      // layout(binding = 1) uniform MainBlock { ... };
      var bindingRegex = /layout\s*\(.*?binding\s*=\s*(-?\d+).*?\)\s*uniform\s+(\w+)\s+(\w+)?/g, samplerBindings = {}, uniformBindings = {}, bindingMatch;
      while(bindingMatch = bindingRegex.exec(source)) {
        // We have a layout(binding=x) enabled uniform. Parse the array length of that uniform, if it is an array, i.e. a
        //    layout(binding = 3) uniform sampler2D mainTexture[arrayLength];
        // or 
        //    layout(binding = 1, std140) uniform MainBlock { ... } name[arrayLength];
        var arrayLength = 1;
        for(var i = bindingMatch.index; i < source.length && source[i] != ';'; ++i) {
          if (source[i] == '[') {
            arrayLength = jstoi_q(source.slice(i+1));
            break;
          }
          if (source[i] == '{') i = find_closing_parens_index(source, i, '{', '}') - 1;
        }
        var binding = jstoi_q(bindingMatch[1]);
        var bindingsType = 0x8872/*GL_MAX_TEXTURE_IMAGE_UNITS*/;
        if (bindingMatch[3] && bindingMatch[2].indexOf('sampler') != -1) {
          samplerBindings[bindingMatch[3]] = [binding, arrayLength];
        } else {
          bindingsType = 0x8A2E/*GL_MAX_COMBINED_UNIFORM_BLOCKS*/;
          uniformBindings[bindingMatch[2]] = [binding, arrayLength];
        }
        var numBindingPoints = GLctx.getParameter(bindingsType);
        if (!(binding >= 0 && binding + arrayLength <= numBindingPoints)) {
          err('Specified an out of range layout(binding=x) directive "' + binding + '"! (' + bindingMatch[0] + '). Valid range is [0, ' + numBindingPoints + '-1]');
          GL.recordError(0x501 /* GL_INVALID_VALUE */);
          return;
        }
      }
  
      // Remove all the layout(binding = x) directives so that they do not make
      // their way to the actual WebGL shader compiler. These regexes get quite hairy, check against
      // https://regex101.com/ when working on these.
      source = source.replace(/layout\s*\(.*?binding\s*=\s*([-\d]+).*?\)/g, ''); // "layout(binding = 3)" -> ""
      source = source.replace(/(layout\s*\((.*?)),\s*binding\s*=\s*([-\d]+)\)/g, '$1)'); // "layout(std140, binding = 1)" -> "layout(std140)"
      source = source.replace(/layout\s*\(\s*binding\s*=\s*([-\d]+)\s*,(.*?)\)/g, 'layout($2)'); // "layout(binding = 1, std140)" -> "layout(std140)"
  
      // Remember all the directives to be handled after glLinkProgram is called.
      GL.shaders[shader].explicitSamplerBindings = samplerBindings;
      GL.shaders[shader].explicitUniformBindings = uniformBindings;
  
      GLctx.shaderSource(GL.shaders[shader], source);
    }

  function _glStencilFuncSeparate(x0, x1, x2, x3) { GLctx['stencilFuncSeparate'](x0, x1, x2, x3) }

  function _glStencilMask(x0) { GLctx['stencilMask'](x0) }

  function _glStencilOpSeparate(x0, x1, x2, x3) { GLctx['stencilOpSeparate'](x0, x1, x2, x3) }

  function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
      if (GL.currentContext.version >= 2) {
        // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
        } else if (pixels) {
          var heap = heapObjectForWebGLType(type);
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
        } else {
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, null);
        }
        return;
      }
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    }

  function _glTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels) {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx['texImage3D'](target, level, internalFormat, width, height, depth, border, format, type, pixels);
      } else if (pixels) {
        var heap = heapObjectForWebGLType(type);
        GLctx['texImage3D'](target, level, internalFormat, width, height, depth, border, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
      } else {
        GLctx['texImage3D'](target, level, internalFormat, width, height, depth, border, format, type, null);
      }
    }

  function _glTexParameterf(x0, x1, x2) { GLctx['texParameterf'](x0, x1, x2) }

  function _glTexParameteri(x0, x1, x2) { GLctx['texParameteri'](x0, x1, x2) }

  function _glTexParameteriv(target, pname, params) {
      var param = HEAP32[((params)>>2)];
      GLctx.texParameteri(target, pname, param);
    }

  function _glTexStorage2D(x0, x1, x2, x3, x4) { GLctx['texStorage2D'](x0, x1, x2, x3, x4) }

  function _glTexStorage3D(x0, x1, x2, x3, x4, x5) { GLctx['texStorage3D'](x0, x1, x2, x3, x4, x5) }

  function _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
      if (GL.currentContext.version >= 2) {
        // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } else if (pixels) {
          var heap = heapObjectForWebGLType(type);
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
        } else {
          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, null);
        }
        return;
      }
      var pixelData = null;
      if (pixels) pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
      GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
    }

  function _glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels) {
      if (GLctx.currentPixelUnpackBufferBinding) {
        GLctx['texSubImage3D'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
      } else if (pixels) {
        var heap = heapObjectForWebGLType(type);
        GLctx['texSubImage3D'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
      } else {
        GLctx['texSubImage3D'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, null);
      }
    }

  var miniTempWebGLFloatBuffers = [];
  function _glUniform1fv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform1fv(webglGetUniformLocation(location), HEAPF32, value>>2, count);
        return;
      }
  
      if (count <= 288) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*4)>>2);
      }
      GLctx.uniform1fv(webglGetUniformLocation(location), view);
    }

  function _glUniform1i(location, v0) {
      GLctx.uniform1i(webglGetUniformLocation(location), v0);
    }

  var __miniTempWebGLIntBuffers = [];
  function _glUniform1iv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform1iv(webglGetUniformLocation(location), HEAP32, value>>2, count);
        return;
      }
  
      if (count <= 288) {
        // avoid allocation when uploading few enough uniforms
        var view = __miniTempWebGLIntBuffers[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2, (value+count*4)>>2);
      }
      GLctx.uniform1iv(webglGetUniformLocation(location), view);
    }

  function _glUniform1uiv(location, count, value) {
      GLctx.uniform1uiv(webglGetUniformLocation(location), HEAPU32, value>>2, count);
    }

  function _glUniform2fv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform2fv(webglGetUniformLocation(location), HEAPF32, value>>2, count*2);
        return;
      }
  
      if (count <= 144) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*8)>>2);
      }
      GLctx.uniform2fv(webglGetUniformLocation(location), view);
    }

  function _glUniform2iv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform2iv(webglGetUniformLocation(location), HEAP32, value>>2, count*2);
        return;
      }
  
      if (count <= 144) {
        // avoid allocation when uploading few enough uniforms
        var view = __miniTempWebGLIntBuffers[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2, (value+count*8)>>2);
      }
      GLctx.uniform2iv(webglGetUniformLocation(location), view);
    }

  function _glUniform2uiv(location, count, value) {
      GLctx.uniform2uiv(webglGetUniformLocation(location), HEAPU32, value>>2, count*2);
    }

  function _glUniform3fv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform3fv(webglGetUniformLocation(location), HEAPF32, value>>2, count*3);
        return;
      }
  
      if (count <= 96) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*12)>>2);
      }
      GLctx.uniform3fv(webglGetUniformLocation(location), view);
    }

  function _glUniform3iv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform3iv(webglGetUniformLocation(location), HEAP32, value>>2, count*3);
        return;
      }
  
      if (count <= 96) {
        // avoid allocation when uploading few enough uniforms
        var view = __miniTempWebGLIntBuffers[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2, (value+count*12)>>2);
      }
      GLctx.uniform3iv(webglGetUniformLocation(location), view);
    }

  function _glUniform3uiv(location, count, value) {
      GLctx.uniform3uiv(webglGetUniformLocation(location), HEAPU32, value>>2, count*3);
    }

  function _glUniform4fv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform4fv(webglGetUniformLocation(location), HEAPF32, value>>2, count*4);
        return;
      }
  
      if (count <= 72) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[4*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 4 * count; i += 4) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*16)>>2);
      }
      GLctx.uniform4fv(webglGetUniformLocation(location), view);
    }

  function _glUniform4iv(location, count, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniform4iv(webglGetUniformLocation(location), HEAP32, value>>2, count*4);
        return;
      }
  
      if (count <= 72) {
        // avoid allocation when uploading few enough uniforms
        var view = __miniTempWebGLIntBuffers[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = HEAP32[(((value)+(4*i))>>2)];
          view[i+1] = HEAP32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAP32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAP32[(((value)+(4*i+12))>>2)];
        }
      } else
      {
        var view = HEAP32.subarray((value)>>2, (value+count*16)>>2);
      }
      GLctx.uniform4iv(webglGetUniformLocation(location), view);
    }

  function _glUniform4uiv(location, count, value) {
      GLctx.uniform4uiv(webglGetUniformLocation(location), HEAPU32, value>>2, count*4);
    }

  function _glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding) {
      program = GL.programs[program];
  
      GLctx['uniformBlockBinding'](program, uniformBlockIndex, uniformBlockBinding);
    }

  function _glUniformMatrix3fv(location, count, transpose, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, HEAPF32, value>>2, count*9);
        return;
      }
  
      if (count <= 32) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[9*count-1];
        for (var i = 0; i < 9*count; i += 9) {
          view[i] = HEAPF32[(((value)+(4*i))>>2)];
          view[i+1] = HEAPF32[(((value)+(4*i+4))>>2)];
          view[i+2] = HEAPF32[(((value)+(4*i+8))>>2)];
          view[i+3] = HEAPF32[(((value)+(4*i+12))>>2)];
          view[i+4] = HEAPF32[(((value)+(4*i+16))>>2)];
          view[i+5] = HEAPF32[(((value)+(4*i+20))>>2)];
          view[i+6] = HEAPF32[(((value)+(4*i+24))>>2)];
          view[i+7] = HEAPF32[(((value)+(4*i+28))>>2)];
          view[i+8] = HEAPF32[(((value)+(4*i+32))>>2)];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*36)>>2);
      }
      GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
    }

  function _glUniformMatrix4fv(location, count, transpose, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, value>>2, count*16);
        return;
      }
  
      if (count <= 18) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[16*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 16 * count; i += 16) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
          view[i + 4] = heap[dst + 4];
          view[i + 5] = heap[dst + 5];
          view[i + 6] = heap[dst + 6];
          view[i + 7] = heap[dst + 7];
          view[i + 8] = heap[dst + 8];
          view[i + 9] = heap[dst + 9];
          view[i + 10] = heap[dst + 10];
          view[i + 11] = heap[dst + 11];
          view[i + 12] = heap[dst + 12];
          view[i + 13] = heap[dst + 13];
          view[i + 14] = heap[dst + 14];
          view[i + 15] = heap[dst + 15];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*64)>>2);
      }
      GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
    }

  function _glUnmapBuffer(target) {
      if (!emscriptenWebGLValidateMapBufferTarget(target)) {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
        err('GL_INVALID_ENUM in glUnmapBuffer');
        return 0;
      }
  
      var buffer = emscriptenWebGLGetBufferBinding(target);
      var mapping = GL.mappedBuffers[buffer];
      if (!mapping) {
        GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        err('buffer was never mapped in glUnmapBuffer');
        return 0;
      }
      GL.mappedBuffers[buffer] = null;
  
      if (!(mapping.access & 0x10)) /* GL_MAP_FLUSH_EXPLICIT_BIT */
        if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
          GLctx.bufferSubData(target, mapping.offset, HEAPU8, mapping.mem, mapping.length);
        } else {
          GLctx.bufferSubData(target, mapping.offset, HEAPU8.subarray(mapping.mem, mapping.mem+mapping.length));
        }
      _free(mapping.mem);
      return 1;
    }

  function webglApplyExplicitProgramBindings() {
      var p = GLctx.currentProgram;
      if (!p.explicitProgramBindingsApplied) {
        if (GL.currentContext.version >= 2) {
          Object.keys(p.explicitUniformBindings).forEach(function(ubo) {
            var bindings = p.explicitUniformBindings[ubo];
            for(var i = 0; i < bindings[1]; ++i) {
              var blockIndex = GLctx.getUniformBlockIndex(p, ubo + (bindings[1] > 1 ? '[' + i + ']' : ''));
              GLctx.uniformBlockBinding(p, blockIndex, bindings[0]+i);
            }
          });
        }
        Object.keys(p.explicitSamplerBindings).forEach(function(sampler) {
          var bindings = p.explicitSamplerBindings[sampler];
          for(var i = 0; i < bindings[1]; ++i) {
            GLctx.uniform1i(GLctx.getUniformLocation(p, sampler + (i ? '['+i+']' : '')), bindings[0]+i);
          }
        });
        p.explicitProgramBindingsApplied = 1;
      }
    }
  function _glUseProgram(program) {
      program = GL.programs[program];
      GLctx.useProgram(program);
      // Record the currently active program so that we can access the uniform
      // mapping table of that program.
      if ((GLctx.currentProgram = program)) {
        webglApplyExplicitProgramBindings();
      }
    }

  function _glValidateProgram(program) {
      GLctx.validateProgram(GL.programs[program]);
    }

  function _glVertexAttrib4f(x0, x1, x2, x3, x4) { GLctx['vertexAttrib4f'](x0, x1, x2, x3, x4) }

  function _glVertexAttrib4fv(index, v) {
  
      GLctx.vertexAttrib4f(index, HEAPF32[v>>2], HEAPF32[v+4>>2], HEAPF32[v+8>>2], HEAPF32[v+12>>2]);
    }

  function _glVertexAttribIPointer(index, size, type, stride, ptr) {
      var cb = GL.currentContext.clientBuffers[index];
      if (!GLctx.currentArrayBufferBinding) {
        cb.size = size;
        cb.type = type;
        cb.normalized = false;
        cb.stride = stride;
        cb.ptr = ptr;
        cb.clientside = true;
        cb.vertexAttribPointerAdaptor = function(index, size, type, normalized, stride, ptr) {
          this.vertexAttribIPointer(index, size, type, stride, ptr);
        };
        return;
      }
      cb.clientside = false;
      GLctx['vertexAttribIPointer'](index, size, type, stride, ptr);
    }

  function _glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
      var cb = GL.currentContext.clientBuffers[index];
      if (!GLctx.currentArrayBufferBinding) {
        cb.size = size;
        cb.type = type;
        cb.normalized = normalized;
        cb.stride = stride;
        cb.ptr = ptr;
        cb.clientside = true;
        cb.vertexAttribPointerAdaptor = function(index, size, type, normalized, stride, ptr) {
          this.vertexAttribPointer(index, size, type, normalized, stride, ptr);
        };
        return;
      }
      cb.clientside = false;
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    }

  function _glViewport(x0, x1, x2, x3) { GLctx['viewport'](x0, x1, x2, x3) }

  function _llvm_eh_typeid_for(type) {
      return type;
    }

  function _setTempRet0(val) {
      setTempRet0(val);
    }

  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    }
  
  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];
  function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while (days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }
  function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
      };
  
      var pattern = UTF8ToString(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
        // Modified Conversion Specifiers
        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
        '%EY': '%Y',                      // Replaced by the full alternative year representation.
        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value == 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      }
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      }
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        }
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      }
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      }
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear()-1;
          }
      }
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
          // January 4th, which is also the week that includes the first Thursday of the year, and
          // is also the first week that contains at least four days in the year.
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
          // the last week of the preceding year; thus, for Saturday 2nd January 1999,
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
          // or 31st is a Monday, it and any following days are part of week 1 of the following year.
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
  
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          var twelveHour = date.tm_hour;
          if (twelveHour == 0) twelveHour = 12;
          else if (twelveHour > 12) twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          return date.tm_wday || 7;
        },
        '%U': function(date) {
          var days = date.tm_yday + 7 - date.tm_wday;
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week)
          // as a decimal number [01,53]. If the week containing 1 January has four
          // or more days in the new year, then it is considered week 1.
          // Otherwise, it is the last week of the previous year, and the next week is week 1.
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);
          // If 1 Jan is just 1-3 days past Monday, the previous week
          // is also in this year.
          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {
            val++;
          }
          if (!val) {
            val = 52;
            // If 31 December of prev year a Thursday, or Friday of a
            // leap year, then the prev year has 53 weeks.
            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;
            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {
              val++;
            }
          } else if (val == 53) {
            // If 1 January is not a Thursday, and not a Wednesday of a
            // leap year, then this year has only 52 weeks.
            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;
            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))
              val = 1;
          }
          return leadingNulls(val, 2);
        },
        '%w': function(date) {
          return date.tm_wday;
        },
        '%W': function(date) {
          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);
          return leadingNulls(Math.floor(days / 7), 2);
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
  
      // Replace %% with a pair of NULLs (which cannot occur in a C string), then
      // re-inject them after processing.
      pattern = pattern.replace(/%%/g, '\0\0')
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.includes(rule)) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
      pattern = pattern.replace(/\0\0/g, '%')
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;;
ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };;
Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas) { Browser.requestFullscreen(lockPointer, resizeCanvas) };
  Module["requestFullScreen"] = function Module_requestFullScreen() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };
var GLctx;;
for (var i = 0; i < 32; ++i) tempFixedLengthArray.push(new Array(i));;
var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
  for (/**@suppress{duplicate}*/var i = 0; i < 288; ++i) {
  miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i+1);
  }
  ;
var __miniTempWebGLIntBuffersStorage = new Int32Array(288);
  for (/**@suppress{duplicate}*/var i = 0; i < 288; ++i) {
  __miniTempWebGLIntBuffers[i] = __miniTempWebGLIntBuffersStorage.subarray(0, i+1);
  }
  ;
var ASSERTIONS = true;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var asmLibraryArg = {
  "ClearTurnsInternal": _ClearTurnsInternal,
  "ConvertString": _ConvertString,
  "CreateJoystickInternal": _CreateJoystickInternal,
  "DpadJoystickInternal": _DpadJoystickInternal,
  "GetAllTurnsInternal": _GetAllTurnsInternal,
  "GetChallengeIdInternal": _GetChallengeIdInternal,
  "GetJSMemoryInfo": _GetJSMemoryInfo,
  "GetMyTurnDataInternal": _GetMyTurnDataInternal,
  "GetPersistentDataInternal": _GetPersistentDataInternal,
  "GetPlayerStateDictionary": _GetPlayerStateDictionary,
  "GetPlayerStateFloatById": _GetPlayerStateFloatById,
  "GetPlayerStateIntById": _GetPlayerStateIntById,
  "GetPlayerStateStringById": _GetPlayerStateStringById,
  "GetProfileByPlayerId": _GetProfileByPlayerId,
  "GetRoomCodeInternal": _GetRoomCodeInternal,
  "GetStateDictionaryInternal": _GetStateDictionaryInternal,
  "GetStateFloatInternal": _GetStateFloatInternal,
  "GetStateIntInternal": _GetStateIntInternal,
  "GetStateStringInternal": _GetStateStringInternal,
  "InsertCoinInternal": _InsertCoinInternal,
  "InsertPersistentDataInternal": _InsertPersistentDataInternal,
  "IsHostInternal": _IsHostInternal,
  "IsStreamScreenInternal": _IsStreamScreenInternal,
  "JS_Accelerometer_IsRunning": _JS_Accelerometer_IsRunning,
  "JS_Accelerometer_Start": _JS_Accelerometer_Start,
  "JS_Accelerometer_Stop": _JS_Accelerometer_Stop,
  "JS_CallAsLongAsNoExceptionsSeen": _JS_CallAsLongAsNoExceptionsSeen,
  "JS_Cursor_SetImage": _JS_Cursor_SetImage,
  "JS_Cursor_SetShow": _JS_Cursor_SetShow,
  "JS_DOM_MapViewportCoordinateToElementLocalCoordinate": _JS_DOM_MapViewportCoordinateToElementLocalCoordinate,
  "JS_DOM_UnityCanvasSelector": _JS_DOM_UnityCanvasSelector,
  "JS_Eval_OpenURL": _JS_Eval_OpenURL,
  "JS_FileSystem_Initialize": _JS_FileSystem_Initialize,
  "JS_FileSystem_Sync": _JS_FileSystem_Sync,
  "JS_GravitySensor_IsRunning": _JS_GravitySensor_IsRunning,
  "JS_GravitySensor_Start": _JS_GravitySensor_Start,
  "JS_GravitySensor_Stop": _JS_GravitySensor_Stop,
  "JS_GuardAgainstJsExceptions": _JS_GuardAgainstJsExceptions,
  "JS_Gyroscope_IsRunning": _JS_Gyroscope_IsRunning,
  "JS_Gyroscope_Start": _JS_Gyroscope_Start,
  "JS_Gyroscope_Stop": _JS_Gyroscope_Stop,
  "JS_Init_ContextMenuHandler": _JS_Init_ContextMenuHandler,
  "JS_LinearAccelerationSensor_IsRunning": _JS_LinearAccelerationSensor_IsRunning,
  "JS_LinearAccelerationSensor_Start": _JS_LinearAccelerationSensor_Start,
  "JS_LinearAccelerationSensor_Stop": _JS_LinearAccelerationSensor_Stop,
  "JS_Log_Dump": _JS_Log_Dump,
  "JS_Log_StackTrace": _JS_Log_StackTrace,
  "JS_MobileKeybard_GetIgnoreBlurEvent": _JS_MobileKeybard_GetIgnoreBlurEvent,
  "JS_MobileKeyboard_GetKeyboardStatus": _JS_MobileKeyboard_GetKeyboardStatus,
  "JS_MobileKeyboard_GetText": _JS_MobileKeyboard_GetText,
  "JS_MobileKeyboard_GetTextSelection": _JS_MobileKeyboard_GetTextSelection,
  "JS_MobileKeyboard_Hide": _JS_MobileKeyboard_Hide,
  "JS_MobileKeyboard_SetCharacterLimit": _JS_MobileKeyboard_SetCharacterLimit,
  "JS_MobileKeyboard_SetText": _JS_MobileKeyboard_SetText,
  "JS_MobileKeyboard_SetTextSelection": _JS_MobileKeyboard_SetTextSelection,
  "JS_MobileKeyboard_Show": _JS_MobileKeyboard_Show,
  "JS_OrientationSensor_IsRunning": _JS_OrientationSensor_IsRunning,
  "JS_OrientationSensor_Start": _JS_OrientationSensor_Start,
  "JS_OrientationSensor_Stop": _JS_OrientationSensor_Stop,
  "JS_Profiler_InjectJobs": _JS_Profiler_InjectJobs,
  "JS_RequestDeviceSensorPermissionsOnTouch": _JS_RequestDeviceSensorPermissionsOnTouch,
  "JS_RunQuitCallbacks": _JS_RunQuitCallbacks,
  "JS_ScreenOrientation_DeInit": _JS_ScreenOrientation_DeInit,
  "JS_ScreenOrientation_Init": _JS_ScreenOrientation_Init,
  "JS_ScreenOrientation_Lock": _JS_ScreenOrientation_Lock,
  "JS_Sound_Create_Channel": _JS_Sound_Create_Channel,
  "JS_Sound_GetLength": _JS_Sound_GetLength,
  "JS_Sound_GetLoadState": _JS_Sound_GetLoadState,
  "JS_Sound_Init": _JS_Sound_Init,
  "JS_Sound_Load": _JS_Sound_Load,
  "JS_Sound_Load_PCM": _JS_Sound_Load_PCM,
  "JS_Sound_Play": _JS_Sound_Play,
  "JS_Sound_ReleaseInstance": _JS_Sound_ReleaseInstance,
  "JS_Sound_ResumeIfNeeded": _JS_Sound_ResumeIfNeeded,
  "JS_Sound_Set3D": _JS_Sound_Set3D,
  "JS_Sound_SetListenerOrientation": _JS_Sound_SetListenerOrientation,
  "JS_Sound_SetListenerPosition": _JS_Sound_SetListenerPosition,
  "JS_Sound_SetLoop": _JS_Sound_SetLoop,
  "JS_Sound_SetLoopPoints": _JS_Sound_SetLoopPoints,
  "JS_Sound_SetPaused": _JS_Sound_SetPaused,
  "JS_Sound_SetPitch": _JS_Sound_SetPitch,
  "JS_Sound_SetPosition": _JS_Sound_SetPosition,
  "JS_Sound_SetVolume": _JS_Sound_SetVolume,
  "JS_Sound_Stop": _JS_Sound_Stop,
  "JS_SystemInfo_GetCanvasClientSize": _JS_SystemInfo_GetCanvasClientSize,
  "JS_SystemInfo_GetDocumentURL": _JS_SystemInfo_GetDocumentURL,
  "JS_SystemInfo_GetGPUInfo": _JS_SystemInfo_GetGPUInfo,
  "JS_SystemInfo_GetMatchWebGLToCanvasSize": _JS_SystemInfo_GetMatchWebGLToCanvasSize,
  "JS_SystemInfo_GetMemory": _JS_SystemInfo_GetMemory,
  "JS_SystemInfo_GetOS": _JS_SystemInfo_GetOS,
  "JS_SystemInfo_GetPreferredDevicePixelRatio": _JS_SystemInfo_GetPreferredDevicePixelRatio,
  "JS_SystemInfo_GetScreenSize": _JS_SystemInfo_GetScreenSize,
  "JS_SystemInfo_HasAstcHdr": _JS_SystemInfo_HasAstcHdr,
  "JS_SystemInfo_HasCursorLock": _JS_SystemInfo_HasCursorLock,
  "JS_SystemInfo_HasFullscreen": _JS_SystemInfo_HasFullscreen,
  "JS_SystemInfo_HasWebGL": _JS_SystemInfo_HasWebGL,
  "JS_UnityEngineShouldQuit": _JS_UnityEngineShouldQuit,
  "KickInternal": _KickInternal,
  "MyPlayerInternal": _MyPlayerInternal,
  "OnDisconnectInternal": _OnDisconnectInternal,
  "OnPlayerJoinInternal": _OnPlayerJoinInternal,
  "ResetPlayersStatesInternal": _ResetPlayersStatesInternal,
  "ResetStatesInternal": _ResetStatesInternal,
  "RpcCallInternal": _RpcCallInternal,
  "RpcRegisterInternal": _RpcRegisterInternal,
  "SaveMyTurnDataInternal": _SaveMyTurnDataInternal,
  "SetPersistentDataInternal": _SetPersistentDataInternal,
  "SetPlayerStateByPlayerId": _SetPlayerStateByPlayerId,
  "SetPlayerStateDictionary": _SetPlayerStateDictionary,
  "SetPlayerStateFloatByPlayerId": _SetPlayerStateFloatByPlayerId,
  "SetPlayerStateStringById": _SetPlayerStateStringById,
  "SetStateDictionary": _SetStateDictionary,
  "SetStateFloatInternal": _SetStateFloatInternal,
  "SetStateInternal": _SetStateInternal,
  "SetStateString": _SetStateString,
  "StartMatchmakingInternal": _StartMatchmakingInternal,
  "TransferHostInternal": _TransferHostInternal,
  "UnsubscribeOnPlayerJoinInternal": _UnsubscribeOnPlayerJoinInternal,
  "UnsubscribeOnQuitInternal": _UnsubscribeOnQuitInternal,
  "WaitForPlayerStateInternal": _WaitForPlayerStateInternal,
  "WaitForStateInternal": _WaitForStateInternal,
  "__assert_fail": ___assert_fail,
  "__cxa_allocate_exception": ___cxa_allocate_exception,
  "__cxa_begin_catch": ___cxa_begin_catch,
  "__cxa_end_catch": ___cxa_end_catch,
  "__cxa_find_matching_catch_2": ___cxa_find_matching_catch_2,
  "__cxa_find_matching_catch_3": ___cxa_find_matching_catch_3,
  "__cxa_find_matching_catch_4": ___cxa_find_matching_catch_4,
  "__cxa_free_exception": ___cxa_free_exception,
  "__cxa_rethrow": ___cxa_rethrow,
  "__cxa_throw": ___cxa_throw,
  "__resumeException": ___resumeException,
  "__syscall__newselect": ___syscall__newselect,
  "__syscall_accept4": ___syscall_accept4,
  "__syscall_chmod": ___syscall_chmod,
  "__syscall_connect": ___syscall_connect,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_getdents64": ___syscall_getdents64,
  "__syscall_getsockopt": ___syscall_getsockopt,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdir": ___syscall_mkdir,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_recvfrom": ___syscall_recvfrom,
  "__syscall_renameat": ___syscall_renameat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_sendto": ___syscall_sendto,
  "__syscall_socket": ___syscall_socket,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_statfs64": ___syscall_statfs64,
  "__syscall_truncate64": ___syscall_truncate64,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "_dlopen_js": __dlopen_js,
  "_dlsym_js": __dlsym_js,
  "_emscripten_date_now": __emscripten_date_now,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_emscripten_throw_longjmp": __emscripten_throw_longjmp,
  "_gmtime_js": __gmtime_js,
  "_localtime_js": __localtime_js,
  "_mktime_js": __mktime_js,
  "_mmap_js": __mmap_js,
  "_munmap_js": __munmap_js,
  "_tzset_js": __tzset_js,
  "abort": _abort,
  "emscripten_asm_const_int": _emscripten_asm_const_int,
  "emscripten_asm_const_int_sync_on_main_thread": _emscripten_asm_const_int_sync_on_main_thread,
  "emscripten_cancel_main_loop": _emscripten_cancel_main_loop,
  "emscripten_clear_interval": _emscripten_clear_interval,
  "emscripten_console_error": _emscripten_console_error,
  "emscripten_exit_fullscreen": _emscripten_exit_fullscreen,
  "emscripten_exit_pointerlock": _emscripten_exit_pointerlock,
  "emscripten_get_canvas_element_size": _emscripten_get_canvas_element_size,
  "emscripten_get_fullscreen_status": _emscripten_get_fullscreen_status,
  "emscripten_get_gamepad_status": _emscripten_get_gamepad_status,
  "emscripten_get_heap_max": _emscripten_get_heap_max,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_get_now_res": _emscripten_get_now_res,
  "emscripten_get_num_gamepads": _emscripten_get_num_gamepads,
  "emscripten_html5_remove_all_event_listeners": _emscripten_html5_remove_all_event_listeners,
  "emscripten_is_webgl_context_lost": _emscripten_is_webgl_context_lost,
  "emscripten_log": _emscripten_log,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_request_fullscreen": _emscripten_request_fullscreen,
  "emscripten_request_pointerlock": _emscripten_request_pointerlock,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "emscripten_sample_gamepad_data": _emscripten_sample_gamepad_data,
  "emscripten_set_blur_callback_on_thread": _emscripten_set_blur_callback_on_thread,
  "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
  "emscripten_set_focus_callback_on_thread": _emscripten_set_focus_callback_on_thread,
  "emscripten_set_fullscreenchange_callback_on_thread": _emscripten_set_fullscreenchange_callback_on_thread,
  "emscripten_set_gamepadconnected_callback_on_thread": _emscripten_set_gamepadconnected_callback_on_thread,
  "emscripten_set_gamepaddisconnected_callback_on_thread": _emscripten_set_gamepaddisconnected_callback_on_thread,
  "emscripten_set_interval": _emscripten_set_interval,
  "emscripten_set_keydown_callback_on_thread": _emscripten_set_keydown_callback_on_thread,
  "emscripten_set_keypress_callback_on_thread": _emscripten_set_keypress_callback_on_thread,
  "emscripten_set_keyup_callback_on_thread": _emscripten_set_keyup_callback_on_thread,
  "emscripten_set_main_loop": _emscripten_set_main_loop,
  "emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing,
  "emscripten_set_mousedown_callback_on_thread": _emscripten_set_mousedown_callback_on_thread,
  "emscripten_set_mousemove_callback_on_thread": _emscripten_set_mousemove_callback_on_thread,
  "emscripten_set_mouseup_callback_on_thread": _emscripten_set_mouseup_callback_on_thread,
  "emscripten_set_pointerlockchange_callback_on_thread": _emscripten_set_pointerlockchange_callback_on_thread,
  "emscripten_set_touchcancel_callback_on_thread": _emscripten_set_touchcancel_callback_on_thread,
  "emscripten_set_touchend_callback_on_thread": _emscripten_set_touchend_callback_on_thread,
  "emscripten_set_touchmove_callback_on_thread": _emscripten_set_touchmove_callback_on_thread,
  "emscripten_set_touchstart_callback_on_thread": _emscripten_set_touchstart_callback_on_thread,
  "emscripten_set_wheel_callback_on_thread": _emscripten_set_wheel_callback_on_thread,
  "emscripten_webgl_create_context": _emscripten_webgl_create_context,
  "emscripten_webgl_destroy_context": _emscripten_webgl_destroy_context,
  "emscripten_webgl_enable_extension": _emscripten_webgl_enable_extension,
  "emscripten_webgl_get_current_context": _emscripten_webgl_get_current_context,
  "emscripten_webgl_init_context_attributes": _emscripten_webgl_init_context_attributes,
  "emscripten_webgl_make_context_current": _emscripten_webgl_make_context_current,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "exit": _exit,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "getTempRet0": _getTempRet0,
  "gethostbyaddr": _gethostbyaddr,
  "gethostbyname": _gethostbyname,
  "glActiveTexture": _glActiveTexture,
  "glAttachShader": _glAttachShader,
  "glBeginQuery": _glBeginQuery,
  "glBindAttribLocation": _glBindAttribLocation,
  "glBindBuffer": _glBindBuffer,
  "glBindBufferBase": _glBindBufferBase,
  "glBindBufferRange": _glBindBufferRange,
  "glBindFramebuffer": _glBindFramebuffer,
  "glBindRenderbuffer": _glBindRenderbuffer,
  "glBindSampler": _glBindSampler,
  "glBindTexture": _glBindTexture,
  "glBindVertexArray": _glBindVertexArray,
  "glBlendEquation": _glBlendEquation,
  "glBlendEquationSeparate": _glBlendEquationSeparate,
  "glBlendFuncSeparate": _glBlendFuncSeparate,
  "glBlitFramebuffer": _glBlitFramebuffer,
  "glBufferData": _glBufferData,
  "glBufferSubData": _glBufferSubData,
  "glCheckFramebufferStatus": _glCheckFramebufferStatus,
  "glClear": _glClear,
  "glClearBufferfi": _glClearBufferfi,
  "glClearBufferfv": _glClearBufferfv,
  "glClearBufferuiv": _glClearBufferuiv,
  "glClearColor": _glClearColor,
  "glClearDepthf": _glClearDepthf,
  "glClearStencil": _glClearStencil,
  "glClientWaitSync": _glClientWaitSync,
  "glColorMask": _glColorMask,
  "glCompileShader": _glCompileShader,
  "glCompressedTexImage2D": _glCompressedTexImage2D,
  "glCompressedTexImage3D": _glCompressedTexImage3D,
  "glCompressedTexSubImage2D": _glCompressedTexSubImage2D,
  "glCompressedTexSubImage3D": _glCompressedTexSubImage3D,
  "glCopyBufferSubData": _glCopyBufferSubData,
  "glCopyTexImage2D": _glCopyTexImage2D,
  "glCopyTexSubImage2D": _glCopyTexSubImage2D,
  "glCreateProgram": _glCreateProgram,
  "glCreateShader": _glCreateShader,
  "glCullFace": _glCullFace,
  "glDeleteBuffers": _glDeleteBuffers,
  "glDeleteFramebuffers": _glDeleteFramebuffers,
  "glDeleteProgram": _glDeleteProgram,
  "glDeleteQueries": _glDeleteQueries,
  "glDeleteRenderbuffers": _glDeleteRenderbuffers,
  "glDeleteSamplers": _glDeleteSamplers,
  "glDeleteShader": _glDeleteShader,
  "glDeleteSync": _glDeleteSync,
  "glDeleteTextures": _glDeleteTextures,
  "glDeleteVertexArrays": _glDeleteVertexArrays,
  "glDepthFunc": _glDepthFunc,
  "glDepthMask": _glDepthMask,
  "glDetachShader": _glDetachShader,
  "glDisable": _glDisable,
  "glDisableVertexAttribArray": _glDisableVertexAttribArray,
  "glDrawArrays": _glDrawArrays,
  "glDrawArraysInstanced": _glDrawArraysInstanced,
  "glDrawBuffers": _glDrawBuffers,
  "glDrawElements": _glDrawElements,
  "glDrawElementsInstanced": _glDrawElementsInstanced,
  "glEnable": _glEnable,
  "glEnableVertexAttribArray": _glEnableVertexAttribArray,
  "glEndQuery": _glEndQuery,
  "glFenceSync": _glFenceSync,
  "glFinish": _glFinish,
  "glFlush": _glFlush,
  "glFlushMappedBufferRange": _glFlushMappedBufferRange,
  "glFramebufferRenderbuffer": _glFramebufferRenderbuffer,
  "glFramebufferTexture2D": _glFramebufferTexture2D,
  "glFramebufferTextureLayer": _glFramebufferTextureLayer,
  "glFrontFace": _glFrontFace,
  "glGenBuffers": _glGenBuffers,
  "glGenFramebuffers": _glGenFramebuffers,
  "glGenQueries": _glGenQueries,
  "glGenRenderbuffers": _glGenRenderbuffers,
  "glGenSamplers": _glGenSamplers,
  "glGenTextures": _glGenTextures,
  "glGenVertexArrays": _glGenVertexArrays,
  "glGenerateMipmap": _glGenerateMipmap,
  "glGetActiveAttrib": _glGetActiveAttrib,
  "glGetActiveUniform": _glGetActiveUniform,
  "glGetActiveUniformBlockName": _glGetActiveUniformBlockName,
  "glGetActiveUniformBlockiv": _glGetActiveUniformBlockiv,
  "glGetActiveUniformsiv": _glGetActiveUniformsiv,
  "glGetAttribLocation": _glGetAttribLocation,
  "glGetBufferSubData": _glGetBufferSubData,
  "glGetError": _glGetError,
  "glGetFramebufferAttachmentParameteriv": _glGetFramebufferAttachmentParameteriv,
  "glGetIntegeri_v": _glGetIntegeri_v,
  "glGetIntegerv": _glGetIntegerv,
  "glGetInternalformativ": _glGetInternalformativ,
  "glGetProgramBinary": _glGetProgramBinary,
  "glGetProgramInfoLog": _glGetProgramInfoLog,
  "glGetProgramiv": _glGetProgramiv,
  "glGetQueryObjectuiv": _glGetQueryObjectuiv,
  "glGetQueryiv": _glGetQueryiv,
  "glGetRenderbufferParameteriv": _glGetRenderbufferParameteriv,
  "glGetShaderInfoLog": _glGetShaderInfoLog,
  "glGetShaderPrecisionFormat": _glGetShaderPrecisionFormat,
  "glGetShaderSource": _glGetShaderSource,
  "glGetShaderiv": _glGetShaderiv,
  "glGetString": _glGetString,
  "glGetStringi": _glGetStringi,
  "glGetTexParameteriv": _glGetTexParameteriv,
  "glGetUniformBlockIndex": _glGetUniformBlockIndex,
  "glGetUniformIndices": _glGetUniformIndices,
  "glGetUniformLocation": _glGetUniformLocation,
  "glGetUniformiv": _glGetUniformiv,
  "glGetVertexAttribiv": _glGetVertexAttribiv,
  "glInvalidateFramebuffer": _glInvalidateFramebuffer,
  "glIsEnabled": _glIsEnabled,
  "glIsVertexArray": _glIsVertexArray,
  "glLinkProgram": _glLinkProgram,
  "glMapBufferRange": _glMapBufferRange,
  "glPixelStorei": _glPixelStorei,
  "glPolygonOffset": _glPolygonOffset,
  "glProgramBinary": _glProgramBinary,
  "glProgramParameteri": _glProgramParameteri,
  "glReadBuffer": _glReadBuffer,
  "glReadPixels": _glReadPixels,
  "glRenderbufferStorage": _glRenderbufferStorage,
  "glRenderbufferStorageMultisample": _glRenderbufferStorageMultisample,
  "glSamplerParameteri": _glSamplerParameteri,
  "glScissor": _glScissor,
  "glShaderSource": _glShaderSource,
  "glStencilFuncSeparate": _glStencilFuncSeparate,
  "glStencilMask": _glStencilMask,
  "glStencilOpSeparate": _glStencilOpSeparate,
  "glTexImage2D": _glTexImage2D,
  "glTexImage3D": _glTexImage3D,
  "glTexParameterf": _glTexParameterf,
  "glTexParameteri": _glTexParameteri,
  "glTexParameteriv": _glTexParameteriv,
  "glTexStorage2D": _glTexStorage2D,
  "glTexStorage3D": _glTexStorage3D,
  "glTexSubImage2D": _glTexSubImage2D,
  "glTexSubImage3D": _glTexSubImage3D,
  "glUniform1fv": _glUniform1fv,
  "glUniform1i": _glUniform1i,
  "glUniform1iv": _glUniform1iv,
  "glUniform1uiv": _glUniform1uiv,
  "glUniform2fv": _glUniform2fv,
  "glUniform2iv": _glUniform2iv,
  "glUniform2uiv": _glUniform2uiv,
  "glUniform3fv": _glUniform3fv,
  "glUniform3iv": _glUniform3iv,
  "glUniform3uiv": _glUniform3uiv,
  "glUniform4fv": _glUniform4fv,
  "glUniform4iv": _glUniform4iv,
  "glUniform4uiv": _glUniform4uiv,
  "glUniformBlockBinding": _glUniformBlockBinding,
  "glUniformMatrix3fv": _glUniformMatrix3fv,
  "glUniformMatrix4fv": _glUniformMatrix4fv,
  "glUnmapBuffer": _glUnmapBuffer,
  "glUseProgram": _glUseProgram,
  "glValidateProgram": _glValidateProgram,
  "glVertexAttrib4f": _glVertexAttrib4f,
  "glVertexAttrib4fv": _glVertexAttrib4fv,
  "glVertexAttribIPointer": _glVertexAttribIPointer,
  "glVertexAttribPointer": _glVertexAttribPointer,
  "glViewport": _glViewport,
  "invoke_ddiii": invoke_ddiii,
  "invoke_dii": invoke_dii,
  "invoke_diii": invoke_diii,
  "invoke_fffi": invoke_fffi,
  "invoke_fi": invoke_fi,
  "invoke_fii": invoke_fii,
  "invoke_fiii": invoke_fiii,
  "invoke_i": invoke_i,
  "invoke_idi": invoke_idi,
  "invoke_ii": invoke_ii,
  "invoke_iifi": invoke_iifi,
  "invoke_iii": invoke_iii,
  "invoke_iiifi": invoke_iiifi,
  "invoke_iiifii": invoke_iiifii,
  "invoke_iiii": invoke_iiii,
  "invoke_iiiidii": invoke_iiiidii,
  "invoke_iiiii": invoke_iiiii,
  "invoke_iiiiii": invoke_iiiiii,
  "invoke_iiiiiii": invoke_iiiiiii,
  "invoke_iiiiiiii": invoke_iiiiiiii,
  "invoke_iiiiiiiii": invoke_iiiiiiiii,
  "invoke_iiiiiiiiii": invoke_iiiiiiiiii,
  "invoke_iiiiiiiiiii": invoke_iiiiiiiiiii,
  "invoke_iiiiiiiiiiii": invoke_iiiiiiiiiiii,
  "invoke_iiiiiiiiiji": invoke_iiiiiiiiiji,
  "invoke_iiiijii": invoke_iiiijii,
  "invoke_iiijii": invoke_iiijii,
  "invoke_iiijiii": invoke_iiijiii,
  "invoke_iij": invoke_iij,
  "invoke_iiji": invoke_iiji,
  "invoke_iijii": invoke_iijii,
  "invoke_iijiii": invoke_iijiii,
  "invoke_iijji": invoke_iijji,
  "invoke_iji": invoke_iji,
  "invoke_ijji": invoke_ijji,
  "invoke_j": invoke_j,
  "invoke_ji": invoke_ji,
  "invoke_jii": invoke_jii,
  "invoke_jiii": invoke_jiii,
  "invoke_jiiiii": invoke_jiiiii,
  "invoke_jiiiiiiiiii": invoke_jiiiiiiiiii,
  "invoke_jiji": invoke_jiji,
  "invoke_jijii": invoke_jijii,
  "invoke_jjji": invoke_jjji,
  "invoke_v": invoke_v,
  "invoke_vi": invoke_vi,
  "invoke_vidi": invoke_vidi,
  "invoke_viffi": invoke_viffi,
  "invoke_vifi": invoke_vifi,
  "invoke_vifii": invoke_vifii,
  "invoke_vii": invoke_vii,
  "invoke_viidi": invoke_viidi,
  "invoke_viiffi": invoke_viiffi,
  "invoke_viifi": invoke_viifi,
  "invoke_viifii": invoke_viifii,
  "invoke_viii": invoke_viii,
  "invoke_viiii": invoke_viiii,
  "invoke_viiiifi": invoke_viiiifi,
  "invoke_viiiii": invoke_viiiii,
  "invoke_viiiiii": invoke_viiiiii,
  "invoke_viiiiiii": invoke_viiiiiii,
  "invoke_viiiiiiii": invoke_viiiiiiii,
  "invoke_viiiiiiiii": invoke_viiiiiiiii,
  "invoke_viiiiiiiiii": invoke_viiiiiiiiii,
  "invoke_viiiji": invoke_viiiji,
  "invoke_viiji": invoke_viiji,
  "invoke_viji": invoke_viji,
  "invoke_vijii": invoke_vijii,
  "invoke_vijiii": invoke_vijiii,
  "invoke_vji": invoke_vji,
  "invoke_vjiiiii": invoke_vjiiiii,
  "invoke_vjjjiiii": invoke_vjjjiiii,
  "llvm_eh_typeid_for": _llvm_eh_typeid_for,
  "setTempRet0": _setTempRet0,
  "strftime": _strftime
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = createExportWrapper("__wasm_call_ctors");

/** @type {function(...*):?} */
var _ReleaseKeys = Module["_ReleaseKeys"] = createExportWrapper("ReleaseKeys");

/** @type {function(...*):?} */
var _getMemInfo = Module["_getMemInfo"] = createExportWrapper("getMemInfo");

/** @type {function(...*):?} */
var _SendMessageFloat = Module["_SendMessageFloat"] = createExportWrapper("SendMessageFloat");

/** @type {function(...*):?} */
var _SendMessageString = Module["_SendMessageString"] = createExportWrapper("SendMessageString");

/** @type {function(...*):?} */
var _SendMessage = Module["_SendMessage"] = createExportWrapper("SendMessage");

/** @type {function(...*):?} */
var _SetFullscreen = Module["_SetFullscreen"] = createExportWrapper("SetFullscreen");

/** @type {function(...*):?} */
var _main = Module["_main"] = createExportWrapper("main");

/** @type {function(...*):?} */
var _InjectProfilerSample = Module["_InjectProfilerSample"] = createExportWrapper("InjectProfilerSample");

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = createExportWrapper("__errno_location");

/** @type {function(...*):?} */
var ___stdio_exit = Module["___stdio_exit"] = createExportWrapper("__stdio_exit");

/** @type {function(...*):?} */
var ___dl_seterr = Module["___dl_seterr"] = createExportWrapper("__dl_seterr");

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = createExportWrapper("htonl");

/** @type {function(...*):?} */
var _htons = Module["_htons"] = createExportWrapper("htons");

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = createExportWrapper("ntohs");

/** @type {function(...*):?} */
var _strlen = Module["_strlen"] = createExportWrapper("strlen");

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = createExportWrapper("malloc");

/** @type {function(...*):?} */
var _free = Module["_free"] = createExportWrapper("free");

/** @type {function(...*):?} */
var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = createExportWrapper("emscripten_builtin_memalign");

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = createExportWrapper("setThrew");

/** @type {function(...*):?} */
var _saveSetjmp = Module["_saveSetjmp"] = createExportWrapper("saveSetjmp");

/** @type {function(...*):?} */
var _emscripten_stack_init = Module["_emscripten_stack_init"] = function() {
  return (_emscripten_stack_init = Module["_emscripten_stack_init"] = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = function() {
  return (_emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = function() {
  return (_emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = function() {
  return (_emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = createExportWrapper("stackSave");

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = createExportWrapper("stackRestore");

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = createExportWrapper("stackAlloc");

/** @type {function(...*):?} */
var ___cxa_demangle = Module["___cxa_demangle"] = createExportWrapper("__cxa_demangle");

/** @type {function(...*):?} */
var ___cxa_can_catch = Module["___cxa_can_catch"] = createExportWrapper("__cxa_can_catch");

/** @type {function(...*):?} */
var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = createExportWrapper("__cxa_is_pointer_type");

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = createExportWrapper("dynCall_iidiiii");

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = createExportWrapper("dynCall_vii");

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = createExportWrapper("dynCall_iiii");

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = createExportWrapper("dynCall_v");

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = createExportWrapper("dynCall_ii");

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = createExportWrapper("dynCall_vi");

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = createExportWrapper("dynCall_iiiii");

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = createExportWrapper("dynCall_iii");

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = createExportWrapper("dynCall_viii");

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = createExportWrapper("dynCall_viiii");

/** @type {function(...*):?} */
var dynCall_viiiiii = Module["dynCall_viiiiii"] = createExportWrapper("dynCall_viiiiii");

/** @type {function(...*):?} */
var dynCall_viiiii = Module["dynCall_viiiii"] = createExportWrapper("dynCall_viiiii");

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = createExportWrapper("dynCall_iiiiii");

/** @type {function(...*):?} */
var dynCall_i = Module["dynCall_i"] = createExportWrapper("dynCall_i");

/** @type {function(...*):?} */
var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = createExportWrapper("dynCall_iiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiijiii = Module["dynCall_iiijiii"] = createExportWrapper("dynCall_iiijiii");

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij");

/** @type {function(...*):?} */
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = createExportWrapper("dynCall_iiiiiii");

/** @type {function(...*):?} */
var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");

/** @type {function(...*):?} */
var dynCall_viiiiiiii = Module["dynCall_viiiiiiii"] = createExportWrapper("dynCall_viiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiijii = Module["dynCall_iiiijii"] = createExportWrapper("dynCall_iiiijii");

/** @type {function(...*):?} */
var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji");

/** @type {function(...*):?} */
var dynCall_iiijii = Module["dynCall_iiijii"] = createExportWrapper("dynCall_iiijii");

/** @type {function(...*):?} */
var dynCall_iiiidii = Module["dynCall_iiiidii"] = createExportWrapper("dynCall_iiiidii");

/** @type {function(...*):?} */
var dynCall_vidi = Module["dynCall_vidi"] = createExportWrapper("dynCall_vidi");

/** @type {function(...*):?} */
var dynCall_viidi = Module["dynCall_viidi"] = createExportWrapper("dynCall_viidi");

/** @type {function(...*):?} */
var dynCall_iifi = Module["dynCall_iifi"] = createExportWrapper("dynCall_iifi");

/** @type {function(...*):?} */
var dynCall_fiii = Module["dynCall_fiii"] = createExportWrapper("dynCall_fiii");

/** @type {function(...*):?} */
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = createExportWrapper("dynCall_viiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiifii = Module["dynCall_iiiifii"] = createExportWrapper("dynCall_iiiifii");

/** @type {function(...*):?} */
var dynCall_iiifii = Module["dynCall_iiifii"] = createExportWrapper("dynCall_iiifii");

/** @type {function(...*):?} */
var dynCall_viiiifii = Module["dynCall_viiiifii"] = createExportWrapper("dynCall_viiiifii");

/** @type {function(...*):?} */
var dynCall_viifi = Module["dynCall_viifi"] = createExportWrapper("dynCall_viifi");

/** @type {function(...*):?} */
var dynCall_vijii = Module["dynCall_vijii"] = createExportWrapper("dynCall_vijii");

/** @type {function(...*):?} */
var dynCall_iijiii = Module["dynCall_iijiii"] = createExportWrapper("dynCall_iijiii");

/** @type {function(...*):?} */
var dynCall_viiffi = Module["dynCall_viiffi"] = createExportWrapper("dynCall_viiffi");

/** @type {function(...*):?} */
var dynCall_fffi = Module["dynCall_fffi"] = createExportWrapper("dynCall_fffi");

/** @type {function(...*):?} */
var dynCall_viifii = Module["dynCall_viifii"] = createExportWrapper("dynCall_viifii");

/** @type {function(...*):?} */
var dynCall_vifi = Module["dynCall_vifi"] = createExportWrapper("dynCall_vifi");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiiji = Module["dynCall_iiiiiiiiiji"] = createExportWrapper("dynCall_iiiiiiiiiji");

/** @type {function(...*):?} */
var dynCall_vji = Module["dynCall_vji"] = createExportWrapper("dynCall_vji");

/** @type {function(...*):?} */
var dynCall_vifii = Module["dynCall_vifii"] = createExportWrapper("dynCall_vifii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiifi = Module["dynCall_iiiifi"] = createExportWrapper("dynCall_iiiifi");

/** @type {function(...*):?} */
var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");

/** @type {function(...*):?} */
var dynCall_fii = Module["dynCall_fii"] = createExportWrapper("dynCall_fii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiiiii = Module["dynCall_iiiiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_fiiffi = Module["dynCall_fiiffi"] = createExportWrapper("dynCall_fiiffi");

/** @type {function(...*):?} */
var dynCall_viiififii = Module["dynCall_viiififii"] = createExportWrapper("dynCall_viiififii");

/** @type {function(...*):?} */
var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji");

/** @type {function(...*):?} */
var dynCall_didi = Module["dynCall_didi"] = createExportWrapper("dynCall_didi");

/** @type {function(...*):?} */
var dynCall_fifi = Module["dynCall_fifi"] = createExportWrapper("dynCall_fifi");

/** @type {function(...*):?} */
var dynCall_diidi = Module["dynCall_diidi"] = createExportWrapper("dynCall_diidi");

/** @type {function(...*):?} */
var dynCall_jiiji = Module["dynCall_jiiji"] = createExportWrapper("dynCall_jiiji");

/** @type {function(...*):?} */
var dynCall_fiifi = Module["dynCall_fiifi"] = createExportWrapper("dynCall_fiifi");

/** @type {function(...*):?} */
var dynCall_iiffi = Module["dynCall_iiffi"] = createExportWrapper("dynCall_iiffi");

/** @type {function(...*):?} */
var dynCall_iiddi = Module["dynCall_iiddi"] = createExportWrapper("dynCall_iiddi");

/** @type {function(...*):?} */
var dynCall_iijji = Module["dynCall_iijji"] = createExportWrapper("dynCall_iijji");

/** @type {function(...*):?} */
var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiii");

/** @type {function(...*):?} */
var dynCall_ddiii = Module["dynCall_ddiii"] = createExportWrapper("dynCall_ddiii");

/** @type {function(...*):?} */
var dynCall_fi = Module["dynCall_fi"] = createExportWrapper("dynCall_fi");

/** @type {function(...*):?} */
var dynCall_iiifi = Module["dynCall_iiifi"] = createExportWrapper("dynCall_iiifi");

/** @type {function(...*):?} */
var dynCall_viiiifi = Module["dynCall_viiiifi"] = createExportWrapper("dynCall_viiiifi");

/** @type {function(...*):?} */
var dynCall_dii = Module["dynCall_dii"] = createExportWrapper("dynCall_dii");

/** @type {function(...*):?} */
var dynCall_idi = Module["dynCall_idi"] = createExportWrapper("dynCall_idi");

/** @type {function(...*):?} */
var dynCall_jiiijii = Module["dynCall_jiiijii"] = createExportWrapper("dynCall_jiiijii");

/** @type {function(...*):?} */
var dynCall_viiijiii = Module["dynCall_viiijiii"] = createExportWrapper("dynCall_viiijiii");

/** @type {function(...*):?} */
var dynCall_iidi = Module["dynCall_iidi"] = createExportWrapper("dynCall_iidi");

/** @type {function(...*):?} */
var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");

/** @type {function(...*):?} */
var dynCall_ijji = Module["dynCall_ijji"] = createExportWrapper("dynCall_ijji");

/** @type {function(...*):?} */
var dynCall_j = Module["dynCall_j"] = createExportWrapper("dynCall_j");

/** @type {function(...*):?} */
var dynCall_iijii = Module["dynCall_iijii"] = createExportWrapper("dynCall_iijii");

/** @type {function(...*):?} */
var dynCall_iji = Module["dynCall_iji"] = createExportWrapper("dynCall_iji");

/** @type {function(...*):?} */
var dynCall_jjji = Module["dynCall_jjji"] = createExportWrapper("dynCall_jjji");

/** @type {function(...*):?} */
var dynCall_jiiiii = Module["dynCall_jiiiii"] = createExportWrapper("dynCall_jiiiii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiii");

/** @type {function(...*):?} */
var dynCall_jijii = Module["dynCall_jijii"] = createExportWrapper("dynCall_jijii");

/** @type {function(...*):?} */
var dynCall_vijiii = Module["dynCall_vijiii"] = createExportWrapper("dynCall_vijiii");

/** @type {function(...*):?} */
var dynCall_vjjjiiii = Module["dynCall_vjjjiiii"] = createExportWrapper("dynCall_vjjjiiii");

/** @type {function(...*):?} */
var dynCall_vjiiiii = Module["dynCall_vjiiiii"] = createExportWrapper("dynCall_vjiiiii");

/** @type {function(...*):?} */
var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");

/** @type {function(...*):?} */
var dynCall_fiiii = Module["dynCall_fiiii"] = createExportWrapper("dynCall_fiiii");

/** @type {function(...*):?} */
var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");

/** @type {function(...*):?} */
var dynCall_ifi = Module["dynCall_ifi"] = createExportWrapper("dynCall_ifi");

/** @type {function(...*):?} */
var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiiiiii = Module["dynCall_viiiiiiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiii = Module["dynCall_viiiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiiii = Module["dynCall_iiiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiji = Module["dynCall_iiiiji"] = createExportWrapper("dynCall_iiiiji");

/** @type {function(...*):?} */
var dynCall_viiijii = Module["dynCall_viiijii"] = createExportWrapper("dynCall_viiijii");

/** @type {function(...*):?} */
var dynCall_ijjiii = Module["dynCall_ijjiii"] = createExportWrapper("dynCall_ijjiii");

/** @type {function(...*):?} */
var dynCall_ijiiii = Module["dynCall_ijiiii"] = createExportWrapper("dynCall_ijiiii");

/** @type {function(...*):?} */
var dynCall_ijiii = Module["dynCall_ijiii"] = createExportWrapper("dynCall_ijiii");

/** @type {function(...*):?} */
var dynCall_diiiii = Module["dynCall_diiiii"] = createExportWrapper("dynCall_diiiii");

/** @type {function(...*):?} */
var dynCall_vijji = Module["dynCall_vijji"] = createExportWrapper("dynCall_vijji");

/** @type {function(...*):?} */
var dynCall_viffffi = Module["dynCall_viffffi"] = createExportWrapper("dynCall_viffffi");

/** @type {function(...*):?} */
var dynCall_vfffi = Module["dynCall_vfffi"] = createExportWrapper("dynCall_vfffi");

/** @type {function(...*):?} */
var dynCall_vffi = Module["dynCall_vffi"] = createExportWrapper("dynCall_vffi");

/** @type {function(...*):?} */
var dynCall_vffffi = Module["dynCall_vffffi"] = createExportWrapper("dynCall_vffffi");

/** @type {function(...*):?} */
var dynCall_viiifi = Module["dynCall_viiifi"] = createExportWrapper("dynCall_viiifi");

/** @type {function(...*):?} */
var dynCall_viiiiffi = Module["dynCall_viiiiffi"] = createExportWrapper("dynCall_viiiiffi");

/** @type {function(...*):?} */
var dynCall_viiiffii = Module["dynCall_viiiffii"] = createExportWrapper("dynCall_viiiffii");

/** @type {function(...*):?} */
var dynCall_vifffi = Module["dynCall_vifffi"] = createExportWrapper("dynCall_vifffi");

/** @type {function(...*):?} */
var dynCall_viffi = Module["dynCall_viffi"] = createExportWrapper("dynCall_viffi");

/** @type {function(...*):?} */
var dynCall_vfiii = Module["dynCall_vfiii"] = createExportWrapper("dynCall_vfiii");

/** @type {function(...*):?} */
var dynCall_ffi = Module["dynCall_ffi"] = createExportWrapper("dynCall_ffi");

/** @type {function(...*):?} */
var dynCall_ffffi = Module["dynCall_ffffi"] = createExportWrapper("dynCall_ffffi");

/** @type {function(...*):?} */
var dynCall_iffi = Module["dynCall_iffi"] = createExportWrapper("dynCall_iffi");

/** @type {function(...*):?} */
var dynCall_fffifffi = Module["dynCall_fffifffi"] = createExportWrapper("dynCall_fffifffi");

/** @type {function(...*):?} */
var dynCall_fdi = Module["dynCall_fdi"] = createExportWrapper("dynCall_fdi");

/** @type {function(...*):?} */
var dynCall_dddi = Module["dynCall_dddi"] = createExportWrapper("dynCall_dddi");

/** @type {function(...*):?} */
var dynCall_ddi = Module["dynCall_ddi"] = createExportWrapper("dynCall_ddi");

/** @type {function(...*):?} */
var dynCall_vfii = Module["dynCall_vfii"] = createExportWrapper("dynCall_vfii");

/** @type {function(...*):?} */
var dynCall_ddddi = Module["dynCall_ddddi"] = createExportWrapper("dynCall_ddddi");

/** @type {function(...*):?} */
var dynCall_jji = Module["dynCall_jji"] = createExportWrapper("dynCall_jji");

/** @type {function(...*):?} */
var dynCall_jjjji = Module["dynCall_jjjji"] = createExportWrapper("dynCall_jjjji");

/** @type {function(...*):?} */
var dynCall_vjiiii = Module["dynCall_vjiiii"] = createExportWrapper("dynCall_vjiiii");

/** @type {function(...*):?} */
var dynCall_vijjii = Module["dynCall_vijjii"] = createExportWrapper("dynCall_vijjii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiijijiii = Module["dynCall_viiiiiiiijijiii"] = createExportWrapper("dynCall_viiiiiiiijijiii");

/** @type {function(...*):?} */
var dynCall_viiiiiffii = Module["dynCall_viiiiiffii"] = createExportWrapper("dynCall_viiiiiffii");

/** @type {function(...*):?} */
var dynCall_viffffii = Module["dynCall_viffffii"] = createExportWrapper("dynCall_viffffii");

/** @type {function(...*):?} */
var dynCall_iiiifiii = Module["dynCall_iiiifiii"] = createExportWrapper("dynCall_iiiifiii");

/** @type {function(...*):?} */
var dynCall_iiifiii = Module["dynCall_iiifiii"] = createExportWrapper("dynCall_iiifiii");

/** @type {function(...*):?} */
var dynCall_viiifiii = Module["dynCall_viiifiii"] = createExportWrapper("dynCall_viiifiii");

/** @type {function(...*):?} */
var dynCall_viiifii = Module["dynCall_viiifii"] = createExportWrapper("dynCall_viiifii");

/** @type {function(...*):?} */
var dynCall_viiififi = Module["dynCall_viiififi"] = createExportWrapper("dynCall_viiififi");

/** @type {function(...*):?} */
var dynCall_viiififfi = Module["dynCall_viiififfi"] = createExportWrapper("dynCall_viiififfi");

/** @type {function(...*):?} */
var dynCall_iiiiifi = Module["dynCall_iiiiifi"] = createExportWrapper("dynCall_iiiiifi");

/** @type {function(...*):?} */
var dynCall_iifii = Module["dynCall_iifii"] = createExportWrapper("dynCall_iifii");

/** @type {function(...*):?} */
var dynCall_iifiii = Module["dynCall_iifiii"] = createExportWrapper("dynCall_iifiii");

/** @type {function(...*):?} */
var dynCall_iiiiifiii = Module["dynCall_iiiiifiii"] = createExportWrapper("dynCall_iiiiifiii");

/** @type {function(...*):?} */
var dynCall_iiifiiii = Module["dynCall_iiifiiii"] = createExportWrapper("dynCall_iiifiiii");

/** @type {function(...*):?} */
var dynCall_vifffffi = Module["dynCall_vifffffi"] = createExportWrapper("dynCall_vifffffi");

/** @type {function(...*):?} */
var dynCall_viiiiifi = Module["dynCall_viiiiifi"] = createExportWrapper("dynCall_viiiiifi");

/** @type {function(...*):?} */
var dynCall_viffiiii = Module["dynCall_viffiiii"] = createExportWrapper("dynCall_viffiiii");

/** @type {function(...*):?} */
var dynCall_viiiffffiiii = Module["dynCall_viiiffffiiii"] = createExportWrapper("dynCall_viiiffffiiii");

/** @type {function(...*):?} */
var dynCall_viifffffffiiiii = Module["dynCall_viifffffffiiiii"] = createExportWrapper("dynCall_viifffffffiiiii");

/** @type {function(...*):?} */
var dynCall_fiiiii = Module["dynCall_fiiiii"] = createExportWrapper("dynCall_fiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiffiiiiiiiiiffffiiii = Module["dynCall_iiiiiiffiiiiiiiiiffffiiii"] = createExportWrapper("dynCall_iiiiiiffiiiiiiiiiffffiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiffiiiiiiiiiiiiiii = Module["dynCall_iiiiiiffiiiiiiiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiffiiiiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_viffii = Module["dynCall_viffii"] = createExportWrapper("dynCall_viffii");

/** @type {function(...*):?} */
var dynCall_vififiii = Module["dynCall_vififiii"] = createExportWrapper("dynCall_vififiii");

/** @type {function(...*):?} */
var dynCall_viififii = Module["dynCall_viififii"] = createExportWrapper("dynCall_viififii");

/** @type {function(...*):?} */
var dynCall_fiffi = Module["dynCall_fiffi"] = createExportWrapper("dynCall_fiffi");

/** @type {function(...*):?} */
var dynCall_viijji = Module["dynCall_viijji"] = createExportWrapper("dynCall_viijji");

/** @type {function(...*):?} */
var dynCall_diii = Module["dynCall_diii"] = createExportWrapper("dynCall_diii");

/** @type {function(...*):?} */
var dynCall_viiidi = Module["dynCall_viiidi"] = createExportWrapper("dynCall_viiidi");

/** @type {function(...*):?} */
var dynCall_jijji = Module["dynCall_jijji"] = createExportWrapper("dynCall_jijji");

/** @type {function(...*):?} */
var dynCall_viiffffi = Module["dynCall_viiffffi"] = createExportWrapper("dynCall_viiffffi");

/** @type {function(...*):?} */
var dynCall_fifffi = Module["dynCall_fifffi"] = createExportWrapper("dynCall_fifffi");

/** @type {function(...*):?} */
var dynCall_ifffi = Module["dynCall_ifffi"] = createExportWrapper("dynCall_ifffi");

/** @type {function(...*):?} */
var dynCall_fiifii = Module["dynCall_fiifii"] = createExportWrapper("dynCall_fiifii");

/** @type {function(...*):?} */
var dynCall_fiifiii = Module["dynCall_fiifiii"] = createExportWrapper("dynCall_fiifiii");

/** @type {function(...*):?} */
var dynCall_viffiii = Module["dynCall_viffiii"] = createExportWrapper("dynCall_viffiii");

/** @type {function(...*):?} */
var dynCall_viffifi = Module["dynCall_viffifi"] = createExportWrapper("dynCall_viffifi");

/** @type {function(...*):?} */
var dynCall_fiffffi = Module["dynCall_fiffffi"] = createExportWrapper("dynCall_fiffffi");

/** @type {function(...*):?} */
var dynCall_fffffffi = Module["dynCall_fffffffi"] = createExportWrapper("dynCall_fffffffi");

/** @type {function(...*):?} */
var dynCall_viiffifi = Module["dynCall_viiffifi"] = createExportWrapper("dynCall_viiffifi");

/** @type {function(...*):?} */
var dynCall_viiiffiiiiiiiii = Module["dynCall_viiiffiiiiiiiii"] = createExportWrapper("dynCall_viiiffiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_viiiffiiiiii = Module["dynCall_viiiffiiiiii"] = createExportWrapper("dynCall_viiiffiiiiii");

/** @type {function(...*):?} */
var dynCall_viiffiiiiiiiiii = Module["dynCall_viiffiiiiiiiiii"] = createExportWrapper("dynCall_viiffiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_viiffiiiiiii = Module["dynCall_viiffiiiiiii"] = createExportWrapper("dynCall_viiffiiiiiii");

/** @type {function(...*):?} */
var dynCall_viffffffi = Module["dynCall_viffffffi"] = createExportWrapper("dynCall_viffffffi");

/** @type {function(...*):?} */
var dynCall_iiiffiiii = Module["dynCall_iiiffiiii"] = createExportWrapper("dynCall_iiiffiiii");

/** @type {function(...*):?} */
var dynCall_fffffi = Module["dynCall_fffffi"] = createExportWrapper("dynCall_fffffi");

/** @type {function(...*):?} */
var dynCall_iiiiffiiii = Module["dynCall_iiiiffiiii"] = createExportWrapper("dynCall_iiiiffiiii");

/** @type {function(...*):?} */
var dynCall_fiiiffi = Module["dynCall_fiiiffi"] = createExportWrapper("dynCall_fiiiffi");

/** @type {function(...*):?} */
var dynCall_diiii = Module["dynCall_diiii"] = createExportWrapper("dynCall_diiii");

/** @type {function(...*):?} */
var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");

/** @type {function(...*):?} */
var dynCall_ijii = Module["dynCall_ijii"] = createExportWrapper("dynCall_ijii");

/** @type {function(...*):?} */
var dynCall_vjii = Module["dynCall_vjii"] = createExportWrapper("dynCall_vjii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiijiiii = Module["dynCall_viiiiiiiijiiii"] = createExportWrapper("dynCall_viiiiiiiijiiii");

/** @type {function(...*):?} */
var dynCall_viiiiiifiiiiii = Module["dynCall_viiiiiifiiiiii"] = createExportWrapper("dynCall_viiiiiifiiiiii");

/** @type {function(...*):?} */
var dynCall_viffffiii = Module["dynCall_viffffiii"] = createExportWrapper("dynCall_viffffiii");

/** @type {function(...*):?} */
var dynCall_viifiii = Module["dynCall_viifiii"] = createExportWrapper("dynCall_viifiii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiiii = Module["dynCall_viiiiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_vifiiiiii = Module["dynCall_vifiiiiii"] = createExportWrapper("dynCall_vifiiiiii");

/** @type {function(...*):?} */
var dynCall_ffii = Module["dynCall_ffii"] = createExportWrapper("dynCall_ffii");

/** @type {function(...*):?} */
var dynCall_viifiiii = Module["dynCall_viifiiii"] = createExportWrapper("dynCall_viifiiii");

/** @type {function(...*):?} */
var dynCall_fifii = Module["dynCall_fifii"] = createExportWrapper("dynCall_fifii");

/** @type {function(...*):?} */
var dynCall_vifffii = Module["dynCall_vifffii"] = createExportWrapper("dynCall_vifffii");

/** @type {function(...*):?} */
var dynCall_viiiffi = Module["dynCall_viiiffi"] = createExportWrapper("dynCall_viiiffi");

/** @type {function(...*):?} */
var dynCall_viiifffi = Module["dynCall_viiifffi"] = createExportWrapper("dynCall_viiifffi");

/** @type {function(...*):?} */
var dynCall_iiiifiiii = Module["dynCall_iiiifiiii"] = createExportWrapper("dynCall_iiiifiiii");

/** @type {function(...*):?} */
var dynCall_viiiiiffi = Module["dynCall_viiiiiffi"] = createExportWrapper("dynCall_viiiiiffi");

/** @type {function(...*):?} */
var dynCall_iifffi = Module["dynCall_iifffi"] = createExportWrapper("dynCall_iifffi");

/** @type {function(...*):?} */
var dynCall_viiidii = Module["dynCall_viiidii"] = createExportWrapper("dynCall_viiidii");

/** @type {function(...*):?} */
var dynCall_ijiiiiiiiii = Module["dynCall_ijiiiiiiiii"] = createExportWrapper("dynCall_ijiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_jjjii = Module["dynCall_jjjii"] = createExportWrapper("dynCall_jjjii");

/** @type {function(...*):?} */
var dynCall_iijjijii = Module["dynCall_iijjijii"] = createExportWrapper("dynCall_iijjijii");

/** @type {function(...*):?} */
var dynCall_viiiijii = Module["dynCall_viiiijii"] = createExportWrapper("dynCall_viiiijii");

/** @type {function(...*):?} */
var dynCall_jiijii = Module["dynCall_jiijii"] = createExportWrapper("dynCall_jiijii");

/** @type {function(...*):?} */
var dynCall_viijiii = Module["dynCall_viijiii"] = createExportWrapper("dynCall_viijiii");

/** @type {function(...*):?} */
var dynCall_jjii = Module["dynCall_jjii"] = createExportWrapper("dynCall_jjii");

/** @type {function(...*):?} */
var dynCall_viffffffffffffffffi = Module["dynCall_viffffffffffffffffi"] = createExportWrapper("dynCall_viffffffffffffffffi");

/** @type {function(...*):?} */
var dynCall_viiiifiii = Module["dynCall_viiiifiii"] = createExportWrapper("dynCall_viiiifiii");

/** @type {function(...*):?} */
var dynCall_viifffi = Module["dynCall_viifffi"] = createExportWrapper("dynCall_viifffi");

/** @type {function(...*):?} */
var dynCall_viifffffi = Module["dynCall_viifffffi"] = createExportWrapper("dynCall_viifffffi");

/** @type {function(...*):?} */
var dynCall_viiffffffi = Module["dynCall_viiffffffi"] = createExportWrapper("dynCall_viiffffffi");

/** @type {function(...*):?} */
var dynCall_viifffffffi = Module["dynCall_viifffffffi"] = createExportWrapper("dynCall_viifffffffi");

/** @type {function(...*):?} */
var dynCall_viiffffffffi = Module["dynCall_viiffffffffi"] = createExportWrapper("dynCall_viiffffffffi");

/** @type {function(...*):?} */
var dynCall_vifiiii = Module["dynCall_vifiiii"] = createExportWrapper("dynCall_vifiiii");

/** @type {function(...*):?} */
var dynCall_vidiii = Module["dynCall_vidiii"] = createExportWrapper("dynCall_vidiii");

/** @type {function(...*):?} */
var dynCall_viiffffffffiii = Module["dynCall_viiffffffffiii"] = createExportWrapper("dynCall_viiffffffffiii");

/** @type {function(...*):?} */
var dynCall_viiiiffffii = Module["dynCall_viiiiffffii"] = createExportWrapper("dynCall_viiiiffffii");

/** @type {function(...*):?} */
var dynCall_fiiiiii = Module["dynCall_fiiiiii"] = createExportWrapper("dynCall_fiiiiii");

/** @type {function(...*):?} */
var dynCall_idiiii = Module["dynCall_idiiii"] = createExportWrapper("dynCall_idiiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiii"] = createExportWrapper("dynCall_iiiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_vijiiiiiii = Module["dynCall_vijiiiiiii"] = createExportWrapper("dynCall_vijiiiiiii");

/** @type {function(...*):?} */
var dynCall_vijiiiiiiii = Module["dynCall_vijiiiiiiii"] = createExportWrapper("dynCall_vijiiiiiiii");

/** @type {function(...*):?} */
var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");

/** @type {function(...*):?} */
var dynCall_jjiiii = Module["dynCall_jjiiii"] = createExportWrapper("dynCall_jjiiii");

/** @type {function(...*):?} */
var dynCall_jjiiiii = Module["dynCall_jjiiiii"] = createExportWrapper("dynCall_jjiiiii");

/** @type {function(...*):?} */
var dynCall_viijiiiiii = Module["dynCall_viijiiiiii"] = createExportWrapper("dynCall_viijiiiiii");

/** @type {function(...*):?} */
var dynCall_iijiiiiii = Module["dynCall_iijiiiiii"] = createExportWrapper("dynCall_iijiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiijjii = Module["dynCall_iiiijjii"] = createExportWrapper("dynCall_iiiijjii");

/** @type {function(...*):?} */
var dynCall_jijjji = Module["dynCall_jijjji"] = createExportWrapper("dynCall_jijjji");

/** @type {function(...*):?} */
var dynCall_jijjjii = Module["dynCall_jijjjii"] = createExportWrapper("dynCall_jijjjii");

/** @type {function(...*):?} */
var dynCall_jjiii = Module["dynCall_jjiii"] = createExportWrapper("dynCall_jjiii");

/** @type {function(...*):?} */
var dynCall_ijijiiiii = Module["dynCall_ijijiiiii"] = createExportWrapper("dynCall_ijijiiiii");

/** @type {function(...*):?} */
var dynCall_ijjjiii = Module["dynCall_ijjjiii"] = createExportWrapper("dynCall_ijjjiii");

/** @type {function(...*):?} */
var dynCall_vijjjiijii = Module["dynCall_vijjjiijii"] = createExportWrapper("dynCall_vijjjiijii");

/** @type {function(...*):?} */
var dynCall_ijjjiijii = Module["dynCall_ijjjiijii"] = createExportWrapper("dynCall_ijjjiijii");

/** @type {function(...*):?} */
var dynCall_vijiiiiii = Module["dynCall_vijiiiiii"] = createExportWrapper("dynCall_vijiiiiii");

/** @type {function(...*):?} */
var dynCall_vijiiii = Module["dynCall_vijiiii"] = createExportWrapper("dynCall_vijiiii");

/** @type {function(...*):?} */
var dynCall_jdi = Module["dynCall_jdi"] = createExportWrapper("dynCall_jdi");

/** @type {function(...*):?} */
var dynCall_jfi = Module["dynCall_jfi"] = createExportWrapper("dynCall_jfi");

/** @type {function(...*):?} */
var dynCall_fji = Module["dynCall_fji"] = createExportWrapper("dynCall_fji");

/** @type {function(...*):?} */
var dynCall_dji = Module["dynCall_dji"] = createExportWrapper("dynCall_dji");

/** @type {function(...*):?} */
var dynCall_dfi = Module["dynCall_dfi"] = createExportWrapper("dynCall_dfi");

/** @type {function(...*):?} */
var dynCall_jidii = Module["dynCall_jidii"] = createExportWrapper("dynCall_jidii");

/** @type {function(...*):?} */
var dynCall_jidi = Module["dynCall_jidi"] = createExportWrapper("dynCall_jidi");

/** @type {function(...*):?} */
var dynCall_ijiijii = Module["dynCall_ijiijii"] = createExportWrapper("dynCall_ijiijii");

/** @type {function(...*):?} */
var dynCall_vjjiiiii = Module["dynCall_vjjiiiii"] = createExportWrapper("dynCall_vjjiiiii");

/** @type {function(...*):?} */
var dynCall_vjjii = Module["dynCall_vjjii"] = createExportWrapper("dynCall_vjjii");

/** @type {function(...*):?} */
var dynCall_ijiiji = Module["dynCall_ijiiji"] = createExportWrapper("dynCall_ijiiji");

/** @type {function(...*):?} */
var dynCall_ijiiiii = Module["dynCall_ijiiiii"] = createExportWrapper("dynCall_ijiiiii");

/** @type {function(...*):?} */
var dynCall_ijiiiiji = Module["dynCall_ijiiiiji"] = createExportWrapper("dynCall_ijiiiiji");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiiiii = Module["dynCall_viiiiiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_ddii = Module["dynCall_ddii"] = createExportWrapper("dynCall_ddii");

/** @type {function(...*):?} */
var dynCall_idiii = Module["dynCall_idiii"] = createExportWrapper("dynCall_idiii");

/** @type {function(...*):?} */
var dynCall_idiiiii = Module["dynCall_idiiiii"] = createExportWrapper("dynCall_idiiiii");

/** @type {function(...*):?} */
var dynCall_iidiii = Module["dynCall_iidiii"] = createExportWrapper("dynCall_iidiii");

/** @type {function(...*):?} */
var dynCall_ifiii = Module["dynCall_ifiii"] = createExportWrapper("dynCall_ifiii");

/** @type {function(...*):?} */
var dynCall_ifiiiii = Module["dynCall_ifiiiii"] = createExportWrapper("dynCall_ifiiiii");

/** @type {function(...*):?} */
var dynCall_vdiii = Module["dynCall_vdiii"] = createExportWrapper("dynCall_vdiii");

/** @type {function(...*):?} */
var dynCall_jdii = Module["dynCall_jdii"] = createExportWrapper("dynCall_jdii");

/** @type {function(...*):?} */
var dynCall_vijijji = Module["dynCall_vijijji"] = createExportWrapper("dynCall_vijijji");

/** @type {function(...*):?} */
var dynCall_iijjji = Module["dynCall_iijjji"] = createExportWrapper("dynCall_iijjji");

/** @type {function(...*):?} */
var dynCall_viijjji = Module["dynCall_viijjji"] = createExportWrapper("dynCall_viijjji");

/** @type {function(...*):?} */
var dynCall_vdii = Module["dynCall_vdii"] = createExportWrapper("dynCall_vdii");

/** @type {function(...*):?} */
var dynCall_diddi = Module["dynCall_diddi"] = createExportWrapper("dynCall_diddi");

/** @type {function(...*):?} */
var dynCall_viiijji = Module["dynCall_viiijji"] = createExportWrapper("dynCall_viiijji");

/** @type {function(...*):?} */
var dynCall_iijjii = Module["dynCall_iijjii"] = createExportWrapper("dynCall_iijjii");

/** @type {function(...*):?} */
var dynCall_viijijii = Module["dynCall_viijijii"] = createExportWrapper("dynCall_viijijii");

/** @type {function(...*):?} */
var dynCall_viijijiii = Module["dynCall_viijijiii"] = createExportWrapper("dynCall_viijijiii");

/** @type {function(...*):?} */
var dynCall_vijiji = Module["dynCall_vijiji"] = createExportWrapper("dynCall_vijiji");

/** @type {function(...*):?} */
var dynCall_viijiijiii = Module["dynCall_viijiijiii"] = createExportWrapper("dynCall_viijiijiii");

/** @type {function(...*):?} */
var dynCall_viiiijiiii = Module["dynCall_viiiijiiii"] = createExportWrapper("dynCall_viiiijiiii");

/** @type {function(...*):?} */
var dynCall_jiiiiii = Module["dynCall_jiiiiii"] = createExportWrapper("dynCall_jiiiiii");

/** @type {function(...*):?} */
var dynCall_di = Module["dynCall_di"] = createExportWrapper("dynCall_di");

/** @type {function(...*):?} */
var dynCall_viijjii = Module["dynCall_viijjii"] = createExportWrapper("dynCall_viijjii");

/** @type {function(...*):?} */
var dynCall_vijjji = Module["dynCall_vijjji"] = createExportWrapper("dynCall_vijjji");

/** @type {function(...*):?} */
var dynCall_jiiiiiiiiii = Module["dynCall_jiiiiiiiiii"] = createExportWrapper("dynCall_jiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiidii = Module["dynCall_iiiiidii"] = createExportWrapper("dynCall_iiiiidii");

/** @type {function(...*):?} */
var dynCall_iiiiijii = Module["dynCall_iiiiijii"] = createExportWrapper("dynCall_iiiiijii");

/** @type {function(...*):?} */
var dynCall_iddi = Module["dynCall_iddi"] = createExportWrapper("dynCall_iddi");

/** @type {function(...*):?} */
var dynCall_iiidiii = Module["dynCall_iiidiii"] = createExportWrapper("dynCall_iiidiii");

/** @type {function(...*):?} */
var dynCall_iidii = Module["dynCall_iidii"] = createExportWrapper("dynCall_iidii");

/** @type {function(...*):?} */
var dynCall_viifffiii = Module["dynCall_viifffiii"] = createExportWrapper("dynCall_viifffiii");

/** @type {function(...*):?} */
var dynCall_iiiiffiiiji = Module["dynCall_iiiiffiiiji"] = createExportWrapper("dynCall_iiiiffiiiji");

/** @type {function(...*):?} */
var dynCall_iiiiffiiiii = Module["dynCall_iiiiffiiiii"] = createExportWrapper("dynCall_iiiiffiiiii");

/** @type {function(...*):?} */
var dynCall_diiiidi = Module["dynCall_diiiidi"] = createExportWrapper("dynCall_diiiidi");

/** @type {function(...*):?} */
var dynCall_jiiiiji = Module["dynCall_jiiiiji"] = createExportWrapper("dynCall_jiiiiji");

/** @type {function(...*):?} */
var dynCall_fiiiifi = Module["dynCall_fiiiifi"] = createExportWrapper("dynCall_fiiiifi");

/** @type {function(...*):?} */
var dynCall_iiidi = Module["dynCall_iiidi"] = createExportWrapper("dynCall_iiidi");

/** @type {function(...*):?} */
var dynCall_vdi = Module["dynCall_vdi"] = createExportWrapper("dynCall_vdi");

/** @type {function(...*):?} */
var dynCall_vfi = Module["dynCall_vfi"] = createExportWrapper("dynCall_vfi");

/** @type {function(...*):?} */
var dynCall_vif = Module["dynCall_vif"] = createExportWrapper("dynCall_vif");

/** @type {function(...*):?} */
var dynCall_viif = Module["dynCall_viif"] = createExportWrapper("dynCall_viif");

/** @type {function(...*):?} */
var dynCall_ijj = Module["dynCall_ijj"] = createExportWrapper("dynCall_ijj");

/** @type {function(...*):?} */
var dynCall_vjji = Module["dynCall_vjji"] = createExportWrapper("dynCall_vjji");

/** @type {function(...*):?} */
var dynCall_fff = Module["dynCall_fff"] = createExportWrapper("dynCall_fff");

/** @type {function(...*):?} */
var dynCall_vjiiiiiii = Module["dynCall_vjiiiiiii"] = createExportWrapper("dynCall_vjiiiiiii");

/** @type {function(...*):?} */
var dynCall_vid = Module["dynCall_vid"] = createExportWrapper("dynCall_vid");

/** @type {function(...*):?} */
var dynCall_viijj = Module["dynCall_viijj"] = createExportWrapper("dynCall_viijj");

/** @type {function(...*):?} */
var dynCall_viffff = Module["dynCall_viffff"] = createExportWrapper("dynCall_viffff");

/** @type {function(...*):?} */
var dynCall_viiiiif = Module["dynCall_viiiiif"] = createExportWrapper("dynCall_viiiiif");

/** @type {function(...*):?} */
var dynCall_viiiif = Module["dynCall_viiiif"] = createExportWrapper("dynCall_viiiif");

/** @type {function(...*):?} */
var dynCall_viiiiiif = Module["dynCall_viiiiiif"] = createExportWrapper("dynCall_viiiiiif");

/** @type {function(...*):?} */
var dynCall_iiiijiii = Module["dynCall_iiiijiii"] = createExportWrapper("dynCall_iiiijiii");

/** @type {function(...*):?} */
var dynCall_iiiij = Module["dynCall_iiiij"] = createExportWrapper("dynCall_iiiij");

/** @type {function(...*):?} */
var dynCall_iiif = Module["dynCall_iiif"] = createExportWrapper("dynCall_iiif");

/** @type {function(...*):?} */
var dynCall_fif = Module["dynCall_fif"] = createExportWrapper("dynCall_fif");

/** @type {function(...*):?} */
var dynCall_iiiiiifff = Module["dynCall_iiiiiifff"] = createExportWrapper("dynCall_iiiiiifff");

/** @type {function(...*):?} */
var dynCall_iiiiiifiif = Module["dynCall_iiiiiifiif"] = createExportWrapper("dynCall_iiiiiifiif");

/** @type {function(...*):?} */
var dynCall_iiiiiifiii = Module["dynCall_iiiiiifiii"] = createExportWrapper("dynCall_iiiiiifiii");

/** @type {function(...*):?} */
var dynCall_iiiiiiifiif = Module["dynCall_iiiiiiifiif"] = createExportWrapper("dynCall_iiiiiiifiif");

/** @type {function(...*):?} */
var dynCall_fiff = Module["dynCall_fiff"] = createExportWrapper("dynCall_fiff");

/** @type {function(...*):?} */
var dynCall_fiiiiiifiifif = Module["dynCall_fiiiiiifiifif"] = createExportWrapper("dynCall_fiiiiiifiifif");

/** @type {function(...*):?} */
var dynCall_fiiiiiifiiiif = Module["dynCall_fiiiiiifiiiif"] = createExportWrapper("dynCall_fiiiiiifiiiif");

/** @type {function(...*):?} */
var dynCall_iifiiiijii = Module["dynCall_iifiiiijii"] = createExportWrapper("dynCall_iifiiiijii");

/** @type {function(...*):?} */
var dynCall_vifif = Module["dynCall_vifif"] = createExportWrapper("dynCall_vifif");

/** @type {function(...*):?} */
var dynCall_vifijii = Module["dynCall_vifijii"] = createExportWrapper("dynCall_vifijii");

/** @type {function(...*):?} */
var dynCall_iiiifffiii = Module["dynCall_iiiifffiii"] = createExportWrapper("dynCall_iiiifffiii");

/** @type {function(...*):?} */
var dynCall_iiiifffffi = Module["dynCall_iiiifffffi"] = createExportWrapper("dynCall_iiiifffffi");

/** @type {function(...*):?} */
var dynCall_viffiiiif = Module["dynCall_viffiiiif"] = createExportWrapper("dynCall_viffiiiif");

/** @type {function(...*):?} */
var dynCall_viffiifffffiii = Module["dynCall_viffiifffffiii"] = createExportWrapper("dynCall_viffiifffffiii");

/** @type {function(...*):?} */
var dynCall_viffffiifffiiiiif = Module["dynCall_viffffiifffiiiiif"] = createExportWrapper("dynCall_viffffiifffiiiiif");

/** @type {function(...*):?} */
var dynCall_iiiifffffii = Module["dynCall_iiiifffffii"] = createExportWrapper("dynCall_iiiifffffii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiiifii = Module["dynCall_viiiiiiiiiiifii"] = createExportWrapper("dynCall_viiiiiiiiiiifii");

/** @type {function(...*):?} */
var dynCall_viff = Module["dynCall_viff"] = createExportWrapper("dynCall_viff");

/** @type {function(...*):?} */
var dynCall_iiiifiiiii = Module["dynCall_iiiifiiiii"] = createExportWrapper("dynCall_iiiifiiiii");

/** @type {function(...*):?} */
var dynCall_iiiiifiiiiif = Module["dynCall_iiiiifiiiiif"] = createExportWrapper("dynCall_iiiiifiiiiif");

/** @type {function(...*):?} */
var dynCall_viiff = Module["dynCall_viiff"] = createExportWrapper("dynCall_viiff");

/** @type {function(...*):?} */
var dynCall_viiifiiiii = Module["dynCall_viiifiiiii"] = createExportWrapper("dynCall_viiifiiiii");

/** @type {function(...*):?} */
var dynCall_viiiifiiiiif = Module["dynCall_viiiifiiiiif"] = createExportWrapper("dynCall_viiiifiiiiif");

/** @type {function(...*):?} */
var dynCall_iifff = Module["dynCall_iifff"] = createExportWrapper("dynCall_iifff");

/** @type {function(...*):?} */
var dynCall_iif = Module["dynCall_iif"] = createExportWrapper("dynCall_iif");

/** @type {function(...*):?} */
var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij");

/** @type {function(...*):?} */
var dynCall_viijijj = Module["dynCall_viijijj"] = createExportWrapper("dynCall_viijijj");

/** @type {function(...*):?} */
var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij");

/** @type {function(...*):?} */
var dynCall_iiiiiifffiiifiii = Module["dynCall_iiiiiifffiiifiii"] = createExportWrapper("dynCall_iiiiiifffiiifiii");

/** @type {function(...*):?} */
var dynCall_fiiiif = Module["dynCall_fiiiif"] = createExportWrapper("dynCall_fiiiif");

/** @type {function(...*):?} */
var dynCall_ij = Module["dynCall_ij"] = createExportWrapper("dynCall_ij");

/** @type {function(...*):?} */
var dynCall_vf = Module["dynCall_vf"] = createExportWrapper("dynCall_vf");

/** @type {function(...*):?} */
var dynCall_vffff = Module["dynCall_vffff"] = createExportWrapper("dynCall_vffff");

/** @type {function(...*):?} */
var dynCall_vff = Module["dynCall_vff"] = createExportWrapper("dynCall_vff");

/** @type {function(...*):?} */
var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij");

/** @type {function(...*):?} */
var dynCall_viiiiiji = Module["dynCall_viiiiiji"] = createExportWrapper("dynCall_viiiiiji");

/** @type {function(...*):?} */
var dynCall_viiiiiiiiiiiiiiiiii = Module["dynCall_viiiiiiiiiiiiiiiiii"] = createExportWrapper("dynCall_viiiiiiiiiiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_vifff = Module["dynCall_vifff"] = createExportWrapper("dynCall_vifff");

/** @type {function(...*):?} */
var dynCall_viifff = Module["dynCall_viifff"] = createExportWrapper("dynCall_viifff");

/** @type {function(...*):?} */
var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");

/** @type {function(...*):?} */
var dynCall_vfff = Module["dynCall_vfff"] = createExportWrapper("dynCall_vfff");

/** @type {function(...*):?} */
var dynCall_f = Module["dynCall_f"] = createExportWrapper("dynCall_f");

/** @type {function(...*):?} */
var dynCall_viiif = Module["dynCall_viiif"] = createExportWrapper("dynCall_viiif");

/** @type {function(...*):?} */
var dynCall_ff = Module["dynCall_ff"] = createExportWrapper("dynCall_ff");

/** @type {function(...*):?} */
var dynCall_iiiiiiffiiiiiiiiiffffiii = Module["dynCall_iiiiiiffiiiiiiiiiffffiii"] = createExportWrapper("dynCall_iiiiiiffiiiiiiiiiffffiii");

/** @type {function(...*):?} */
var dynCall_viififi = Module["dynCall_viififi"] = createExportWrapper("dynCall_viififi");

/** @type {function(...*):?} */
var dynCall_viiffiiiiiiiii = Module["dynCall_viiffiiiiiiiii"] = createExportWrapper("dynCall_viiffiiiiiiiii");

/** @type {function(...*):?} */
var dynCall_viiffiiiiii = Module["dynCall_viiffiiiiii"] = createExportWrapper("dynCall_viiffiiiiii");

/** @type {function(...*):?} */
var dynCall_viiiiiiiijiii = Module["dynCall_viiiiiiiijiii"] = createExportWrapper("dynCall_viiiiiiiijiii");


function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return dynCall_ii(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    dynCall_vii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_v(index) {
  var sp = stackSave();
  try {
    dynCall_v(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_iii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    dynCall_vi(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_iiiii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_iiii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_iiiiii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_viii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_i(index) {
  var sp = stackSave();
  try {
    return dynCall_i(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viiii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_fiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_fiii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_diii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_diii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    dynCall_viiiiii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    dynCall_viiiii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  var sp = stackSave();
  try {
    dynCall_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ddiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_ddiii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viffi(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viffi(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiidii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return dynCall_iiiidii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vidi(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_vidi(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viidi(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viidi(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_dii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_dii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  var sp = stackSave();
  try {
    dynCall_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iifi(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_iifi(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    dynCall_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vifi(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_vifi(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viifi(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viifi(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiifii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_iiifii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiffi(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    dynCall_viiffi(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_fffi(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_fffi(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viifii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    dynCall_viifii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_fii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_fii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vifii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_vifii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_fi(index,a1) {
  var sp = stackSave();
  try {
    return dynCall_fi(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiifi(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_iiifi(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiifi(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    dynCall_viiiifi(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_idi(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_idi(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    dynCall_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iij(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_iij(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiijiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    return dynCall_iiijiii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ji(index,a1) {
  var sp = stackSave();
  try {
    return dynCall_ji(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_jii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_j(index) {
  var sp = stackSave();
  try {
    return dynCall_j(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iji(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_iji(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jjji(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_jjji(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jijii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_jijii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viji(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viji(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiijii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    return dynCall_iiiijii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiji(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    dynCall_viiji(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiijii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return dynCall_iiijii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiiji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  var sp = stackSave();
  try {
    return dynCall_iiiiiiiiiji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vji(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_vji(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_jiii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vijii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    dynCall_vijii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iijiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return dynCall_iijiii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiji(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    dynCall_viiiji(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  var sp = stackSave();
  try {
    return dynCall_jiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ijji(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_ijji(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiji(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_jiji(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iijji(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return dynCall_iijji(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iijii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_iijii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return dynCall_jiiiii(index,a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vijiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    dynCall_vijiii(index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vjjjiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  var sp = stackSave();
  try {
    dynCall_vjjjiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vjiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    dynCall_vjiiiii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiji(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_iiji(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}




// === Auto-generated postamble setup entry stuff ===

unexportedRuntimeFunction('intArrayFromString', false);
unexportedRuntimeFunction('intArrayToString', false);
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;
unexportedRuntimeFunction('setValue', false);
unexportedRuntimeFunction('getValue', false);
unexportedRuntimeFunction('allocate', false);
unexportedRuntimeFunction('UTF8ArrayToString', false);
unexportedRuntimeFunction('UTF8ToString', false);
unexportedRuntimeFunction('stringToUTF8Array', false);
unexportedRuntimeFunction('stringToUTF8', false);
unexportedRuntimeFunction('lengthBytesUTF8', false);
Module["stackTrace"] = stackTrace;
unexportedRuntimeFunction('addOnPreRun', false);
unexportedRuntimeFunction('addOnInit', false);
unexportedRuntimeFunction('addOnPreMain', false);
unexportedRuntimeFunction('addOnExit', false);
unexportedRuntimeFunction('addOnPostRun', false);
unexportedRuntimeFunction('writeStringToMemory', false);
unexportedRuntimeFunction('writeArrayToMemory', false);
unexportedRuntimeFunction('writeAsciiToMemory', false);
Module["addRunDependency"] = addRunDependency;
Module["removeRunDependency"] = removeRunDependency;
unexportedRuntimeFunction('FS_createFolder', false);
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
unexportedRuntimeFunction('FS_createPreloadedFile', true);
unexportedRuntimeFunction('FS_createLazyFile', true);
unexportedRuntimeFunction('FS_createLink', false);
unexportedRuntimeFunction('FS_createDevice', true);
unexportedRuntimeFunction('FS_unlink', true);
unexportedRuntimeFunction('getLEB', false);
unexportedRuntimeFunction('getFunctionTables', false);
unexportedRuntimeFunction('alignFunctionTables', false);
unexportedRuntimeFunction('registerFunctions', false);
unexportedRuntimeFunction('addFunction', false);
unexportedRuntimeFunction('removeFunction', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('prettyPrint', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('getCompilerSetting', false);
unexportedRuntimeFunction('print', false);
unexportedRuntimeFunction('printErr', false);
unexportedRuntimeFunction('getTempRet0', false);
unexportedRuntimeFunction('setTempRet0', false);
unexportedRuntimeFunction('callMain', false);
unexportedRuntimeFunction('abort', false);
unexportedRuntimeFunction('keepRuntimeAlive', false);
unexportedRuntimeFunction('zeroMemory', false);
unexportedRuntimeFunction('stringToNewUTF8', false);
unexportedRuntimeFunction('emscripten_realloc_buffer', false);
unexportedRuntimeFunction('ENV', false);
unexportedRuntimeFunction('ERRNO_CODES', false);
unexportedRuntimeFunction('ERRNO_MESSAGES', false);
unexportedRuntimeFunction('setErrNo', false);
unexportedRuntimeFunction('inetPton4', false);
unexportedRuntimeFunction('inetNtop4', false);
unexportedRuntimeFunction('inetPton6', false);
unexportedRuntimeFunction('inetNtop6', false);
unexportedRuntimeFunction('readSockaddr', false);
unexportedRuntimeFunction('writeSockaddr', false);
unexportedRuntimeFunction('DNS', false);
unexportedRuntimeFunction('getHostByName', false);
unexportedRuntimeFunction('Protocols', false);
unexportedRuntimeFunction('Sockets', false);
unexportedRuntimeFunction('getRandomDevice', false);
unexportedRuntimeFunction('traverseStack', false);
unexportedRuntimeFunction('UNWIND_CACHE', false);
unexportedRuntimeFunction('convertPCtoSourceLocation', false);
unexportedRuntimeFunction('readAsmConstArgsArray', false);
unexportedRuntimeFunction('readAsmConstArgs', false);
unexportedRuntimeFunction('mainThreadEM_ASM', false);
unexportedRuntimeFunction('jstoi_q', false);
unexportedRuntimeFunction('jstoi_s', false);
unexportedRuntimeFunction('getExecutableName', false);
unexportedRuntimeFunction('listenOnce', false);
unexportedRuntimeFunction('autoResumeAudioContext', false);
unexportedRuntimeFunction('dynCallLegacy', false);
unexportedRuntimeFunction('getDynCaller', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('handleException', false);
unexportedRuntimeFunction('runtimeKeepalivePush', false);
unexportedRuntimeFunction('runtimeKeepalivePop', false);
unexportedRuntimeFunction('callUserCallback', false);
unexportedRuntimeFunction('maybeExit', false);
unexportedRuntimeFunction('safeSetTimeout', false);
unexportedRuntimeFunction('asmjsMangle', false);
unexportedRuntimeFunction('asyncLoad', false);
unexportedRuntimeFunction('alignMemory', false);
unexportedRuntimeFunction('mmapAlloc', false);
unexportedRuntimeFunction('reallyNegative', false);
unexportedRuntimeFunction('unSign', false);
unexportedRuntimeFunction('reSign', false);
unexportedRuntimeFunction('formatString', false);
unexportedRuntimeFunction('PATH', false);
unexportedRuntimeFunction('PATH_FS', false);
unexportedRuntimeFunction('SYSCALLS', false);
unexportedRuntimeFunction('getSocketFromFD', false);
unexportedRuntimeFunction('getSocketAddress', false);
unexportedRuntimeFunction('JSEvents', false);
unexportedRuntimeFunction('registerKeyEventCallback', false);
unexportedRuntimeFunction('specialHTMLTargets', false);
unexportedRuntimeFunction('maybeCStringToJsString', false);
unexportedRuntimeFunction('findEventTarget', false);
unexportedRuntimeFunction('findCanvasEventTarget', false);
unexportedRuntimeFunction('getBoundingClientRect', false);
unexportedRuntimeFunction('fillMouseEventData', false);
unexportedRuntimeFunction('registerMouseEventCallback', false);
unexportedRuntimeFunction('registerWheelEventCallback', false);
unexportedRuntimeFunction('registerUiEventCallback', false);
unexportedRuntimeFunction('registerFocusEventCallback', false);
unexportedRuntimeFunction('fillDeviceOrientationEventData', false);
unexportedRuntimeFunction('registerDeviceOrientationEventCallback', false);
unexportedRuntimeFunction('fillDeviceMotionEventData', false);
unexportedRuntimeFunction('registerDeviceMotionEventCallback', false);
unexportedRuntimeFunction('screenOrientation', false);
unexportedRuntimeFunction('fillOrientationChangeEventData', false);
unexportedRuntimeFunction('registerOrientationChangeEventCallback', false);
unexportedRuntimeFunction('fillFullscreenChangeEventData', false);
unexportedRuntimeFunction('registerFullscreenChangeEventCallback', false);
unexportedRuntimeFunction('registerRestoreOldStyle', false);
unexportedRuntimeFunction('hideEverythingExceptGivenElement', false);
unexportedRuntimeFunction('restoreHiddenElements', false);
unexportedRuntimeFunction('setLetterbox', false);
unexportedRuntimeFunction('currentFullscreenStrategy', false);
unexportedRuntimeFunction('restoreOldWindowedStyle', false);
unexportedRuntimeFunction('softFullscreenResizeWebGLRenderTarget', false);
unexportedRuntimeFunction('doRequestFullscreen', false);
unexportedRuntimeFunction('fillPointerlockChangeEventData', false);
unexportedRuntimeFunction('registerPointerlockChangeEventCallback', false);
unexportedRuntimeFunction('registerPointerlockErrorEventCallback', false);
unexportedRuntimeFunction('requestPointerLock', false);
unexportedRuntimeFunction('fillVisibilityChangeEventData', false);
unexportedRuntimeFunction('registerVisibilityChangeEventCallback', false);
unexportedRuntimeFunction('registerTouchEventCallback', false);
unexportedRuntimeFunction('fillGamepadEventData', false);
unexportedRuntimeFunction('registerGamepadEventCallback', false);
unexportedRuntimeFunction('registerBeforeUnloadEventCallback', false);
unexportedRuntimeFunction('fillBatteryEventData', false);
unexportedRuntimeFunction('battery', false);
unexportedRuntimeFunction('registerBatteryEventCallback', false);
unexportedRuntimeFunction('setCanvasElementSize', false);
unexportedRuntimeFunction('getCanvasElementSize', false);
unexportedRuntimeFunction('demangle', false);
unexportedRuntimeFunction('demangleAll', false);
unexportedRuntimeFunction('jsStackTrace', false);
Module["stackTrace"] = stackTrace;
unexportedRuntimeFunction('getEnvStrings', false);
unexportedRuntimeFunction('checkWasiClock', false);
unexportedRuntimeFunction('writeI53ToI64', false);
unexportedRuntimeFunction('writeI53ToI64Clamped', false);
unexportedRuntimeFunction('writeI53ToI64Signaling', false);
unexportedRuntimeFunction('writeI53ToU64Clamped', false);
unexportedRuntimeFunction('writeI53ToU64Signaling', false);
unexportedRuntimeFunction('readI53FromI64', false);
unexportedRuntimeFunction('readI53FromU64', false);
unexportedRuntimeFunction('convertI32PairToI53', false);
unexportedRuntimeFunction('convertU32PairToI53', false);
unexportedRuntimeFunction('setImmediateWrapped', false);
unexportedRuntimeFunction('clearImmediateWrapped', false);
unexportedRuntimeFunction('polyfillSetImmediate', false);
unexportedRuntimeFunction('uncaughtExceptionCount', false);
unexportedRuntimeFunction('exceptionLast', false);
unexportedRuntimeFunction('exceptionCaught', false);
unexportedRuntimeFunction('ExceptionInfo', false);
unexportedRuntimeFunction('CatchInfo', false);
unexportedRuntimeFunction('exception_addRef', false);
unexportedRuntimeFunction('exception_decRef', false);
unexportedRuntimeFunction('formatException', false);
unexportedRuntimeFunction('Browser', false);
unexportedRuntimeFunction('funcWrappers', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('setMainLoop', false);
unexportedRuntimeFunction('wget', false);
unexportedRuntimeFunction('FS', false);
unexportedRuntimeFunction('MEMFS', false);
unexportedRuntimeFunction('TTY', false);
unexportedRuntimeFunction('PIPEFS', false);
unexportedRuntimeFunction('SOCKFS', false);
unexportedRuntimeFunction('_setNetworkCallback', false);
unexportedRuntimeFunction('tempFixedLengthArray', false);
unexportedRuntimeFunction('miniTempWebGLFloatBuffers', false);
unexportedRuntimeFunction('heapObjectForWebGLType', false);
unexportedRuntimeFunction('heapAccessShiftForWebGLHeap', false);
unexportedRuntimeFunction('GL', false);
unexportedRuntimeFunction('emscriptenWebGLGet', false);
unexportedRuntimeFunction('computeUnpackAlignedImageSize', false);
unexportedRuntimeFunction('emscriptenWebGLGetTexPixelData', false);
unexportedRuntimeFunction('emscriptenWebGLGetUniform', false);
unexportedRuntimeFunction('webglGetUniformLocation', false);
unexportedRuntimeFunction('webglPrepareUniformLocationsBeforeFirstUse', false);
unexportedRuntimeFunction('webglGetLeftBracePos', false);
unexportedRuntimeFunction('emscriptenWebGLGetVertexAttrib', false);
unexportedRuntimeFunction('webglApplyExplicitProgramBindings', false);
unexportedRuntimeFunction('emscriptenWebGLGetBufferBinding', false);
unexportedRuntimeFunction('emscriptenWebGLValidateMapBufferTarget', false);
unexportedRuntimeFunction('writeGLArray', false);
unexportedRuntimeFunction('AL', false);
unexportedRuntimeFunction('SDL_unicode', false);
unexportedRuntimeFunction('SDL_ttfContext', false);
unexportedRuntimeFunction('SDL_audio', false);
unexportedRuntimeFunction('SDL', false);
unexportedRuntimeFunction('SDL_gfx', false);
unexportedRuntimeFunction('GLUT', false);
unexportedRuntimeFunction('EGL', false);
unexportedRuntimeFunction('GLFW_Window', false);
unexportedRuntimeFunction('GLFW', false);
unexportedRuntimeFunction('GLEW', false);
unexportedRuntimeFunction('IDBStore', false);
unexportedRuntimeFunction('runAndAbortIfError', false);
unexportedRuntimeFunction('emscriptenWebGLGetIndexed', false);
unexportedRuntimeFunction('remove_cpp_comments_in_shaders', false);
unexportedRuntimeFunction('find_closing_parens_index', false);
unexportedRuntimeFunction('preprocess_c_code', false);
unexportedRuntimeFunction('WEBAudio', false);
unexportedRuntimeFunction('WEBAudio__user', false);
unexportedRuntimeFunction('jsAudioAddPendingBlockedAudio', false);
unexportedRuntimeFunction('jsAudioAddPendingBlockedAudio__user', false);
unexportedRuntimeFunction('jsAudioPlayPendingBlockedAudio', false);
unexportedRuntimeFunction('jsAudioPlayPendingBlockedAudio__user', false);
unexportedRuntimeFunction('jsAudioPlayBlockedAudios', false);
unexportedRuntimeFunction('jsAudioPlayBlockedAudios__user', false);
unexportedRuntimeFunction('jsAudioMixinSetPitch', false);
unexportedRuntimeFunction('jsAudioMixinSetPitch__user', false);
unexportedRuntimeFunction('jsAudioGetMimeTypeFromType', false);
unexportedRuntimeFunction('jsAudioGetMimeTypeFromType__user', false);
unexportedRuntimeFunction('jsAudioCreateCompressedSoundClip', false);
unexportedRuntimeFunction('jsAudioCreateCompressedSoundClip__user', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClip', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClip__user', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClipFromPCM', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClipFromPCM__user', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClipFromCompressedAudio', false);
unexportedRuntimeFunction('jsAudioCreateUncompressedSoundClipFromCompressedAudio__user', false);
unexportedRuntimeFunction('jsAudioCreateChannel', false);
unexportedRuntimeFunction('jsAudioCreateChannel__user', false);
unexportedRuntimeFunction('registerTouchEventCallback__user', false);
unexportedRuntimeFunction('dlopen_main_init', false);
unexportedRuntimeFunction('dlopen_main_init__user', false);
unexportedRuntimeFunction('jsDomCssEscapeId', false);
unexportedRuntimeFunction('jsDomCssEscapeId__user', false);
unexportedRuntimeFunction('jsCanvasSelector', false);
unexportedRuntimeFunction('jsCanvasSelector__user', false);
unexportedRuntimeFunction('fs', false);
unexportedRuntimeFunction('fs__user', false);
unexportedRuntimeFunction('ExceptionsSeen', false);
unexportedRuntimeFunction('ExceptionsSeen__user', false);
unexportedRuntimeFunction('IDBFS', false);
unexportedRuntimeFunction('mobile_input', false);
unexportedRuntimeFunction('mobile_input__user', false);
unexportedRuntimeFunction('mobile_input_text', false);
unexportedRuntimeFunction('mobile_input_text__user', false);
unexportedRuntimeFunction('mobile_input_hide_delay', false);
unexportedRuntimeFunction('mobile_input_hide_delay__user', false);
unexportedRuntimeFunction('mobile_input_ignore_blur_event', false);
unexportedRuntimeFunction('mobile_input_ignore_blur_event__user', false);
unexportedRuntimeFunction('JS_ScreenOrientation_callback', false);
unexportedRuntimeFunction('JS_ScreenOrientation_callback__user', false);
unexportedRuntimeFunction('JS_ScreenOrientation_eventHandler', false);
unexportedRuntimeFunction('JS_ScreenOrientation_eventHandler__user', false);
unexportedRuntimeFunction('JS_ScreenOrientation_requestedLockType', false);
unexportedRuntimeFunction('JS_ScreenOrientation_requestedLockType__user', false);
unexportedRuntimeFunction('JS_ScreenOrientation_appliedLockType', false);
unexportedRuntimeFunction('JS_ScreenOrientation_appliedLockType__user', false);
unexportedRuntimeFunction('JS_ScreenOrientation_timeoutID', false);
unexportedRuntimeFunction('JS_ScreenOrientation_timeoutID__user', false);
unexportedRuntimeFunction('JS_OrientationSensor_frequencyRequest', false);
unexportedRuntimeFunction('JS_OrientationSensor_frequencyRequest__user', false);
unexportedRuntimeFunction('JS_OrientationSensor_callback', false);
unexportedRuntimeFunction('JS_OrientationSensor_callback__user', false);
unexportedRuntimeFunction('JS_OrientationSensor', false);
unexportedRuntimeFunction('JS_OrientationSensor__user', false);
unexportedRuntimeFunction('JS_Accelerometer_frequencyRequest', false);
unexportedRuntimeFunction('JS_Accelerometer_frequencyRequest__user', false);
unexportedRuntimeFunction('JS_Accelerometer_callback', false);
unexportedRuntimeFunction('JS_Accelerometer_callback__user', false);
unexportedRuntimeFunction('JS_Accelerometer', false);
unexportedRuntimeFunction('JS_Accelerometer__user', false);
unexportedRuntimeFunction('JS_Accelerometer_multiplier', false);
unexportedRuntimeFunction('JS_Accelerometer_multiplier__user', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_frequencyRequest', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_frequencyRequest__user', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_callback', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_callback__user', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor__user', false);
unexportedRuntimeFunction('JS_GravitySensor_frequencyRequest', false);
unexportedRuntimeFunction('JS_GravitySensor_frequencyRequest__user', false);
unexportedRuntimeFunction('JS_GravitySensor_callback', false);
unexportedRuntimeFunction('JS_GravitySensor_callback__user', false);
unexportedRuntimeFunction('JS_GravitySensor', false);
unexportedRuntimeFunction('JS_GravitySensor__user', false);
unexportedRuntimeFunction('JS_Accelerometer_frequency', false);
unexportedRuntimeFunction('JS_Accelerometer_frequency__user', false);
unexportedRuntimeFunction('JS_Accelerometer_lastValue', false);
unexportedRuntimeFunction('JS_Accelerometer_lastValue__user', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_frequency', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_frequency__user', false);
unexportedRuntimeFunction('JS_Gyroscope_frequencyRequest', false);
unexportedRuntimeFunction('JS_Gyroscope_frequencyRequest__user', false);
unexportedRuntimeFunction('JS_Gyroscope_callback', false);
unexportedRuntimeFunction('JS_Gyroscope_callback__user', false);
unexportedRuntimeFunction('JS_Gyroscope', false);
unexportedRuntimeFunction('JS_Gyroscope__user', false);
unexportedRuntimeFunction('JS_DeviceSensorPermissions', false);
unexportedRuntimeFunction('JS_DeviceSensorPermissions__user', false);
unexportedRuntimeFunction('JS_DefineAccelerometerMultiplier', false);
unexportedRuntimeFunction('JS_DefineAccelerometerMultiplier__user', false);
unexportedRuntimeFunction('JS_RequestDeviceSensorPermissions', false);
unexportedRuntimeFunction('JS_RequestDeviceSensorPermissions__user', false);
unexportedRuntimeFunction('JS_OrientationSensor_eventHandler', false);
unexportedRuntimeFunction('JS_OrientationSensor_eventHandler__user', false);
unexportedRuntimeFunction('JS_Accelerometer_eventHandler', false);
unexportedRuntimeFunction('JS_Accelerometer_eventHandler__user', false);
unexportedRuntimeFunction('JS_ComputeGravity', false);
unexportedRuntimeFunction('JS_ComputeGravity__user', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_eventHandler', false);
unexportedRuntimeFunction('JS_LinearAccelerationSensor_eventHandler__user', false);
unexportedRuntimeFunction('JS_GravitySensor_eventHandler', false);
unexportedRuntimeFunction('JS_GravitySensor_eventHandler__user', false);
unexportedRuntimeFunction('JS_Gyroscope_eventHandler', false);
unexportedRuntimeFunction('JS_Gyroscope_eventHandler__user', false);
unexportedRuntimeFunction('JS_DeviceOrientation_eventHandler', false);
unexportedRuntimeFunction('JS_DeviceOrientation_eventHandler__user', false);
unexportedRuntimeFunction('JS_DeviceMotion_eventHandler', false);
unexportedRuntimeFunction('JS_DeviceMotion_eventHandler__user', false);
unexportedRuntimeFunction('JS_DeviceMotion_add', false);
unexportedRuntimeFunction('JS_DeviceMotion_add__user', false);
unexportedRuntimeFunction('JS_DeviceMotion_remove', false);
unexportedRuntimeFunction('JS_DeviceMotion_remove__user', false);
unexportedRuntimeFunction('UNETWebSocketsInstances', false);
unexportedRuntimeFunction('UNETWebSocketsInstances__user', false);
unexportedRuntimeFunction('videoInstances', false);
unexportedRuntimeFunction('videoInstances__user', false);
unexportedRuntimeFunction('videoInstanceIdCounter', false);
unexportedRuntimeFunction('videoInstanceIdCounter__user', false);
unexportedRuntimeFunction('hasSRGBATextures', false);
unexportedRuntimeFunction('hasSRGBATextures__user', false);
unexportedRuntimeFunction('s2lTexture', false);
unexportedRuntimeFunction('s2lTexture__user', false);
unexportedRuntimeFunction('s2lFBO', false);
unexportedRuntimeFunction('s2lFBO__user', false);
unexportedRuntimeFunction('s2lVBO', false);
unexportedRuntimeFunction('s2lVBO__user', false);
unexportedRuntimeFunction('s2lProgram', false);
unexportedRuntimeFunction('s2lProgram__user', false);
unexportedRuntimeFunction('s2lVertexPositionNDC', false);
unexportedRuntimeFunction('s2lVertexPositionNDC__user', false);
unexportedRuntimeFunction('jsVideoEnded', false);
unexportedRuntimeFunction('jsVideoEnded__user', false);
unexportedRuntimeFunction('jsVideoAllAudioTracksAreDisabled', false);
unexportedRuntimeFunction('jsVideoAllAudioTracksAreDisabled__user', false);
unexportedRuntimeFunction('jsVideoPendingBlockedVideos', false);
unexportedRuntimeFunction('jsVideoPendingBlockedVideos__user', false);
unexportedRuntimeFunction('jsVideoAddPendingBlockedVideo', false);
unexportedRuntimeFunction('jsVideoAddPendingBlockedVideo__user', false);
unexportedRuntimeFunction('jsVideoPlayPendingBlockedVideo', false);
unexportedRuntimeFunction('jsVideoPlayPendingBlockedVideo__user', false);
unexportedRuntimeFunction('jsVideoRemovePendingBlockedVideo', false);
unexportedRuntimeFunction('jsVideoRemovePendingBlockedVideo__user', false);
unexportedRuntimeFunction('jsVideoAttemptToPlayBlockedVideos', false);
unexportedRuntimeFunction('jsVideoAttemptToPlayBlockedVideos__user', false);
unexportedRuntimeFunction('jsVideoCreateTexture2D', false);
unexportedRuntimeFunction('jsVideoCreateTexture2D__user', false);
unexportedRuntimeFunction('jsSupportedVideoFormats', false);
unexportedRuntimeFunction('jsSupportedVideoFormats__user', false);
unexportedRuntimeFunction('jsUnsupportedVideoFormats', false);
unexportedRuntimeFunction('jsUnsupportedVideoFormats__user', false);
unexportedRuntimeFunction('activeWebCams', false);
unexportedRuntimeFunction('activeWebCams__user', false);
unexportedRuntimeFunction('cameraAccess', false);
unexportedRuntimeFunction('cameraAccess__user', false);
unexportedRuntimeFunction('wr', false);
unexportedRuntimeFunction('wr__user', false);
unexportedRuntimeFunction('jsWebRequestGetResponseHeaderString', false);
unexportedRuntimeFunction('jsWebRequestGetResponseHeaderString__user', false);
unexportedRuntimeFunction('warnOnce', false);
unexportedRuntimeFunction('stackSave', false);
unexportedRuntimeFunction('stackRestore', false);
unexportedRuntimeFunction('stackAlloc', false);
unexportedRuntimeFunction('AsciiToString', false);
unexportedRuntimeFunction('stringToAscii', false);
unexportedRuntimeFunction('UTF16ToString', false);
unexportedRuntimeFunction('stringToUTF16', false);
unexportedRuntimeFunction('lengthBytesUTF16', false);
unexportedRuntimeFunction('UTF32ToString', false);
unexportedRuntimeFunction('stringToUTF32', false);
unexportedRuntimeFunction('lengthBytesUTF32', false);
unexportedRuntimeFunction('allocateUTF8', false);
unexportedRuntimeFunction('allocateUTF8OnStack', false);
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
unexportedRuntimeSymbol('ALLOC_NORMAL', false);
unexportedRuntimeSymbol('ALLOC_STACK', false);

var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = Module['_main'];

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as
    // execution is asynchronously handed off to a pthread.
    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  } finally {
    calledMain = true;

  }
}

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  _emscripten_stack_init();
  writeStackCookie();
}

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    ___stdio_exit();
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  checkUnflushedContent();

  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
  if (keepRuntimeAlive() && !implicit) {
    var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';
    readyPromiseReject(msg);
    err(msg);
  }

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();







  return unityFramework.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = unityFramework;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return unityFramework; });
else if (typeof exports === 'object')
  exports["unityFramework"] = unityFramework;
